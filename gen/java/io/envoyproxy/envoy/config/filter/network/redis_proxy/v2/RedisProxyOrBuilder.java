// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/config/filter/network/redis_proxy/v2/redis_proxy.proto

package io.envoyproxy.envoy.config.filter.network.redis_proxy.v2;

public interface RedisProxyOrBuilder extends
    // @@protoc_insertion_point(interface_extends:envoy.config.filter.network.redis_proxy.v2.RedisProxy)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * The prefix to use when emitting :ref:`statistics &lt;config_network_filters_redis_proxy_stats&gt;`.
   * </pre>
   *
   * <code>string stat_prefix = 1 [(.validate.rules) = { ... }</code>
   * @return The statPrefix.
   */
  java.lang.String getStatPrefix();
  /**
   * <pre>
   * The prefix to use when emitting :ref:`statistics &lt;config_network_filters_redis_proxy_stats&gt;`.
   * </pre>
   *
   * <code>string stat_prefix = 1 [(.validate.rules) = { ... }</code>
   * @return The bytes for statPrefix.
   */
  com.google.protobuf.ByteString
      getStatPrefixBytes();

  /**
   * <pre>
   * Name of cluster from cluster manager. See the :ref:`configuration section
   * &lt;arch_overview_redis_configuration&gt;` of the architecture overview for recommendations on
   * configuring the backing cluster.
   * .. attention::
   *   This field is deprecated. Use a :ref:`catch_all
   *   route&lt;envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.catch_all_route&gt;`
   *   instead.
   * </pre>
   *
   * <code>string cluster = 2 [deprecated = true, (.envoy.annotations.disallowed_by_default) = true];</code>
   * @deprecated envoy.config.filter.network.redis_proxy.v2.RedisProxy.cluster is deprecated.
   *     See envoy/config/filter/network/redis_proxy/v2/redis_proxy.proto;l=189
   * @return The cluster.
   */
  @java.lang.Deprecated java.lang.String getCluster();
  /**
   * <pre>
   * Name of cluster from cluster manager. See the :ref:`configuration section
   * &lt;arch_overview_redis_configuration&gt;` of the architecture overview for recommendations on
   * configuring the backing cluster.
   * .. attention::
   *   This field is deprecated. Use a :ref:`catch_all
   *   route&lt;envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.catch_all_route&gt;`
   *   instead.
   * </pre>
   *
   * <code>string cluster = 2 [deprecated = true, (.envoy.annotations.disallowed_by_default) = true];</code>
   * @deprecated envoy.config.filter.network.redis_proxy.v2.RedisProxy.cluster is deprecated.
   *     See envoy/config/filter/network/redis_proxy/v2/redis_proxy.proto;l=189
   * @return The bytes for cluster.
   */
  @java.lang.Deprecated com.google.protobuf.ByteString
      getClusterBytes();

  /**
   * <pre>
   * Network settings for the connection pool to the upstream clusters.
   * </pre>
   *
   * <code>.envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings settings = 3 [(.validate.rules) = { ... }</code>
   * @return Whether the settings field is set.
   */
  boolean hasSettings();
  /**
   * <pre>
   * Network settings for the connection pool to the upstream clusters.
   * </pre>
   *
   * <code>.envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings settings = 3 [(.validate.rules) = { ... }</code>
   * @return The settings.
   */
  io.envoyproxy.envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings getSettings();
  /**
   * <pre>
   * Network settings for the connection pool to the upstream clusters.
   * </pre>
   *
   * <code>.envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings settings = 3 [(.validate.rules) = { ... }</code>
   */
  io.envoyproxy.envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettingsOrBuilder getSettingsOrBuilder();

  /**
   * <pre>
   * Indicates that latency stat should be computed in microseconds. By default it is computed in
   * milliseconds.
   * </pre>
   *
   * <code>bool latency_in_micros = 4;</code>
   * @return The latencyInMicros.
   */
  boolean getLatencyInMicros();

  /**
   * <pre>
   * List of **unique** prefixes used to separate keys from different workloads to different
   * clusters. Envoy will always favor the longest match first in case of overlap. A catch-all
   * cluster can be used to forward commands when there is no match. Time complexity of the
   * lookups are in O(min(longest key prefix, key length)).
   * Example:
   * .. code-block:: yaml
   *    prefix_routes:
   *      routes:
   *        - prefix: "ab"
   *          cluster: "cluster_a"
   *        - prefix: "abc"
   *          cluster: "cluster_b"
   * When using the above routes, the following prefixes would be sent to:
   * * ``get abc:users`` would retrieve the key 'abc:users' from cluster_b.
   * * ``get ab:users`` would retrieve the key 'ab:users' from cluster_a.
   * * ``get z:users`` would return a NoUpstreamHost error. A :ref:`catch-all
   *   route&lt;envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.catch_all_route&gt;`
   *   would have retrieved the key from that cluster instead.
   * See the :ref:`configuration section
   * &lt;arch_overview_redis_configuration&gt;` of the architecture overview for recommendations on
   * configuring the backing clusters.
   * </pre>
   *
   * <code>.envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes prefix_routes = 5;</code>
   * @return Whether the prefixRoutes field is set.
   */
  boolean hasPrefixRoutes();
  /**
   * <pre>
   * List of **unique** prefixes used to separate keys from different workloads to different
   * clusters. Envoy will always favor the longest match first in case of overlap. A catch-all
   * cluster can be used to forward commands when there is no match. Time complexity of the
   * lookups are in O(min(longest key prefix, key length)).
   * Example:
   * .. code-block:: yaml
   *    prefix_routes:
   *      routes:
   *        - prefix: "ab"
   *          cluster: "cluster_a"
   *        - prefix: "abc"
   *          cluster: "cluster_b"
   * When using the above routes, the following prefixes would be sent to:
   * * ``get abc:users`` would retrieve the key 'abc:users' from cluster_b.
   * * ``get ab:users`` would retrieve the key 'ab:users' from cluster_a.
   * * ``get z:users`` would return a NoUpstreamHost error. A :ref:`catch-all
   *   route&lt;envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.catch_all_route&gt;`
   *   would have retrieved the key from that cluster instead.
   * See the :ref:`configuration section
   * &lt;arch_overview_redis_configuration&gt;` of the architecture overview for recommendations on
   * configuring the backing clusters.
   * </pre>
   *
   * <code>.envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes prefix_routes = 5;</code>
   * @return The prefixRoutes.
   */
  io.envoyproxy.envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes getPrefixRoutes();
  /**
   * <pre>
   * List of **unique** prefixes used to separate keys from different workloads to different
   * clusters. Envoy will always favor the longest match first in case of overlap. A catch-all
   * cluster can be used to forward commands when there is no match. Time complexity of the
   * lookups are in O(min(longest key prefix, key length)).
   * Example:
   * .. code-block:: yaml
   *    prefix_routes:
   *      routes:
   *        - prefix: "ab"
   *          cluster: "cluster_a"
   *        - prefix: "abc"
   *          cluster: "cluster_b"
   * When using the above routes, the following prefixes would be sent to:
   * * ``get abc:users`` would retrieve the key 'abc:users' from cluster_b.
   * * ``get ab:users`` would retrieve the key 'ab:users' from cluster_a.
   * * ``get z:users`` would return a NoUpstreamHost error. A :ref:`catch-all
   *   route&lt;envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.catch_all_route&gt;`
   *   would have retrieved the key from that cluster instead.
   * See the :ref:`configuration section
   * &lt;arch_overview_redis_configuration&gt;` of the architecture overview for recommendations on
   * configuring the backing clusters.
   * </pre>
   *
   * <code>.envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes prefix_routes = 5;</code>
   */
  io.envoyproxy.envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutesOrBuilder getPrefixRoutesOrBuilder();

  /**
   * <pre>
   * Authenticate Redis client connections locally by forcing downstream clients to issue a `Redis
   * AUTH command &lt;https://redis.io/commands/auth&gt;`_ with this password before enabling any other
   * command. If an AUTH command's password matches this password, an "OK" response will be returned
   * to the client. If the AUTH command password does not match this password, then an "ERR invalid
   * password" error will be returned. If any other command is received before AUTH when this
   * password is set, then a "NOAUTH Authentication required." error response will be sent to the
   * client. If an AUTH command is received when the password is not set, then an "ERR Client sent
   * AUTH, but no password is set" error will be returned.
   * </pre>
   *
   * <code>.envoy.api.v2.core.DataSource downstream_auth_password = 6 [(.udpa.annotations.sensitive) = true];</code>
   * @return Whether the downstreamAuthPassword field is set.
   */
  boolean hasDownstreamAuthPassword();
  /**
   * <pre>
   * Authenticate Redis client connections locally by forcing downstream clients to issue a `Redis
   * AUTH command &lt;https://redis.io/commands/auth&gt;`_ with this password before enabling any other
   * command. If an AUTH command's password matches this password, an "OK" response will be returned
   * to the client. If the AUTH command password does not match this password, then an "ERR invalid
   * password" error will be returned. If any other command is received before AUTH when this
   * password is set, then a "NOAUTH Authentication required." error response will be sent to the
   * client. If an AUTH command is received when the password is not set, then an "ERR Client sent
   * AUTH, but no password is set" error will be returned.
   * </pre>
   *
   * <code>.envoy.api.v2.core.DataSource downstream_auth_password = 6 [(.udpa.annotations.sensitive) = true];</code>
   * @return The downstreamAuthPassword.
   */
  io.envoyproxy.envoy.api.v2.core.DataSource getDownstreamAuthPassword();
  /**
   * <pre>
   * Authenticate Redis client connections locally by forcing downstream clients to issue a `Redis
   * AUTH command &lt;https://redis.io/commands/auth&gt;`_ with this password before enabling any other
   * command. If an AUTH command's password matches this password, an "OK" response will be returned
   * to the client. If the AUTH command password does not match this password, then an "ERR invalid
   * password" error will be returned. If any other command is received before AUTH when this
   * password is set, then a "NOAUTH Authentication required." error response will be sent to the
   * client. If an AUTH command is received when the password is not set, then an "ERR Client sent
   * AUTH, but no password is set" error will be returned.
   * </pre>
   *
   * <code>.envoy.api.v2.core.DataSource downstream_auth_password = 6 [(.udpa.annotations.sensitive) = true];</code>
   */
  io.envoyproxy.envoy.api.v2.core.DataSourceOrBuilder getDownstreamAuthPasswordOrBuilder();
}
