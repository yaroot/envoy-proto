// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/config/listener/v3/listener.proto

package io.envoyproxy.envoy.config.listener.v3;

/**
 * <pre>
 * [#next-free-field: 34]
 * </pre>
 *
 * Protobuf type {@code envoy.config.listener.v3.Listener}
 */
public final class Listener extends
    com.google.protobuf.GeneratedMessageV3 implements
    // @@protoc_insertion_point(message_implements:envoy.config.listener.v3.Listener)
    ListenerOrBuilder {
private static final long serialVersionUID = 0L;
  // Use Listener.newBuilder() to construct.
  private Listener(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }
  private Listener() {
    name_ = "";
    additionalAddresses_ = java.util.Collections.emptyList();
    statPrefix_ = "";
    filterChains_ = java.util.Collections.emptyList();
    drainType_ = 0;
    listenerFilters_ = java.util.Collections.emptyList();
    socketOptions_ = java.util.Collections.emptyList();
    trafficDirection_ = 0;
    accessLog_ = java.util.Collections.emptyList();
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(
      UnusedPrivateParameter unused) {
    return new Listener();
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet
  getUnknownFields() {
    return this.unknownFields;
  }
  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            io.envoyproxy.envoy.config.listener.v3.Listener.class, io.envoyproxy.envoy.config.listener.v3.Listener.Builder.class);
  }

  /**
   * Protobuf enum {@code envoy.config.listener.v3.Listener.DrainType}
   */
  public enum DrainType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * Drain in response to calling /healthcheck/fail admin endpoint (along with the health check
     * filter), listener removal/modification, and hot restart.
     * </pre>
     *
     * <code>DEFAULT = 0;</code>
     */
    DEFAULT(0),
    /**
     * <pre>
     * Drain in response to listener removal/modification and hot restart. This setting does not
     * include /healthcheck/fail. This setting may be desirable if Envoy is hosting both ingress
     * and egress listeners.
     * </pre>
     *
     * <code>MODIFY_ONLY = 1;</code>
     */
    MODIFY_ONLY(1),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * Drain in response to calling /healthcheck/fail admin endpoint (along with the health check
     * filter), listener removal/modification, and hot restart.
     * </pre>
     *
     * <code>DEFAULT = 0;</code>
     */
    public static final int DEFAULT_VALUE = 0;
    /**
     * <pre>
     * Drain in response to listener removal/modification and hot restart. This setting does not
     * include /healthcheck/fail. This setting may be desirable if Envoy is hosting both ingress
     * and egress listeners.
     * </pre>
     *
     * <code>MODIFY_ONLY = 1;</code>
     */
    public static final int MODIFY_ONLY_VALUE = 1;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static DrainType valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static DrainType forNumber(int value) {
      switch (value) {
        case 0: return DEFAULT;
        case 1: return MODIFY_ONLY;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<DrainType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        DrainType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<DrainType>() {
            public DrainType findValueByNumber(int number) {
              return DrainType.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.listener.v3.Listener.getDescriptor().getEnumTypes().get(0);
    }

    private static final DrainType[] VALUES = values();

    public static DrainType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private DrainType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:envoy.config.listener.v3.Listener.DrainType)
  }

  public interface DeprecatedV1OrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.config.listener.v3.Listener.DeprecatedV1)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Whether the listener should bind to the port. A listener that doesn't
     * bind can only receive connections redirected from other listeners that
     * set use_original_dst parameter to true. Default is true.
     * This is deprecated. Use :ref:`Listener.bind_to_port
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue bind_to_port = 1;</code>
     * @return Whether the bindToPort field is set.
     */
    boolean hasBindToPort();
    /**
     * <pre>
     * Whether the listener should bind to the port. A listener that doesn't
     * bind can only receive connections redirected from other listeners that
     * set use_original_dst parameter to true. Default is true.
     * This is deprecated. Use :ref:`Listener.bind_to_port
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue bind_to_port = 1;</code>
     * @return The bindToPort.
     */
    com.google.protobuf.BoolValue getBindToPort();
    /**
     * <pre>
     * Whether the listener should bind to the port. A listener that doesn't
     * bind can only receive connections redirected from other listeners that
     * set use_original_dst parameter to true. Default is true.
     * This is deprecated. Use :ref:`Listener.bind_to_port
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue bind_to_port = 1;</code>
     */
    com.google.protobuf.BoolValueOrBuilder getBindToPortOrBuilder();
  }
  /**
   * <pre>
   * [#not-implemented-hide:]
   * </pre>
   *
   * Protobuf type {@code envoy.config.listener.v3.Listener.DeprecatedV1}
   */
  public static final class DeprecatedV1 extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.config.listener.v3.Listener.DeprecatedV1)
      DeprecatedV1OrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DeprecatedV1.newBuilder() to construct.
    private DeprecatedV1(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DeprecatedV1() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new DeprecatedV1();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_DeprecatedV1_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_DeprecatedV1_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1.class, io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1.Builder.class);
    }

    public static final int BIND_TO_PORT_FIELD_NUMBER = 1;
    private com.google.protobuf.BoolValue bindToPort_;
    /**
     * <pre>
     * Whether the listener should bind to the port. A listener that doesn't
     * bind can only receive connections redirected from other listeners that
     * set use_original_dst parameter to true. Default is true.
     * This is deprecated. Use :ref:`Listener.bind_to_port
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue bind_to_port = 1;</code>
     * @return Whether the bindToPort field is set.
     */
    @java.lang.Override
    public boolean hasBindToPort() {
      return bindToPort_ != null;
    }
    /**
     * <pre>
     * Whether the listener should bind to the port. A listener that doesn't
     * bind can only receive connections redirected from other listeners that
     * set use_original_dst parameter to true. Default is true.
     * This is deprecated. Use :ref:`Listener.bind_to_port
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue bind_to_port = 1;</code>
     * @return The bindToPort.
     */
    @java.lang.Override
    public com.google.protobuf.BoolValue getBindToPort() {
      return bindToPort_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : bindToPort_;
    }
    /**
     * <pre>
     * Whether the listener should bind to the port. A listener that doesn't
     * bind can only receive connections redirected from other listeners that
     * set use_original_dst parameter to true. Default is true.
     * This is deprecated. Use :ref:`Listener.bind_to_port
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue bind_to_port = 1;</code>
     */
    @java.lang.Override
    public com.google.protobuf.BoolValueOrBuilder getBindToPortOrBuilder() {
      return bindToPort_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : bindToPort_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (bindToPort_ != null) {
        output.writeMessage(1, getBindToPort());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (bindToPort_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getBindToPort());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 other = (io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1) obj;

      if (hasBindToPort() != other.hasBindToPort()) return false;
      if (hasBindToPort()) {
        if (!getBindToPort()
            .equals(other.getBindToPort())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasBindToPort()) {
        hash = (37 * hash) + BIND_TO_PORT_FIELD_NUMBER;
        hash = (53 * hash) + getBindToPort().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * Protobuf type {@code envoy.config.listener.v3.Listener.DeprecatedV1}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.config.listener.v3.Listener.DeprecatedV1)
        io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1OrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_DeprecatedV1_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_DeprecatedV1_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1.class, io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        bindToPort_ = null;
        if (bindToPortBuilder_ != null) {
          bindToPortBuilder_.dispose();
          bindToPortBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_DeprecatedV1_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 getDefaultInstanceForType() {
        return io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 build() {
        io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 buildPartial() {
        io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 result = new io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.bindToPort_ = bindToPortBuilder_ == null
              ? bindToPort_
              : bindToPortBuilder_.build();
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1) {
          return mergeFrom((io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 other) {
        if (other == io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1.getDefaultInstance()) return this;
        if (other.hasBindToPort()) {
          mergeBindToPort(other.getBindToPort());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getBindToPortFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.BoolValue bindToPort_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> bindToPortBuilder_;
      /**
       * <pre>
       * Whether the listener should bind to the port. A listener that doesn't
       * bind can only receive connections redirected from other listeners that
       * set use_original_dst parameter to true. Default is true.
       * This is deprecated. Use :ref:`Listener.bind_to_port
       * &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;`
       * </pre>
       *
       * <code>.google.protobuf.BoolValue bind_to_port = 1;</code>
       * @return Whether the bindToPort field is set.
       */
      public boolean hasBindToPort() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Whether the listener should bind to the port. A listener that doesn't
       * bind can only receive connections redirected from other listeners that
       * set use_original_dst parameter to true. Default is true.
       * This is deprecated. Use :ref:`Listener.bind_to_port
       * &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;`
       * </pre>
       *
       * <code>.google.protobuf.BoolValue bind_to_port = 1;</code>
       * @return The bindToPort.
       */
      public com.google.protobuf.BoolValue getBindToPort() {
        if (bindToPortBuilder_ == null) {
          return bindToPort_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : bindToPort_;
        } else {
          return bindToPortBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Whether the listener should bind to the port. A listener that doesn't
       * bind can only receive connections redirected from other listeners that
       * set use_original_dst parameter to true. Default is true.
       * This is deprecated. Use :ref:`Listener.bind_to_port
       * &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;`
       * </pre>
       *
       * <code>.google.protobuf.BoolValue bind_to_port = 1;</code>
       */
      public Builder setBindToPort(com.google.protobuf.BoolValue value) {
        if (bindToPortBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          bindToPort_ = value;
        } else {
          bindToPortBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether the listener should bind to the port. A listener that doesn't
       * bind can only receive connections redirected from other listeners that
       * set use_original_dst parameter to true. Default is true.
       * This is deprecated. Use :ref:`Listener.bind_to_port
       * &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;`
       * </pre>
       *
       * <code>.google.protobuf.BoolValue bind_to_port = 1;</code>
       */
      public Builder setBindToPort(
          com.google.protobuf.BoolValue.Builder builderForValue) {
        if (bindToPortBuilder_ == null) {
          bindToPort_ = builderForValue.build();
        } else {
          bindToPortBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether the listener should bind to the port. A listener that doesn't
       * bind can only receive connections redirected from other listeners that
       * set use_original_dst parameter to true. Default is true.
       * This is deprecated. Use :ref:`Listener.bind_to_port
       * &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;`
       * </pre>
       *
       * <code>.google.protobuf.BoolValue bind_to_port = 1;</code>
       */
      public Builder mergeBindToPort(com.google.protobuf.BoolValue value) {
        if (bindToPortBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            bindToPort_ != null &&
            bindToPort_ != com.google.protobuf.BoolValue.getDefaultInstance()) {
            getBindToPortBuilder().mergeFrom(value);
          } else {
            bindToPort_ = value;
          }
        } else {
          bindToPortBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether the listener should bind to the port. A listener that doesn't
       * bind can only receive connections redirected from other listeners that
       * set use_original_dst parameter to true. Default is true.
       * This is deprecated. Use :ref:`Listener.bind_to_port
       * &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;`
       * </pre>
       *
       * <code>.google.protobuf.BoolValue bind_to_port = 1;</code>
       */
      public Builder clearBindToPort() {
        bitField0_ = (bitField0_ & ~0x00000001);
        bindToPort_ = null;
        if (bindToPortBuilder_ != null) {
          bindToPortBuilder_.dispose();
          bindToPortBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether the listener should bind to the port. A listener that doesn't
       * bind can only receive connections redirected from other listeners that
       * set use_original_dst parameter to true. Default is true.
       * This is deprecated. Use :ref:`Listener.bind_to_port
       * &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;`
       * </pre>
       *
       * <code>.google.protobuf.BoolValue bind_to_port = 1;</code>
       */
      public com.google.protobuf.BoolValue.Builder getBindToPortBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getBindToPortFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Whether the listener should bind to the port. A listener that doesn't
       * bind can only receive connections redirected from other listeners that
       * set use_original_dst parameter to true. Default is true.
       * This is deprecated. Use :ref:`Listener.bind_to_port
       * &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;`
       * </pre>
       *
       * <code>.google.protobuf.BoolValue bind_to_port = 1;</code>
       */
      public com.google.protobuf.BoolValueOrBuilder getBindToPortOrBuilder() {
        if (bindToPortBuilder_ != null) {
          return bindToPortBuilder_.getMessageOrBuilder();
        } else {
          return bindToPort_ == null ?
              com.google.protobuf.BoolValue.getDefaultInstance() : bindToPort_;
        }
      }
      /**
       * <pre>
       * Whether the listener should bind to the port. A listener that doesn't
       * bind can only receive connections redirected from other listeners that
       * set use_original_dst parameter to true. Default is true.
       * This is deprecated. Use :ref:`Listener.bind_to_port
       * &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;`
       * </pre>
       *
       * <code>.google.protobuf.BoolValue bind_to_port = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
          getBindToPortFieldBuilder() {
        if (bindToPortBuilder_ == null) {
          bindToPortBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                  getBindToPort(),
                  getParentForChildren(),
                  isClean());
          bindToPort_ = null;
        }
        return bindToPortBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.config.listener.v3.Listener.DeprecatedV1)
    }

    // @@protoc_insertion_point(class_scope:envoy.config.listener.v3.Listener.DeprecatedV1)
    private static final io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1();
    }

    public static io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DeprecatedV1>
        PARSER = new com.google.protobuf.AbstractParser<DeprecatedV1>() {
      @java.lang.Override
      public DeprecatedV1 parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<DeprecatedV1> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeprecatedV1> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ConnectionBalanceConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.config.listener.v3.Listener.ConnectionBalanceConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * If specified, the listener will use the exact connection balancer.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance exact_balance = 1;</code>
     * @return Whether the exactBalance field is set.
     */
    boolean hasExactBalance();
    /**
     * <pre>
     * If specified, the listener will use the exact connection balancer.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance exact_balance = 1;</code>
     * @return The exactBalance.
     */
    io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance getExactBalance();
    /**
     * <pre>
     * If specified, the listener will use the exact connection balancer.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance exact_balance = 1;</code>
     */
    io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalanceOrBuilder getExactBalanceOrBuilder();

    /**
     * <pre>
     * The listener will use the connection balancer according to ``type_url``. If ``type_url`` is invalid,
     * Envoy will not attempt to balance active connections between worker threads.
     * [#extension-category: envoy.network.connection_balance]
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig extend_balance = 2;</code>
     * @return Whether the extendBalance field is set.
     */
    boolean hasExtendBalance();
    /**
     * <pre>
     * The listener will use the connection balancer according to ``type_url``. If ``type_url`` is invalid,
     * Envoy will not attempt to balance active connections between worker threads.
     * [#extension-category: envoy.network.connection_balance]
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig extend_balance = 2;</code>
     * @return The extendBalance.
     */
    io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig getExtendBalance();
    /**
     * <pre>
     * The listener will use the connection balancer according to ``type_url``. If ``type_url`` is invalid,
     * Envoy will not attempt to balance active connections between worker threads.
     * [#extension-category: envoy.network.connection_balance]
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig extend_balance = 2;</code>
     */
    io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder getExtendBalanceOrBuilder();

    public io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.BalanceTypeCase getBalanceTypeCase();
  }
  /**
   * <pre>
   * Configuration for listener connection balancing.
   * </pre>
   *
   * Protobuf type {@code envoy.config.listener.v3.Listener.ConnectionBalanceConfig}
   */
  public static final class ConnectionBalanceConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.config.listener.v3.Listener.ConnectionBalanceConfig)
      ConnectionBalanceConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ConnectionBalanceConfig.newBuilder() to construct.
    private ConnectionBalanceConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ConnectionBalanceConfig() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ConnectionBalanceConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_ConnectionBalanceConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_ConnectionBalanceConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.class, io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.Builder.class);
    }

    public interface ExactBalanceOrBuilder extends
        // @@protoc_insertion_point(interface_extends:envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance)
        com.google.protobuf.MessageOrBuilder {
    }
    /**
     * <pre>
     * A connection balancer implementation that does exact balancing. This means that a lock is
     * held during balancing so that connection counts are nearly exactly balanced between worker
     * threads. This is "nearly" exact in the sense that a connection might close in parallel thus
     * making the counts incorrect, but this should be rectified on the next accept. This balancer
     * sacrifices accept throughput for accuracy and should be used when there are a small number of
     * connections that rarely cycle (e.g., service mesh gRPC egress).
     * </pre>
     *
     * Protobuf type {@code envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance}
     */
    public static final class ExactBalance extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance)
        ExactBalanceOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use ExactBalance.newBuilder() to construct.
      private ExactBalance(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private ExactBalance() {
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new ExactBalance();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_ConnectionBalanceConfig_ExactBalance_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_ConnectionBalanceConfig_ExactBalance_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance.class, io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance.Builder.class);
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance)) {
          return super.equals(obj);
        }
        io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance other = (io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance) obj;

        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * A connection balancer implementation that does exact balancing. This means that a lock is
       * held during balancing so that connection counts are nearly exactly balanced between worker
       * threads. This is "nearly" exact in the sense that a connection might close in parallel thus
       * making the counts incorrect, but this should be rectified on the next accept. This balancer
       * sacrifices accept throughput for accuracy and should be used when there are a small number of
       * connections that rarely cycle (e.g., service mesh gRPC egress).
       * </pre>
       *
       * Protobuf type {@code envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance)
          io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalanceOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_ConnectionBalanceConfig_ExactBalance_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_ConnectionBalanceConfig_ExactBalance_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance.class, io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance.Builder.class);
        }

        // Construct using io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_ConnectionBalanceConfig_ExactBalance_descriptor;
        }

        @java.lang.Override
        public io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance getDefaultInstanceForType() {
          return io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance.getDefaultInstance();
        }

        @java.lang.Override
        public io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance build() {
          io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance buildPartial() {
          io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance result = new io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance(this);
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance) {
            return mergeFrom((io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance other) {
          if (other == io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance.getDefaultInstance()) return this;
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance)
      }

      // @@protoc_insertion_point(class_scope:envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance)
      private static final io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance();
      }

      public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<ExactBalance>
          PARSER = new com.google.protobuf.AbstractParser<ExactBalance>() {
        @java.lang.Override
        public ExactBalance parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<ExactBalance> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<ExactBalance> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int balanceTypeCase_ = 0;
    private java.lang.Object balanceType_;
    public enum BalanceTypeCase
        implements com.google.protobuf.Internal.EnumLite,
            com.google.protobuf.AbstractMessage.InternalOneOfEnum {
      EXACT_BALANCE(1),
      EXTEND_BALANCE(2),
      BALANCETYPE_NOT_SET(0);
      private final int value;
      private BalanceTypeCase(int value) {
        this.value = value;
      }
      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static BalanceTypeCase valueOf(int value) {
        return forNumber(value);
      }

      public static BalanceTypeCase forNumber(int value) {
        switch (value) {
          case 1: return EXACT_BALANCE;
          case 2: return EXTEND_BALANCE;
          case 0: return BALANCETYPE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public BalanceTypeCase
    getBalanceTypeCase() {
      return BalanceTypeCase.forNumber(
          balanceTypeCase_);
    }

    public static final int EXACT_BALANCE_FIELD_NUMBER = 1;
    /**
     * <pre>
     * If specified, the listener will use the exact connection balancer.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance exact_balance = 1;</code>
     * @return Whether the exactBalance field is set.
     */
    @java.lang.Override
    public boolean hasExactBalance() {
      return balanceTypeCase_ == 1;
    }
    /**
     * <pre>
     * If specified, the listener will use the exact connection balancer.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance exact_balance = 1;</code>
     * @return The exactBalance.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance getExactBalance() {
      if (balanceTypeCase_ == 1) {
         return (io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance) balanceType_;
      }
      return io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance.getDefaultInstance();
    }
    /**
     * <pre>
     * If specified, the listener will use the exact connection balancer.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance exact_balance = 1;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalanceOrBuilder getExactBalanceOrBuilder() {
      if (balanceTypeCase_ == 1) {
         return (io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance) balanceType_;
      }
      return io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance.getDefaultInstance();
    }

    public static final int EXTEND_BALANCE_FIELD_NUMBER = 2;
    /**
     * <pre>
     * The listener will use the connection balancer according to ``type_url``. If ``type_url`` is invalid,
     * Envoy will not attempt to balance active connections between worker threads.
     * [#extension-category: envoy.network.connection_balance]
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig extend_balance = 2;</code>
     * @return Whether the extendBalance field is set.
     */
    @java.lang.Override
    public boolean hasExtendBalance() {
      return balanceTypeCase_ == 2;
    }
    /**
     * <pre>
     * The listener will use the connection balancer according to ``type_url``. If ``type_url`` is invalid,
     * Envoy will not attempt to balance active connections between worker threads.
     * [#extension-category: envoy.network.connection_balance]
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig extend_balance = 2;</code>
     * @return The extendBalance.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig getExtendBalance() {
      if (balanceTypeCase_ == 2) {
         return (io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig) balanceType_;
      }
      return io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.getDefaultInstance();
    }
    /**
     * <pre>
     * The listener will use the connection balancer according to ``type_url``. If ``type_url`` is invalid,
     * Envoy will not attempt to balance active connections between worker threads.
     * [#extension-category: envoy.network.connection_balance]
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig extend_balance = 2;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder getExtendBalanceOrBuilder() {
      if (balanceTypeCase_ == 2) {
         return (io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig) balanceType_;
      }
      return io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.getDefaultInstance();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (balanceTypeCase_ == 1) {
        output.writeMessage(1, (io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance) balanceType_);
      }
      if (balanceTypeCase_ == 2) {
        output.writeMessage(2, (io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig) balanceType_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (balanceTypeCase_ == 1) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, (io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance) balanceType_);
      }
      if (balanceTypeCase_ == 2) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, (io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig) balanceType_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig other = (io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig) obj;

      if (!getBalanceTypeCase().equals(other.getBalanceTypeCase())) return false;
      switch (balanceTypeCase_) {
        case 1:
          if (!getExactBalance()
              .equals(other.getExactBalance())) return false;
          break;
        case 2:
          if (!getExtendBalance()
              .equals(other.getExtendBalance())) return false;
          break;
        case 0:
        default:
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      switch (balanceTypeCase_) {
        case 1:
          hash = (37 * hash) + EXACT_BALANCE_FIELD_NUMBER;
          hash = (53 * hash) + getExactBalance().hashCode();
          break;
        case 2:
          hash = (37 * hash) + EXTEND_BALANCE_FIELD_NUMBER;
          hash = (53 * hash) + getExtendBalance().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Configuration for listener connection balancing.
     * </pre>
     *
     * Protobuf type {@code envoy.config.listener.v3.Listener.ConnectionBalanceConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.config.listener.v3.Listener.ConnectionBalanceConfig)
        io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_ConnectionBalanceConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_ConnectionBalanceConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.class, io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (exactBalanceBuilder_ != null) {
          exactBalanceBuilder_.clear();
        }
        if (extendBalanceBuilder_ != null) {
          extendBalanceBuilder_.clear();
        }
        balanceTypeCase_ = 0;
        balanceType_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_ConnectionBalanceConfig_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig getDefaultInstanceForType() {
        return io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig build() {
        io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig buildPartial() {
        io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig result = new io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        buildPartialOneofs(result);
        onBuilt();
        return result;
      }

      private void buildPartial0(io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig result) {
        int from_bitField0_ = bitField0_;
      }

      private void buildPartialOneofs(io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig result) {
        result.balanceTypeCase_ = balanceTypeCase_;
        result.balanceType_ = this.balanceType_;
        if (balanceTypeCase_ == 1 &&
            exactBalanceBuilder_ != null) {
          result.balanceType_ = exactBalanceBuilder_.build();
        }
        if (balanceTypeCase_ == 2 &&
            extendBalanceBuilder_ != null) {
          result.balanceType_ = extendBalanceBuilder_.build();
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig) {
          return mergeFrom((io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig other) {
        if (other == io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.getDefaultInstance()) return this;
        switch (other.getBalanceTypeCase()) {
          case EXACT_BALANCE: {
            mergeExactBalance(other.getExactBalance());
            break;
          }
          case EXTEND_BALANCE: {
            mergeExtendBalance(other.getExtendBalance());
            break;
          }
          case BALANCETYPE_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getExactBalanceFieldBuilder().getBuilder(),
                    extensionRegistry);
                balanceTypeCase_ = 1;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getExtendBalanceFieldBuilder().getBuilder(),
                    extensionRegistry);
                balanceTypeCase_ = 2;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int balanceTypeCase_ = 0;
      private java.lang.Object balanceType_;
      public BalanceTypeCase
          getBalanceTypeCase() {
        return BalanceTypeCase.forNumber(
            balanceTypeCase_);
      }

      public Builder clearBalanceType() {
        balanceTypeCase_ = 0;
        balanceType_ = null;
        onChanged();
        return this;
      }

      private int bitField0_;

      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance, io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance.Builder, io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalanceOrBuilder> exactBalanceBuilder_;
      /**
       * <pre>
       * If specified, the listener will use the exact connection balancer.
       * </pre>
       *
       * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance exact_balance = 1;</code>
       * @return Whether the exactBalance field is set.
       */
      @java.lang.Override
      public boolean hasExactBalance() {
        return balanceTypeCase_ == 1;
      }
      /**
       * <pre>
       * If specified, the listener will use the exact connection balancer.
       * </pre>
       *
       * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance exact_balance = 1;</code>
       * @return The exactBalance.
       */
      @java.lang.Override
      public io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance getExactBalance() {
        if (exactBalanceBuilder_ == null) {
          if (balanceTypeCase_ == 1) {
            return (io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance) balanceType_;
          }
          return io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance.getDefaultInstance();
        } else {
          if (balanceTypeCase_ == 1) {
            return exactBalanceBuilder_.getMessage();
          }
          return io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * If specified, the listener will use the exact connection balancer.
       * </pre>
       *
       * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance exact_balance = 1;</code>
       */
      public Builder setExactBalance(io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance value) {
        if (exactBalanceBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          balanceType_ = value;
          onChanged();
        } else {
          exactBalanceBuilder_.setMessage(value);
        }
        balanceTypeCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * If specified, the listener will use the exact connection balancer.
       * </pre>
       *
       * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance exact_balance = 1;</code>
       */
      public Builder setExactBalance(
          io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance.Builder builderForValue) {
        if (exactBalanceBuilder_ == null) {
          balanceType_ = builderForValue.build();
          onChanged();
        } else {
          exactBalanceBuilder_.setMessage(builderForValue.build());
        }
        balanceTypeCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * If specified, the listener will use the exact connection balancer.
       * </pre>
       *
       * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance exact_balance = 1;</code>
       */
      public Builder mergeExactBalance(io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance value) {
        if (exactBalanceBuilder_ == null) {
          if (balanceTypeCase_ == 1 &&
              balanceType_ != io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance.getDefaultInstance()) {
            balanceType_ = io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance.newBuilder((io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance) balanceType_)
                .mergeFrom(value).buildPartial();
          } else {
            balanceType_ = value;
          }
          onChanged();
        } else {
          if (balanceTypeCase_ == 1) {
            exactBalanceBuilder_.mergeFrom(value);
          } else {
            exactBalanceBuilder_.setMessage(value);
          }
        }
        balanceTypeCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * If specified, the listener will use the exact connection balancer.
       * </pre>
       *
       * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance exact_balance = 1;</code>
       */
      public Builder clearExactBalance() {
        if (exactBalanceBuilder_ == null) {
          if (balanceTypeCase_ == 1) {
            balanceTypeCase_ = 0;
            balanceType_ = null;
            onChanged();
          }
        } else {
          if (balanceTypeCase_ == 1) {
            balanceTypeCase_ = 0;
            balanceType_ = null;
          }
          exactBalanceBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * If specified, the listener will use the exact connection balancer.
       * </pre>
       *
       * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance exact_balance = 1;</code>
       */
      public io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance.Builder getExactBalanceBuilder() {
        return getExactBalanceFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * If specified, the listener will use the exact connection balancer.
       * </pre>
       *
       * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance exact_balance = 1;</code>
       */
      @java.lang.Override
      public io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalanceOrBuilder getExactBalanceOrBuilder() {
        if ((balanceTypeCase_ == 1) && (exactBalanceBuilder_ != null)) {
          return exactBalanceBuilder_.getMessageOrBuilder();
        } else {
          if (balanceTypeCase_ == 1) {
            return (io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance) balanceType_;
          }
          return io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * If specified, the listener will use the exact connection balancer.
       * </pre>
       *
       * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance exact_balance = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance, io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance.Builder, io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalanceOrBuilder> 
          getExactBalanceFieldBuilder() {
        if (exactBalanceBuilder_ == null) {
          if (!(balanceTypeCase_ == 1)) {
            balanceType_ = io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance.getDefaultInstance();
          }
          exactBalanceBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance, io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance.Builder, io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalanceOrBuilder>(
                  (io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.ExactBalance) balanceType_,
                  getParentForChildren(),
                  isClean());
          balanceType_ = null;
        }
        balanceTypeCase_ = 1;
        onChanged();
        return exactBalanceBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder> extendBalanceBuilder_;
      /**
       * <pre>
       * The listener will use the connection balancer according to ``type_url``. If ``type_url`` is invalid,
       * Envoy will not attempt to balance active connections between worker threads.
       * [#extension-category: envoy.network.connection_balance]
       * </pre>
       *
       * <code>.envoy.config.core.v3.TypedExtensionConfig extend_balance = 2;</code>
       * @return Whether the extendBalance field is set.
       */
      @java.lang.Override
      public boolean hasExtendBalance() {
        return balanceTypeCase_ == 2;
      }
      /**
       * <pre>
       * The listener will use the connection balancer according to ``type_url``. If ``type_url`` is invalid,
       * Envoy will not attempt to balance active connections between worker threads.
       * [#extension-category: envoy.network.connection_balance]
       * </pre>
       *
       * <code>.envoy.config.core.v3.TypedExtensionConfig extend_balance = 2;</code>
       * @return The extendBalance.
       */
      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig getExtendBalance() {
        if (extendBalanceBuilder_ == null) {
          if (balanceTypeCase_ == 2) {
            return (io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig) balanceType_;
          }
          return io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.getDefaultInstance();
        } else {
          if (balanceTypeCase_ == 2) {
            return extendBalanceBuilder_.getMessage();
          }
          return io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * The listener will use the connection balancer according to ``type_url``. If ``type_url`` is invalid,
       * Envoy will not attempt to balance active connections between worker threads.
       * [#extension-category: envoy.network.connection_balance]
       * </pre>
       *
       * <code>.envoy.config.core.v3.TypedExtensionConfig extend_balance = 2;</code>
       */
      public Builder setExtendBalance(io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig value) {
        if (extendBalanceBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          balanceType_ = value;
          onChanged();
        } else {
          extendBalanceBuilder_.setMessage(value);
        }
        balanceTypeCase_ = 2;
        return this;
      }
      /**
       * <pre>
       * The listener will use the connection balancer according to ``type_url``. If ``type_url`` is invalid,
       * Envoy will not attempt to balance active connections between worker threads.
       * [#extension-category: envoy.network.connection_balance]
       * </pre>
       *
       * <code>.envoy.config.core.v3.TypedExtensionConfig extend_balance = 2;</code>
       */
      public Builder setExtendBalance(
          io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder builderForValue) {
        if (extendBalanceBuilder_ == null) {
          balanceType_ = builderForValue.build();
          onChanged();
        } else {
          extendBalanceBuilder_.setMessage(builderForValue.build());
        }
        balanceTypeCase_ = 2;
        return this;
      }
      /**
       * <pre>
       * The listener will use the connection balancer according to ``type_url``. If ``type_url`` is invalid,
       * Envoy will not attempt to balance active connections between worker threads.
       * [#extension-category: envoy.network.connection_balance]
       * </pre>
       *
       * <code>.envoy.config.core.v3.TypedExtensionConfig extend_balance = 2;</code>
       */
      public Builder mergeExtendBalance(io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig value) {
        if (extendBalanceBuilder_ == null) {
          if (balanceTypeCase_ == 2 &&
              balanceType_ != io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.getDefaultInstance()) {
            balanceType_ = io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.newBuilder((io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig) balanceType_)
                .mergeFrom(value).buildPartial();
          } else {
            balanceType_ = value;
          }
          onChanged();
        } else {
          if (balanceTypeCase_ == 2) {
            extendBalanceBuilder_.mergeFrom(value);
          } else {
            extendBalanceBuilder_.setMessage(value);
          }
        }
        balanceTypeCase_ = 2;
        return this;
      }
      /**
       * <pre>
       * The listener will use the connection balancer according to ``type_url``. If ``type_url`` is invalid,
       * Envoy will not attempt to balance active connections between worker threads.
       * [#extension-category: envoy.network.connection_balance]
       * </pre>
       *
       * <code>.envoy.config.core.v3.TypedExtensionConfig extend_balance = 2;</code>
       */
      public Builder clearExtendBalance() {
        if (extendBalanceBuilder_ == null) {
          if (balanceTypeCase_ == 2) {
            balanceTypeCase_ = 0;
            balanceType_ = null;
            onChanged();
          }
        } else {
          if (balanceTypeCase_ == 2) {
            balanceTypeCase_ = 0;
            balanceType_ = null;
          }
          extendBalanceBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The listener will use the connection balancer according to ``type_url``. If ``type_url`` is invalid,
       * Envoy will not attempt to balance active connections between worker threads.
       * [#extension-category: envoy.network.connection_balance]
       * </pre>
       *
       * <code>.envoy.config.core.v3.TypedExtensionConfig extend_balance = 2;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder getExtendBalanceBuilder() {
        return getExtendBalanceFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The listener will use the connection balancer according to ``type_url``. If ``type_url`` is invalid,
       * Envoy will not attempt to balance active connections between worker threads.
       * [#extension-category: envoy.network.connection_balance]
       * </pre>
       *
       * <code>.envoy.config.core.v3.TypedExtensionConfig extend_balance = 2;</code>
       */
      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder getExtendBalanceOrBuilder() {
        if ((balanceTypeCase_ == 2) && (extendBalanceBuilder_ != null)) {
          return extendBalanceBuilder_.getMessageOrBuilder();
        } else {
          if (balanceTypeCase_ == 2) {
            return (io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig) balanceType_;
          }
          return io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * The listener will use the connection balancer according to ``type_url``. If ``type_url`` is invalid,
       * Envoy will not attempt to balance active connections between worker threads.
       * [#extension-category: envoy.network.connection_balance]
       * </pre>
       *
       * <code>.envoy.config.core.v3.TypedExtensionConfig extend_balance = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder> 
          getExtendBalanceFieldBuilder() {
        if (extendBalanceBuilder_ == null) {
          if (!(balanceTypeCase_ == 2)) {
            balanceType_ = io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.getDefaultInstance();
          }
          extendBalanceBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder>(
                  (io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig) balanceType_,
                  getParentForChildren(),
                  isClean());
          balanceType_ = null;
        }
        balanceTypeCase_ = 2;
        onChanged();
        return extendBalanceBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.config.listener.v3.Listener.ConnectionBalanceConfig)
    }

    // @@protoc_insertion_point(class_scope:envoy.config.listener.v3.Listener.ConnectionBalanceConfig)
    private static final io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig();
    }

    public static io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ConnectionBalanceConfig>
        PARSER = new com.google.protobuf.AbstractParser<ConnectionBalanceConfig>() {
      @java.lang.Override
      public ConnectionBalanceConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ConnectionBalanceConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ConnectionBalanceConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface InternalListenerConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.config.listener.v3.Listener.InternalListenerConfig)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Configuration for envoy internal listener. All the future internal listener features should be added here.
   * </pre>
   *
   * Protobuf type {@code envoy.config.listener.v3.Listener.InternalListenerConfig}
   */
  public static final class InternalListenerConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.config.listener.v3.Listener.InternalListenerConfig)
      InternalListenerConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use InternalListenerConfig.newBuilder() to construct.
    private InternalListenerConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private InternalListenerConfig() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new InternalListenerConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_InternalListenerConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_InternalListenerConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig.class, io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig other = (io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig) obj;

      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Configuration for envoy internal listener. All the future internal listener features should be added here.
     * </pre>
     *
     * Protobuf type {@code envoy.config.listener.v3.Listener.InternalListenerConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.config.listener.v3.Listener.InternalListenerConfig)
        io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_InternalListenerConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_InternalListenerConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig.class, io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_InternalListenerConfig_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig getDefaultInstanceForType() {
        return io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig build() {
        io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig buildPartial() {
        io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig result = new io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig) {
          return mergeFrom((io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig other) {
        if (other == io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.config.listener.v3.Listener.InternalListenerConfig)
    }

    // @@protoc_insertion_point(class_scope:envoy.config.listener.v3.Listener.InternalListenerConfig)
    private static final io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig();
    }

    public static io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<InternalListenerConfig>
        PARSER = new com.google.protobuf.AbstractParser<InternalListenerConfig>() {
      @java.lang.Override
      public InternalListenerConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<InternalListenerConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<InternalListenerConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private int listenerSpecifierCase_ = 0;
  private java.lang.Object listenerSpecifier_;
  public enum ListenerSpecifierCase
      implements com.google.protobuf.Internal.EnumLite,
          com.google.protobuf.AbstractMessage.InternalOneOfEnum {
    INTERNAL_LISTENER(27),
    LISTENERSPECIFIER_NOT_SET(0);
    private final int value;
    private ListenerSpecifierCase(int value) {
      this.value = value;
    }
    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static ListenerSpecifierCase valueOf(int value) {
      return forNumber(value);
    }

    public static ListenerSpecifierCase forNumber(int value) {
      switch (value) {
        case 27: return INTERNAL_LISTENER;
        case 0: return LISTENERSPECIFIER_NOT_SET;
        default: return null;
      }
    }
    public int getNumber() {
      return this.value;
    }
  };

  public ListenerSpecifierCase
  getListenerSpecifierCase() {
    return ListenerSpecifierCase.forNumber(
        listenerSpecifierCase_);
  }

  public static final int NAME_FIELD_NUMBER = 1;
  @SuppressWarnings("serial")
  private volatile java.lang.Object name_ = "";
  /**
   * <pre>
   * The unique name by which this listener is known. If no name is provided,
   * Envoy will allocate an internal UUID for the listener. If the listener is to be dynamically
   * updated or removed via :ref:`LDS &lt;config_listeners_lds&gt;` a unique name must be provided.
   * </pre>
   *
   * <code>string name = 1;</code>
   * @return The name.
   */
  @java.lang.Override
  public java.lang.String getName() {
    java.lang.Object ref = name_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      name_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * The unique name by which this listener is known. If no name is provided,
   * Envoy will allocate an internal UUID for the listener. If the listener is to be dynamically
   * updated or removed via :ref:`LDS &lt;config_listeners_lds&gt;` a unique name must be provided.
   * </pre>
   *
   * <code>string name = 1;</code>
   * @return The bytes for name.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getNameBytes() {
    java.lang.Object ref = name_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      name_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ADDRESS_FIELD_NUMBER = 2;
  private io.envoyproxy.envoy.config.core.v3.Address address_;
  /**
   * <pre>
   * The address that the listener should listen on. In general, the address must be unique, though
   * that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on
   * Linux as the actual port will be allocated by the OS.
   * Required unless ``api_listener`` or ``listener_specifier`` is populated.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Address address = 2;</code>
   * @return Whether the address field is set.
   */
  @java.lang.Override
  public boolean hasAddress() {
    return address_ != null;
  }
  /**
   * <pre>
   * The address that the listener should listen on. In general, the address must be unique, though
   * that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on
   * Linux as the actual port will be allocated by the OS.
   * Required unless ``api_listener`` or ``listener_specifier`` is populated.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Address address = 2;</code>
   * @return The address.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.Address getAddress() {
    return address_ == null ? io.envoyproxy.envoy.config.core.v3.Address.getDefaultInstance() : address_;
  }
  /**
   * <pre>
   * The address that the listener should listen on. In general, the address must be unique, though
   * that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on
   * Linux as the actual port will be allocated by the OS.
   * Required unless ``api_listener`` or ``listener_specifier`` is populated.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Address address = 2;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.AddressOrBuilder getAddressOrBuilder() {
    return address_ == null ? io.envoyproxy.envoy.config.core.v3.Address.getDefaultInstance() : address_;
  }

  public static final int ADDITIONAL_ADDRESSES_FIELD_NUMBER = 33;
  @SuppressWarnings("serial")
  private java.util.List<io.envoyproxy.envoy.config.listener.v3.AdditionalAddress> additionalAddresses_;
  /**
   * <pre>
   * The additional addresses the listener should listen on. The addresses must be unique across all
   * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
   * all addresses use the same protocol, and multiple internal addresses are not supported.
   * </pre>
   *
   * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
   */
  @java.lang.Override
  public java.util.List<io.envoyproxy.envoy.config.listener.v3.AdditionalAddress> getAdditionalAddressesList() {
    return additionalAddresses_;
  }
  /**
   * <pre>
   * The additional addresses the listener should listen on. The addresses must be unique across all
   * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
   * all addresses use the same protocol, and multiple internal addresses are not supported.
   * </pre>
   *
   * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
   */
  @java.lang.Override
  public java.util.List<? extends io.envoyproxy.envoy.config.listener.v3.AdditionalAddressOrBuilder> 
      getAdditionalAddressesOrBuilderList() {
    return additionalAddresses_;
  }
  /**
   * <pre>
   * The additional addresses the listener should listen on. The addresses must be unique across all
   * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
   * all addresses use the same protocol, and multiple internal addresses are not supported.
   * </pre>
   *
   * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
   */
  @java.lang.Override
  public int getAdditionalAddressesCount() {
    return additionalAddresses_.size();
  }
  /**
   * <pre>
   * The additional addresses the listener should listen on. The addresses must be unique across all
   * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
   * all addresses use the same protocol, and multiple internal addresses are not supported.
   * </pre>
   *
   * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.listener.v3.AdditionalAddress getAdditionalAddresses(int index) {
    return additionalAddresses_.get(index);
  }
  /**
   * <pre>
   * The additional addresses the listener should listen on. The addresses must be unique across all
   * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
   * all addresses use the same protocol, and multiple internal addresses are not supported.
   * </pre>
   *
   * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.listener.v3.AdditionalAddressOrBuilder getAdditionalAddressesOrBuilder(
      int index) {
    return additionalAddresses_.get(index);
  }

  public static final int STAT_PREFIX_FIELD_NUMBER = 28;
  @SuppressWarnings("serial")
  private volatile java.lang.Object statPrefix_ = "";
  /**
   * <pre>
   * Optional prefix to use on listener stats. If empty, the stats will be rooted at
   * ``listener.&lt;address as string&gt;.``. If non-empty, stats will be rooted at
   * ``listener.&lt;stat_prefix&gt;.``.
   * </pre>
   *
   * <code>string stat_prefix = 28;</code>
   * @return The statPrefix.
   */
  @java.lang.Override
  public java.lang.String getStatPrefix() {
    java.lang.Object ref = statPrefix_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      statPrefix_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Optional prefix to use on listener stats. If empty, the stats will be rooted at
   * ``listener.&lt;address as string&gt;.``. If non-empty, stats will be rooted at
   * ``listener.&lt;stat_prefix&gt;.``.
   * </pre>
   *
   * <code>string stat_prefix = 28;</code>
   * @return The bytes for statPrefix.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getStatPrefixBytes() {
    java.lang.Object ref = statPrefix_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      statPrefix_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int FILTER_CHAINS_FIELD_NUMBER = 3;
  @SuppressWarnings("serial")
  private java.util.List<io.envoyproxy.envoy.config.listener.v3.FilterChain> filterChains_;
  /**
   * <pre>
   * A list of filter chains to consider for this listener. The
   * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
   * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
   * connection.
   * Example using SNI for filter chain selection can be found in the
   * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
   * </pre>
   *
   * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
   */
  @java.lang.Override
  public java.util.List<io.envoyproxy.envoy.config.listener.v3.FilterChain> getFilterChainsList() {
    return filterChains_;
  }
  /**
   * <pre>
   * A list of filter chains to consider for this listener. The
   * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
   * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
   * connection.
   * Example using SNI for filter chain selection can be found in the
   * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
   * </pre>
   *
   * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
   */
  @java.lang.Override
  public java.util.List<? extends io.envoyproxy.envoy.config.listener.v3.FilterChainOrBuilder> 
      getFilterChainsOrBuilderList() {
    return filterChains_;
  }
  /**
   * <pre>
   * A list of filter chains to consider for this listener. The
   * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
   * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
   * connection.
   * Example using SNI for filter chain selection can be found in the
   * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
   * </pre>
   *
   * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
   */
  @java.lang.Override
  public int getFilterChainsCount() {
    return filterChains_.size();
  }
  /**
   * <pre>
   * A list of filter chains to consider for this listener. The
   * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
   * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
   * connection.
   * Example using SNI for filter chain selection can be found in the
   * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
   * </pre>
   *
   * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.listener.v3.FilterChain getFilterChains(int index) {
    return filterChains_.get(index);
  }
  /**
   * <pre>
   * A list of filter chains to consider for this listener. The
   * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
   * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
   * connection.
   * Example using SNI for filter chain selection can be found in the
   * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
   * </pre>
   *
   * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.listener.v3.FilterChainOrBuilder getFilterChainsOrBuilder(
      int index) {
    return filterChains_.get(index);
  }

  public static final int FILTER_CHAIN_MATCHER_FIELD_NUMBER = 32;
  private com.github.xds.type.matcher.v3.Matcher filterChainMatcher_;
  /**
   * <pre>
   * :ref:`Matcher API &lt;arch_overview_matching_listener&gt;` resolving the filter chain name from the
   * network properties. This matcher is used as a replacement for the filter chain match condition
   * :ref:`filter_chain_match
   * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;`. If specified, all
   * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;` must have a
   * non-empty and unique :ref:`name &lt;envoy_v3_api_field_config.listener.v3.FilterChain.name&gt;` field
   * and not specify :ref:`filter_chain_match
   * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;` field.
   * .. note::
   *  Once matched, each connection is permanently bound to its filter chain.
   *  If the matcher changes but the filter chain remains the same, the
   *  connections bound to the filter chain are not drained. If, however, the
   *  filter chain is removed or structurally modified, then the drain for its
   *  connections is initiated.
   * </pre>
   *
   * <code>.xds.type.matcher.v3.Matcher filter_chain_matcher = 32 [(.xds.annotations.v3.field_status) = { ... }</code>
   * @return Whether the filterChainMatcher field is set.
   */
  @java.lang.Override
  public boolean hasFilterChainMatcher() {
    return filterChainMatcher_ != null;
  }
  /**
   * <pre>
   * :ref:`Matcher API &lt;arch_overview_matching_listener&gt;` resolving the filter chain name from the
   * network properties. This matcher is used as a replacement for the filter chain match condition
   * :ref:`filter_chain_match
   * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;`. If specified, all
   * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;` must have a
   * non-empty and unique :ref:`name &lt;envoy_v3_api_field_config.listener.v3.FilterChain.name&gt;` field
   * and not specify :ref:`filter_chain_match
   * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;` field.
   * .. note::
   *  Once matched, each connection is permanently bound to its filter chain.
   *  If the matcher changes but the filter chain remains the same, the
   *  connections bound to the filter chain are not drained. If, however, the
   *  filter chain is removed or structurally modified, then the drain for its
   *  connections is initiated.
   * </pre>
   *
   * <code>.xds.type.matcher.v3.Matcher filter_chain_matcher = 32 [(.xds.annotations.v3.field_status) = { ... }</code>
   * @return The filterChainMatcher.
   */
  @java.lang.Override
  public com.github.xds.type.matcher.v3.Matcher getFilterChainMatcher() {
    return filterChainMatcher_ == null ? com.github.xds.type.matcher.v3.Matcher.getDefaultInstance() : filterChainMatcher_;
  }
  /**
   * <pre>
   * :ref:`Matcher API &lt;arch_overview_matching_listener&gt;` resolving the filter chain name from the
   * network properties. This matcher is used as a replacement for the filter chain match condition
   * :ref:`filter_chain_match
   * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;`. If specified, all
   * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;` must have a
   * non-empty and unique :ref:`name &lt;envoy_v3_api_field_config.listener.v3.FilterChain.name&gt;` field
   * and not specify :ref:`filter_chain_match
   * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;` field.
   * .. note::
   *  Once matched, each connection is permanently bound to its filter chain.
   *  If the matcher changes but the filter chain remains the same, the
   *  connections bound to the filter chain are not drained. If, however, the
   *  filter chain is removed or structurally modified, then the drain for its
   *  connections is initiated.
   * </pre>
   *
   * <code>.xds.type.matcher.v3.Matcher filter_chain_matcher = 32 [(.xds.annotations.v3.field_status) = { ... }</code>
   */
  @java.lang.Override
  public com.github.xds.type.matcher.v3.MatcherOrBuilder getFilterChainMatcherOrBuilder() {
    return filterChainMatcher_ == null ? com.github.xds.type.matcher.v3.Matcher.getDefaultInstance() : filterChainMatcher_;
  }

  public static final int USE_ORIGINAL_DST_FIELD_NUMBER = 4;
  private com.google.protobuf.BoolValue useOriginalDst_;
  /**
   * <pre>
   * If a connection is redirected using ``iptables``, the port on which the proxy
   * receives it might be different from the original destination address. When this flag is set to
   * true, the listener hands off redirected connections to the listener associated with the
   * original destination address. If there is no listener associated with the original destination
   * address, the connection is handled by the listener that receives it. Defaults to false.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue use_original_dst = 4;</code>
   * @return Whether the useOriginalDst field is set.
   */
  @java.lang.Override
  public boolean hasUseOriginalDst() {
    return useOriginalDst_ != null;
  }
  /**
   * <pre>
   * If a connection is redirected using ``iptables``, the port on which the proxy
   * receives it might be different from the original destination address. When this flag is set to
   * true, the listener hands off redirected connections to the listener associated with the
   * original destination address. If there is no listener associated with the original destination
   * address, the connection is handled by the listener that receives it. Defaults to false.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue use_original_dst = 4;</code>
   * @return The useOriginalDst.
   */
  @java.lang.Override
  public com.google.protobuf.BoolValue getUseOriginalDst() {
    return useOriginalDst_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : useOriginalDst_;
  }
  /**
   * <pre>
   * If a connection is redirected using ``iptables``, the port on which the proxy
   * receives it might be different from the original destination address. When this flag is set to
   * true, the listener hands off redirected connections to the listener associated with the
   * original destination address. If there is no listener associated with the original destination
   * address, the connection is handled by the listener that receives it. Defaults to false.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue use_original_dst = 4;</code>
   */
  @java.lang.Override
  public com.google.protobuf.BoolValueOrBuilder getUseOriginalDstOrBuilder() {
    return useOriginalDst_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : useOriginalDst_;
  }

  public static final int DEFAULT_FILTER_CHAIN_FIELD_NUMBER = 25;
  private io.envoyproxy.envoy.config.listener.v3.FilterChain defaultFilterChain_;
  /**
   * <pre>
   * The default filter chain if none of the filter chain matches. If no default filter chain is supplied,
   * the connection will be closed. The filter chain match is ignored in this field.
   * </pre>
   *
   * <code>.envoy.config.listener.v3.FilterChain default_filter_chain = 25;</code>
   * @return Whether the defaultFilterChain field is set.
   */
  @java.lang.Override
  public boolean hasDefaultFilterChain() {
    return defaultFilterChain_ != null;
  }
  /**
   * <pre>
   * The default filter chain if none of the filter chain matches. If no default filter chain is supplied,
   * the connection will be closed. The filter chain match is ignored in this field.
   * </pre>
   *
   * <code>.envoy.config.listener.v3.FilterChain default_filter_chain = 25;</code>
   * @return The defaultFilterChain.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.listener.v3.FilterChain getDefaultFilterChain() {
    return defaultFilterChain_ == null ? io.envoyproxy.envoy.config.listener.v3.FilterChain.getDefaultInstance() : defaultFilterChain_;
  }
  /**
   * <pre>
   * The default filter chain if none of the filter chain matches. If no default filter chain is supplied,
   * the connection will be closed. The filter chain match is ignored in this field.
   * </pre>
   *
   * <code>.envoy.config.listener.v3.FilterChain default_filter_chain = 25;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.listener.v3.FilterChainOrBuilder getDefaultFilterChainOrBuilder() {
    return defaultFilterChain_ == null ? io.envoyproxy.envoy.config.listener.v3.FilterChain.getDefaultInstance() : defaultFilterChain_;
  }

  public static final int PER_CONNECTION_BUFFER_LIMIT_BYTES_FIELD_NUMBER = 5;
  private com.google.protobuf.UInt32Value perConnectionBufferLimitBytes_;
  /**
   * <pre>
   * Soft limit on size of the listener’s new connection read and write buffers.
   * If unspecified, an implementation defined default is applied (1MiB).
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
   * @return Whether the perConnectionBufferLimitBytes field is set.
   */
  @java.lang.Override
  public boolean hasPerConnectionBufferLimitBytes() {
    return perConnectionBufferLimitBytes_ != null;
  }
  /**
   * <pre>
   * Soft limit on size of the listener’s new connection read and write buffers.
   * If unspecified, an implementation defined default is applied (1MiB).
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
   * @return The perConnectionBufferLimitBytes.
   */
  @java.lang.Override
  public com.google.protobuf.UInt32Value getPerConnectionBufferLimitBytes() {
    return perConnectionBufferLimitBytes_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : perConnectionBufferLimitBytes_;
  }
  /**
   * <pre>
   * Soft limit on size of the listener’s new connection read and write buffers.
   * If unspecified, an implementation defined default is applied (1MiB).
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.UInt32ValueOrBuilder getPerConnectionBufferLimitBytesOrBuilder() {
    return perConnectionBufferLimitBytes_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : perConnectionBufferLimitBytes_;
  }

  public static final int METADATA_FIELD_NUMBER = 6;
  private io.envoyproxy.envoy.config.core.v3.Metadata metadata_;
  /**
   * <pre>
   * Listener metadata.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Metadata metadata = 6;</code>
   * @return Whether the metadata field is set.
   */
  @java.lang.Override
  public boolean hasMetadata() {
    return metadata_ != null;
  }
  /**
   * <pre>
   * Listener metadata.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Metadata metadata = 6;</code>
   * @return The metadata.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.Metadata getMetadata() {
    return metadata_ == null ? io.envoyproxy.envoy.config.core.v3.Metadata.getDefaultInstance() : metadata_;
  }
  /**
   * <pre>
   * Listener metadata.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Metadata metadata = 6;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.MetadataOrBuilder getMetadataOrBuilder() {
    return metadata_ == null ? io.envoyproxy.envoy.config.core.v3.Metadata.getDefaultInstance() : metadata_;
  }

  public static final int DEPRECATED_V1_FIELD_NUMBER = 7;
  private io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 deprecatedV1_;
  /**
   * <pre>
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.envoy.config.listener.v3.Listener.DeprecatedV1 deprecated_v1 = 7 [deprecated = true, (.envoy.annotations.deprecated_at_minor_version) = "3.0"];</code>
   * @deprecated envoy.config.listener.v3.Listener.deprecated_v1 is deprecated.
   *     See envoy/config/listener/v3/listener.proto;l=188
   * @return Whether the deprecatedV1 field is set.
   */
  @java.lang.Override
  @java.lang.Deprecated public boolean hasDeprecatedV1() {
    return deprecatedV1_ != null;
  }
  /**
   * <pre>
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.envoy.config.listener.v3.Listener.DeprecatedV1 deprecated_v1 = 7 [deprecated = true, (.envoy.annotations.deprecated_at_minor_version) = "3.0"];</code>
   * @deprecated envoy.config.listener.v3.Listener.deprecated_v1 is deprecated.
   *     See envoy/config/listener/v3/listener.proto;l=188
   * @return The deprecatedV1.
   */
  @java.lang.Override
  @java.lang.Deprecated public io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 getDeprecatedV1() {
    return deprecatedV1_ == null ? io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1.getDefaultInstance() : deprecatedV1_;
  }
  /**
   * <pre>
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.envoy.config.listener.v3.Listener.DeprecatedV1 deprecated_v1 = 7 [deprecated = true, (.envoy.annotations.deprecated_at_minor_version) = "3.0"];</code>
   */
  @java.lang.Override
  @java.lang.Deprecated public io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1OrBuilder getDeprecatedV1OrBuilder() {
    return deprecatedV1_ == null ? io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1.getDefaultInstance() : deprecatedV1_;
  }

  public static final int DRAIN_TYPE_FIELD_NUMBER = 8;
  private int drainType_ = 0;
  /**
   * <pre>
   * The type of draining to perform at a listener-wide level.
   * </pre>
   *
   * <code>.envoy.config.listener.v3.Listener.DrainType drain_type = 8;</code>
   * @return The enum numeric value on the wire for drainType.
   */
  @java.lang.Override public int getDrainTypeValue() {
    return drainType_;
  }
  /**
   * <pre>
   * The type of draining to perform at a listener-wide level.
   * </pre>
   *
   * <code>.envoy.config.listener.v3.Listener.DrainType drain_type = 8;</code>
   * @return The drainType.
   */
  @java.lang.Override public io.envoyproxy.envoy.config.listener.v3.Listener.DrainType getDrainType() {
    io.envoyproxy.envoy.config.listener.v3.Listener.DrainType result = io.envoyproxy.envoy.config.listener.v3.Listener.DrainType.forNumber(drainType_);
    return result == null ? io.envoyproxy.envoy.config.listener.v3.Listener.DrainType.UNRECOGNIZED : result;
  }

  public static final int LISTENER_FILTERS_FIELD_NUMBER = 9;
  @SuppressWarnings("serial")
  private java.util.List<io.envoyproxy.envoy.config.listener.v3.ListenerFilter> listenerFilters_;
  /**
   * <pre>
   * Listener filters have the opportunity to manipulate and augment the connection metadata that
   * is used in connection filter chain matching, for example. These filters are run before any in
   * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
   * filters are processed sequentially right after a socket has been accepted by the listener, and
   * before a connection is created.
   * UDP Listener filters can be specified when the protocol in the listener socket address in
   * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
   * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
   * </pre>
   *
   * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
   */
  @java.lang.Override
  public java.util.List<io.envoyproxy.envoy.config.listener.v3.ListenerFilter> getListenerFiltersList() {
    return listenerFilters_;
  }
  /**
   * <pre>
   * Listener filters have the opportunity to manipulate and augment the connection metadata that
   * is used in connection filter chain matching, for example. These filters are run before any in
   * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
   * filters are processed sequentially right after a socket has been accepted by the listener, and
   * before a connection is created.
   * UDP Listener filters can be specified when the protocol in the listener socket address in
   * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
   * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
   * </pre>
   *
   * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
   */
  @java.lang.Override
  public java.util.List<? extends io.envoyproxy.envoy.config.listener.v3.ListenerFilterOrBuilder> 
      getListenerFiltersOrBuilderList() {
    return listenerFilters_;
  }
  /**
   * <pre>
   * Listener filters have the opportunity to manipulate and augment the connection metadata that
   * is used in connection filter chain matching, for example. These filters are run before any in
   * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
   * filters are processed sequentially right after a socket has been accepted by the listener, and
   * before a connection is created.
   * UDP Listener filters can be specified when the protocol in the listener socket address in
   * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
   * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
   * </pre>
   *
   * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
   */
  @java.lang.Override
  public int getListenerFiltersCount() {
    return listenerFilters_.size();
  }
  /**
   * <pre>
   * Listener filters have the opportunity to manipulate and augment the connection metadata that
   * is used in connection filter chain matching, for example. These filters are run before any in
   * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
   * filters are processed sequentially right after a socket has been accepted by the listener, and
   * before a connection is created.
   * UDP Listener filters can be specified when the protocol in the listener socket address in
   * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
   * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
   * </pre>
   *
   * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.listener.v3.ListenerFilter getListenerFilters(int index) {
    return listenerFilters_.get(index);
  }
  /**
   * <pre>
   * Listener filters have the opportunity to manipulate and augment the connection metadata that
   * is used in connection filter chain matching, for example. These filters are run before any in
   * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
   * filters are processed sequentially right after a socket has been accepted by the listener, and
   * before a connection is created.
   * UDP Listener filters can be specified when the protocol in the listener socket address in
   * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
   * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
   * </pre>
   *
   * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.listener.v3.ListenerFilterOrBuilder getListenerFiltersOrBuilder(
      int index) {
    return listenerFilters_.get(index);
  }

  public static final int LISTENER_FILTERS_TIMEOUT_FIELD_NUMBER = 15;
  private com.google.protobuf.Duration listenerFiltersTimeout_;
  /**
   * <pre>
   * The timeout to wait for all listener filters to complete operation. If the timeout is reached,
   * the accepted socket is closed without a connection being created unless
   * ``continue_on_listener_filters_timeout`` is set to true. Specify 0 to disable the
   * timeout. If not specified, a default timeout of 15s is used.
   * </pre>
   *
   * <code>.google.protobuf.Duration listener_filters_timeout = 15;</code>
   * @return Whether the listenerFiltersTimeout field is set.
   */
  @java.lang.Override
  public boolean hasListenerFiltersTimeout() {
    return listenerFiltersTimeout_ != null;
  }
  /**
   * <pre>
   * The timeout to wait for all listener filters to complete operation. If the timeout is reached,
   * the accepted socket is closed without a connection being created unless
   * ``continue_on_listener_filters_timeout`` is set to true. Specify 0 to disable the
   * timeout. If not specified, a default timeout of 15s is used.
   * </pre>
   *
   * <code>.google.protobuf.Duration listener_filters_timeout = 15;</code>
   * @return The listenerFiltersTimeout.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getListenerFiltersTimeout() {
    return listenerFiltersTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : listenerFiltersTimeout_;
  }
  /**
   * <pre>
   * The timeout to wait for all listener filters to complete operation. If the timeout is reached,
   * the accepted socket is closed without a connection being created unless
   * ``continue_on_listener_filters_timeout`` is set to true. Specify 0 to disable the
   * timeout. If not specified, a default timeout of 15s is used.
   * </pre>
   *
   * <code>.google.protobuf.Duration listener_filters_timeout = 15;</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getListenerFiltersTimeoutOrBuilder() {
    return listenerFiltersTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : listenerFiltersTimeout_;
  }

  public static final int CONTINUE_ON_LISTENER_FILTERS_TIMEOUT_FIELD_NUMBER = 17;
  private boolean continueOnListenerFiltersTimeout_ = false;
  /**
   * <pre>
   * Whether a connection should be created when listener filters timeout. Default is false.
   * .. attention::
   *   Some listener filters, such as :ref:`Proxy Protocol filter
   *   &lt;config_listener_filters_proxy_protocol&gt;`, should not be used with this option. It will cause
   *   unexpected behavior when a connection is created.
   * </pre>
   *
   * <code>bool continue_on_listener_filters_timeout = 17;</code>
   * @return The continueOnListenerFiltersTimeout.
   */
  @java.lang.Override
  public boolean getContinueOnListenerFiltersTimeout() {
    return continueOnListenerFiltersTimeout_;
  }

  public static final int TRANSPARENT_FIELD_NUMBER = 10;
  private com.google.protobuf.BoolValue transparent_;
  /**
   * <pre>
   * Whether the listener should be set as a transparent socket.
   * When this flag is set to true, connections can be redirected to the listener using an
   * ``iptables`` ``TPROXY`` target, in which case the original source and destination addresses and
   * ports are preserved on accepted connections. This flag should be used in combination with
   * :ref:`an original_dst &lt;config_listener_filters_original_dst&gt;` :ref:`listener filter
   * &lt;envoy_v3_api_field_config.listener.v3.Listener.listener_filters&gt;` to mark the connections' local addresses as
   * "restored." This can be used to hand off each redirected connection to another listener
   * associated with the connection's destination address. Direct connections to the socket without
   * using ``TPROXY`` cannot be distinguished from connections redirected using ``TPROXY`` and are
   * therefore treated as if they were redirected.
   * When this flag is set to false, the listener's socket is explicitly reset as non-transparent.
   * Setting this flag requires Envoy to run with the ``CAP_NET_ADMIN`` capability.
   * When this flag is not set (default), the socket is not modified, i.e. the transparent option
   * is neither set nor reset.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue transparent = 10;</code>
   * @return Whether the transparent field is set.
   */
  @java.lang.Override
  public boolean hasTransparent() {
    return transparent_ != null;
  }
  /**
   * <pre>
   * Whether the listener should be set as a transparent socket.
   * When this flag is set to true, connections can be redirected to the listener using an
   * ``iptables`` ``TPROXY`` target, in which case the original source and destination addresses and
   * ports are preserved on accepted connections. This flag should be used in combination with
   * :ref:`an original_dst &lt;config_listener_filters_original_dst&gt;` :ref:`listener filter
   * &lt;envoy_v3_api_field_config.listener.v3.Listener.listener_filters&gt;` to mark the connections' local addresses as
   * "restored." This can be used to hand off each redirected connection to another listener
   * associated with the connection's destination address. Direct connections to the socket without
   * using ``TPROXY`` cannot be distinguished from connections redirected using ``TPROXY`` and are
   * therefore treated as if they were redirected.
   * When this flag is set to false, the listener's socket is explicitly reset as non-transparent.
   * Setting this flag requires Envoy to run with the ``CAP_NET_ADMIN`` capability.
   * When this flag is not set (default), the socket is not modified, i.e. the transparent option
   * is neither set nor reset.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue transparent = 10;</code>
   * @return The transparent.
   */
  @java.lang.Override
  public com.google.protobuf.BoolValue getTransparent() {
    return transparent_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : transparent_;
  }
  /**
   * <pre>
   * Whether the listener should be set as a transparent socket.
   * When this flag is set to true, connections can be redirected to the listener using an
   * ``iptables`` ``TPROXY`` target, in which case the original source and destination addresses and
   * ports are preserved on accepted connections. This flag should be used in combination with
   * :ref:`an original_dst &lt;config_listener_filters_original_dst&gt;` :ref:`listener filter
   * &lt;envoy_v3_api_field_config.listener.v3.Listener.listener_filters&gt;` to mark the connections' local addresses as
   * "restored." This can be used to hand off each redirected connection to another listener
   * associated with the connection's destination address. Direct connections to the socket without
   * using ``TPROXY`` cannot be distinguished from connections redirected using ``TPROXY`` and are
   * therefore treated as if they were redirected.
   * When this flag is set to false, the listener's socket is explicitly reset as non-transparent.
   * Setting this flag requires Envoy to run with the ``CAP_NET_ADMIN`` capability.
   * When this flag is not set (default), the socket is not modified, i.e. the transparent option
   * is neither set nor reset.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue transparent = 10;</code>
   */
  @java.lang.Override
  public com.google.protobuf.BoolValueOrBuilder getTransparentOrBuilder() {
    return transparent_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : transparent_;
  }

  public static final int FREEBIND_FIELD_NUMBER = 11;
  private com.google.protobuf.BoolValue freebind_;
  /**
   * <pre>
   * Whether the listener should set the ``IP_FREEBIND`` socket option. When this
   * flag is set to true, listeners can be bound to an IP address that is not
   * configured on the system running Envoy. When this flag is set to false, the
   * option ``IP_FREEBIND`` is disabled on the socket. When this flag is not set
   * (default), the socket is not modified, i.e. the option is neither enabled
   * nor disabled.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue freebind = 11;</code>
   * @return Whether the freebind field is set.
   */
  @java.lang.Override
  public boolean hasFreebind() {
    return freebind_ != null;
  }
  /**
   * <pre>
   * Whether the listener should set the ``IP_FREEBIND`` socket option. When this
   * flag is set to true, listeners can be bound to an IP address that is not
   * configured on the system running Envoy. When this flag is set to false, the
   * option ``IP_FREEBIND`` is disabled on the socket. When this flag is not set
   * (default), the socket is not modified, i.e. the option is neither enabled
   * nor disabled.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue freebind = 11;</code>
   * @return The freebind.
   */
  @java.lang.Override
  public com.google.protobuf.BoolValue getFreebind() {
    return freebind_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : freebind_;
  }
  /**
   * <pre>
   * Whether the listener should set the ``IP_FREEBIND`` socket option. When this
   * flag is set to true, listeners can be bound to an IP address that is not
   * configured on the system running Envoy. When this flag is set to false, the
   * option ``IP_FREEBIND`` is disabled on the socket. When this flag is not set
   * (default), the socket is not modified, i.e. the option is neither enabled
   * nor disabled.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue freebind = 11;</code>
   */
  @java.lang.Override
  public com.google.protobuf.BoolValueOrBuilder getFreebindOrBuilder() {
    return freebind_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : freebind_;
  }

  public static final int SOCKET_OPTIONS_FIELD_NUMBER = 13;
  @SuppressWarnings("serial")
  private java.util.List<io.envoyproxy.envoy.config.core.v3.SocketOption> socketOptions_;
  /**
   * <pre>
   * Additional socket options that may not be present in Envoy source code or
   * precompiled binaries. The socket options can be updated for a listener when
   * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
   * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
   * to make it clear that the options were not updated.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
   */
  @java.lang.Override
  public java.util.List<io.envoyproxy.envoy.config.core.v3.SocketOption> getSocketOptionsList() {
    return socketOptions_;
  }
  /**
   * <pre>
   * Additional socket options that may not be present in Envoy source code or
   * precompiled binaries. The socket options can be updated for a listener when
   * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
   * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
   * to make it clear that the options were not updated.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
   */
  @java.lang.Override
  public java.util.List<? extends io.envoyproxy.envoy.config.core.v3.SocketOptionOrBuilder> 
      getSocketOptionsOrBuilderList() {
    return socketOptions_;
  }
  /**
   * <pre>
   * Additional socket options that may not be present in Envoy source code or
   * precompiled binaries. The socket options can be updated for a listener when
   * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
   * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
   * to make it clear that the options were not updated.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
   */
  @java.lang.Override
  public int getSocketOptionsCount() {
    return socketOptions_.size();
  }
  /**
   * <pre>
   * Additional socket options that may not be present in Envoy source code or
   * precompiled binaries. The socket options can be updated for a listener when
   * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
   * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
   * to make it clear that the options were not updated.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.SocketOption getSocketOptions(int index) {
    return socketOptions_.get(index);
  }
  /**
   * <pre>
   * Additional socket options that may not be present in Envoy source code or
   * precompiled binaries. The socket options can be updated for a listener when
   * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
   * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
   * to make it clear that the options were not updated.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.SocketOptionOrBuilder getSocketOptionsOrBuilder(
      int index) {
    return socketOptions_.get(index);
  }

  public static final int TCP_FAST_OPEN_QUEUE_LENGTH_FIELD_NUMBER = 12;
  private com.google.protobuf.UInt32Value tcpFastOpenQueueLength_;
  /**
   * <pre>
   * Whether the listener should accept TCP Fast Open (TFO) connections.
   * When this flag is set to a value greater than 0, the option TCP_FASTOPEN is enabled on
   * the socket, with a queue length of the specified size
   * (see `details in RFC7413 &lt;https://tools.ietf.org/html/rfc7413#section-5.1&gt;`_).
   * When this flag is set to 0, the option TCP_FASTOPEN is disabled on the socket.
   * When this flag is not set (default), the socket is not modified,
   * i.e. the option is neither enabled nor disabled.
   * On Linux, the net.ipv4.tcp_fastopen kernel parameter must include flag 0x2 to enable
   * TCP_FASTOPEN.
   * See `ip-sysctl.txt &lt;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt&gt;`_.
   * On macOS, only values of 0, 1, and unset are valid; other values may result in an error.
   * To set the queue length on macOS, set the net.inet.tcp.fastopen_backlog kernel parameter.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value tcp_fast_open_queue_length = 12;</code>
   * @return Whether the tcpFastOpenQueueLength field is set.
   */
  @java.lang.Override
  public boolean hasTcpFastOpenQueueLength() {
    return tcpFastOpenQueueLength_ != null;
  }
  /**
   * <pre>
   * Whether the listener should accept TCP Fast Open (TFO) connections.
   * When this flag is set to a value greater than 0, the option TCP_FASTOPEN is enabled on
   * the socket, with a queue length of the specified size
   * (see `details in RFC7413 &lt;https://tools.ietf.org/html/rfc7413#section-5.1&gt;`_).
   * When this flag is set to 0, the option TCP_FASTOPEN is disabled on the socket.
   * When this flag is not set (default), the socket is not modified,
   * i.e. the option is neither enabled nor disabled.
   * On Linux, the net.ipv4.tcp_fastopen kernel parameter must include flag 0x2 to enable
   * TCP_FASTOPEN.
   * See `ip-sysctl.txt &lt;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt&gt;`_.
   * On macOS, only values of 0, 1, and unset are valid; other values may result in an error.
   * To set the queue length on macOS, set the net.inet.tcp.fastopen_backlog kernel parameter.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value tcp_fast_open_queue_length = 12;</code>
   * @return The tcpFastOpenQueueLength.
   */
  @java.lang.Override
  public com.google.protobuf.UInt32Value getTcpFastOpenQueueLength() {
    return tcpFastOpenQueueLength_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : tcpFastOpenQueueLength_;
  }
  /**
   * <pre>
   * Whether the listener should accept TCP Fast Open (TFO) connections.
   * When this flag is set to a value greater than 0, the option TCP_FASTOPEN is enabled on
   * the socket, with a queue length of the specified size
   * (see `details in RFC7413 &lt;https://tools.ietf.org/html/rfc7413#section-5.1&gt;`_).
   * When this flag is set to 0, the option TCP_FASTOPEN is disabled on the socket.
   * When this flag is not set (default), the socket is not modified,
   * i.e. the option is neither enabled nor disabled.
   * On Linux, the net.ipv4.tcp_fastopen kernel parameter must include flag 0x2 to enable
   * TCP_FASTOPEN.
   * See `ip-sysctl.txt &lt;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt&gt;`_.
   * On macOS, only values of 0, 1, and unset are valid; other values may result in an error.
   * To set the queue length on macOS, set the net.inet.tcp.fastopen_backlog kernel parameter.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value tcp_fast_open_queue_length = 12;</code>
   */
  @java.lang.Override
  public com.google.protobuf.UInt32ValueOrBuilder getTcpFastOpenQueueLengthOrBuilder() {
    return tcpFastOpenQueueLength_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : tcpFastOpenQueueLength_;
  }

  public static final int TRAFFIC_DIRECTION_FIELD_NUMBER = 16;
  private int trafficDirection_ = 0;
  /**
   * <pre>
   * Specifies the intended direction of the traffic relative to the local Envoy.
   * This property is required on Windows for listeners using the original destination filter,
   * see :ref:`Original Destination &lt;config_listener_filters_original_dst&gt;`.
   * </pre>
   *
   * <code>.envoy.config.core.v3.TrafficDirection traffic_direction = 16;</code>
   * @return The enum numeric value on the wire for trafficDirection.
   */
  @java.lang.Override public int getTrafficDirectionValue() {
    return trafficDirection_;
  }
  /**
   * <pre>
   * Specifies the intended direction of the traffic relative to the local Envoy.
   * This property is required on Windows for listeners using the original destination filter,
   * see :ref:`Original Destination &lt;config_listener_filters_original_dst&gt;`.
   * </pre>
   *
   * <code>.envoy.config.core.v3.TrafficDirection traffic_direction = 16;</code>
   * @return The trafficDirection.
   */
  @java.lang.Override public io.envoyproxy.envoy.config.core.v3.TrafficDirection getTrafficDirection() {
    io.envoyproxy.envoy.config.core.v3.TrafficDirection result = io.envoyproxy.envoy.config.core.v3.TrafficDirection.forNumber(trafficDirection_);
    return result == null ? io.envoyproxy.envoy.config.core.v3.TrafficDirection.UNRECOGNIZED : result;
  }

  public static final int UDP_LISTENER_CONFIG_FIELD_NUMBER = 18;
  private io.envoyproxy.envoy.config.listener.v3.UdpListenerConfig udpListenerConfig_;
  /**
   * <pre>
   * If the protocol in the listener socket address in :ref:`protocol
   * &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
   * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`, this field specifies UDP
   * listener specific configuration.
   * </pre>
   *
   * <code>.envoy.config.listener.v3.UdpListenerConfig udp_listener_config = 18;</code>
   * @return Whether the udpListenerConfig field is set.
   */
  @java.lang.Override
  public boolean hasUdpListenerConfig() {
    return udpListenerConfig_ != null;
  }
  /**
   * <pre>
   * If the protocol in the listener socket address in :ref:`protocol
   * &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
   * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`, this field specifies UDP
   * listener specific configuration.
   * </pre>
   *
   * <code>.envoy.config.listener.v3.UdpListenerConfig udp_listener_config = 18;</code>
   * @return The udpListenerConfig.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.listener.v3.UdpListenerConfig getUdpListenerConfig() {
    return udpListenerConfig_ == null ? io.envoyproxy.envoy.config.listener.v3.UdpListenerConfig.getDefaultInstance() : udpListenerConfig_;
  }
  /**
   * <pre>
   * If the protocol in the listener socket address in :ref:`protocol
   * &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
   * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`, this field specifies UDP
   * listener specific configuration.
   * </pre>
   *
   * <code>.envoy.config.listener.v3.UdpListenerConfig udp_listener_config = 18;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.listener.v3.UdpListenerConfigOrBuilder getUdpListenerConfigOrBuilder() {
    return udpListenerConfig_ == null ? io.envoyproxy.envoy.config.listener.v3.UdpListenerConfig.getDefaultInstance() : udpListenerConfig_;
  }

  public static final int API_LISTENER_FIELD_NUMBER = 19;
  private io.envoyproxy.envoy.config.listener.v3.ApiListener apiListener_;
  /**
   * <pre>
   * Used to represent an API listener, which is used in non-proxy clients. The type of API
   * exposed to the non-proxy application depends on the type of API listener.
   * When this field is set, no other field except for :ref:`name&lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`
   * should be set.
   * .. note::
   *  Currently only one ApiListener can be installed; and it can only be done via bootstrap config,
   *  not LDS.
   * [#next-major-version: In the v3 API, instead of this messy approach where the socket
   * listener fields are directly in the top-level Listener message and the API listener types
   * are in the ApiListener message, the socket listener messages should be in their own message,
   * and the top-level Listener should essentially be a oneof that selects between the
   * socket listener and the various types of API listener. That way, a given Listener message
   * can structurally only contain the fields of the relevant type.]
   * </pre>
   *
   * <code>.envoy.config.listener.v3.ApiListener api_listener = 19;</code>
   * @return Whether the apiListener field is set.
   */
  @java.lang.Override
  public boolean hasApiListener() {
    return apiListener_ != null;
  }
  /**
   * <pre>
   * Used to represent an API listener, which is used in non-proxy clients. The type of API
   * exposed to the non-proxy application depends on the type of API listener.
   * When this field is set, no other field except for :ref:`name&lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`
   * should be set.
   * .. note::
   *  Currently only one ApiListener can be installed; and it can only be done via bootstrap config,
   *  not LDS.
   * [#next-major-version: In the v3 API, instead of this messy approach where the socket
   * listener fields are directly in the top-level Listener message and the API listener types
   * are in the ApiListener message, the socket listener messages should be in their own message,
   * and the top-level Listener should essentially be a oneof that selects between the
   * socket listener and the various types of API listener. That way, a given Listener message
   * can structurally only contain the fields of the relevant type.]
   * </pre>
   *
   * <code>.envoy.config.listener.v3.ApiListener api_listener = 19;</code>
   * @return The apiListener.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.listener.v3.ApiListener getApiListener() {
    return apiListener_ == null ? io.envoyproxy.envoy.config.listener.v3.ApiListener.getDefaultInstance() : apiListener_;
  }
  /**
   * <pre>
   * Used to represent an API listener, which is used in non-proxy clients. The type of API
   * exposed to the non-proxy application depends on the type of API listener.
   * When this field is set, no other field except for :ref:`name&lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`
   * should be set.
   * .. note::
   *  Currently only one ApiListener can be installed; and it can only be done via bootstrap config,
   *  not LDS.
   * [#next-major-version: In the v3 API, instead of this messy approach where the socket
   * listener fields are directly in the top-level Listener message and the API listener types
   * are in the ApiListener message, the socket listener messages should be in their own message,
   * and the top-level Listener should essentially be a oneof that selects between the
   * socket listener and the various types of API listener. That way, a given Listener message
   * can structurally only contain the fields of the relevant type.]
   * </pre>
   *
   * <code>.envoy.config.listener.v3.ApiListener api_listener = 19;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.listener.v3.ApiListenerOrBuilder getApiListenerOrBuilder() {
    return apiListener_ == null ? io.envoyproxy.envoy.config.listener.v3.ApiListener.getDefaultInstance() : apiListener_;
  }

  public static final int CONNECTION_BALANCE_CONFIG_FIELD_NUMBER = 20;
  private io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig connectionBalanceConfig_;
  /**
   * <pre>
   * The listener's connection balancer configuration, currently only applicable to TCP listeners.
   * If no configuration is specified, Envoy will not attempt to balance active connections between
   * worker threads.
   * In the scenario that the listener X redirects all the connections to the listeners Y1 and Y2
   * by setting :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;` in X
   * and :ref:`bind_to_port &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;` to false in Y1 and Y2,
   * it is recommended to disable the balance config in listener X to avoid the cost of balancing, and
   * enable the balance config in Y1 and Y2 to balance the connections among the workers.
   * </pre>
   *
   * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig connection_balance_config = 20;</code>
   * @return Whether the connectionBalanceConfig field is set.
   */
  @java.lang.Override
  public boolean hasConnectionBalanceConfig() {
    return connectionBalanceConfig_ != null;
  }
  /**
   * <pre>
   * The listener's connection balancer configuration, currently only applicable to TCP listeners.
   * If no configuration is specified, Envoy will not attempt to balance active connections between
   * worker threads.
   * In the scenario that the listener X redirects all the connections to the listeners Y1 and Y2
   * by setting :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;` in X
   * and :ref:`bind_to_port &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;` to false in Y1 and Y2,
   * it is recommended to disable the balance config in listener X to avoid the cost of balancing, and
   * enable the balance config in Y1 and Y2 to balance the connections among the workers.
   * </pre>
   *
   * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig connection_balance_config = 20;</code>
   * @return The connectionBalanceConfig.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig getConnectionBalanceConfig() {
    return connectionBalanceConfig_ == null ? io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.getDefaultInstance() : connectionBalanceConfig_;
  }
  /**
   * <pre>
   * The listener's connection balancer configuration, currently only applicable to TCP listeners.
   * If no configuration is specified, Envoy will not attempt to balance active connections between
   * worker threads.
   * In the scenario that the listener X redirects all the connections to the listeners Y1 and Y2
   * by setting :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;` in X
   * and :ref:`bind_to_port &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;` to false in Y1 and Y2,
   * it is recommended to disable the balance config in listener X to avoid the cost of balancing, and
   * enable the balance config in Y1 and Y2 to balance the connections among the workers.
   * </pre>
   *
   * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig connection_balance_config = 20;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfigOrBuilder getConnectionBalanceConfigOrBuilder() {
    return connectionBalanceConfig_ == null ? io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.getDefaultInstance() : connectionBalanceConfig_;
  }

  public static final int REUSE_PORT_FIELD_NUMBER = 21;
  private boolean reusePort_ = false;
  /**
   * <pre>
   * Deprecated. Use ``enable_reuse_port`` instead.
   * </pre>
   *
   * <code>bool reuse_port = 21 [deprecated = true, (.envoy.annotations.deprecated_at_minor_version) = "3.0"];</code>
   * @deprecated envoy.config.listener.v3.Listener.reuse_port is deprecated.
   *     See envoy/config/listener/v3/listener.proto;l=307
   * @return The reusePort.
   */
  @java.lang.Override
  @java.lang.Deprecated public boolean getReusePort() {
    return reusePort_;
  }

  public static final int ENABLE_REUSE_PORT_FIELD_NUMBER = 29;
  private com.google.protobuf.BoolValue enableReusePort_;
  /**
   * <pre>
   * When this flag is set to true, listeners set the ``SO_REUSEPORT`` socket option and
   * create one socket for each worker thread. This makes inbound connections
   * distribute among worker threads roughly evenly in cases where there are a high number
   * of connections. When this flag is set to false, all worker threads share one socket. This field
   * defaults to true. The change of field will be rejected during an listener update when the
   * runtime flag ``envoy.reloadable_features.enable_update_listener_socket_options`` is enabled.
   * Otherwise, the update of this field will be ignored quietly.
   * .. attention::
   *   Although this field defaults to true, it has different behavior on different platforms. See
   *   the following text for more information.
   * * On Linux, reuse_port is respected for both TCP and UDP listeners. It also works correctly
   *   with hot restart.
   * * On macOS, reuse_port for TCP does not do what it does on Linux. Instead of load balancing,
   *   the last socket wins and receives all connections/packets. For TCP, reuse_port is force
   *   disabled and the user is warned. For UDP, it is enabled, but only one worker will receive
   *   packets. For QUIC/H3, SW routing will send packets to other workers. For "raw" UDP, only
   *   a single worker will currently receive packets.
   * * On Windows, reuse_port for TCP has undefined behavior. It is force disabled and the user
   *   is warned similar to macOS. It is left enabled for UDP with undefined behavior currently.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue enable_reuse_port = 29;</code>
   * @return Whether the enableReusePort field is set.
   */
  @java.lang.Override
  public boolean hasEnableReusePort() {
    return enableReusePort_ != null;
  }
  /**
   * <pre>
   * When this flag is set to true, listeners set the ``SO_REUSEPORT`` socket option and
   * create one socket for each worker thread. This makes inbound connections
   * distribute among worker threads roughly evenly in cases where there are a high number
   * of connections. When this flag is set to false, all worker threads share one socket. This field
   * defaults to true. The change of field will be rejected during an listener update when the
   * runtime flag ``envoy.reloadable_features.enable_update_listener_socket_options`` is enabled.
   * Otherwise, the update of this field will be ignored quietly.
   * .. attention::
   *   Although this field defaults to true, it has different behavior on different platforms. See
   *   the following text for more information.
   * * On Linux, reuse_port is respected for both TCP and UDP listeners. It also works correctly
   *   with hot restart.
   * * On macOS, reuse_port for TCP does not do what it does on Linux. Instead of load balancing,
   *   the last socket wins and receives all connections/packets. For TCP, reuse_port is force
   *   disabled and the user is warned. For UDP, it is enabled, but only one worker will receive
   *   packets. For QUIC/H3, SW routing will send packets to other workers. For "raw" UDP, only
   *   a single worker will currently receive packets.
   * * On Windows, reuse_port for TCP has undefined behavior. It is force disabled and the user
   *   is warned similar to macOS. It is left enabled for UDP with undefined behavior currently.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue enable_reuse_port = 29;</code>
   * @return The enableReusePort.
   */
  @java.lang.Override
  public com.google.protobuf.BoolValue getEnableReusePort() {
    return enableReusePort_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : enableReusePort_;
  }
  /**
   * <pre>
   * When this flag is set to true, listeners set the ``SO_REUSEPORT`` socket option and
   * create one socket for each worker thread. This makes inbound connections
   * distribute among worker threads roughly evenly in cases where there are a high number
   * of connections. When this flag is set to false, all worker threads share one socket. This field
   * defaults to true. The change of field will be rejected during an listener update when the
   * runtime flag ``envoy.reloadable_features.enable_update_listener_socket_options`` is enabled.
   * Otherwise, the update of this field will be ignored quietly.
   * .. attention::
   *   Although this field defaults to true, it has different behavior on different platforms. See
   *   the following text for more information.
   * * On Linux, reuse_port is respected for both TCP and UDP listeners. It also works correctly
   *   with hot restart.
   * * On macOS, reuse_port for TCP does not do what it does on Linux. Instead of load balancing,
   *   the last socket wins and receives all connections/packets. For TCP, reuse_port is force
   *   disabled and the user is warned. For UDP, it is enabled, but only one worker will receive
   *   packets. For QUIC/H3, SW routing will send packets to other workers. For "raw" UDP, only
   *   a single worker will currently receive packets.
   * * On Windows, reuse_port for TCP has undefined behavior. It is force disabled and the user
   *   is warned similar to macOS. It is left enabled for UDP with undefined behavior currently.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue enable_reuse_port = 29;</code>
   */
  @java.lang.Override
  public com.google.protobuf.BoolValueOrBuilder getEnableReusePortOrBuilder() {
    return enableReusePort_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : enableReusePort_;
  }

  public static final int ACCESS_LOG_FIELD_NUMBER = 22;
  @SuppressWarnings("serial")
  private java.util.List<io.envoyproxy.envoy.config.accesslog.v3.AccessLog> accessLog_;
  /**
   * <pre>
   * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
   * emitted by this listener.
   * </pre>
   *
   * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
   */
  @java.lang.Override
  public java.util.List<io.envoyproxy.envoy.config.accesslog.v3.AccessLog> getAccessLogList() {
    return accessLog_;
  }
  /**
   * <pre>
   * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
   * emitted by this listener.
   * </pre>
   *
   * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
   */
  @java.lang.Override
  public java.util.List<? extends io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder> 
      getAccessLogOrBuilderList() {
    return accessLog_;
  }
  /**
   * <pre>
   * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
   * emitted by this listener.
   * </pre>
   *
   * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
   */
  @java.lang.Override
  public int getAccessLogCount() {
    return accessLog_.size();
  }
  /**
   * <pre>
   * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
   * emitted by this listener.
   * </pre>
   *
   * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.accesslog.v3.AccessLog getAccessLog(int index) {
    return accessLog_.get(index);
  }
  /**
   * <pre>
   * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
   * emitted by this listener.
   * </pre>
   *
   * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder getAccessLogOrBuilder(
      int index) {
    return accessLog_.get(index);
  }

  public static final int TCP_BACKLOG_SIZE_FIELD_NUMBER = 24;
  private com.google.protobuf.UInt32Value tcpBacklogSize_;
  /**
   * <pre>
   * The maximum length a tcp listener's pending connections queue can grow to. If no value is
   * provided net.core.somaxconn will be used on Linux and 128 otherwise.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value tcp_backlog_size = 24;</code>
   * @return Whether the tcpBacklogSize field is set.
   */
  @java.lang.Override
  public boolean hasTcpBacklogSize() {
    return tcpBacklogSize_ != null;
  }
  /**
   * <pre>
   * The maximum length a tcp listener's pending connections queue can grow to. If no value is
   * provided net.core.somaxconn will be used on Linux and 128 otherwise.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value tcp_backlog_size = 24;</code>
   * @return The tcpBacklogSize.
   */
  @java.lang.Override
  public com.google.protobuf.UInt32Value getTcpBacklogSize() {
    return tcpBacklogSize_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : tcpBacklogSize_;
  }
  /**
   * <pre>
   * The maximum length a tcp listener's pending connections queue can grow to. If no value is
   * provided net.core.somaxconn will be used on Linux and 128 otherwise.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value tcp_backlog_size = 24;</code>
   */
  @java.lang.Override
  public com.google.protobuf.UInt32ValueOrBuilder getTcpBacklogSizeOrBuilder() {
    return tcpBacklogSize_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : tcpBacklogSize_;
  }

  public static final int BIND_TO_PORT_FIELD_NUMBER = 26;
  private com.google.protobuf.BoolValue bindToPort_;
  /**
   * <pre>
   * Whether the listener should bind to the port. A listener that doesn't
   * bind can only receive connections redirected from other listeners that set
   * :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;`
   * to true. Default is true.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue bind_to_port = 26;</code>
   * @return Whether the bindToPort field is set.
   */
  @java.lang.Override
  public boolean hasBindToPort() {
    return bindToPort_ != null;
  }
  /**
   * <pre>
   * Whether the listener should bind to the port. A listener that doesn't
   * bind can only receive connections redirected from other listeners that set
   * :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;`
   * to true. Default is true.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue bind_to_port = 26;</code>
   * @return The bindToPort.
   */
  @java.lang.Override
  public com.google.protobuf.BoolValue getBindToPort() {
    return bindToPort_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : bindToPort_;
  }
  /**
   * <pre>
   * Whether the listener should bind to the port. A listener that doesn't
   * bind can only receive connections redirected from other listeners that set
   * :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;`
   * to true. Default is true.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue bind_to_port = 26;</code>
   */
  @java.lang.Override
  public com.google.protobuf.BoolValueOrBuilder getBindToPortOrBuilder() {
    return bindToPort_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : bindToPort_;
  }

  public static final int INTERNAL_LISTENER_FIELD_NUMBER = 27;
  /**
   * <pre>
   * Used to represent an internal listener which does not listen on OSI L4 address but can be used by the
   * :ref:`envoy cluster &lt;envoy_v3_api_msg_config.cluster.v3.Cluster&gt;` to create a user space connection to.
   * The internal listener acts as a TCP listener. It supports listener filters and network filter chains.
   * Upstream clusters refer to the internal listeners by their :ref:`name
   * &lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`. :ref:`Address
   * &lt;envoy_v3_api_field_config.listener.v3.Listener.address&gt;` must not be set on the internal listeners.
   * There are some limitations that are derived from the implementation. The known limitations include:
   * * :ref:`ConnectionBalanceConfig &lt;envoy_v3_api_msg_config.listener.v3.Listener.ConnectionBalanceConfig&gt;` is not
   *   allowed because both the cluster connection and the listener connection must be owned by the same dispatcher.
   * * :ref:`tcp_backlog_size &lt;envoy_v3_api_field_config.listener.v3.Listener.tcp_backlog_size&gt;`
   * * :ref:`freebind &lt;envoy_v3_api_field_config.listener.v3.Listener.freebind&gt;`
   * * :ref:`transparent &lt;envoy_v3_api_field_config.listener.v3.Listener.transparent&gt;`
   * </pre>
   *
   * <code>.envoy.config.listener.v3.Listener.InternalListenerConfig internal_listener = 27;</code>
   * @return Whether the internalListener field is set.
   */
  @java.lang.Override
  public boolean hasInternalListener() {
    return listenerSpecifierCase_ == 27;
  }
  /**
   * <pre>
   * Used to represent an internal listener which does not listen on OSI L4 address but can be used by the
   * :ref:`envoy cluster &lt;envoy_v3_api_msg_config.cluster.v3.Cluster&gt;` to create a user space connection to.
   * The internal listener acts as a TCP listener. It supports listener filters and network filter chains.
   * Upstream clusters refer to the internal listeners by their :ref:`name
   * &lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`. :ref:`Address
   * &lt;envoy_v3_api_field_config.listener.v3.Listener.address&gt;` must not be set on the internal listeners.
   * There are some limitations that are derived from the implementation. The known limitations include:
   * * :ref:`ConnectionBalanceConfig &lt;envoy_v3_api_msg_config.listener.v3.Listener.ConnectionBalanceConfig&gt;` is not
   *   allowed because both the cluster connection and the listener connection must be owned by the same dispatcher.
   * * :ref:`tcp_backlog_size &lt;envoy_v3_api_field_config.listener.v3.Listener.tcp_backlog_size&gt;`
   * * :ref:`freebind &lt;envoy_v3_api_field_config.listener.v3.Listener.freebind&gt;`
   * * :ref:`transparent &lt;envoy_v3_api_field_config.listener.v3.Listener.transparent&gt;`
   * </pre>
   *
   * <code>.envoy.config.listener.v3.Listener.InternalListenerConfig internal_listener = 27;</code>
   * @return The internalListener.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig getInternalListener() {
    if (listenerSpecifierCase_ == 27) {
       return (io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig) listenerSpecifier_;
    }
    return io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig.getDefaultInstance();
  }
  /**
   * <pre>
   * Used to represent an internal listener which does not listen on OSI L4 address but can be used by the
   * :ref:`envoy cluster &lt;envoy_v3_api_msg_config.cluster.v3.Cluster&gt;` to create a user space connection to.
   * The internal listener acts as a TCP listener. It supports listener filters and network filter chains.
   * Upstream clusters refer to the internal listeners by their :ref:`name
   * &lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`. :ref:`Address
   * &lt;envoy_v3_api_field_config.listener.v3.Listener.address&gt;` must not be set on the internal listeners.
   * There are some limitations that are derived from the implementation. The known limitations include:
   * * :ref:`ConnectionBalanceConfig &lt;envoy_v3_api_msg_config.listener.v3.Listener.ConnectionBalanceConfig&gt;` is not
   *   allowed because both the cluster connection and the listener connection must be owned by the same dispatcher.
   * * :ref:`tcp_backlog_size &lt;envoy_v3_api_field_config.listener.v3.Listener.tcp_backlog_size&gt;`
   * * :ref:`freebind &lt;envoy_v3_api_field_config.listener.v3.Listener.freebind&gt;`
   * * :ref:`transparent &lt;envoy_v3_api_field_config.listener.v3.Listener.transparent&gt;`
   * </pre>
   *
   * <code>.envoy.config.listener.v3.Listener.InternalListenerConfig internal_listener = 27;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfigOrBuilder getInternalListenerOrBuilder() {
    if (listenerSpecifierCase_ == 27) {
       return (io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig) listenerSpecifier_;
    }
    return io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig.getDefaultInstance();
  }

  public static final int ENABLE_MPTCP_FIELD_NUMBER = 30;
  private boolean enableMptcp_ = false;
  /**
   * <pre>
   * Enable MPTCP (multi-path TCP) on this listener. Clients will be allowed to establish
   * MPTCP connections. Non-MPTCP clients will fall back to regular TCP.
   * </pre>
   *
   * <code>bool enable_mptcp = 30;</code>
   * @return The enableMptcp.
   */
  @java.lang.Override
  public boolean getEnableMptcp() {
    return enableMptcp_;
  }

  public static final int IGNORE_GLOBAL_CONN_LIMIT_FIELD_NUMBER = 31;
  private boolean ignoreGlobalConnLimit_ = false;
  /**
   * <pre>
   * Whether the listener should limit connections based upon the value of
   * :ref:`global_downstream_max_connections &lt;config_overload_manager_limiting_connections&gt;`.
   * </pre>
   *
   * <code>bool ignore_global_conn_limit = 31;</code>
   * @return The ignoreGlobalConnLimit.
   */
  @java.lang.Override
  public boolean getIgnoreGlobalConnLimit() {
    return ignoreGlobalConnLimit_;
  }

  private byte memoizedIsInitialized = -1;
  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
    }
    if (address_ != null) {
      output.writeMessage(2, getAddress());
    }
    for (int i = 0; i < filterChains_.size(); i++) {
      output.writeMessage(3, filterChains_.get(i));
    }
    if (useOriginalDst_ != null) {
      output.writeMessage(4, getUseOriginalDst());
    }
    if (perConnectionBufferLimitBytes_ != null) {
      output.writeMessage(5, getPerConnectionBufferLimitBytes());
    }
    if (metadata_ != null) {
      output.writeMessage(6, getMetadata());
    }
    if (deprecatedV1_ != null) {
      output.writeMessage(7, getDeprecatedV1());
    }
    if (drainType_ != io.envoyproxy.envoy.config.listener.v3.Listener.DrainType.DEFAULT.getNumber()) {
      output.writeEnum(8, drainType_);
    }
    for (int i = 0; i < listenerFilters_.size(); i++) {
      output.writeMessage(9, listenerFilters_.get(i));
    }
    if (transparent_ != null) {
      output.writeMessage(10, getTransparent());
    }
    if (freebind_ != null) {
      output.writeMessage(11, getFreebind());
    }
    if (tcpFastOpenQueueLength_ != null) {
      output.writeMessage(12, getTcpFastOpenQueueLength());
    }
    for (int i = 0; i < socketOptions_.size(); i++) {
      output.writeMessage(13, socketOptions_.get(i));
    }
    if (listenerFiltersTimeout_ != null) {
      output.writeMessage(15, getListenerFiltersTimeout());
    }
    if (trafficDirection_ != io.envoyproxy.envoy.config.core.v3.TrafficDirection.UNSPECIFIED.getNumber()) {
      output.writeEnum(16, trafficDirection_);
    }
    if (continueOnListenerFiltersTimeout_ != false) {
      output.writeBool(17, continueOnListenerFiltersTimeout_);
    }
    if (udpListenerConfig_ != null) {
      output.writeMessage(18, getUdpListenerConfig());
    }
    if (apiListener_ != null) {
      output.writeMessage(19, getApiListener());
    }
    if (connectionBalanceConfig_ != null) {
      output.writeMessage(20, getConnectionBalanceConfig());
    }
    if (reusePort_ != false) {
      output.writeBool(21, reusePort_);
    }
    for (int i = 0; i < accessLog_.size(); i++) {
      output.writeMessage(22, accessLog_.get(i));
    }
    if (tcpBacklogSize_ != null) {
      output.writeMessage(24, getTcpBacklogSize());
    }
    if (defaultFilterChain_ != null) {
      output.writeMessage(25, getDefaultFilterChain());
    }
    if (bindToPort_ != null) {
      output.writeMessage(26, getBindToPort());
    }
    if (listenerSpecifierCase_ == 27) {
      output.writeMessage(27, (io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig) listenerSpecifier_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(statPrefix_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 28, statPrefix_);
    }
    if (enableReusePort_ != null) {
      output.writeMessage(29, getEnableReusePort());
    }
    if (enableMptcp_ != false) {
      output.writeBool(30, enableMptcp_);
    }
    if (ignoreGlobalConnLimit_ != false) {
      output.writeBool(31, ignoreGlobalConnLimit_);
    }
    if (filterChainMatcher_ != null) {
      output.writeMessage(32, getFilterChainMatcher());
    }
    for (int i = 0; i < additionalAddresses_.size(); i++) {
      output.writeMessage(33, additionalAddresses_.get(i));
    }
    getUnknownFields().writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
    }
    if (address_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(2, getAddress());
    }
    for (int i = 0; i < filterChains_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(3, filterChains_.get(i));
    }
    if (useOriginalDst_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(4, getUseOriginalDst());
    }
    if (perConnectionBufferLimitBytes_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(5, getPerConnectionBufferLimitBytes());
    }
    if (metadata_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(6, getMetadata());
    }
    if (deprecatedV1_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(7, getDeprecatedV1());
    }
    if (drainType_ != io.envoyproxy.envoy.config.listener.v3.Listener.DrainType.DEFAULT.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(8, drainType_);
    }
    for (int i = 0; i < listenerFilters_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(9, listenerFilters_.get(i));
    }
    if (transparent_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(10, getTransparent());
    }
    if (freebind_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(11, getFreebind());
    }
    if (tcpFastOpenQueueLength_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(12, getTcpFastOpenQueueLength());
    }
    for (int i = 0; i < socketOptions_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(13, socketOptions_.get(i));
    }
    if (listenerFiltersTimeout_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(15, getListenerFiltersTimeout());
    }
    if (trafficDirection_ != io.envoyproxy.envoy.config.core.v3.TrafficDirection.UNSPECIFIED.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(16, trafficDirection_);
    }
    if (continueOnListenerFiltersTimeout_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(17, continueOnListenerFiltersTimeout_);
    }
    if (udpListenerConfig_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(18, getUdpListenerConfig());
    }
    if (apiListener_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(19, getApiListener());
    }
    if (connectionBalanceConfig_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(20, getConnectionBalanceConfig());
    }
    if (reusePort_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(21, reusePort_);
    }
    for (int i = 0; i < accessLog_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(22, accessLog_.get(i));
    }
    if (tcpBacklogSize_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(24, getTcpBacklogSize());
    }
    if (defaultFilterChain_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(25, getDefaultFilterChain());
    }
    if (bindToPort_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(26, getBindToPort());
    }
    if (listenerSpecifierCase_ == 27) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(27, (io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig) listenerSpecifier_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(statPrefix_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(28, statPrefix_);
    }
    if (enableReusePort_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(29, getEnableReusePort());
    }
    if (enableMptcp_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(30, enableMptcp_);
    }
    if (ignoreGlobalConnLimit_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(31, ignoreGlobalConnLimit_);
    }
    if (filterChainMatcher_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(32, getFilterChainMatcher());
    }
    for (int i = 0; i < additionalAddresses_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(33, additionalAddresses_.get(i));
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
     return true;
    }
    if (!(obj instanceof io.envoyproxy.envoy.config.listener.v3.Listener)) {
      return super.equals(obj);
    }
    io.envoyproxy.envoy.config.listener.v3.Listener other = (io.envoyproxy.envoy.config.listener.v3.Listener) obj;

    if (!getName()
        .equals(other.getName())) return false;
    if (hasAddress() != other.hasAddress()) return false;
    if (hasAddress()) {
      if (!getAddress()
          .equals(other.getAddress())) return false;
    }
    if (!getAdditionalAddressesList()
        .equals(other.getAdditionalAddressesList())) return false;
    if (!getStatPrefix()
        .equals(other.getStatPrefix())) return false;
    if (!getFilterChainsList()
        .equals(other.getFilterChainsList())) return false;
    if (hasFilterChainMatcher() != other.hasFilterChainMatcher()) return false;
    if (hasFilterChainMatcher()) {
      if (!getFilterChainMatcher()
          .equals(other.getFilterChainMatcher())) return false;
    }
    if (hasUseOriginalDst() != other.hasUseOriginalDst()) return false;
    if (hasUseOriginalDst()) {
      if (!getUseOriginalDst()
          .equals(other.getUseOriginalDst())) return false;
    }
    if (hasDefaultFilterChain() != other.hasDefaultFilterChain()) return false;
    if (hasDefaultFilterChain()) {
      if (!getDefaultFilterChain()
          .equals(other.getDefaultFilterChain())) return false;
    }
    if (hasPerConnectionBufferLimitBytes() != other.hasPerConnectionBufferLimitBytes()) return false;
    if (hasPerConnectionBufferLimitBytes()) {
      if (!getPerConnectionBufferLimitBytes()
          .equals(other.getPerConnectionBufferLimitBytes())) return false;
    }
    if (hasMetadata() != other.hasMetadata()) return false;
    if (hasMetadata()) {
      if (!getMetadata()
          .equals(other.getMetadata())) return false;
    }
    if (hasDeprecatedV1() != other.hasDeprecatedV1()) return false;
    if (hasDeprecatedV1()) {
      if (!getDeprecatedV1()
          .equals(other.getDeprecatedV1())) return false;
    }
    if (drainType_ != other.drainType_) return false;
    if (!getListenerFiltersList()
        .equals(other.getListenerFiltersList())) return false;
    if (hasListenerFiltersTimeout() != other.hasListenerFiltersTimeout()) return false;
    if (hasListenerFiltersTimeout()) {
      if (!getListenerFiltersTimeout()
          .equals(other.getListenerFiltersTimeout())) return false;
    }
    if (getContinueOnListenerFiltersTimeout()
        != other.getContinueOnListenerFiltersTimeout()) return false;
    if (hasTransparent() != other.hasTransparent()) return false;
    if (hasTransparent()) {
      if (!getTransparent()
          .equals(other.getTransparent())) return false;
    }
    if (hasFreebind() != other.hasFreebind()) return false;
    if (hasFreebind()) {
      if (!getFreebind()
          .equals(other.getFreebind())) return false;
    }
    if (!getSocketOptionsList()
        .equals(other.getSocketOptionsList())) return false;
    if (hasTcpFastOpenQueueLength() != other.hasTcpFastOpenQueueLength()) return false;
    if (hasTcpFastOpenQueueLength()) {
      if (!getTcpFastOpenQueueLength()
          .equals(other.getTcpFastOpenQueueLength())) return false;
    }
    if (trafficDirection_ != other.trafficDirection_) return false;
    if (hasUdpListenerConfig() != other.hasUdpListenerConfig()) return false;
    if (hasUdpListenerConfig()) {
      if (!getUdpListenerConfig()
          .equals(other.getUdpListenerConfig())) return false;
    }
    if (hasApiListener() != other.hasApiListener()) return false;
    if (hasApiListener()) {
      if (!getApiListener()
          .equals(other.getApiListener())) return false;
    }
    if (hasConnectionBalanceConfig() != other.hasConnectionBalanceConfig()) return false;
    if (hasConnectionBalanceConfig()) {
      if (!getConnectionBalanceConfig()
          .equals(other.getConnectionBalanceConfig())) return false;
    }
    if (getReusePort()
        != other.getReusePort()) return false;
    if (hasEnableReusePort() != other.hasEnableReusePort()) return false;
    if (hasEnableReusePort()) {
      if (!getEnableReusePort()
          .equals(other.getEnableReusePort())) return false;
    }
    if (!getAccessLogList()
        .equals(other.getAccessLogList())) return false;
    if (hasTcpBacklogSize() != other.hasTcpBacklogSize()) return false;
    if (hasTcpBacklogSize()) {
      if (!getTcpBacklogSize()
          .equals(other.getTcpBacklogSize())) return false;
    }
    if (hasBindToPort() != other.hasBindToPort()) return false;
    if (hasBindToPort()) {
      if (!getBindToPort()
          .equals(other.getBindToPort())) return false;
    }
    if (getEnableMptcp()
        != other.getEnableMptcp()) return false;
    if (getIgnoreGlobalConnLimit()
        != other.getIgnoreGlobalConnLimit()) return false;
    if (!getListenerSpecifierCase().equals(other.getListenerSpecifierCase())) return false;
    switch (listenerSpecifierCase_) {
      case 27:
        if (!getInternalListener()
            .equals(other.getInternalListener())) return false;
        break;
      case 0:
      default:
    }
    if (!getUnknownFields().equals(other.getUnknownFields())) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    hash = (37 * hash) + NAME_FIELD_NUMBER;
    hash = (53 * hash) + getName().hashCode();
    if (hasAddress()) {
      hash = (37 * hash) + ADDRESS_FIELD_NUMBER;
      hash = (53 * hash) + getAddress().hashCode();
    }
    if (getAdditionalAddressesCount() > 0) {
      hash = (37 * hash) + ADDITIONAL_ADDRESSES_FIELD_NUMBER;
      hash = (53 * hash) + getAdditionalAddressesList().hashCode();
    }
    hash = (37 * hash) + STAT_PREFIX_FIELD_NUMBER;
    hash = (53 * hash) + getStatPrefix().hashCode();
    if (getFilterChainsCount() > 0) {
      hash = (37 * hash) + FILTER_CHAINS_FIELD_NUMBER;
      hash = (53 * hash) + getFilterChainsList().hashCode();
    }
    if (hasFilterChainMatcher()) {
      hash = (37 * hash) + FILTER_CHAIN_MATCHER_FIELD_NUMBER;
      hash = (53 * hash) + getFilterChainMatcher().hashCode();
    }
    if (hasUseOriginalDst()) {
      hash = (37 * hash) + USE_ORIGINAL_DST_FIELD_NUMBER;
      hash = (53 * hash) + getUseOriginalDst().hashCode();
    }
    if (hasDefaultFilterChain()) {
      hash = (37 * hash) + DEFAULT_FILTER_CHAIN_FIELD_NUMBER;
      hash = (53 * hash) + getDefaultFilterChain().hashCode();
    }
    if (hasPerConnectionBufferLimitBytes()) {
      hash = (37 * hash) + PER_CONNECTION_BUFFER_LIMIT_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + getPerConnectionBufferLimitBytes().hashCode();
    }
    if (hasMetadata()) {
      hash = (37 * hash) + METADATA_FIELD_NUMBER;
      hash = (53 * hash) + getMetadata().hashCode();
    }
    if (hasDeprecatedV1()) {
      hash = (37 * hash) + DEPRECATED_V1_FIELD_NUMBER;
      hash = (53 * hash) + getDeprecatedV1().hashCode();
    }
    hash = (37 * hash) + DRAIN_TYPE_FIELD_NUMBER;
    hash = (53 * hash) + drainType_;
    if (getListenerFiltersCount() > 0) {
      hash = (37 * hash) + LISTENER_FILTERS_FIELD_NUMBER;
      hash = (53 * hash) + getListenerFiltersList().hashCode();
    }
    if (hasListenerFiltersTimeout()) {
      hash = (37 * hash) + LISTENER_FILTERS_TIMEOUT_FIELD_NUMBER;
      hash = (53 * hash) + getListenerFiltersTimeout().hashCode();
    }
    hash = (37 * hash) + CONTINUE_ON_LISTENER_FILTERS_TIMEOUT_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getContinueOnListenerFiltersTimeout());
    if (hasTransparent()) {
      hash = (37 * hash) + TRANSPARENT_FIELD_NUMBER;
      hash = (53 * hash) + getTransparent().hashCode();
    }
    if (hasFreebind()) {
      hash = (37 * hash) + FREEBIND_FIELD_NUMBER;
      hash = (53 * hash) + getFreebind().hashCode();
    }
    if (getSocketOptionsCount() > 0) {
      hash = (37 * hash) + SOCKET_OPTIONS_FIELD_NUMBER;
      hash = (53 * hash) + getSocketOptionsList().hashCode();
    }
    if (hasTcpFastOpenQueueLength()) {
      hash = (37 * hash) + TCP_FAST_OPEN_QUEUE_LENGTH_FIELD_NUMBER;
      hash = (53 * hash) + getTcpFastOpenQueueLength().hashCode();
    }
    hash = (37 * hash) + TRAFFIC_DIRECTION_FIELD_NUMBER;
    hash = (53 * hash) + trafficDirection_;
    if (hasUdpListenerConfig()) {
      hash = (37 * hash) + UDP_LISTENER_CONFIG_FIELD_NUMBER;
      hash = (53 * hash) + getUdpListenerConfig().hashCode();
    }
    if (hasApiListener()) {
      hash = (37 * hash) + API_LISTENER_FIELD_NUMBER;
      hash = (53 * hash) + getApiListener().hashCode();
    }
    if (hasConnectionBalanceConfig()) {
      hash = (37 * hash) + CONNECTION_BALANCE_CONFIG_FIELD_NUMBER;
      hash = (53 * hash) + getConnectionBalanceConfig().hashCode();
    }
    hash = (37 * hash) + REUSE_PORT_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getReusePort());
    if (hasEnableReusePort()) {
      hash = (37 * hash) + ENABLE_REUSE_PORT_FIELD_NUMBER;
      hash = (53 * hash) + getEnableReusePort().hashCode();
    }
    if (getAccessLogCount() > 0) {
      hash = (37 * hash) + ACCESS_LOG_FIELD_NUMBER;
      hash = (53 * hash) + getAccessLogList().hashCode();
    }
    if (hasTcpBacklogSize()) {
      hash = (37 * hash) + TCP_BACKLOG_SIZE_FIELD_NUMBER;
      hash = (53 * hash) + getTcpBacklogSize().hashCode();
    }
    if (hasBindToPort()) {
      hash = (37 * hash) + BIND_TO_PORT_FIELD_NUMBER;
      hash = (53 * hash) + getBindToPort().hashCode();
    }
    hash = (37 * hash) + ENABLE_MPTCP_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getEnableMptcp());
    hash = (37 * hash) + IGNORE_GLOBAL_CONN_LIMIT_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getIgnoreGlobalConnLimit());
    switch (listenerSpecifierCase_) {
      case 27:
        hash = (37 * hash) + INTERNAL_LISTENER_FIELD_NUMBER;
        hash = (53 * hash) + getInternalListener().hashCode();
        break;
      case 0:
      default:
    }
    hash = (29 * hash) + getUnknownFields().hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static io.envoyproxy.envoy.config.listener.v3.Listener parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.envoyproxy.envoy.config.listener.v3.Listener parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.envoyproxy.envoy.config.listener.v3.Listener parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.envoyproxy.envoy.config.listener.v3.Listener parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.envoyproxy.envoy.config.listener.v3.Listener parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.envoyproxy.envoy.config.listener.v3.Listener parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.envoyproxy.envoy.config.listener.v3.Listener parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.envoyproxy.envoy.config.listener.v3.Listener parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.envoyproxy.envoy.config.listener.v3.Listener parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input);
  }
  public static io.envoyproxy.envoy.config.listener.v3.Listener parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.envoyproxy.envoy.config.listener.v3.Listener parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.envoyproxy.envoy.config.listener.v3.Listener parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(io.envoyproxy.envoy.config.listener.v3.Listener prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * <pre>
   * [#next-free-field: 34]
   * </pre>
   *
   * Protobuf type {@code envoy.config.listener.v3.Listener}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:envoy.config.listener.v3.Listener)
      io.envoyproxy.envoy.config.listener.v3.ListenerOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.listener.v3.Listener.class, io.envoyproxy.envoy.config.listener.v3.Listener.Builder.class);
    }

    // Construct using io.envoyproxy.envoy.config.listener.v3.Listener.newBuilder()
    private Builder() {

    }

    private Builder(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);

    }
    @java.lang.Override
    public Builder clear() {
      super.clear();
      bitField0_ = 0;
      name_ = "";
      address_ = null;
      if (addressBuilder_ != null) {
        addressBuilder_.dispose();
        addressBuilder_ = null;
      }
      if (additionalAddressesBuilder_ == null) {
        additionalAddresses_ = java.util.Collections.emptyList();
      } else {
        additionalAddresses_ = null;
        additionalAddressesBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00000004);
      statPrefix_ = "";
      if (filterChainsBuilder_ == null) {
        filterChains_ = java.util.Collections.emptyList();
      } else {
        filterChains_ = null;
        filterChainsBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00000010);
      filterChainMatcher_ = null;
      if (filterChainMatcherBuilder_ != null) {
        filterChainMatcherBuilder_.dispose();
        filterChainMatcherBuilder_ = null;
      }
      useOriginalDst_ = null;
      if (useOriginalDstBuilder_ != null) {
        useOriginalDstBuilder_.dispose();
        useOriginalDstBuilder_ = null;
      }
      defaultFilterChain_ = null;
      if (defaultFilterChainBuilder_ != null) {
        defaultFilterChainBuilder_.dispose();
        defaultFilterChainBuilder_ = null;
      }
      perConnectionBufferLimitBytes_ = null;
      if (perConnectionBufferLimitBytesBuilder_ != null) {
        perConnectionBufferLimitBytesBuilder_.dispose();
        perConnectionBufferLimitBytesBuilder_ = null;
      }
      metadata_ = null;
      if (metadataBuilder_ != null) {
        metadataBuilder_.dispose();
        metadataBuilder_ = null;
      }
      deprecatedV1_ = null;
      if (deprecatedV1Builder_ != null) {
        deprecatedV1Builder_.dispose();
        deprecatedV1Builder_ = null;
      }
      drainType_ = 0;
      if (listenerFiltersBuilder_ == null) {
        listenerFilters_ = java.util.Collections.emptyList();
      } else {
        listenerFilters_ = null;
        listenerFiltersBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00001000);
      listenerFiltersTimeout_ = null;
      if (listenerFiltersTimeoutBuilder_ != null) {
        listenerFiltersTimeoutBuilder_.dispose();
        listenerFiltersTimeoutBuilder_ = null;
      }
      continueOnListenerFiltersTimeout_ = false;
      transparent_ = null;
      if (transparentBuilder_ != null) {
        transparentBuilder_.dispose();
        transparentBuilder_ = null;
      }
      freebind_ = null;
      if (freebindBuilder_ != null) {
        freebindBuilder_.dispose();
        freebindBuilder_ = null;
      }
      if (socketOptionsBuilder_ == null) {
        socketOptions_ = java.util.Collections.emptyList();
      } else {
        socketOptions_ = null;
        socketOptionsBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00020000);
      tcpFastOpenQueueLength_ = null;
      if (tcpFastOpenQueueLengthBuilder_ != null) {
        tcpFastOpenQueueLengthBuilder_.dispose();
        tcpFastOpenQueueLengthBuilder_ = null;
      }
      trafficDirection_ = 0;
      udpListenerConfig_ = null;
      if (udpListenerConfigBuilder_ != null) {
        udpListenerConfigBuilder_.dispose();
        udpListenerConfigBuilder_ = null;
      }
      apiListener_ = null;
      if (apiListenerBuilder_ != null) {
        apiListenerBuilder_.dispose();
        apiListenerBuilder_ = null;
      }
      connectionBalanceConfig_ = null;
      if (connectionBalanceConfigBuilder_ != null) {
        connectionBalanceConfigBuilder_.dispose();
        connectionBalanceConfigBuilder_ = null;
      }
      reusePort_ = false;
      enableReusePort_ = null;
      if (enableReusePortBuilder_ != null) {
        enableReusePortBuilder_.dispose();
        enableReusePortBuilder_ = null;
      }
      if (accessLogBuilder_ == null) {
        accessLog_ = java.util.Collections.emptyList();
      } else {
        accessLog_ = null;
        accessLogBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x02000000);
      tcpBacklogSize_ = null;
      if (tcpBacklogSizeBuilder_ != null) {
        tcpBacklogSizeBuilder_.dispose();
        tcpBacklogSizeBuilder_ = null;
      }
      bindToPort_ = null;
      if (bindToPortBuilder_ != null) {
        bindToPortBuilder_.dispose();
        bindToPortBuilder_ = null;
      }
      if (internalListenerBuilder_ != null) {
        internalListenerBuilder_.clear();
      }
      enableMptcp_ = false;
      ignoreGlobalConnLimit_ = false;
      listenerSpecifierCase_ = 0;
      listenerSpecifier_ = null;
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return io.envoyproxy.envoy.config.listener.v3.ListenerProto.internal_static_envoy_config_listener_v3_Listener_descriptor;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.listener.v3.Listener getDefaultInstanceForType() {
      return io.envoyproxy.envoy.config.listener.v3.Listener.getDefaultInstance();
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.listener.v3.Listener build() {
      io.envoyproxy.envoy.config.listener.v3.Listener result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.listener.v3.Listener buildPartial() {
      io.envoyproxy.envoy.config.listener.v3.Listener result = new io.envoyproxy.envoy.config.listener.v3.Listener(this);
      buildPartialRepeatedFields(result);
      if (bitField0_ != 0) { buildPartial0(result); }
      buildPartialOneofs(result);
      onBuilt();
      return result;
    }

    private void buildPartialRepeatedFields(io.envoyproxy.envoy.config.listener.v3.Listener result) {
      if (additionalAddressesBuilder_ == null) {
        if (((bitField0_ & 0x00000004) != 0)) {
          additionalAddresses_ = java.util.Collections.unmodifiableList(additionalAddresses_);
          bitField0_ = (bitField0_ & ~0x00000004);
        }
        result.additionalAddresses_ = additionalAddresses_;
      } else {
        result.additionalAddresses_ = additionalAddressesBuilder_.build();
      }
      if (filterChainsBuilder_ == null) {
        if (((bitField0_ & 0x00000010) != 0)) {
          filterChains_ = java.util.Collections.unmodifiableList(filterChains_);
          bitField0_ = (bitField0_ & ~0x00000010);
        }
        result.filterChains_ = filterChains_;
      } else {
        result.filterChains_ = filterChainsBuilder_.build();
      }
      if (listenerFiltersBuilder_ == null) {
        if (((bitField0_ & 0x00001000) != 0)) {
          listenerFilters_ = java.util.Collections.unmodifiableList(listenerFilters_);
          bitField0_ = (bitField0_ & ~0x00001000);
        }
        result.listenerFilters_ = listenerFilters_;
      } else {
        result.listenerFilters_ = listenerFiltersBuilder_.build();
      }
      if (socketOptionsBuilder_ == null) {
        if (((bitField0_ & 0x00020000) != 0)) {
          socketOptions_ = java.util.Collections.unmodifiableList(socketOptions_);
          bitField0_ = (bitField0_ & ~0x00020000);
        }
        result.socketOptions_ = socketOptions_;
      } else {
        result.socketOptions_ = socketOptionsBuilder_.build();
      }
      if (accessLogBuilder_ == null) {
        if (((bitField0_ & 0x02000000) != 0)) {
          accessLog_ = java.util.Collections.unmodifiableList(accessLog_);
          bitField0_ = (bitField0_ & ~0x02000000);
        }
        result.accessLog_ = accessLog_;
      } else {
        result.accessLog_ = accessLogBuilder_.build();
      }
    }

    private void buildPartial0(io.envoyproxy.envoy.config.listener.v3.Listener result) {
      int from_bitField0_ = bitField0_;
      if (((from_bitField0_ & 0x00000001) != 0)) {
        result.name_ = name_;
      }
      if (((from_bitField0_ & 0x00000002) != 0)) {
        result.address_ = addressBuilder_ == null
            ? address_
            : addressBuilder_.build();
      }
      if (((from_bitField0_ & 0x00000008) != 0)) {
        result.statPrefix_ = statPrefix_;
      }
      if (((from_bitField0_ & 0x00000020) != 0)) {
        result.filterChainMatcher_ = filterChainMatcherBuilder_ == null
            ? filterChainMatcher_
            : filterChainMatcherBuilder_.build();
      }
      if (((from_bitField0_ & 0x00000040) != 0)) {
        result.useOriginalDst_ = useOriginalDstBuilder_ == null
            ? useOriginalDst_
            : useOriginalDstBuilder_.build();
      }
      if (((from_bitField0_ & 0x00000080) != 0)) {
        result.defaultFilterChain_ = defaultFilterChainBuilder_ == null
            ? defaultFilterChain_
            : defaultFilterChainBuilder_.build();
      }
      if (((from_bitField0_ & 0x00000100) != 0)) {
        result.perConnectionBufferLimitBytes_ = perConnectionBufferLimitBytesBuilder_ == null
            ? perConnectionBufferLimitBytes_
            : perConnectionBufferLimitBytesBuilder_.build();
      }
      if (((from_bitField0_ & 0x00000200) != 0)) {
        result.metadata_ = metadataBuilder_ == null
            ? metadata_
            : metadataBuilder_.build();
      }
      if (((from_bitField0_ & 0x00000400) != 0)) {
        result.deprecatedV1_ = deprecatedV1Builder_ == null
            ? deprecatedV1_
            : deprecatedV1Builder_.build();
      }
      if (((from_bitField0_ & 0x00000800) != 0)) {
        result.drainType_ = drainType_;
      }
      if (((from_bitField0_ & 0x00002000) != 0)) {
        result.listenerFiltersTimeout_ = listenerFiltersTimeoutBuilder_ == null
            ? listenerFiltersTimeout_
            : listenerFiltersTimeoutBuilder_.build();
      }
      if (((from_bitField0_ & 0x00004000) != 0)) {
        result.continueOnListenerFiltersTimeout_ = continueOnListenerFiltersTimeout_;
      }
      if (((from_bitField0_ & 0x00008000) != 0)) {
        result.transparent_ = transparentBuilder_ == null
            ? transparent_
            : transparentBuilder_.build();
      }
      if (((from_bitField0_ & 0x00010000) != 0)) {
        result.freebind_ = freebindBuilder_ == null
            ? freebind_
            : freebindBuilder_.build();
      }
      if (((from_bitField0_ & 0x00040000) != 0)) {
        result.tcpFastOpenQueueLength_ = tcpFastOpenQueueLengthBuilder_ == null
            ? tcpFastOpenQueueLength_
            : tcpFastOpenQueueLengthBuilder_.build();
      }
      if (((from_bitField0_ & 0x00080000) != 0)) {
        result.trafficDirection_ = trafficDirection_;
      }
      if (((from_bitField0_ & 0x00100000) != 0)) {
        result.udpListenerConfig_ = udpListenerConfigBuilder_ == null
            ? udpListenerConfig_
            : udpListenerConfigBuilder_.build();
      }
      if (((from_bitField0_ & 0x00200000) != 0)) {
        result.apiListener_ = apiListenerBuilder_ == null
            ? apiListener_
            : apiListenerBuilder_.build();
      }
      if (((from_bitField0_ & 0x00400000) != 0)) {
        result.connectionBalanceConfig_ = connectionBalanceConfigBuilder_ == null
            ? connectionBalanceConfig_
            : connectionBalanceConfigBuilder_.build();
      }
      if (((from_bitField0_ & 0x00800000) != 0)) {
        result.reusePort_ = reusePort_;
      }
      if (((from_bitField0_ & 0x01000000) != 0)) {
        result.enableReusePort_ = enableReusePortBuilder_ == null
            ? enableReusePort_
            : enableReusePortBuilder_.build();
      }
      if (((from_bitField0_ & 0x04000000) != 0)) {
        result.tcpBacklogSize_ = tcpBacklogSizeBuilder_ == null
            ? tcpBacklogSize_
            : tcpBacklogSizeBuilder_.build();
      }
      if (((from_bitField0_ & 0x08000000) != 0)) {
        result.bindToPort_ = bindToPortBuilder_ == null
            ? bindToPort_
            : bindToPortBuilder_.build();
      }
      if (((from_bitField0_ & 0x20000000) != 0)) {
        result.enableMptcp_ = enableMptcp_;
      }
      if (((from_bitField0_ & 0x40000000) != 0)) {
        result.ignoreGlobalConnLimit_ = ignoreGlobalConnLimit_;
      }
    }

    private void buildPartialOneofs(io.envoyproxy.envoy.config.listener.v3.Listener result) {
      result.listenerSpecifierCase_ = listenerSpecifierCase_;
      result.listenerSpecifier_ = this.listenerSpecifier_;
      if (listenerSpecifierCase_ == 27 &&
          internalListenerBuilder_ != null) {
        result.listenerSpecifier_ = internalListenerBuilder_.build();
      }
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }
    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.setField(field, value);
    }
    @java.lang.Override
    public Builder clearField(
        com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }
    @java.lang.Override
    public Builder clearOneof(
        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }
    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }
    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }
    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof io.envoyproxy.envoy.config.listener.v3.Listener) {
        return mergeFrom((io.envoyproxy.envoy.config.listener.v3.Listener)other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(io.envoyproxy.envoy.config.listener.v3.Listener other) {
      if (other == io.envoyproxy.envoy.config.listener.v3.Listener.getDefaultInstance()) return this;
      if (!other.getName().isEmpty()) {
        name_ = other.name_;
        bitField0_ |= 0x00000001;
        onChanged();
      }
      if (other.hasAddress()) {
        mergeAddress(other.getAddress());
      }
      if (additionalAddressesBuilder_ == null) {
        if (!other.additionalAddresses_.isEmpty()) {
          if (additionalAddresses_.isEmpty()) {
            additionalAddresses_ = other.additionalAddresses_;
            bitField0_ = (bitField0_ & ~0x00000004);
          } else {
            ensureAdditionalAddressesIsMutable();
            additionalAddresses_.addAll(other.additionalAddresses_);
          }
          onChanged();
        }
      } else {
        if (!other.additionalAddresses_.isEmpty()) {
          if (additionalAddressesBuilder_.isEmpty()) {
            additionalAddressesBuilder_.dispose();
            additionalAddressesBuilder_ = null;
            additionalAddresses_ = other.additionalAddresses_;
            bitField0_ = (bitField0_ & ~0x00000004);
            additionalAddressesBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getAdditionalAddressesFieldBuilder() : null;
          } else {
            additionalAddressesBuilder_.addAllMessages(other.additionalAddresses_);
          }
        }
      }
      if (!other.getStatPrefix().isEmpty()) {
        statPrefix_ = other.statPrefix_;
        bitField0_ |= 0x00000008;
        onChanged();
      }
      if (filterChainsBuilder_ == null) {
        if (!other.filterChains_.isEmpty()) {
          if (filterChains_.isEmpty()) {
            filterChains_ = other.filterChains_;
            bitField0_ = (bitField0_ & ~0x00000010);
          } else {
            ensureFilterChainsIsMutable();
            filterChains_.addAll(other.filterChains_);
          }
          onChanged();
        }
      } else {
        if (!other.filterChains_.isEmpty()) {
          if (filterChainsBuilder_.isEmpty()) {
            filterChainsBuilder_.dispose();
            filterChainsBuilder_ = null;
            filterChains_ = other.filterChains_;
            bitField0_ = (bitField0_ & ~0x00000010);
            filterChainsBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getFilterChainsFieldBuilder() : null;
          } else {
            filterChainsBuilder_.addAllMessages(other.filterChains_);
          }
        }
      }
      if (other.hasFilterChainMatcher()) {
        mergeFilterChainMatcher(other.getFilterChainMatcher());
      }
      if (other.hasUseOriginalDst()) {
        mergeUseOriginalDst(other.getUseOriginalDst());
      }
      if (other.hasDefaultFilterChain()) {
        mergeDefaultFilterChain(other.getDefaultFilterChain());
      }
      if (other.hasPerConnectionBufferLimitBytes()) {
        mergePerConnectionBufferLimitBytes(other.getPerConnectionBufferLimitBytes());
      }
      if (other.hasMetadata()) {
        mergeMetadata(other.getMetadata());
      }
      if (other.hasDeprecatedV1()) {
        mergeDeprecatedV1(other.getDeprecatedV1());
      }
      if (other.drainType_ != 0) {
        setDrainTypeValue(other.getDrainTypeValue());
      }
      if (listenerFiltersBuilder_ == null) {
        if (!other.listenerFilters_.isEmpty()) {
          if (listenerFilters_.isEmpty()) {
            listenerFilters_ = other.listenerFilters_;
            bitField0_ = (bitField0_ & ~0x00001000);
          } else {
            ensureListenerFiltersIsMutable();
            listenerFilters_.addAll(other.listenerFilters_);
          }
          onChanged();
        }
      } else {
        if (!other.listenerFilters_.isEmpty()) {
          if (listenerFiltersBuilder_.isEmpty()) {
            listenerFiltersBuilder_.dispose();
            listenerFiltersBuilder_ = null;
            listenerFilters_ = other.listenerFilters_;
            bitField0_ = (bitField0_ & ~0x00001000);
            listenerFiltersBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getListenerFiltersFieldBuilder() : null;
          } else {
            listenerFiltersBuilder_.addAllMessages(other.listenerFilters_);
          }
        }
      }
      if (other.hasListenerFiltersTimeout()) {
        mergeListenerFiltersTimeout(other.getListenerFiltersTimeout());
      }
      if (other.getContinueOnListenerFiltersTimeout() != false) {
        setContinueOnListenerFiltersTimeout(other.getContinueOnListenerFiltersTimeout());
      }
      if (other.hasTransparent()) {
        mergeTransparent(other.getTransparent());
      }
      if (other.hasFreebind()) {
        mergeFreebind(other.getFreebind());
      }
      if (socketOptionsBuilder_ == null) {
        if (!other.socketOptions_.isEmpty()) {
          if (socketOptions_.isEmpty()) {
            socketOptions_ = other.socketOptions_;
            bitField0_ = (bitField0_ & ~0x00020000);
          } else {
            ensureSocketOptionsIsMutable();
            socketOptions_.addAll(other.socketOptions_);
          }
          onChanged();
        }
      } else {
        if (!other.socketOptions_.isEmpty()) {
          if (socketOptionsBuilder_.isEmpty()) {
            socketOptionsBuilder_.dispose();
            socketOptionsBuilder_ = null;
            socketOptions_ = other.socketOptions_;
            bitField0_ = (bitField0_ & ~0x00020000);
            socketOptionsBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getSocketOptionsFieldBuilder() : null;
          } else {
            socketOptionsBuilder_.addAllMessages(other.socketOptions_);
          }
        }
      }
      if (other.hasTcpFastOpenQueueLength()) {
        mergeTcpFastOpenQueueLength(other.getTcpFastOpenQueueLength());
      }
      if (other.trafficDirection_ != 0) {
        setTrafficDirectionValue(other.getTrafficDirectionValue());
      }
      if (other.hasUdpListenerConfig()) {
        mergeUdpListenerConfig(other.getUdpListenerConfig());
      }
      if (other.hasApiListener()) {
        mergeApiListener(other.getApiListener());
      }
      if (other.hasConnectionBalanceConfig()) {
        mergeConnectionBalanceConfig(other.getConnectionBalanceConfig());
      }
      if (other.getReusePort() != false) {
        setReusePort(other.getReusePort());
      }
      if (other.hasEnableReusePort()) {
        mergeEnableReusePort(other.getEnableReusePort());
      }
      if (accessLogBuilder_ == null) {
        if (!other.accessLog_.isEmpty()) {
          if (accessLog_.isEmpty()) {
            accessLog_ = other.accessLog_;
            bitField0_ = (bitField0_ & ~0x02000000);
          } else {
            ensureAccessLogIsMutable();
            accessLog_.addAll(other.accessLog_);
          }
          onChanged();
        }
      } else {
        if (!other.accessLog_.isEmpty()) {
          if (accessLogBuilder_.isEmpty()) {
            accessLogBuilder_.dispose();
            accessLogBuilder_ = null;
            accessLog_ = other.accessLog_;
            bitField0_ = (bitField0_ & ~0x02000000);
            accessLogBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getAccessLogFieldBuilder() : null;
          } else {
            accessLogBuilder_.addAllMessages(other.accessLog_);
          }
        }
      }
      if (other.hasTcpBacklogSize()) {
        mergeTcpBacklogSize(other.getTcpBacklogSize());
      }
      if (other.hasBindToPort()) {
        mergeBindToPort(other.getBindToPort());
      }
      if (other.getEnableMptcp() != false) {
        setEnableMptcp(other.getEnableMptcp());
      }
      if (other.getIgnoreGlobalConnLimit() != false) {
        setIgnoreGlobalConnLimit(other.getIgnoreGlobalConnLimit());
      }
      switch (other.getListenerSpecifierCase()) {
        case INTERNAL_LISTENER: {
          mergeInternalListener(other.getInternalListener());
          break;
        }
        case LISTENERSPECIFIER_NOT_SET: {
          break;
        }
      }
      this.mergeUnknownFields(other.getUnknownFields());
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              name_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00000001;
              break;
            } // case 10
            case 18: {
              input.readMessage(
                  getAddressFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000002;
              break;
            } // case 18
            case 26: {
              io.envoyproxy.envoy.config.listener.v3.FilterChain m =
                  input.readMessage(
                      io.envoyproxy.envoy.config.listener.v3.FilterChain.parser(),
                      extensionRegistry);
              if (filterChainsBuilder_ == null) {
                ensureFilterChainsIsMutable();
                filterChains_.add(m);
              } else {
                filterChainsBuilder_.addMessage(m);
              }
              break;
            } // case 26
            case 34: {
              input.readMessage(
                  getUseOriginalDstFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000040;
              break;
            } // case 34
            case 42: {
              input.readMessage(
                  getPerConnectionBufferLimitBytesFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000100;
              break;
            } // case 42
            case 50: {
              input.readMessage(
                  getMetadataFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000200;
              break;
            } // case 50
            case 58: {
              input.readMessage(
                  getDeprecatedV1FieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000400;
              break;
            } // case 58
            case 64: {
              drainType_ = input.readEnum();
              bitField0_ |= 0x00000800;
              break;
            } // case 64
            case 74: {
              io.envoyproxy.envoy.config.listener.v3.ListenerFilter m =
                  input.readMessage(
                      io.envoyproxy.envoy.config.listener.v3.ListenerFilter.parser(),
                      extensionRegistry);
              if (listenerFiltersBuilder_ == null) {
                ensureListenerFiltersIsMutable();
                listenerFilters_.add(m);
              } else {
                listenerFiltersBuilder_.addMessage(m);
              }
              break;
            } // case 74
            case 82: {
              input.readMessage(
                  getTransparentFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00008000;
              break;
            } // case 82
            case 90: {
              input.readMessage(
                  getFreebindFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00010000;
              break;
            } // case 90
            case 98: {
              input.readMessage(
                  getTcpFastOpenQueueLengthFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00040000;
              break;
            } // case 98
            case 106: {
              io.envoyproxy.envoy.config.core.v3.SocketOption m =
                  input.readMessage(
                      io.envoyproxy.envoy.config.core.v3.SocketOption.parser(),
                      extensionRegistry);
              if (socketOptionsBuilder_ == null) {
                ensureSocketOptionsIsMutable();
                socketOptions_.add(m);
              } else {
                socketOptionsBuilder_.addMessage(m);
              }
              break;
            } // case 106
            case 122: {
              input.readMessage(
                  getListenerFiltersTimeoutFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00002000;
              break;
            } // case 122
            case 128: {
              trafficDirection_ = input.readEnum();
              bitField0_ |= 0x00080000;
              break;
            } // case 128
            case 136: {
              continueOnListenerFiltersTimeout_ = input.readBool();
              bitField0_ |= 0x00004000;
              break;
            } // case 136
            case 146: {
              input.readMessage(
                  getUdpListenerConfigFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00100000;
              break;
            } // case 146
            case 154: {
              input.readMessage(
                  getApiListenerFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00200000;
              break;
            } // case 154
            case 162: {
              input.readMessage(
                  getConnectionBalanceConfigFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00400000;
              break;
            } // case 162
            case 168: {
              reusePort_ = input.readBool();
              bitField0_ |= 0x00800000;
              break;
            } // case 168
            case 178: {
              io.envoyproxy.envoy.config.accesslog.v3.AccessLog m =
                  input.readMessage(
                      io.envoyproxy.envoy.config.accesslog.v3.AccessLog.parser(),
                      extensionRegistry);
              if (accessLogBuilder_ == null) {
                ensureAccessLogIsMutable();
                accessLog_.add(m);
              } else {
                accessLogBuilder_.addMessage(m);
              }
              break;
            } // case 178
            case 194: {
              input.readMessage(
                  getTcpBacklogSizeFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x04000000;
              break;
            } // case 194
            case 202: {
              input.readMessage(
                  getDefaultFilterChainFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000080;
              break;
            } // case 202
            case 210: {
              input.readMessage(
                  getBindToPortFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x08000000;
              break;
            } // case 210
            case 218: {
              input.readMessage(
                  getInternalListenerFieldBuilder().getBuilder(),
                  extensionRegistry);
              listenerSpecifierCase_ = 27;
              break;
            } // case 218
            case 226: {
              statPrefix_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00000008;
              break;
            } // case 226
            case 234: {
              input.readMessage(
                  getEnableReusePortFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x01000000;
              break;
            } // case 234
            case 240: {
              enableMptcp_ = input.readBool();
              bitField0_ |= 0x20000000;
              break;
            } // case 240
            case 248: {
              ignoreGlobalConnLimit_ = input.readBool();
              bitField0_ |= 0x40000000;
              break;
            } // case 248
            case 258: {
              input.readMessage(
                  getFilterChainMatcherFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000020;
              break;
            } // case 258
            case 266: {
              io.envoyproxy.envoy.config.listener.v3.AdditionalAddress m =
                  input.readMessage(
                      io.envoyproxy.envoy.config.listener.v3.AdditionalAddress.parser(),
                      extensionRegistry);
              if (additionalAddressesBuilder_ == null) {
                ensureAdditionalAddressesIsMutable();
                additionalAddresses_.add(m);
              } else {
                additionalAddressesBuilder_.addMessage(m);
              }
              break;
            } // case 266
            default: {
              if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                done = true; // was an endgroup tag
              }
              break;
            } // default:
          } // switch (tag)
        } // while (!done)
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.unwrapIOException();
      } finally {
        onChanged();
      } // finally
      return this;
    }
    private int listenerSpecifierCase_ = 0;
    private java.lang.Object listenerSpecifier_;
    public ListenerSpecifierCase
        getListenerSpecifierCase() {
      return ListenerSpecifierCase.forNumber(
          listenerSpecifierCase_);
    }

    public Builder clearListenerSpecifier() {
      listenerSpecifierCase_ = 0;
      listenerSpecifier_ = null;
      onChanged();
      return this;
    }

    private int bitField0_;

    private java.lang.Object name_ = "";
    /**
     * <pre>
     * The unique name by which this listener is known. If no name is provided,
     * Envoy will allocate an internal UUID for the listener. If the listener is to be dynamically
     * updated or removed via :ref:`LDS &lt;config_listeners_lds&gt;` a unique name must be provided.
     * </pre>
     *
     * <code>string name = 1;</code>
     * @return The name.
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * The unique name by which this listener is known. If no name is provided,
     * Envoy will allocate an internal UUID for the listener. If the listener is to be dynamically
     * updated or removed via :ref:`LDS &lt;config_listeners_lds&gt;` a unique name must be provided.
     * </pre>
     *
     * <code>string name = 1;</code>
     * @return The bytes for name.
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * The unique name by which this listener is known. If no name is provided,
     * Envoy will allocate an internal UUID for the listener. If the listener is to be dynamically
     * updated or removed via :ref:`LDS &lt;config_listeners_lds&gt;` a unique name must be provided.
     * </pre>
     *
     * <code>string name = 1;</code>
     * @param value The name to set.
     * @return This builder for chaining.
     */
    public Builder setName(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      name_ = value;
      bitField0_ |= 0x00000001;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The unique name by which this listener is known. If no name is provided,
     * Envoy will allocate an internal UUID for the listener. If the listener is to be dynamically
     * updated or removed via :ref:`LDS &lt;config_listeners_lds&gt;` a unique name must be provided.
     * </pre>
     *
     * <code>string name = 1;</code>
     * @return This builder for chaining.
     */
    public Builder clearName() {
      name_ = getDefaultInstance().getName();
      bitField0_ = (bitField0_ & ~0x00000001);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The unique name by which this listener is known. If no name is provided,
     * Envoy will allocate an internal UUID for the listener. If the listener is to be dynamically
     * updated or removed via :ref:`LDS &lt;config_listeners_lds&gt;` a unique name must be provided.
     * </pre>
     *
     * <code>string name = 1;</code>
     * @param value The bytes for name to set.
     * @return This builder for chaining.
     */
    public Builder setNameBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      name_ = value;
      bitField0_ |= 0x00000001;
      onChanged();
      return this;
    }

    private io.envoyproxy.envoy.config.core.v3.Address address_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.Address, io.envoyproxy.envoy.config.core.v3.Address.Builder, io.envoyproxy.envoy.config.core.v3.AddressOrBuilder> addressBuilder_;
    /**
     * <pre>
     * The address that the listener should listen on. In general, the address must be unique, though
     * that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on
     * Linux as the actual port will be allocated by the OS.
     * Required unless ``api_listener`` or ``listener_specifier`` is populated.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Address address = 2;</code>
     * @return Whether the address field is set.
     */
    public boolean hasAddress() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The address that the listener should listen on. In general, the address must be unique, though
     * that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on
     * Linux as the actual port will be allocated by the OS.
     * Required unless ``api_listener`` or ``listener_specifier`` is populated.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Address address = 2;</code>
     * @return The address.
     */
    public io.envoyproxy.envoy.config.core.v3.Address getAddress() {
      if (addressBuilder_ == null) {
        return address_ == null ? io.envoyproxy.envoy.config.core.v3.Address.getDefaultInstance() : address_;
      } else {
        return addressBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The address that the listener should listen on. In general, the address must be unique, though
     * that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on
     * Linux as the actual port will be allocated by the OS.
     * Required unless ``api_listener`` or ``listener_specifier`` is populated.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Address address = 2;</code>
     */
    public Builder setAddress(io.envoyproxy.envoy.config.core.v3.Address value) {
      if (addressBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        address_ = value;
      } else {
        addressBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000002;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The address that the listener should listen on. In general, the address must be unique, though
     * that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on
     * Linux as the actual port will be allocated by the OS.
     * Required unless ``api_listener`` or ``listener_specifier`` is populated.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Address address = 2;</code>
     */
    public Builder setAddress(
        io.envoyproxy.envoy.config.core.v3.Address.Builder builderForValue) {
      if (addressBuilder_ == null) {
        address_ = builderForValue.build();
      } else {
        addressBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000002;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The address that the listener should listen on. In general, the address must be unique, though
     * that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on
     * Linux as the actual port will be allocated by the OS.
     * Required unless ``api_listener`` or ``listener_specifier`` is populated.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Address address = 2;</code>
     */
    public Builder mergeAddress(io.envoyproxy.envoy.config.core.v3.Address value) {
      if (addressBuilder_ == null) {
        if (((bitField0_ & 0x00000002) != 0) &&
          address_ != null &&
          address_ != io.envoyproxy.envoy.config.core.v3.Address.getDefaultInstance()) {
          getAddressBuilder().mergeFrom(value);
        } else {
          address_ = value;
        }
      } else {
        addressBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000002;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The address that the listener should listen on. In general, the address must be unique, though
     * that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on
     * Linux as the actual port will be allocated by the OS.
     * Required unless ``api_listener`` or ``listener_specifier`` is populated.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Address address = 2;</code>
     */
    public Builder clearAddress() {
      bitField0_ = (bitField0_ & ~0x00000002);
      address_ = null;
      if (addressBuilder_ != null) {
        addressBuilder_.dispose();
        addressBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The address that the listener should listen on. In general, the address must be unique, though
     * that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on
     * Linux as the actual port will be allocated by the OS.
     * Required unless ``api_listener`` or ``listener_specifier`` is populated.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Address address = 2;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.Address.Builder getAddressBuilder() {
      bitField0_ |= 0x00000002;
      onChanged();
      return getAddressFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The address that the listener should listen on. In general, the address must be unique, though
     * that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on
     * Linux as the actual port will be allocated by the OS.
     * Required unless ``api_listener`` or ``listener_specifier`` is populated.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Address address = 2;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.AddressOrBuilder getAddressOrBuilder() {
      if (addressBuilder_ != null) {
        return addressBuilder_.getMessageOrBuilder();
      } else {
        return address_ == null ?
            io.envoyproxy.envoy.config.core.v3.Address.getDefaultInstance() : address_;
      }
    }
    /**
     * <pre>
     * The address that the listener should listen on. In general, the address must be unique, though
     * that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on
     * Linux as the actual port will be allocated by the OS.
     * Required unless ``api_listener`` or ``listener_specifier`` is populated.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Address address = 2;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.Address, io.envoyproxy.envoy.config.core.v3.Address.Builder, io.envoyproxy.envoy.config.core.v3.AddressOrBuilder> 
        getAddressFieldBuilder() {
      if (addressBuilder_ == null) {
        addressBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.Address, io.envoyproxy.envoy.config.core.v3.Address.Builder, io.envoyproxy.envoy.config.core.v3.AddressOrBuilder>(
                getAddress(),
                getParentForChildren(),
                isClean());
        address_ = null;
      }
      return addressBuilder_;
    }

    private java.util.List<io.envoyproxy.envoy.config.listener.v3.AdditionalAddress> additionalAddresses_ =
      java.util.Collections.emptyList();
    private void ensureAdditionalAddressesIsMutable() {
      if (!((bitField0_ & 0x00000004) != 0)) {
        additionalAddresses_ = new java.util.ArrayList<io.envoyproxy.envoy.config.listener.v3.AdditionalAddress>(additionalAddresses_);
        bitField0_ |= 0x00000004;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.listener.v3.AdditionalAddress, io.envoyproxy.envoy.config.listener.v3.AdditionalAddress.Builder, io.envoyproxy.envoy.config.listener.v3.AdditionalAddressOrBuilder> additionalAddressesBuilder_;

    /**
     * <pre>
     * The additional addresses the listener should listen on. The addresses must be unique across all
     * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
     * all addresses use the same protocol, and multiple internal addresses are not supported.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.listener.v3.AdditionalAddress> getAdditionalAddressesList() {
      if (additionalAddressesBuilder_ == null) {
        return java.util.Collections.unmodifiableList(additionalAddresses_);
      } else {
        return additionalAddressesBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * The additional addresses the listener should listen on. The addresses must be unique across all
     * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
     * all addresses use the same protocol, and multiple internal addresses are not supported.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
     */
    public int getAdditionalAddressesCount() {
      if (additionalAddressesBuilder_ == null) {
        return additionalAddresses_.size();
      } else {
        return additionalAddressesBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * The additional addresses the listener should listen on. The addresses must be unique across all
     * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
     * all addresses use the same protocol, and multiple internal addresses are not supported.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.AdditionalAddress getAdditionalAddresses(int index) {
      if (additionalAddressesBuilder_ == null) {
        return additionalAddresses_.get(index);
      } else {
        return additionalAddressesBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * The additional addresses the listener should listen on. The addresses must be unique across all
     * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
     * all addresses use the same protocol, and multiple internal addresses are not supported.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
     */
    public Builder setAdditionalAddresses(
        int index, io.envoyproxy.envoy.config.listener.v3.AdditionalAddress value) {
      if (additionalAddressesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAdditionalAddressesIsMutable();
        additionalAddresses_.set(index, value);
        onChanged();
      } else {
        additionalAddressesBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * The additional addresses the listener should listen on. The addresses must be unique across all
     * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
     * all addresses use the same protocol, and multiple internal addresses are not supported.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
     */
    public Builder setAdditionalAddresses(
        int index, io.envoyproxy.envoy.config.listener.v3.AdditionalAddress.Builder builderForValue) {
      if (additionalAddressesBuilder_ == null) {
        ensureAdditionalAddressesIsMutable();
        additionalAddresses_.set(index, builderForValue.build());
        onChanged();
      } else {
        additionalAddressesBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * The additional addresses the listener should listen on. The addresses must be unique across all
     * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
     * all addresses use the same protocol, and multiple internal addresses are not supported.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
     */
    public Builder addAdditionalAddresses(io.envoyproxy.envoy.config.listener.v3.AdditionalAddress value) {
      if (additionalAddressesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAdditionalAddressesIsMutable();
        additionalAddresses_.add(value);
        onChanged();
      } else {
        additionalAddressesBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * The additional addresses the listener should listen on. The addresses must be unique across all
     * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
     * all addresses use the same protocol, and multiple internal addresses are not supported.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
     */
    public Builder addAdditionalAddresses(
        int index, io.envoyproxy.envoy.config.listener.v3.AdditionalAddress value) {
      if (additionalAddressesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAdditionalAddressesIsMutable();
        additionalAddresses_.add(index, value);
        onChanged();
      } else {
        additionalAddressesBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * The additional addresses the listener should listen on. The addresses must be unique across all
     * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
     * all addresses use the same protocol, and multiple internal addresses are not supported.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
     */
    public Builder addAdditionalAddresses(
        io.envoyproxy.envoy.config.listener.v3.AdditionalAddress.Builder builderForValue) {
      if (additionalAddressesBuilder_ == null) {
        ensureAdditionalAddressesIsMutable();
        additionalAddresses_.add(builderForValue.build());
        onChanged();
      } else {
        additionalAddressesBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * The additional addresses the listener should listen on. The addresses must be unique across all
     * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
     * all addresses use the same protocol, and multiple internal addresses are not supported.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
     */
    public Builder addAdditionalAddresses(
        int index, io.envoyproxy.envoy.config.listener.v3.AdditionalAddress.Builder builderForValue) {
      if (additionalAddressesBuilder_ == null) {
        ensureAdditionalAddressesIsMutable();
        additionalAddresses_.add(index, builderForValue.build());
        onChanged();
      } else {
        additionalAddressesBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * The additional addresses the listener should listen on. The addresses must be unique across all
     * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
     * all addresses use the same protocol, and multiple internal addresses are not supported.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
     */
    public Builder addAllAdditionalAddresses(
        java.lang.Iterable<? extends io.envoyproxy.envoy.config.listener.v3.AdditionalAddress> values) {
      if (additionalAddressesBuilder_ == null) {
        ensureAdditionalAddressesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, additionalAddresses_);
        onChanged();
      } else {
        additionalAddressesBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * The additional addresses the listener should listen on. The addresses must be unique across all
     * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
     * all addresses use the same protocol, and multiple internal addresses are not supported.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
     */
    public Builder clearAdditionalAddresses() {
      if (additionalAddressesBuilder_ == null) {
        additionalAddresses_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
      } else {
        additionalAddressesBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * The additional addresses the listener should listen on. The addresses must be unique across all
     * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
     * all addresses use the same protocol, and multiple internal addresses are not supported.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
     */
    public Builder removeAdditionalAddresses(int index) {
      if (additionalAddressesBuilder_ == null) {
        ensureAdditionalAddressesIsMutable();
        additionalAddresses_.remove(index);
        onChanged();
      } else {
        additionalAddressesBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * The additional addresses the listener should listen on. The addresses must be unique across all
     * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
     * all addresses use the same protocol, and multiple internal addresses are not supported.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.AdditionalAddress.Builder getAdditionalAddressesBuilder(
        int index) {
      return getAdditionalAddressesFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * The additional addresses the listener should listen on. The addresses must be unique across all
     * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
     * all addresses use the same protocol, and multiple internal addresses are not supported.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.AdditionalAddressOrBuilder getAdditionalAddressesOrBuilder(
        int index) {
      if (additionalAddressesBuilder_ == null) {
        return additionalAddresses_.get(index);  } else {
        return additionalAddressesBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * The additional addresses the listener should listen on. The addresses must be unique across all
     * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
     * all addresses use the same protocol, and multiple internal addresses are not supported.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
     */
    public java.util.List<? extends io.envoyproxy.envoy.config.listener.v3.AdditionalAddressOrBuilder> 
         getAdditionalAddressesOrBuilderList() {
      if (additionalAddressesBuilder_ != null) {
        return additionalAddressesBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(additionalAddresses_);
      }
    }
    /**
     * <pre>
     * The additional addresses the listener should listen on. The addresses must be unique across all
     * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
     * all addresses use the same protocol, and multiple internal addresses are not supported.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.AdditionalAddress.Builder addAdditionalAddressesBuilder() {
      return getAdditionalAddressesFieldBuilder().addBuilder(
          io.envoyproxy.envoy.config.listener.v3.AdditionalAddress.getDefaultInstance());
    }
    /**
     * <pre>
     * The additional addresses the listener should listen on. The addresses must be unique across all
     * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
     * all addresses use the same protocol, and multiple internal addresses are not supported.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.AdditionalAddress.Builder addAdditionalAddressesBuilder(
        int index) {
      return getAdditionalAddressesFieldBuilder().addBuilder(
          index, io.envoyproxy.envoy.config.listener.v3.AdditionalAddress.getDefaultInstance());
    }
    /**
     * <pre>
     * The additional addresses the listener should listen on. The addresses must be unique across all
     * listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
     * all addresses use the same protocol, and multiple internal addresses are not supported.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.AdditionalAddress additional_addresses = 33;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.listener.v3.AdditionalAddress.Builder> 
         getAdditionalAddressesBuilderList() {
      return getAdditionalAddressesFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.listener.v3.AdditionalAddress, io.envoyproxy.envoy.config.listener.v3.AdditionalAddress.Builder, io.envoyproxy.envoy.config.listener.v3.AdditionalAddressOrBuilder> 
        getAdditionalAddressesFieldBuilder() {
      if (additionalAddressesBuilder_ == null) {
        additionalAddressesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.envoyproxy.envoy.config.listener.v3.AdditionalAddress, io.envoyproxy.envoy.config.listener.v3.AdditionalAddress.Builder, io.envoyproxy.envoy.config.listener.v3.AdditionalAddressOrBuilder>(
                additionalAddresses_,
                ((bitField0_ & 0x00000004) != 0),
                getParentForChildren(),
                isClean());
        additionalAddresses_ = null;
      }
      return additionalAddressesBuilder_;
    }

    private java.lang.Object statPrefix_ = "";
    /**
     * <pre>
     * Optional prefix to use on listener stats. If empty, the stats will be rooted at
     * ``listener.&lt;address as string&gt;.``. If non-empty, stats will be rooted at
     * ``listener.&lt;stat_prefix&gt;.``.
     * </pre>
     *
     * <code>string stat_prefix = 28;</code>
     * @return The statPrefix.
     */
    public java.lang.String getStatPrefix() {
      java.lang.Object ref = statPrefix_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        statPrefix_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Optional prefix to use on listener stats. If empty, the stats will be rooted at
     * ``listener.&lt;address as string&gt;.``. If non-empty, stats will be rooted at
     * ``listener.&lt;stat_prefix&gt;.``.
     * </pre>
     *
     * <code>string stat_prefix = 28;</code>
     * @return The bytes for statPrefix.
     */
    public com.google.protobuf.ByteString
        getStatPrefixBytes() {
      java.lang.Object ref = statPrefix_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        statPrefix_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Optional prefix to use on listener stats. If empty, the stats will be rooted at
     * ``listener.&lt;address as string&gt;.``. If non-empty, stats will be rooted at
     * ``listener.&lt;stat_prefix&gt;.``.
     * </pre>
     *
     * <code>string stat_prefix = 28;</code>
     * @param value The statPrefix to set.
     * @return This builder for chaining.
     */
    public Builder setStatPrefix(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      statPrefix_ = value;
      bitField0_ |= 0x00000008;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Optional prefix to use on listener stats. If empty, the stats will be rooted at
     * ``listener.&lt;address as string&gt;.``. If non-empty, stats will be rooted at
     * ``listener.&lt;stat_prefix&gt;.``.
     * </pre>
     *
     * <code>string stat_prefix = 28;</code>
     * @return This builder for chaining.
     */
    public Builder clearStatPrefix() {
      statPrefix_ = getDefaultInstance().getStatPrefix();
      bitField0_ = (bitField0_ & ~0x00000008);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Optional prefix to use on listener stats. If empty, the stats will be rooted at
     * ``listener.&lt;address as string&gt;.``. If non-empty, stats will be rooted at
     * ``listener.&lt;stat_prefix&gt;.``.
     * </pre>
     *
     * <code>string stat_prefix = 28;</code>
     * @param value The bytes for statPrefix to set.
     * @return This builder for chaining.
     */
    public Builder setStatPrefixBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      statPrefix_ = value;
      bitField0_ |= 0x00000008;
      onChanged();
      return this;
    }

    private java.util.List<io.envoyproxy.envoy.config.listener.v3.FilterChain> filterChains_ =
      java.util.Collections.emptyList();
    private void ensureFilterChainsIsMutable() {
      if (!((bitField0_ & 0x00000010) != 0)) {
        filterChains_ = new java.util.ArrayList<io.envoyproxy.envoy.config.listener.v3.FilterChain>(filterChains_);
        bitField0_ |= 0x00000010;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.listener.v3.FilterChain, io.envoyproxy.envoy.config.listener.v3.FilterChain.Builder, io.envoyproxy.envoy.config.listener.v3.FilterChainOrBuilder> filterChainsBuilder_;

    /**
     * <pre>
     * A list of filter chains to consider for this listener. The
     * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
     * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
     * connection.
     * Example using SNI for filter chain selection can be found in the
     * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.listener.v3.FilterChain> getFilterChainsList() {
      if (filterChainsBuilder_ == null) {
        return java.util.Collections.unmodifiableList(filterChains_);
      } else {
        return filterChainsBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * A list of filter chains to consider for this listener. The
     * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
     * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
     * connection.
     * Example using SNI for filter chain selection can be found in the
     * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
     */
    public int getFilterChainsCount() {
      if (filterChainsBuilder_ == null) {
        return filterChains_.size();
      } else {
        return filterChainsBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * A list of filter chains to consider for this listener. The
     * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
     * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
     * connection.
     * Example using SNI for filter chain selection can be found in the
     * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.FilterChain getFilterChains(int index) {
      if (filterChainsBuilder_ == null) {
        return filterChains_.get(index);
      } else {
        return filterChainsBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * A list of filter chains to consider for this listener. The
     * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
     * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
     * connection.
     * Example using SNI for filter chain selection can be found in the
     * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
     */
    public Builder setFilterChains(
        int index, io.envoyproxy.envoy.config.listener.v3.FilterChain value) {
      if (filterChainsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureFilterChainsIsMutable();
        filterChains_.set(index, value);
        onChanged();
      } else {
        filterChainsBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * A list of filter chains to consider for this listener. The
     * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
     * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
     * connection.
     * Example using SNI for filter chain selection can be found in the
     * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
     */
    public Builder setFilterChains(
        int index, io.envoyproxy.envoy.config.listener.v3.FilterChain.Builder builderForValue) {
      if (filterChainsBuilder_ == null) {
        ensureFilterChainsIsMutable();
        filterChains_.set(index, builderForValue.build());
        onChanged();
      } else {
        filterChainsBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * A list of filter chains to consider for this listener. The
     * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
     * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
     * connection.
     * Example using SNI for filter chain selection can be found in the
     * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
     */
    public Builder addFilterChains(io.envoyproxy.envoy.config.listener.v3.FilterChain value) {
      if (filterChainsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureFilterChainsIsMutable();
        filterChains_.add(value);
        onChanged();
      } else {
        filterChainsBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * A list of filter chains to consider for this listener. The
     * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
     * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
     * connection.
     * Example using SNI for filter chain selection can be found in the
     * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
     */
    public Builder addFilterChains(
        int index, io.envoyproxy.envoy.config.listener.v3.FilterChain value) {
      if (filterChainsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureFilterChainsIsMutable();
        filterChains_.add(index, value);
        onChanged();
      } else {
        filterChainsBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * A list of filter chains to consider for this listener. The
     * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
     * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
     * connection.
     * Example using SNI for filter chain selection can be found in the
     * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
     */
    public Builder addFilterChains(
        io.envoyproxy.envoy.config.listener.v3.FilterChain.Builder builderForValue) {
      if (filterChainsBuilder_ == null) {
        ensureFilterChainsIsMutable();
        filterChains_.add(builderForValue.build());
        onChanged();
      } else {
        filterChainsBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * A list of filter chains to consider for this listener. The
     * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
     * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
     * connection.
     * Example using SNI for filter chain selection can be found in the
     * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
     */
    public Builder addFilterChains(
        int index, io.envoyproxy.envoy.config.listener.v3.FilterChain.Builder builderForValue) {
      if (filterChainsBuilder_ == null) {
        ensureFilterChainsIsMutable();
        filterChains_.add(index, builderForValue.build());
        onChanged();
      } else {
        filterChainsBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * A list of filter chains to consider for this listener. The
     * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
     * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
     * connection.
     * Example using SNI for filter chain selection can be found in the
     * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
     */
    public Builder addAllFilterChains(
        java.lang.Iterable<? extends io.envoyproxy.envoy.config.listener.v3.FilterChain> values) {
      if (filterChainsBuilder_ == null) {
        ensureFilterChainsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, filterChains_);
        onChanged();
      } else {
        filterChainsBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * A list of filter chains to consider for this listener. The
     * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
     * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
     * connection.
     * Example using SNI for filter chain selection can be found in the
     * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
     */
    public Builder clearFilterChains() {
      if (filterChainsBuilder_ == null) {
        filterChains_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
      } else {
        filterChainsBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * A list of filter chains to consider for this listener. The
     * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
     * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
     * connection.
     * Example using SNI for filter chain selection can be found in the
     * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
     */
    public Builder removeFilterChains(int index) {
      if (filterChainsBuilder_ == null) {
        ensureFilterChainsIsMutable();
        filterChains_.remove(index);
        onChanged();
      } else {
        filterChainsBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * A list of filter chains to consider for this listener. The
     * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
     * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
     * connection.
     * Example using SNI for filter chain selection can be found in the
     * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.FilterChain.Builder getFilterChainsBuilder(
        int index) {
      return getFilterChainsFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * A list of filter chains to consider for this listener. The
     * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
     * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
     * connection.
     * Example using SNI for filter chain selection can be found in the
     * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.FilterChainOrBuilder getFilterChainsOrBuilder(
        int index) {
      if (filterChainsBuilder_ == null) {
        return filterChains_.get(index);  } else {
        return filterChainsBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * A list of filter chains to consider for this listener. The
     * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
     * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
     * connection.
     * Example using SNI for filter chain selection can be found in the
     * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
     */
    public java.util.List<? extends io.envoyproxy.envoy.config.listener.v3.FilterChainOrBuilder> 
         getFilterChainsOrBuilderList() {
      if (filterChainsBuilder_ != null) {
        return filterChainsBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(filterChains_);
      }
    }
    /**
     * <pre>
     * A list of filter chains to consider for this listener. The
     * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
     * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
     * connection.
     * Example using SNI for filter chain selection can be found in the
     * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.FilterChain.Builder addFilterChainsBuilder() {
      return getFilterChainsFieldBuilder().addBuilder(
          io.envoyproxy.envoy.config.listener.v3.FilterChain.getDefaultInstance());
    }
    /**
     * <pre>
     * A list of filter chains to consider for this listener. The
     * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
     * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
     * connection.
     * Example using SNI for filter chain selection can be found in the
     * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.FilterChain.Builder addFilterChainsBuilder(
        int index) {
      return getFilterChainsFieldBuilder().addBuilder(
          index, io.envoyproxy.envoy.config.listener.v3.FilterChain.getDefaultInstance());
    }
    /**
     * <pre>
     * A list of filter chains to consider for this listener. The
     * :ref:`FilterChain &lt;envoy_v3_api_msg_config.listener.v3.FilterChain&gt;` with the most specific
     * :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` criteria is used on a
     * connection.
     * Example using SNI for filter chain selection can be found in the
     * :ref:`FAQ entry &lt;faq_how_to_setup_sni&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.FilterChain filter_chains = 3;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.listener.v3.FilterChain.Builder> 
         getFilterChainsBuilderList() {
      return getFilterChainsFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.listener.v3.FilterChain, io.envoyproxy.envoy.config.listener.v3.FilterChain.Builder, io.envoyproxy.envoy.config.listener.v3.FilterChainOrBuilder> 
        getFilterChainsFieldBuilder() {
      if (filterChainsBuilder_ == null) {
        filterChainsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.envoyproxy.envoy.config.listener.v3.FilterChain, io.envoyproxy.envoy.config.listener.v3.FilterChain.Builder, io.envoyproxy.envoy.config.listener.v3.FilterChainOrBuilder>(
                filterChains_,
                ((bitField0_ & 0x00000010) != 0),
                getParentForChildren(),
                isClean());
        filterChains_ = null;
      }
      return filterChainsBuilder_;
    }

    private com.github.xds.type.matcher.v3.Matcher filterChainMatcher_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.github.xds.type.matcher.v3.Matcher, com.github.xds.type.matcher.v3.Matcher.Builder, com.github.xds.type.matcher.v3.MatcherOrBuilder> filterChainMatcherBuilder_;
    /**
     * <pre>
     * :ref:`Matcher API &lt;arch_overview_matching_listener&gt;` resolving the filter chain name from the
     * network properties. This matcher is used as a replacement for the filter chain match condition
     * :ref:`filter_chain_match
     * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;`. If specified, all
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;` must have a
     * non-empty and unique :ref:`name &lt;envoy_v3_api_field_config.listener.v3.FilterChain.name&gt;` field
     * and not specify :ref:`filter_chain_match
     * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;` field.
     * .. note::
     *  Once matched, each connection is permanently bound to its filter chain.
     *  If the matcher changes but the filter chain remains the same, the
     *  connections bound to the filter chain are not drained. If, however, the
     *  filter chain is removed or structurally modified, then the drain for its
     *  connections is initiated.
     * </pre>
     *
     * <code>.xds.type.matcher.v3.Matcher filter_chain_matcher = 32 [(.xds.annotations.v3.field_status) = { ... }</code>
     * @return Whether the filterChainMatcher field is set.
     */
    public boolean hasFilterChainMatcher() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * :ref:`Matcher API &lt;arch_overview_matching_listener&gt;` resolving the filter chain name from the
     * network properties. This matcher is used as a replacement for the filter chain match condition
     * :ref:`filter_chain_match
     * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;`. If specified, all
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;` must have a
     * non-empty and unique :ref:`name &lt;envoy_v3_api_field_config.listener.v3.FilterChain.name&gt;` field
     * and not specify :ref:`filter_chain_match
     * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;` field.
     * .. note::
     *  Once matched, each connection is permanently bound to its filter chain.
     *  If the matcher changes but the filter chain remains the same, the
     *  connections bound to the filter chain are not drained. If, however, the
     *  filter chain is removed or structurally modified, then the drain for its
     *  connections is initiated.
     * </pre>
     *
     * <code>.xds.type.matcher.v3.Matcher filter_chain_matcher = 32 [(.xds.annotations.v3.field_status) = { ... }</code>
     * @return The filterChainMatcher.
     */
    public com.github.xds.type.matcher.v3.Matcher getFilterChainMatcher() {
      if (filterChainMatcherBuilder_ == null) {
        return filterChainMatcher_ == null ? com.github.xds.type.matcher.v3.Matcher.getDefaultInstance() : filterChainMatcher_;
      } else {
        return filterChainMatcherBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * :ref:`Matcher API &lt;arch_overview_matching_listener&gt;` resolving the filter chain name from the
     * network properties. This matcher is used as a replacement for the filter chain match condition
     * :ref:`filter_chain_match
     * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;`. If specified, all
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;` must have a
     * non-empty and unique :ref:`name &lt;envoy_v3_api_field_config.listener.v3.FilterChain.name&gt;` field
     * and not specify :ref:`filter_chain_match
     * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;` field.
     * .. note::
     *  Once matched, each connection is permanently bound to its filter chain.
     *  If the matcher changes but the filter chain remains the same, the
     *  connections bound to the filter chain are not drained. If, however, the
     *  filter chain is removed or structurally modified, then the drain for its
     *  connections is initiated.
     * </pre>
     *
     * <code>.xds.type.matcher.v3.Matcher filter_chain_matcher = 32 [(.xds.annotations.v3.field_status) = { ... }</code>
     */
    public Builder setFilterChainMatcher(com.github.xds.type.matcher.v3.Matcher value) {
      if (filterChainMatcherBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        filterChainMatcher_ = value;
      } else {
        filterChainMatcherBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000020;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * :ref:`Matcher API &lt;arch_overview_matching_listener&gt;` resolving the filter chain name from the
     * network properties. This matcher is used as a replacement for the filter chain match condition
     * :ref:`filter_chain_match
     * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;`. If specified, all
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;` must have a
     * non-empty and unique :ref:`name &lt;envoy_v3_api_field_config.listener.v3.FilterChain.name&gt;` field
     * and not specify :ref:`filter_chain_match
     * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;` field.
     * .. note::
     *  Once matched, each connection is permanently bound to its filter chain.
     *  If the matcher changes but the filter chain remains the same, the
     *  connections bound to the filter chain are not drained. If, however, the
     *  filter chain is removed or structurally modified, then the drain for its
     *  connections is initiated.
     * </pre>
     *
     * <code>.xds.type.matcher.v3.Matcher filter_chain_matcher = 32 [(.xds.annotations.v3.field_status) = { ... }</code>
     */
    public Builder setFilterChainMatcher(
        com.github.xds.type.matcher.v3.Matcher.Builder builderForValue) {
      if (filterChainMatcherBuilder_ == null) {
        filterChainMatcher_ = builderForValue.build();
      } else {
        filterChainMatcherBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000020;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * :ref:`Matcher API &lt;arch_overview_matching_listener&gt;` resolving the filter chain name from the
     * network properties. This matcher is used as a replacement for the filter chain match condition
     * :ref:`filter_chain_match
     * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;`. If specified, all
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;` must have a
     * non-empty and unique :ref:`name &lt;envoy_v3_api_field_config.listener.v3.FilterChain.name&gt;` field
     * and not specify :ref:`filter_chain_match
     * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;` field.
     * .. note::
     *  Once matched, each connection is permanently bound to its filter chain.
     *  If the matcher changes but the filter chain remains the same, the
     *  connections bound to the filter chain are not drained. If, however, the
     *  filter chain is removed or structurally modified, then the drain for its
     *  connections is initiated.
     * </pre>
     *
     * <code>.xds.type.matcher.v3.Matcher filter_chain_matcher = 32 [(.xds.annotations.v3.field_status) = { ... }</code>
     */
    public Builder mergeFilterChainMatcher(com.github.xds.type.matcher.v3.Matcher value) {
      if (filterChainMatcherBuilder_ == null) {
        if (((bitField0_ & 0x00000020) != 0) &&
          filterChainMatcher_ != null &&
          filterChainMatcher_ != com.github.xds.type.matcher.v3.Matcher.getDefaultInstance()) {
          getFilterChainMatcherBuilder().mergeFrom(value);
        } else {
          filterChainMatcher_ = value;
        }
      } else {
        filterChainMatcherBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000020;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * :ref:`Matcher API &lt;arch_overview_matching_listener&gt;` resolving the filter chain name from the
     * network properties. This matcher is used as a replacement for the filter chain match condition
     * :ref:`filter_chain_match
     * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;`. If specified, all
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;` must have a
     * non-empty and unique :ref:`name &lt;envoy_v3_api_field_config.listener.v3.FilterChain.name&gt;` field
     * and not specify :ref:`filter_chain_match
     * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;` field.
     * .. note::
     *  Once matched, each connection is permanently bound to its filter chain.
     *  If the matcher changes but the filter chain remains the same, the
     *  connections bound to the filter chain are not drained. If, however, the
     *  filter chain is removed or structurally modified, then the drain for its
     *  connections is initiated.
     * </pre>
     *
     * <code>.xds.type.matcher.v3.Matcher filter_chain_matcher = 32 [(.xds.annotations.v3.field_status) = { ... }</code>
     */
    public Builder clearFilterChainMatcher() {
      bitField0_ = (bitField0_ & ~0x00000020);
      filterChainMatcher_ = null;
      if (filterChainMatcherBuilder_ != null) {
        filterChainMatcherBuilder_.dispose();
        filterChainMatcherBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * :ref:`Matcher API &lt;arch_overview_matching_listener&gt;` resolving the filter chain name from the
     * network properties. This matcher is used as a replacement for the filter chain match condition
     * :ref:`filter_chain_match
     * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;`. If specified, all
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;` must have a
     * non-empty and unique :ref:`name &lt;envoy_v3_api_field_config.listener.v3.FilterChain.name&gt;` field
     * and not specify :ref:`filter_chain_match
     * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;` field.
     * .. note::
     *  Once matched, each connection is permanently bound to its filter chain.
     *  If the matcher changes but the filter chain remains the same, the
     *  connections bound to the filter chain are not drained. If, however, the
     *  filter chain is removed or structurally modified, then the drain for its
     *  connections is initiated.
     * </pre>
     *
     * <code>.xds.type.matcher.v3.Matcher filter_chain_matcher = 32 [(.xds.annotations.v3.field_status) = { ... }</code>
     */
    public com.github.xds.type.matcher.v3.Matcher.Builder getFilterChainMatcherBuilder() {
      bitField0_ |= 0x00000020;
      onChanged();
      return getFilterChainMatcherFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * :ref:`Matcher API &lt;arch_overview_matching_listener&gt;` resolving the filter chain name from the
     * network properties. This matcher is used as a replacement for the filter chain match condition
     * :ref:`filter_chain_match
     * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;`. If specified, all
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;` must have a
     * non-empty and unique :ref:`name &lt;envoy_v3_api_field_config.listener.v3.FilterChain.name&gt;` field
     * and not specify :ref:`filter_chain_match
     * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;` field.
     * .. note::
     *  Once matched, each connection is permanently bound to its filter chain.
     *  If the matcher changes but the filter chain remains the same, the
     *  connections bound to the filter chain are not drained. If, however, the
     *  filter chain is removed or structurally modified, then the drain for its
     *  connections is initiated.
     * </pre>
     *
     * <code>.xds.type.matcher.v3.Matcher filter_chain_matcher = 32 [(.xds.annotations.v3.field_status) = { ... }</code>
     */
    public com.github.xds.type.matcher.v3.MatcherOrBuilder getFilterChainMatcherOrBuilder() {
      if (filterChainMatcherBuilder_ != null) {
        return filterChainMatcherBuilder_.getMessageOrBuilder();
      } else {
        return filterChainMatcher_ == null ?
            com.github.xds.type.matcher.v3.Matcher.getDefaultInstance() : filterChainMatcher_;
      }
    }
    /**
     * <pre>
     * :ref:`Matcher API &lt;arch_overview_matching_listener&gt;` resolving the filter chain name from the
     * network properties. This matcher is used as a replacement for the filter chain match condition
     * :ref:`filter_chain_match
     * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;`. If specified, all
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;` must have a
     * non-empty and unique :ref:`name &lt;envoy_v3_api_field_config.listener.v3.FilterChain.name&gt;` field
     * and not specify :ref:`filter_chain_match
     * &lt;envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match&gt;` field.
     * .. note::
     *  Once matched, each connection is permanently bound to its filter chain.
     *  If the matcher changes but the filter chain remains the same, the
     *  connections bound to the filter chain are not drained. If, however, the
     *  filter chain is removed or structurally modified, then the drain for its
     *  connections is initiated.
     * </pre>
     *
     * <code>.xds.type.matcher.v3.Matcher filter_chain_matcher = 32 [(.xds.annotations.v3.field_status) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.github.xds.type.matcher.v3.Matcher, com.github.xds.type.matcher.v3.Matcher.Builder, com.github.xds.type.matcher.v3.MatcherOrBuilder> 
        getFilterChainMatcherFieldBuilder() {
      if (filterChainMatcherBuilder_ == null) {
        filterChainMatcherBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.github.xds.type.matcher.v3.Matcher, com.github.xds.type.matcher.v3.Matcher.Builder, com.github.xds.type.matcher.v3.MatcherOrBuilder>(
                getFilterChainMatcher(),
                getParentForChildren(),
                isClean());
        filterChainMatcher_ = null;
      }
      return filterChainMatcherBuilder_;
    }

    private com.google.protobuf.BoolValue useOriginalDst_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> useOriginalDstBuilder_;
    /**
     * <pre>
     * If a connection is redirected using ``iptables``, the port on which the proxy
     * receives it might be different from the original destination address. When this flag is set to
     * true, the listener hands off redirected connections to the listener associated with the
     * original destination address. If there is no listener associated with the original destination
     * address, the connection is handled by the listener that receives it. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_original_dst = 4;</code>
     * @return Whether the useOriginalDst field is set.
     */
    public boolean hasUseOriginalDst() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * If a connection is redirected using ``iptables``, the port on which the proxy
     * receives it might be different from the original destination address. When this flag is set to
     * true, the listener hands off redirected connections to the listener associated with the
     * original destination address. If there is no listener associated with the original destination
     * address, the connection is handled by the listener that receives it. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_original_dst = 4;</code>
     * @return The useOriginalDst.
     */
    public com.google.protobuf.BoolValue getUseOriginalDst() {
      if (useOriginalDstBuilder_ == null) {
        return useOriginalDst_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : useOriginalDst_;
      } else {
        return useOriginalDstBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * If a connection is redirected using ``iptables``, the port on which the proxy
     * receives it might be different from the original destination address. When this flag is set to
     * true, the listener hands off redirected connections to the listener associated with the
     * original destination address. If there is no listener associated with the original destination
     * address, the connection is handled by the listener that receives it. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_original_dst = 4;</code>
     */
    public Builder setUseOriginalDst(com.google.protobuf.BoolValue value) {
      if (useOriginalDstBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        useOriginalDst_ = value;
      } else {
        useOriginalDstBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000040;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If a connection is redirected using ``iptables``, the port on which the proxy
     * receives it might be different from the original destination address. When this flag is set to
     * true, the listener hands off redirected connections to the listener associated with the
     * original destination address. If there is no listener associated with the original destination
     * address, the connection is handled by the listener that receives it. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_original_dst = 4;</code>
     */
    public Builder setUseOriginalDst(
        com.google.protobuf.BoolValue.Builder builderForValue) {
      if (useOriginalDstBuilder_ == null) {
        useOriginalDst_ = builderForValue.build();
      } else {
        useOriginalDstBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000040;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If a connection is redirected using ``iptables``, the port on which the proxy
     * receives it might be different from the original destination address. When this flag is set to
     * true, the listener hands off redirected connections to the listener associated with the
     * original destination address. If there is no listener associated with the original destination
     * address, the connection is handled by the listener that receives it. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_original_dst = 4;</code>
     */
    public Builder mergeUseOriginalDst(com.google.protobuf.BoolValue value) {
      if (useOriginalDstBuilder_ == null) {
        if (((bitField0_ & 0x00000040) != 0) &&
          useOriginalDst_ != null &&
          useOriginalDst_ != com.google.protobuf.BoolValue.getDefaultInstance()) {
          getUseOriginalDstBuilder().mergeFrom(value);
        } else {
          useOriginalDst_ = value;
        }
      } else {
        useOriginalDstBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000040;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If a connection is redirected using ``iptables``, the port on which the proxy
     * receives it might be different from the original destination address. When this flag is set to
     * true, the listener hands off redirected connections to the listener associated with the
     * original destination address. If there is no listener associated with the original destination
     * address, the connection is handled by the listener that receives it. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_original_dst = 4;</code>
     */
    public Builder clearUseOriginalDst() {
      bitField0_ = (bitField0_ & ~0x00000040);
      useOriginalDst_ = null;
      if (useOriginalDstBuilder_ != null) {
        useOriginalDstBuilder_.dispose();
        useOriginalDstBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If a connection is redirected using ``iptables``, the port on which the proxy
     * receives it might be different from the original destination address. When this flag is set to
     * true, the listener hands off redirected connections to the listener associated with the
     * original destination address. If there is no listener associated with the original destination
     * address, the connection is handled by the listener that receives it. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_original_dst = 4;</code>
     */
    public com.google.protobuf.BoolValue.Builder getUseOriginalDstBuilder() {
      bitField0_ |= 0x00000040;
      onChanged();
      return getUseOriginalDstFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * If a connection is redirected using ``iptables``, the port on which the proxy
     * receives it might be different from the original destination address. When this flag is set to
     * true, the listener hands off redirected connections to the listener associated with the
     * original destination address. If there is no listener associated with the original destination
     * address, the connection is handled by the listener that receives it. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_original_dst = 4;</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getUseOriginalDstOrBuilder() {
      if (useOriginalDstBuilder_ != null) {
        return useOriginalDstBuilder_.getMessageOrBuilder();
      } else {
        return useOriginalDst_ == null ?
            com.google.protobuf.BoolValue.getDefaultInstance() : useOriginalDst_;
      }
    }
    /**
     * <pre>
     * If a connection is redirected using ``iptables``, the port on which the proxy
     * receives it might be different from the original destination address. When this flag is set to
     * true, the listener hands off redirected connections to the listener associated with the
     * original destination address. If there is no listener associated with the original destination
     * address, the connection is handled by the listener that receives it. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_original_dst = 4;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
        getUseOriginalDstFieldBuilder() {
      if (useOriginalDstBuilder_ == null) {
        useOriginalDstBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                getUseOriginalDst(),
                getParentForChildren(),
                isClean());
        useOriginalDst_ = null;
      }
      return useOriginalDstBuilder_;
    }

    private io.envoyproxy.envoy.config.listener.v3.FilterChain defaultFilterChain_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.listener.v3.FilterChain, io.envoyproxy.envoy.config.listener.v3.FilterChain.Builder, io.envoyproxy.envoy.config.listener.v3.FilterChainOrBuilder> defaultFilterChainBuilder_;
    /**
     * <pre>
     * The default filter chain if none of the filter chain matches. If no default filter chain is supplied,
     * the connection will be closed. The filter chain match is ignored in this field.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.FilterChain default_filter_chain = 25;</code>
     * @return Whether the defaultFilterChain field is set.
     */
    public boolean hasDefaultFilterChain() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * The default filter chain if none of the filter chain matches. If no default filter chain is supplied,
     * the connection will be closed. The filter chain match is ignored in this field.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.FilterChain default_filter_chain = 25;</code>
     * @return The defaultFilterChain.
     */
    public io.envoyproxy.envoy.config.listener.v3.FilterChain getDefaultFilterChain() {
      if (defaultFilterChainBuilder_ == null) {
        return defaultFilterChain_ == null ? io.envoyproxy.envoy.config.listener.v3.FilterChain.getDefaultInstance() : defaultFilterChain_;
      } else {
        return defaultFilterChainBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The default filter chain if none of the filter chain matches. If no default filter chain is supplied,
     * the connection will be closed. The filter chain match is ignored in this field.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.FilterChain default_filter_chain = 25;</code>
     */
    public Builder setDefaultFilterChain(io.envoyproxy.envoy.config.listener.v3.FilterChain value) {
      if (defaultFilterChainBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        defaultFilterChain_ = value;
      } else {
        defaultFilterChainBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000080;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The default filter chain if none of the filter chain matches. If no default filter chain is supplied,
     * the connection will be closed. The filter chain match is ignored in this field.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.FilterChain default_filter_chain = 25;</code>
     */
    public Builder setDefaultFilterChain(
        io.envoyproxy.envoy.config.listener.v3.FilterChain.Builder builderForValue) {
      if (defaultFilterChainBuilder_ == null) {
        defaultFilterChain_ = builderForValue.build();
      } else {
        defaultFilterChainBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000080;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The default filter chain if none of the filter chain matches. If no default filter chain is supplied,
     * the connection will be closed. The filter chain match is ignored in this field.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.FilterChain default_filter_chain = 25;</code>
     */
    public Builder mergeDefaultFilterChain(io.envoyproxy.envoy.config.listener.v3.FilterChain value) {
      if (defaultFilterChainBuilder_ == null) {
        if (((bitField0_ & 0x00000080) != 0) &&
          defaultFilterChain_ != null &&
          defaultFilterChain_ != io.envoyproxy.envoy.config.listener.v3.FilterChain.getDefaultInstance()) {
          getDefaultFilterChainBuilder().mergeFrom(value);
        } else {
          defaultFilterChain_ = value;
        }
      } else {
        defaultFilterChainBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000080;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The default filter chain if none of the filter chain matches. If no default filter chain is supplied,
     * the connection will be closed. The filter chain match is ignored in this field.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.FilterChain default_filter_chain = 25;</code>
     */
    public Builder clearDefaultFilterChain() {
      bitField0_ = (bitField0_ & ~0x00000080);
      defaultFilterChain_ = null;
      if (defaultFilterChainBuilder_ != null) {
        defaultFilterChainBuilder_.dispose();
        defaultFilterChainBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The default filter chain if none of the filter chain matches. If no default filter chain is supplied,
     * the connection will be closed. The filter chain match is ignored in this field.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.FilterChain default_filter_chain = 25;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.FilterChain.Builder getDefaultFilterChainBuilder() {
      bitField0_ |= 0x00000080;
      onChanged();
      return getDefaultFilterChainFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The default filter chain if none of the filter chain matches. If no default filter chain is supplied,
     * the connection will be closed. The filter chain match is ignored in this field.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.FilterChain default_filter_chain = 25;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.FilterChainOrBuilder getDefaultFilterChainOrBuilder() {
      if (defaultFilterChainBuilder_ != null) {
        return defaultFilterChainBuilder_.getMessageOrBuilder();
      } else {
        return defaultFilterChain_ == null ?
            io.envoyproxy.envoy.config.listener.v3.FilterChain.getDefaultInstance() : defaultFilterChain_;
      }
    }
    /**
     * <pre>
     * The default filter chain if none of the filter chain matches. If no default filter chain is supplied,
     * the connection will be closed. The filter chain match is ignored in this field.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.FilterChain default_filter_chain = 25;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.listener.v3.FilterChain, io.envoyproxy.envoy.config.listener.v3.FilterChain.Builder, io.envoyproxy.envoy.config.listener.v3.FilterChainOrBuilder> 
        getDefaultFilterChainFieldBuilder() {
      if (defaultFilterChainBuilder_ == null) {
        defaultFilterChainBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.listener.v3.FilterChain, io.envoyproxy.envoy.config.listener.v3.FilterChain.Builder, io.envoyproxy.envoy.config.listener.v3.FilterChainOrBuilder>(
                getDefaultFilterChain(),
                getParentForChildren(),
                isClean());
        defaultFilterChain_ = null;
      }
      return defaultFilterChainBuilder_;
    }

    private com.google.protobuf.UInt32Value perConnectionBufferLimitBytes_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> perConnectionBufferLimitBytesBuilder_;
    /**
     * <pre>
     * Soft limit on size of the listener’s new connection read and write buffers.
     * If unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
     * @return Whether the perConnectionBufferLimitBytes field is set.
     */
    public boolean hasPerConnectionBufferLimitBytes() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Soft limit on size of the listener’s new connection read and write buffers.
     * If unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
     * @return The perConnectionBufferLimitBytes.
     */
    public com.google.protobuf.UInt32Value getPerConnectionBufferLimitBytes() {
      if (perConnectionBufferLimitBytesBuilder_ == null) {
        return perConnectionBufferLimitBytes_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : perConnectionBufferLimitBytes_;
      } else {
        return perConnectionBufferLimitBytesBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Soft limit on size of the listener’s new connection read and write buffers.
     * If unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setPerConnectionBufferLimitBytes(com.google.protobuf.UInt32Value value) {
      if (perConnectionBufferLimitBytesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        perConnectionBufferLimitBytes_ = value;
      } else {
        perConnectionBufferLimitBytesBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000100;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Soft limit on size of the listener’s new connection read and write buffers.
     * If unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setPerConnectionBufferLimitBytes(
        com.google.protobuf.UInt32Value.Builder builderForValue) {
      if (perConnectionBufferLimitBytesBuilder_ == null) {
        perConnectionBufferLimitBytes_ = builderForValue.build();
      } else {
        perConnectionBufferLimitBytesBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000100;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Soft limit on size of the listener’s new connection read and write buffers.
     * If unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder mergePerConnectionBufferLimitBytes(com.google.protobuf.UInt32Value value) {
      if (perConnectionBufferLimitBytesBuilder_ == null) {
        if (((bitField0_ & 0x00000100) != 0) &&
          perConnectionBufferLimitBytes_ != null &&
          perConnectionBufferLimitBytes_ != com.google.protobuf.UInt32Value.getDefaultInstance()) {
          getPerConnectionBufferLimitBytesBuilder().mergeFrom(value);
        } else {
          perConnectionBufferLimitBytes_ = value;
        }
      } else {
        perConnectionBufferLimitBytesBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000100;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Soft limit on size of the listener’s new connection read and write buffers.
     * If unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder clearPerConnectionBufferLimitBytes() {
      bitField0_ = (bitField0_ & ~0x00000100);
      perConnectionBufferLimitBytes_ = null;
      if (perConnectionBufferLimitBytesBuilder_ != null) {
        perConnectionBufferLimitBytesBuilder_.dispose();
        perConnectionBufferLimitBytesBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Soft limit on size of the listener’s new connection read and write buffers.
     * If unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
     */
    public com.google.protobuf.UInt32Value.Builder getPerConnectionBufferLimitBytesBuilder() {
      bitField0_ |= 0x00000100;
      onChanged();
      return getPerConnectionBufferLimitBytesFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Soft limit on size of the listener’s new connection read and write buffers.
     * If unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
     */
    public com.google.protobuf.UInt32ValueOrBuilder getPerConnectionBufferLimitBytesOrBuilder() {
      if (perConnectionBufferLimitBytesBuilder_ != null) {
        return perConnectionBufferLimitBytesBuilder_.getMessageOrBuilder();
      } else {
        return perConnectionBufferLimitBytes_ == null ?
            com.google.protobuf.UInt32Value.getDefaultInstance() : perConnectionBufferLimitBytes_;
      }
    }
    /**
     * <pre>
     * Soft limit on size of the listener’s new connection read and write buffers.
     * If unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5 [(.udpa.annotations.security) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
        getPerConnectionBufferLimitBytesFieldBuilder() {
      if (perConnectionBufferLimitBytesBuilder_ == null) {
        perConnectionBufferLimitBytesBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                getPerConnectionBufferLimitBytes(),
                getParentForChildren(),
                isClean());
        perConnectionBufferLimitBytes_ = null;
      }
      return perConnectionBufferLimitBytesBuilder_;
    }

    private io.envoyproxy.envoy.config.core.v3.Metadata metadata_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.Metadata, io.envoyproxy.envoy.config.core.v3.Metadata.Builder, io.envoyproxy.envoy.config.core.v3.MetadataOrBuilder> metadataBuilder_;
    /**
     * <pre>
     * Listener metadata.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Metadata metadata = 6;</code>
     * @return Whether the metadata field is set.
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * Listener metadata.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Metadata metadata = 6;</code>
     * @return The metadata.
     */
    public io.envoyproxy.envoy.config.core.v3.Metadata getMetadata() {
      if (metadataBuilder_ == null) {
        return metadata_ == null ? io.envoyproxy.envoy.config.core.v3.Metadata.getDefaultInstance() : metadata_;
      } else {
        return metadataBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Listener metadata.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Metadata metadata = 6;</code>
     */
    public Builder setMetadata(io.envoyproxy.envoy.config.core.v3.Metadata value) {
      if (metadataBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        metadata_ = value;
      } else {
        metadataBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000200;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Listener metadata.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Metadata metadata = 6;</code>
     */
    public Builder setMetadata(
        io.envoyproxy.envoy.config.core.v3.Metadata.Builder builderForValue) {
      if (metadataBuilder_ == null) {
        metadata_ = builderForValue.build();
      } else {
        metadataBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000200;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Listener metadata.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Metadata metadata = 6;</code>
     */
    public Builder mergeMetadata(io.envoyproxy.envoy.config.core.v3.Metadata value) {
      if (metadataBuilder_ == null) {
        if (((bitField0_ & 0x00000200) != 0) &&
          metadata_ != null &&
          metadata_ != io.envoyproxy.envoy.config.core.v3.Metadata.getDefaultInstance()) {
          getMetadataBuilder().mergeFrom(value);
        } else {
          metadata_ = value;
        }
      } else {
        metadataBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000200;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Listener metadata.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Metadata metadata = 6;</code>
     */
    public Builder clearMetadata() {
      bitField0_ = (bitField0_ & ~0x00000200);
      metadata_ = null;
      if (metadataBuilder_ != null) {
        metadataBuilder_.dispose();
        metadataBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Listener metadata.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Metadata metadata = 6;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.Metadata.Builder getMetadataBuilder() {
      bitField0_ |= 0x00000200;
      onChanged();
      return getMetadataFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Listener metadata.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Metadata metadata = 6;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.MetadataOrBuilder getMetadataOrBuilder() {
      if (metadataBuilder_ != null) {
        return metadataBuilder_.getMessageOrBuilder();
      } else {
        return metadata_ == null ?
            io.envoyproxy.envoy.config.core.v3.Metadata.getDefaultInstance() : metadata_;
      }
    }
    /**
     * <pre>
     * Listener metadata.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Metadata metadata = 6;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.Metadata, io.envoyproxy.envoy.config.core.v3.Metadata.Builder, io.envoyproxy.envoy.config.core.v3.MetadataOrBuilder> 
        getMetadataFieldBuilder() {
      if (metadataBuilder_ == null) {
        metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.Metadata, io.envoyproxy.envoy.config.core.v3.Metadata.Builder, io.envoyproxy.envoy.config.core.v3.MetadataOrBuilder>(
                getMetadata(),
                getParentForChildren(),
                isClean());
        metadata_ = null;
      }
      return metadataBuilder_;
    }

    private io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 deprecatedV1_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1, io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1.Builder, io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1OrBuilder> deprecatedV1Builder_;
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.DeprecatedV1 deprecated_v1 = 7 [deprecated = true, (.envoy.annotations.deprecated_at_minor_version) = "3.0"];</code>
     * @deprecated envoy.config.listener.v3.Listener.deprecated_v1 is deprecated.
     *     See envoy/config/listener/v3/listener.proto;l=188
     * @return Whether the deprecatedV1 field is set.
     */
    @java.lang.Deprecated public boolean hasDeprecatedV1() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.DeprecatedV1 deprecated_v1 = 7 [deprecated = true, (.envoy.annotations.deprecated_at_minor_version) = "3.0"];</code>
     * @deprecated envoy.config.listener.v3.Listener.deprecated_v1 is deprecated.
     *     See envoy/config/listener/v3/listener.proto;l=188
     * @return The deprecatedV1.
     */
    @java.lang.Deprecated public io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 getDeprecatedV1() {
      if (deprecatedV1Builder_ == null) {
        return deprecatedV1_ == null ? io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1.getDefaultInstance() : deprecatedV1_;
      } else {
        return deprecatedV1Builder_.getMessage();
      }
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.DeprecatedV1 deprecated_v1 = 7 [deprecated = true, (.envoy.annotations.deprecated_at_minor_version) = "3.0"];</code>
     */
    @java.lang.Deprecated public Builder setDeprecatedV1(io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 value) {
      if (deprecatedV1Builder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        deprecatedV1_ = value;
      } else {
        deprecatedV1Builder_.setMessage(value);
      }
      bitField0_ |= 0x00000400;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.DeprecatedV1 deprecated_v1 = 7 [deprecated = true, (.envoy.annotations.deprecated_at_minor_version) = "3.0"];</code>
     */
    @java.lang.Deprecated public Builder setDeprecatedV1(
        io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1.Builder builderForValue) {
      if (deprecatedV1Builder_ == null) {
        deprecatedV1_ = builderForValue.build();
      } else {
        deprecatedV1Builder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000400;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.DeprecatedV1 deprecated_v1 = 7 [deprecated = true, (.envoy.annotations.deprecated_at_minor_version) = "3.0"];</code>
     */
    @java.lang.Deprecated public Builder mergeDeprecatedV1(io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1 value) {
      if (deprecatedV1Builder_ == null) {
        if (((bitField0_ & 0x00000400) != 0) &&
          deprecatedV1_ != null &&
          deprecatedV1_ != io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1.getDefaultInstance()) {
          getDeprecatedV1Builder().mergeFrom(value);
        } else {
          deprecatedV1_ = value;
        }
      } else {
        deprecatedV1Builder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000400;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.DeprecatedV1 deprecated_v1 = 7 [deprecated = true, (.envoy.annotations.deprecated_at_minor_version) = "3.0"];</code>
     */
    @java.lang.Deprecated public Builder clearDeprecatedV1() {
      bitField0_ = (bitField0_ & ~0x00000400);
      deprecatedV1_ = null;
      if (deprecatedV1Builder_ != null) {
        deprecatedV1Builder_.dispose();
        deprecatedV1Builder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.DeprecatedV1 deprecated_v1 = 7 [deprecated = true, (.envoy.annotations.deprecated_at_minor_version) = "3.0"];</code>
     */
    @java.lang.Deprecated public io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1.Builder getDeprecatedV1Builder() {
      bitField0_ |= 0x00000400;
      onChanged();
      return getDeprecatedV1FieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.DeprecatedV1 deprecated_v1 = 7 [deprecated = true, (.envoy.annotations.deprecated_at_minor_version) = "3.0"];</code>
     */
    @java.lang.Deprecated public io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1OrBuilder getDeprecatedV1OrBuilder() {
      if (deprecatedV1Builder_ != null) {
        return deprecatedV1Builder_.getMessageOrBuilder();
      } else {
        return deprecatedV1_ == null ?
            io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1.getDefaultInstance() : deprecatedV1_;
      }
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.DeprecatedV1 deprecated_v1 = 7 [deprecated = true, (.envoy.annotations.deprecated_at_minor_version) = "3.0"];</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1, io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1.Builder, io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1OrBuilder> 
        getDeprecatedV1FieldBuilder() {
      if (deprecatedV1Builder_ == null) {
        deprecatedV1Builder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1, io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1.Builder, io.envoyproxy.envoy.config.listener.v3.Listener.DeprecatedV1OrBuilder>(
                getDeprecatedV1(),
                getParentForChildren(),
                isClean());
        deprecatedV1_ = null;
      }
      return deprecatedV1Builder_;
    }

    private int drainType_ = 0;
    /**
     * <pre>
     * The type of draining to perform at a listener-wide level.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.DrainType drain_type = 8;</code>
     * @return The enum numeric value on the wire for drainType.
     */
    @java.lang.Override public int getDrainTypeValue() {
      return drainType_;
    }
    /**
     * <pre>
     * The type of draining to perform at a listener-wide level.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.DrainType drain_type = 8;</code>
     * @param value The enum numeric value on the wire for drainType to set.
     * @return This builder for chaining.
     */
    public Builder setDrainTypeValue(int value) {
      drainType_ = value;
      bitField0_ |= 0x00000800;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The type of draining to perform at a listener-wide level.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.DrainType drain_type = 8;</code>
     * @return The drainType.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.listener.v3.Listener.DrainType getDrainType() {
      io.envoyproxy.envoy.config.listener.v3.Listener.DrainType result = io.envoyproxy.envoy.config.listener.v3.Listener.DrainType.forNumber(drainType_);
      return result == null ? io.envoyproxy.envoy.config.listener.v3.Listener.DrainType.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * The type of draining to perform at a listener-wide level.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.DrainType drain_type = 8;</code>
     * @param value The drainType to set.
     * @return This builder for chaining.
     */
    public Builder setDrainType(io.envoyproxy.envoy.config.listener.v3.Listener.DrainType value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000800;
      drainType_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The type of draining to perform at a listener-wide level.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.DrainType drain_type = 8;</code>
     * @return This builder for chaining.
     */
    public Builder clearDrainType() {
      bitField0_ = (bitField0_ & ~0x00000800);
      drainType_ = 0;
      onChanged();
      return this;
    }

    private java.util.List<io.envoyproxy.envoy.config.listener.v3.ListenerFilter> listenerFilters_ =
      java.util.Collections.emptyList();
    private void ensureListenerFiltersIsMutable() {
      if (!((bitField0_ & 0x00001000) != 0)) {
        listenerFilters_ = new java.util.ArrayList<io.envoyproxy.envoy.config.listener.v3.ListenerFilter>(listenerFilters_);
        bitField0_ |= 0x00001000;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.listener.v3.ListenerFilter, io.envoyproxy.envoy.config.listener.v3.ListenerFilter.Builder, io.envoyproxy.envoy.config.listener.v3.ListenerFilterOrBuilder> listenerFiltersBuilder_;

    /**
     * <pre>
     * Listener filters have the opportunity to manipulate and augment the connection metadata that
     * is used in connection filter chain matching, for example. These filters are run before any in
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
     * filters are processed sequentially right after a socket has been accepted by the listener, and
     * before a connection is created.
     * UDP Listener filters can be specified when the protocol in the listener socket address in
     * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.listener.v3.ListenerFilter> getListenerFiltersList() {
      if (listenerFiltersBuilder_ == null) {
        return java.util.Collections.unmodifiableList(listenerFilters_);
      } else {
        return listenerFiltersBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * Listener filters have the opportunity to manipulate and augment the connection metadata that
     * is used in connection filter chain matching, for example. These filters are run before any in
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
     * filters are processed sequentially right after a socket has been accepted by the listener, and
     * before a connection is created.
     * UDP Listener filters can be specified when the protocol in the listener socket address in
     * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
     */
    public int getListenerFiltersCount() {
      if (listenerFiltersBuilder_ == null) {
        return listenerFilters_.size();
      } else {
        return listenerFiltersBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * Listener filters have the opportunity to manipulate and augment the connection metadata that
     * is used in connection filter chain matching, for example. These filters are run before any in
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
     * filters are processed sequentially right after a socket has been accepted by the listener, and
     * before a connection is created.
     * UDP Listener filters can be specified when the protocol in the listener socket address in
     * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.ListenerFilter getListenerFilters(int index) {
      if (listenerFiltersBuilder_ == null) {
        return listenerFilters_.get(index);
      } else {
        return listenerFiltersBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * Listener filters have the opportunity to manipulate and augment the connection metadata that
     * is used in connection filter chain matching, for example. These filters are run before any in
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
     * filters are processed sequentially right after a socket has been accepted by the listener, and
     * before a connection is created.
     * UDP Listener filters can be specified when the protocol in the listener socket address in
     * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
     */
    public Builder setListenerFilters(
        int index, io.envoyproxy.envoy.config.listener.v3.ListenerFilter value) {
      if (listenerFiltersBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureListenerFiltersIsMutable();
        listenerFilters_.set(index, value);
        onChanged();
      } else {
        listenerFiltersBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * Listener filters have the opportunity to manipulate and augment the connection metadata that
     * is used in connection filter chain matching, for example. These filters are run before any in
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
     * filters are processed sequentially right after a socket has been accepted by the listener, and
     * before a connection is created.
     * UDP Listener filters can be specified when the protocol in the listener socket address in
     * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
     */
    public Builder setListenerFilters(
        int index, io.envoyproxy.envoy.config.listener.v3.ListenerFilter.Builder builderForValue) {
      if (listenerFiltersBuilder_ == null) {
        ensureListenerFiltersIsMutable();
        listenerFilters_.set(index, builderForValue.build());
        onChanged();
      } else {
        listenerFiltersBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Listener filters have the opportunity to manipulate and augment the connection metadata that
     * is used in connection filter chain matching, for example. These filters are run before any in
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
     * filters are processed sequentially right after a socket has been accepted by the listener, and
     * before a connection is created.
     * UDP Listener filters can be specified when the protocol in the listener socket address in
     * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
     */
    public Builder addListenerFilters(io.envoyproxy.envoy.config.listener.v3.ListenerFilter value) {
      if (listenerFiltersBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureListenerFiltersIsMutable();
        listenerFilters_.add(value);
        onChanged();
      } else {
        listenerFiltersBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * Listener filters have the opportunity to manipulate and augment the connection metadata that
     * is used in connection filter chain matching, for example. These filters are run before any in
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
     * filters are processed sequentially right after a socket has been accepted by the listener, and
     * before a connection is created.
     * UDP Listener filters can be specified when the protocol in the listener socket address in
     * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
     */
    public Builder addListenerFilters(
        int index, io.envoyproxy.envoy.config.listener.v3.ListenerFilter value) {
      if (listenerFiltersBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureListenerFiltersIsMutable();
        listenerFilters_.add(index, value);
        onChanged();
      } else {
        listenerFiltersBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * Listener filters have the opportunity to manipulate and augment the connection metadata that
     * is used in connection filter chain matching, for example. These filters are run before any in
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
     * filters are processed sequentially right after a socket has been accepted by the listener, and
     * before a connection is created.
     * UDP Listener filters can be specified when the protocol in the listener socket address in
     * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
     */
    public Builder addListenerFilters(
        io.envoyproxy.envoy.config.listener.v3.ListenerFilter.Builder builderForValue) {
      if (listenerFiltersBuilder_ == null) {
        ensureListenerFiltersIsMutable();
        listenerFilters_.add(builderForValue.build());
        onChanged();
      } else {
        listenerFiltersBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Listener filters have the opportunity to manipulate and augment the connection metadata that
     * is used in connection filter chain matching, for example. These filters are run before any in
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
     * filters are processed sequentially right after a socket has been accepted by the listener, and
     * before a connection is created.
     * UDP Listener filters can be specified when the protocol in the listener socket address in
     * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
     */
    public Builder addListenerFilters(
        int index, io.envoyproxy.envoy.config.listener.v3.ListenerFilter.Builder builderForValue) {
      if (listenerFiltersBuilder_ == null) {
        ensureListenerFiltersIsMutable();
        listenerFilters_.add(index, builderForValue.build());
        onChanged();
      } else {
        listenerFiltersBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Listener filters have the opportunity to manipulate and augment the connection metadata that
     * is used in connection filter chain matching, for example. These filters are run before any in
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
     * filters are processed sequentially right after a socket has been accepted by the listener, and
     * before a connection is created.
     * UDP Listener filters can be specified when the protocol in the listener socket address in
     * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
     */
    public Builder addAllListenerFilters(
        java.lang.Iterable<? extends io.envoyproxy.envoy.config.listener.v3.ListenerFilter> values) {
      if (listenerFiltersBuilder_ == null) {
        ensureListenerFiltersIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, listenerFilters_);
        onChanged();
      } else {
        listenerFiltersBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * Listener filters have the opportunity to manipulate and augment the connection metadata that
     * is used in connection filter chain matching, for example. These filters are run before any in
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
     * filters are processed sequentially right after a socket has been accepted by the listener, and
     * before a connection is created.
     * UDP Listener filters can be specified when the protocol in the listener socket address in
     * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
     */
    public Builder clearListenerFilters() {
      if (listenerFiltersBuilder_ == null) {
        listenerFilters_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00001000);
        onChanged();
      } else {
        listenerFiltersBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * Listener filters have the opportunity to manipulate and augment the connection metadata that
     * is used in connection filter chain matching, for example. These filters are run before any in
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
     * filters are processed sequentially right after a socket has been accepted by the listener, and
     * before a connection is created.
     * UDP Listener filters can be specified when the protocol in the listener socket address in
     * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
     */
    public Builder removeListenerFilters(int index) {
      if (listenerFiltersBuilder_ == null) {
        ensureListenerFiltersIsMutable();
        listenerFilters_.remove(index);
        onChanged();
      } else {
        listenerFiltersBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * Listener filters have the opportunity to manipulate and augment the connection metadata that
     * is used in connection filter chain matching, for example. These filters are run before any in
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
     * filters are processed sequentially right after a socket has been accepted by the listener, and
     * before a connection is created.
     * UDP Listener filters can be specified when the protocol in the listener socket address in
     * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.ListenerFilter.Builder getListenerFiltersBuilder(
        int index) {
      return getListenerFiltersFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * Listener filters have the opportunity to manipulate and augment the connection metadata that
     * is used in connection filter chain matching, for example. These filters are run before any in
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
     * filters are processed sequentially right after a socket has been accepted by the listener, and
     * before a connection is created.
     * UDP Listener filters can be specified when the protocol in the listener socket address in
     * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.ListenerFilterOrBuilder getListenerFiltersOrBuilder(
        int index) {
      if (listenerFiltersBuilder_ == null) {
        return listenerFilters_.get(index);  } else {
        return listenerFiltersBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * Listener filters have the opportunity to manipulate and augment the connection metadata that
     * is used in connection filter chain matching, for example. These filters are run before any in
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
     * filters are processed sequentially right after a socket has been accepted by the listener, and
     * before a connection is created.
     * UDP Listener filters can be specified when the protocol in the listener socket address in
     * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
     */
    public java.util.List<? extends io.envoyproxy.envoy.config.listener.v3.ListenerFilterOrBuilder> 
         getListenerFiltersOrBuilderList() {
      if (listenerFiltersBuilder_ != null) {
        return listenerFiltersBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(listenerFilters_);
      }
    }
    /**
     * <pre>
     * Listener filters have the opportunity to manipulate and augment the connection metadata that
     * is used in connection filter chain matching, for example. These filters are run before any in
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
     * filters are processed sequentially right after a socket has been accepted by the listener, and
     * before a connection is created.
     * UDP Listener filters can be specified when the protocol in the listener socket address in
     * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.ListenerFilter.Builder addListenerFiltersBuilder() {
      return getListenerFiltersFieldBuilder().addBuilder(
          io.envoyproxy.envoy.config.listener.v3.ListenerFilter.getDefaultInstance());
    }
    /**
     * <pre>
     * Listener filters have the opportunity to manipulate and augment the connection metadata that
     * is used in connection filter chain matching, for example. These filters are run before any in
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
     * filters are processed sequentially right after a socket has been accepted by the listener, and
     * before a connection is created.
     * UDP Listener filters can be specified when the protocol in the listener socket address in
     * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.ListenerFilter.Builder addListenerFiltersBuilder(
        int index) {
      return getListenerFiltersFieldBuilder().addBuilder(
          index, io.envoyproxy.envoy.config.listener.v3.ListenerFilter.getDefaultInstance());
    }
    /**
     * <pre>
     * Listener filters have the opportunity to manipulate and augment the connection metadata that
     * is used in connection filter chain matching, for example. These filters are run before any in
     * :ref:`filter_chains &lt;envoy_v3_api_field_config.listener.v3.Listener.filter_chains&gt;`. Order matters as the
     * filters are processed sequentially right after a socket has been accepted by the listener, and
     * before a connection is created.
     * UDP Listener filters can be specified when the protocol in the listener socket address in
     * :ref:`protocol &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.listener.v3.ListenerFilter listener_filters = 9;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.listener.v3.ListenerFilter.Builder> 
         getListenerFiltersBuilderList() {
      return getListenerFiltersFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.listener.v3.ListenerFilter, io.envoyproxy.envoy.config.listener.v3.ListenerFilter.Builder, io.envoyproxy.envoy.config.listener.v3.ListenerFilterOrBuilder> 
        getListenerFiltersFieldBuilder() {
      if (listenerFiltersBuilder_ == null) {
        listenerFiltersBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.envoyproxy.envoy.config.listener.v3.ListenerFilter, io.envoyproxy.envoy.config.listener.v3.ListenerFilter.Builder, io.envoyproxy.envoy.config.listener.v3.ListenerFilterOrBuilder>(
                listenerFilters_,
                ((bitField0_ & 0x00001000) != 0),
                getParentForChildren(),
                isClean());
        listenerFilters_ = null;
      }
      return listenerFiltersBuilder_;
    }

    private com.google.protobuf.Duration listenerFiltersTimeout_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> listenerFiltersTimeoutBuilder_;
    /**
     * <pre>
     * The timeout to wait for all listener filters to complete operation. If the timeout is reached,
     * the accepted socket is closed without a connection being created unless
     * ``continue_on_listener_filters_timeout`` is set to true. Specify 0 to disable the
     * timeout. If not specified, a default timeout of 15s is used.
     * </pre>
     *
     * <code>.google.protobuf.Duration listener_filters_timeout = 15;</code>
     * @return Whether the listenerFiltersTimeout field is set.
     */
    public boolean hasListenerFiltersTimeout() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * The timeout to wait for all listener filters to complete operation. If the timeout is reached,
     * the accepted socket is closed without a connection being created unless
     * ``continue_on_listener_filters_timeout`` is set to true. Specify 0 to disable the
     * timeout. If not specified, a default timeout of 15s is used.
     * </pre>
     *
     * <code>.google.protobuf.Duration listener_filters_timeout = 15;</code>
     * @return The listenerFiltersTimeout.
     */
    public com.google.protobuf.Duration getListenerFiltersTimeout() {
      if (listenerFiltersTimeoutBuilder_ == null) {
        return listenerFiltersTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : listenerFiltersTimeout_;
      } else {
        return listenerFiltersTimeoutBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The timeout to wait for all listener filters to complete operation. If the timeout is reached,
     * the accepted socket is closed without a connection being created unless
     * ``continue_on_listener_filters_timeout`` is set to true. Specify 0 to disable the
     * timeout. If not specified, a default timeout of 15s is used.
     * </pre>
     *
     * <code>.google.protobuf.Duration listener_filters_timeout = 15;</code>
     */
    public Builder setListenerFiltersTimeout(com.google.protobuf.Duration value) {
      if (listenerFiltersTimeoutBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        listenerFiltersTimeout_ = value;
      } else {
        listenerFiltersTimeoutBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00002000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The timeout to wait for all listener filters to complete operation. If the timeout is reached,
     * the accepted socket is closed without a connection being created unless
     * ``continue_on_listener_filters_timeout`` is set to true. Specify 0 to disable the
     * timeout. If not specified, a default timeout of 15s is used.
     * </pre>
     *
     * <code>.google.protobuf.Duration listener_filters_timeout = 15;</code>
     */
    public Builder setListenerFiltersTimeout(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (listenerFiltersTimeoutBuilder_ == null) {
        listenerFiltersTimeout_ = builderForValue.build();
      } else {
        listenerFiltersTimeoutBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00002000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The timeout to wait for all listener filters to complete operation. If the timeout is reached,
     * the accepted socket is closed without a connection being created unless
     * ``continue_on_listener_filters_timeout`` is set to true. Specify 0 to disable the
     * timeout. If not specified, a default timeout of 15s is used.
     * </pre>
     *
     * <code>.google.protobuf.Duration listener_filters_timeout = 15;</code>
     */
    public Builder mergeListenerFiltersTimeout(com.google.protobuf.Duration value) {
      if (listenerFiltersTimeoutBuilder_ == null) {
        if (((bitField0_ & 0x00002000) != 0) &&
          listenerFiltersTimeout_ != null &&
          listenerFiltersTimeout_ != com.google.protobuf.Duration.getDefaultInstance()) {
          getListenerFiltersTimeoutBuilder().mergeFrom(value);
        } else {
          listenerFiltersTimeout_ = value;
        }
      } else {
        listenerFiltersTimeoutBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00002000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The timeout to wait for all listener filters to complete operation. If the timeout is reached,
     * the accepted socket is closed without a connection being created unless
     * ``continue_on_listener_filters_timeout`` is set to true. Specify 0 to disable the
     * timeout. If not specified, a default timeout of 15s is used.
     * </pre>
     *
     * <code>.google.protobuf.Duration listener_filters_timeout = 15;</code>
     */
    public Builder clearListenerFiltersTimeout() {
      bitField0_ = (bitField0_ & ~0x00002000);
      listenerFiltersTimeout_ = null;
      if (listenerFiltersTimeoutBuilder_ != null) {
        listenerFiltersTimeoutBuilder_.dispose();
        listenerFiltersTimeoutBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The timeout to wait for all listener filters to complete operation. If the timeout is reached,
     * the accepted socket is closed without a connection being created unless
     * ``continue_on_listener_filters_timeout`` is set to true. Specify 0 to disable the
     * timeout. If not specified, a default timeout of 15s is used.
     * </pre>
     *
     * <code>.google.protobuf.Duration listener_filters_timeout = 15;</code>
     */
    public com.google.protobuf.Duration.Builder getListenerFiltersTimeoutBuilder() {
      bitField0_ |= 0x00002000;
      onChanged();
      return getListenerFiltersTimeoutFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The timeout to wait for all listener filters to complete operation. If the timeout is reached,
     * the accepted socket is closed without a connection being created unless
     * ``continue_on_listener_filters_timeout`` is set to true. Specify 0 to disable the
     * timeout. If not specified, a default timeout of 15s is used.
     * </pre>
     *
     * <code>.google.protobuf.Duration listener_filters_timeout = 15;</code>
     */
    public com.google.protobuf.DurationOrBuilder getListenerFiltersTimeoutOrBuilder() {
      if (listenerFiltersTimeoutBuilder_ != null) {
        return listenerFiltersTimeoutBuilder_.getMessageOrBuilder();
      } else {
        return listenerFiltersTimeout_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : listenerFiltersTimeout_;
      }
    }
    /**
     * <pre>
     * The timeout to wait for all listener filters to complete operation. If the timeout is reached,
     * the accepted socket is closed without a connection being created unless
     * ``continue_on_listener_filters_timeout`` is set to true. Specify 0 to disable the
     * timeout. If not specified, a default timeout of 15s is used.
     * </pre>
     *
     * <code>.google.protobuf.Duration listener_filters_timeout = 15;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getListenerFiltersTimeoutFieldBuilder() {
      if (listenerFiltersTimeoutBuilder_ == null) {
        listenerFiltersTimeoutBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getListenerFiltersTimeout(),
                getParentForChildren(),
                isClean());
        listenerFiltersTimeout_ = null;
      }
      return listenerFiltersTimeoutBuilder_;
    }

    private boolean continueOnListenerFiltersTimeout_ ;
    /**
     * <pre>
     * Whether a connection should be created when listener filters timeout. Default is false.
     * .. attention::
     *   Some listener filters, such as :ref:`Proxy Protocol filter
     *   &lt;config_listener_filters_proxy_protocol&gt;`, should not be used with this option. It will cause
     *   unexpected behavior when a connection is created.
     * </pre>
     *
     * <code>bool continue_on_listener_filters_timeout = 17;</code>
     * @return The continueOnListenerFiltersTimeout.
     */
    @java.lang.Override
    public boolean getContinueOnListenerFiltersTimeout() {
      return continueOnListenerFiltersTimeout_;
    }
    /**
     * <pre>
     * Whether a connection should be created when listener filters timeout. Default is false.
     * .. attention::
     *   Some listener filters, such as :ref:`Proxy Protocol filter
     *   &lt;config_listener_filters_proxy_protocol&gt;`, should not be used with this option. It will cause
     *   unexpected behavior when a connection is created.
     * </pre>
     *
     * <code>bool continue_on_listener_filters_timeout = 17;</code>
     * @param value The continueOnListenerFiltersTimeout to set.
     * @return This builder for chaining.
     */
    public Builder setContinueOnListenerFiltersTimeout(boolean value) {
      
      continueOnListenerFiltersTimeout_ = value;
      bitField0_ |= 0x00004000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether a connection should be created when listener filters timeout. Default is false.
     * .. attention::
     *   Some listener filters, such as :ref:`Proxy Protocol filter
     *   &lt;config_listener_filters_proxy_protocol&gt;`, should not be used with this option. It will cause
     *   unexpected behavior when a connection is created.
     * </pre>
     *
     * <code>bool continue_on_listener_filters_timeout = 17;</code>
     * @return This builder for chaining.
     */
    public Builder clearContinueOnListenerFiltersTimeout() {
      bitField0_ = (bitField0_ & ~0x00004000);
      continueOnListenerFiltersTimeout_ = false;
      onChanged();
      return this;
    }

    private com.google.protobuf.BoolValue transparent_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> transparentBuilder_;
    /**
     * <pre>
     * Whether the listener should be set as a transparent socket.
     * When this flag is set to true, connections can be redirected to the listener using an
     * ``iptables`` ``TPROXY`` target, in which case the original source and destination addresses and
     * ports are preserved on accepted connections. This flag should be used in combination with
     * :ref:`an original_dst &lt;config_listener_filters_original_dst&gt;` :ref:`listener filter
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.listener_filters&gt;` to mark the connections' local addresses as
     * "restored." This can be used to hand off each redirected connection to another listener
     * associated with the connection's destination address. Direct connections to the socket without
     * using ``TPROXY`` cannot be distinguished from connections redirected using ``TPROXY`` and are
     * therefore treated as if they were redirected.
     * When this flag is set to false, the listener's socket is explicitly reset as non-transparent.
     * Setting this flag requires Envoy to run with the ``CAP_NET_ADMIN`` capability.
     * When this flag is not set (default), the socket is not modified, i.e. the transparent option
     * is neither set nor reset.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue transparent = 10;</code>
     * @return Whether the transparent field is set.
     */
    public boolean hasTransparent() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     * <pre>
     * Whether the listener should be set as a transparent socket.
     * When this flag is set to true, connections can be redirected to the listener using an
     * ``iptables`` ``TPROXY`` target, in which case the original source and destination addresses and
     * ports are preserved on accepted connections. This flag should be used in combination with
     * :ref:`an original_dst &lt;config_listener_filters_original_dst&gt;` :ref:`listener filter
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.listener_filters&gt;` to mark the connections' local addresses as
     * "restored." This can be used to hand off each redirected connection to another listener
     * associated with the connection's destination address. Direct connections to the socket without
     * using ``TPROXY`` cannot be distinguished from connections redirected using ``TPROXY`` and are
     * therefore treated as if they were redirected.
     * When this flag is set to false, the listener's socket is explicitly reset as non-transparent.
     * Setting this flag requires Envoy to run with the ``CAP_NET_ADMIN`` capability.
     * When this flag is not set (default), the socket is not modified, i.e. the transparent option
     * is neither set nor reset.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue transparent = 10;</code>
     * @return The transparent.
     */
    public com.google.protobuf.BoolValue getTransparent() {
      if (transparentBuilder_ == null) {
        return transparent_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : transparent_;
      } else {
        return transparentBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Whether the listener should be set as a transparent socket.
     * When this flag is set to true, connections can be redirected to the listener using an
     * ``iptables`` ``TPROXY`` target, in which case the original source and destination addresses and
     * ports are preserved on accepted connections. This flag should be used in combination with
     * :ref:`an original_dst &lt;config_listener_filters_original_dst&gt;` :ref:`listener filter
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.listener_filters&gt;` to mark the connections' local addresses as
     * "restored." This can be used to hand off each redirected connection to another listener
     * associated with the connection's destination address. Direct connections to the socket without
     * using ``TPROXY`` cannot be distinguished from connections redirected using ``TPROXY`` and are
     * therefore treated as if they were redirected.
     * When this flag is set to false, the listener's socket is explicitly reset as non-transparent.
     * Setting this flag requires Envoy to run with the ``CAP_NET_ADMIN`` capability.
     * When this flag is not set (default), the socket is not modified, i.e. the transparent option
     * is neither set nor reset.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue transparent = 10;</code>
     */
    public Builder setTransparent(com.google.protobuf.BoolValue value) {
      if (transparentBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        transparent_ = value;
      } else {
        transparentBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00008000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the listener should be set as a transparent socket.
     * When this flag is set to true, connections can be redirected to the listener using an
     * ``iptables`` ``TPROXY`` target, in which case the original source and destination addresses and
     * ports are preserved on accepted connections. This flag should be used in combination with
     * :ref:`an original_dst &lt;config_listener_filters_original_dst&gt;` :ref:`listener filter
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.listener_filters&gt;` to mark the connections' local addresses as
     * "restored." This can be used to hand off each redirected connection to another listener
     * associated with the connection's destination address. Direct connections to the socket without
     * using ``TPROXY`` cannot be distinguished from connections redirected using ``TPROXY`` and are
     * therefore treated as if they were redirected.
     * When this flag is set to false, the listener's socket is explicitly reset as non-transparent.
     * Setting this flag requires Envoy to run with the ``CAP_NET_ADMIN`` capability.
     * When this flag is not set (default), the socket is not modified, i.e. the transparent option
     * is neither set nor reset.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue transparent = 10;</code>
     */
    public Builder setTransparent(
        com.google.protobuf.BoolValue.Builder builderForValue) {
      if (transparentBuilder_ == null) {
        transparent_ = builderForValue.build();
      } else {
        transparentBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00008000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the listener should be set as a transparent socket.
     * When this flag is set to true, connections can be redirected to the listener using an
     * ``iptables`` ``TPROXY`` target, in which case the original source and destination addresses and
     * ports are preserved on accepted connections. This flag should be used in combination with
     * :ref:`an original_dst &lt;config_listener_filters_original_dst&gt;` :ref:`listener filter
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.listener_filters&gt;` to mark the connections' local addresses as
     * "restored." This can be used to hand off each redirected connection to another listener
     * associated with the connection's destination address. Direct connections to the socket without
     * using ``TPROXY`` cannot be distinguished from connections redirected using ``TPROXY`` and are
     * therefore treated as if they were redirected.
     * When this flag is set to false, the listener's socket is explicitly reset as non-transparent.
     * Setting this flag requires Envoy to run with the ``CAP_NET_ADMIN`` capability.
     * When this flag is not set (default), the socket is not modified, i.e. the transparent option
     * is neither set nor reset.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue transparent = 10;</code>
     */
    public Builder mergeTransparent(com.google.protobuf.BoolValue value) {
      if (transparentBuilder_ == null) {
        if (((bitField0_ & 0x00008000) != 0) &&
          transparent_ != null &&
          transparent_ != com.google.protobuf.BoolValue.getDefaultInstance()) {
          getTransparentBuilder().mergeFrom(value);
        } else {
          transparent_ = value;
        }
      } else {
        transparentBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00008000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the listener should be set as a transparent socket.
     * When this flag is set to true, connections can be redirected to the listener using an
     * ``iptables`` ``TPROXY`` target, in which case the original source and destination addresses and
     * ports are preserved on accepted connections. This flag should be used in combination with
     * :ref:`an original_dst &lt;config_listener_filters_original_dst&gt;` :ref:`listener filter
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.listener_filters&gt;` to mark the connections' local addresses as
     * "restored." This can be used to hand off each redirected connection to another listener
     * associated with the connection's destination address. Direct connections to the socket without
     * using ``TPROXY`` cannot be distinguished from connections redirected using ``TPROXY`` and are
     * therefore treated as if they were redirected.
     * When this flag is set to false, the listener's socket is explicitly reset as non-transparent.
     * Setting this flag requires Envoy to run with the ``CAP_NET_ADMIN`` capability.
     * When this flag is not set (default), the socket is not modified, i.e. the transparent option
     * is neither set nor reset.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue transparent = 10;</code>
     */
    public Builder clearTransparent() {
      bitField0_ = (bitField0_ & ~0x00008000);
      transparent_ = null;
      if (transparentBuilder_ != null) {
        transparentBuilder_.dispose();
        transparentBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the listener should be set as a transparent socket.
     * When this flag is set to true, connections can be redirected to the listener using an
     * ``iptables`` ``TPROXY`` target, in which case the original source and destination addresses and
     * ports are preserved on accepted connections. This flag should be used in combination with
     * :ref:`an original_dst &lt;config_listener_filters_original_dst&gt;` :ref:`listener filter
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.listener_filters&gt;` to mark the connections' local addresses as
     * "restored." This can be used to hand off each redirected connection to another listener
     * associated with the connection's destination address. Direct connections to the socket without
     * using ``TPROXY`` cannot be distinguished from connections redirected using ``TPROXY`` and are
     * therefore treated as if they were redirected.
     * When this flag is set to false, the listener's socket is explicitly reset as non-transparent.
     * Setting this flag requires Envoy to run with the ``CAP_NET_ADMIN`` capability.
     * When this flag is not set (default), the socket is not modified, i.e. the transparent option
     * is neither set nor reset.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue transparent = 10;</code>
     */
    public com.google.protobuf.BoolValue.Builder getTransparentBuilder() {
      bitField0_ |= 0x00008000;
      onChanged();
      return getTransparentFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Whether the listener should be set as a transparent socket.
     * When this flag is set to true, connections can be redirected to the listener using an
     * ``iptables`` ``TPROXY`` target, in which case the original source and destination addresses and
     * ports are preserved on accepted connections. This flag should be used in combination with
     * :ref:`an original_dst &lt;config_listener_filters_original_dst&gt;` :ref:`listener filter
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.listener_filters&gt;` to mark the connections' local addresses as
     * "restored." This can be used to hand off each redirected connection to another listener
     * associated with the connection's destination address. Direct connections to the socket without
     * using ``TPROXY`` cannot be distinguished from connections redirected using ``TPROXY`` and are
     * therefore treated as if they were redirected.
     * When this flag is set to false, the listener's socket is explicitly reset as non-transparent.
     * Setting this flag requires Envoy to run with the ``CAP_NET_ADMIN`` capability.
     * When this flag is not set (default), the socket is not modified, i.e. the transparent option
     * is neither set nor reset.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue transparent = 10;</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getTransparentOrBuilder() {
      if (transparentBuilder_ != null) {
        return transparentBuilder_.getMessageOrBuilder();
      } else {
        return transparent_ == null ?
            com.google.protobuf.BoolValue.getDefaultInstance() : transparent_;
      }
    }
    /**
     * <pre>
     * Whether the listener should be set as a transparent socket.
     * When this flag is set to true, connections can be redirected to the listener using an
     * ``iptables`` ``TPROXY`` target, in which case the original source and destination addresses and
     * ports are preserved on accepted connections. This flag should be used in combination with
     * :ref:`an original_dst &lt;config_listener_filters_original_dst&gt;` :ref:`listener filter
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.listener_filters&gt;` to mark the connections' local addresses as
     * "restored." This can be used to hand off each redirected connection to another listener
     * associated with the connection's destination address. Direct connections to the socket without
     * using ``TPROXY`` cannot be distinguished from connections redirected using ``TPROXY`` and are
     * therefore treated as if they were redirected.
     * When this flag is set to false, the listener's socket is explicitly reset as non-transparent.
     * Setting this flag requires Envoy to run with the ``CAP_NET_ADMIN`` capability.
     * When this flag is not set (default), the socket is not modified, i.e. the transparent option
     * is neither set nor reset.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue transparent = 10;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
        getTransparentFieldBuilder() {
      if (transparentBuilder_ == null) {
        transparentBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                getTransparent(),
                getParentForChildren(),
                isClean());
        transparent_ = null;
      }
      return transparentBuilder_;
    }

    private com.google.protobuf.BoolValue freebind_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> freebindBuilder_;
    /**
     * <pre>
     * Whether the listener should set the ``IP_FREEBIND`` socket option. When this
     * flag is set to true, listeners can be bound to an IP address that is not
     * configured on the system running Envoy. When this flag is set to false, the
     * option ``IP_FREEBIND`` is disabled on the socket. When this flag is not set
     * (default), the socket is not modified, i.e. the option is neither enabled
     * nor disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue freebind = 11;</code>
     * @return Whether the freebind field is set.
     */
    public boolean hasFreebind() {
      return ((bitField0_ & 0x00010000) != 0);
    }
    /**
     * <pre>
     * Whether the listener should set the ``IP_FREEBIND`` socket option. When this
     * flag is set to true, listeners can be bound to an IP address that is not
     * configured on the system running Envoy. When this flag is set to false, the
     * option ``IP_FREEBIND`` is disabled on the socket. When this flag is not set
     * (default), the socket is not modified, i.e. the option is neither enabled
     * nor disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue freebind = 11;</code>
     * @return The freebind.
     */
    public com.google.protobuf.BoolValue getFreebind() {
      if (freebindBuilder_ == null) {
        return freebind_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : freebind_;
      } else {
        return freebindBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Whether the listener should set the ``IP_FREEBIND`` socket option. When this
     * flag is set to true, listeners can be bound to an IP address that is not
     * configured on the system running Envoy. When this flag is set to false, the
     * option ``IP_FREEBIND`` is disabled on the socket. When this flag is not set
     * (default), the socket is not modified, i.e. the option is neither enabled
     * nor disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue freebind = 11;</code>
     */
    public Builder setFreebind(com.google.protobuf.BoolValue value) {
      if (freebindBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        freebind_ = value;
      } else {
        freebindBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00010000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the listener should set the ``IP_FREEBIND`` socket option. When this
     * flag is set to true, listeners can be bound to an IP address that is not
     * configured on the system running Envoy. When this flag is set to false, the
     * option ``IP_FREEBIND`` is disabled on the socket. When this flag is not set
     * (default), the socket is not modified, i.e. the option is neither enabled
     * nor disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue freebind = 11;</code>
     */
    public Builder setFreebind(
        com.google.protobuf.BoolValue.Builder builderForValue) {
      if (freebindBuilder_ == null) {
        freebind_ = builderForValue.build();
      } else {
        freebindBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00010000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the listener should set the ``IP_FREEBIND`` socket option. When this
     * flag is set to true, listeners can be bound to an IP address that is not
     * configured on the system running Envoy. When this flag is set to false, the
     * option ``IP_FREEBIND`` is disabled on the socket. When this flag is not set
     * (default), the socket is not modified, i.e. the option is neither enabled
     * nor disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue freebind = 11;</code>
     */
    public Builder mergeFreebind(com.google.protobuf.BoolValue value) {
      if (freebindBuilder_ == null) {
        if (((bitField0_ & 0x00010000) != 0) &&
          freebind_ != null &&
          freebind_ != com.google.protobuf.BoolValue.getDefaultInstance()) {
          getFreebindBuilder().mergeFrom(value);
        } else {
          freebind_ = value;
        }
      } else {
        freebindBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00010000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the listener should set the ``IP_FREEBIND`` socket option. When this
     * flag is set to true, listeners can be bound to an IP address that is not
     * configured on the system running Envoy. When this flag is set to false, the
     * option ``IP_FREEBIND`` is disabled on the socket. When this flag is not set
     * (default), the socket is not modified, i.e. the option is neither enabled
     * nor disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue freebind = 11;</code>
     */
    public Builder clearFreebind() {
      bitField0_ = (bitField0_ & ~0x00010000);
      freebind_ = null;
      if (freebindBuilder_ != null) {
        freebindBuilder_.dispose();
        freebindBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the listener should set the ``IP_FREEBIND`` socket option. When this
     * flag is set to true, listeners can be bound to an IP address that is not
     * configured on the system running Envoy. When this flag is set to false, the
     * option ``IP_FREEBIND`` is disabled on the socket. When this flag is not set
     * (default), the socket is not modified, i.e. the option is neither enabled
     * nor disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue freebind = 11;</code>
     */
    public com.google.protobuf.BoolValue.Builder getFreebindBuilder() {
      bitField0_ |= 0x00010000;
      onChanged();
      return getFreebindFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Whether the listener should set the ``IP_FREEBIND`` socket option. When this
     * flag is set to true, listeners can be bound to an IP address that is not
     * configured on the system running Envoy. When this flag is set to false, the
     * option ``IP_FREEBIND`` is disabled on the socket. When this flag is not set
     * (default), the socket is not modified, i.e. the option is neither enabled
     * nor disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue freebind = 11;</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getFreebindOrBuilder() {
      if (freebindBuilder_ != null) {
        return freebindBuilder_.getMessageOrBuilder();
      } else {
        return freebind_ == null ?
            com.google.protobuf.BoolValue.getDefaultInstance() : freebind_;
      }
    }
    /**
     * <pre>
     * Whether the listener should set the ``IP_FREEBIND`` socket option. When this
     * flag is set to true, listeners can be bound to an IP address that is not
     * configured on the system running Envoy. When this flag is set to false, the
     * option ``IP_FREEBIND`` is disabled on the socket. When this flag is not set
     * (default), the socket is not modified, i.e. the option is neither enabled
     * nor disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue freebind = 11;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
        getFreebindFieldBuilder() {
      if (freebindBuilder_ == null) {
        freebindBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                getFreebind(),
                getParentForChildren(),
                isClean());
        freebind_ = null;
      }
      return freebindBuilder_;
    }

    private java.util.List<io.envoyproxy.envoy.config.core.v3.SocketOption> socketOptions_ =
      java.util.Collections.emptyList();
    private void ensureSocketOptionsIsMutable() {
      if (!((bitField0_ & 0x00020000) != 0)) {
        socketOptions_ = new java.util.ArrayList<io.envoyproxy.envoy.config.core.v3.SocketOption>(socketOptions_);
        bitField0_ |= 0x00020000;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.SocketOption, io.envoyproxy.envoy.config.core.v3.SocketOption.Builder, io.envoyproxy.envoy.config.core.v3.SocketOptionOrBuilder> socketOptionsBuilder_;

    /**
     * <pre>
     * Additional socket options that may not be present in Envoy source code or
     * precompiled binaries. The socket options can be updated for a listener when
     * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
     * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
     * to make it clear that the options were not updated.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.core.v3.SocketOption> getSocketOptionsList() {
      if (socketOptionsBuilder_ == null) {
        return java.util.Collections.unmodifiableList(socketOptions_);
      } else {
        return socketOptionsBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * Additional socket options that may not be present in Envoy source code or
     * precompiled binaries. The socket options can be updated for a listener when
     * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
     * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
     * to make it clear that the options were not updated.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
     */
    public int getSocketOptionsCount() {
      if (socketOptionsBuilder_ == null) {
        return socketOptions_.size();
      } else {
        return socketOptionsBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * Additional socket options that may not be present in Envoy source code or
     * precompiled binaries. The socket options can be updated for a listener when
     * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
     * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
     * to make it clear that the options were not updated.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.SocketOption getSocketOptions(int index) {
      if (socketOptionsBuilder_ == null) {
        return socketOptions_.get(index);
      } else {
        return socketOptionsBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * Additional socket options that may not be present in Envoy source code or
     * precompiled binaries. The socket options can be updated for a listener when
     * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
     * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
     * to make it clear that the options were not updated.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
     */
    public Builder setSocketOptions(
        int index, io.envoyproxy.envoy.config.core.v3.SocketOption value) {
      if (socketOptionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureSocketOptionsIsMutable();
        socketOptions_.set(index, value);
        onChanged();
      } else {
        socketOptionsBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * Additional socket options that may not be present in Envoy source code or
     * precompiled binaries. The socket options can be updated for a listener when
     * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
     * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
     * to make it clear that the options were not updated.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
     */
    public Builder setSocketOptions(
        int index, io.envoyproxy.envoy.config.core.v3.SocketOption.Builder builderForValue) {
      if (socketOptionsBuilder_ == null) {
        ensureSocketOptionsIsMutable();
        socketOptions_.set(index, builderForValue.build());
        onChanged();
      } else {
        socketOptionsBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Additional socket options that may not be present in Envoy source code or
     * precompiled binaries. The socket options can be updated for a listener when
     * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
     * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
     * to make it clear that the options were not updated.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
     */
    public Builder addSocketOptions(io.envoyproxy.envoy.config.core.v3.SocketOption value) {
      if (socketOptionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureSocketOptionsIsMutable();
        socketOptions_.add(value);
        onChanged();
      } else {
        socketOptionsBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * Additional socket options that may not be present in Envoy source code or
     * precompiled binaries. The socket options can be updated for a listener when
     * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
     * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
     * to make it clear that the options were not updated.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
     */
    public Builder addSocketOptions(
        int index, io.envoyproxy.envoy.config.core.v3.SocketOption value) {
      if (socketOptionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureSocketOptionsIsMutable();
        socketOptions_.add(index, value);
        onChanged();
      } else {
        socketOptionsBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * Additional socket options that may not be present in Envoy source code or
     * precompiled binaries. The socket options can be updated for a listener when
     * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
     * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
     * to make it clear that the options were not updated.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
     */
    public Builder addSocketOptions(
        io.envoyproxy.envoy.config.core.v3.SocketOption.Builder builderForValue) {
      if (socketOptionsBuilder_ == null) {
        ensureSocketOptionsIsMutable();
        socketOptions_.add(builderForValue.build());
        onChanged();
      } else {
        socketOptionsBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Additional socket options that may not be present in Envoy source code or
     * precompiled binaries. The socket options can be updated for a listener when
     * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
     * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
     * to make it clear that the options were not updated.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
     */
    public Builder addSocketOptions(
        int index, io.envoyproxy.envoy.config.core.v3.SocketOption.Builder builderForValue) {
      if (socketOptionsBuilder_ == null) {
        ensureSocketOptionsIsMutable();
        socketOptions_.add(index, builderForValue.build());
        onChanged();
      } else {
        socketOptionsBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Additional socket options that may not be present in Envoy source code or
     * precompiled binaries. The socket options can be updated for a listener when
     * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
     * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
     * to make it clear that the options were not updated.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
     */
    public Builder addAllSocketOptions(
        java.lang.Iterable<? extends io.envoyproxy.envoy.config.core.v3.SocketOption> values) {
      if (socketOptionsBuilder_ == null) {
        ensureSocketOptionsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, socketOptions_);
        onChanged();
      } else {
        socketOptionsBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * Additional socket options that may not be present in Envoy source code or
     * precompiled binaries. The socket options can be updated for a listener when
     * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
     * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
     * to make it clear that the options were not updated.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
     */
    public Builder clearSocketOptions() {
      if (socketOptionsBuilder_ == null) {
        socketOptions_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00020000);
        onChanged();
      } else {
        socketOptionsBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * Additional socket options that may not be present in Envoy source code or
     * precompiled binaries. The socket options can be updated for a listener when
     * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
     * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
     * to make it clear that the options were not updated.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
     */
    public Builder removeSocketOptions(int index) {
      if (socketOptionsBuilder_ == null) {
        ensureSocketOptionsIsMutable();
        socketOptions_.remove(index);
        onChanged();
      } else {
        socketOptionsBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * Additional socket options that may not be present in Envoy source code or
     * precompiled binaries. The socket options can be updated for a listener when
     * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
     * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
     * to make it clear that the options were not updated.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.SocketOption.Builder getSocketOptionsBuilder(
        int index) {
      return getSocketOptionsFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * Additional socket options that may not be present in Envoy source code or
     * precompiled binaries. The socket options can be updated for a listener when
     * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
     * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
     * to make it clear that the options were not updated.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.SocketOptionOrBuilder getSocketOptionsOrBuilder(
        int index) {
      if (socketOptionsBuilder_ == null) {
        return socketOptions_.get(index);  } else {
        return socketOptionsBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * Additional socket options that may not be present in Envoy source code or
     * precompiled binaries. The socket options can be updated for a listener when
     * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
     * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
     * to make it clear that the options were not updated.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
     */
    public java.util.List<? extends io.envoyproxy.envoy.config.core.v3.SocketOptionOrBuilder> 
         getSocketOptionsOrBuilderList() {
      if (socketOptionsBuilder_ != null) {
        return socketOptionsBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(socketOptions_);
      }
    }
    /**
     * <pre>
     * Additional socket options that may not be present in Envoy source code or
     * precompiled binaries. The socket options can be updated for a listener when
     * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
     * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
     * to make it clear that the options were not updated.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.SocketOption.Builder addSocketOptionsBuilder() {
      return getSocketOptionsFieldBuilder().addBuilder(
          io.envoyproxy.envoy.config.core.v3.SocketOption.getDefaultInstance());
    }
    /**
     * <pre>
     * Additional socket options that may not be present in Envoy source code or
     * precompiled binaries. The socket options can be updated for a listener when
     * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
     * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
     * to make it clear that the options were not updated.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.SocketOption.Builder addSocketOptionsBuilder(
        int index) {
      return getSocketOptionsFieldBuilder().addBuilder(
          index, io.envoyproxy.envoy.config.core.v3.SocketOption.getDefaultInstance());
    }
    /**
     * <pre>
     * Additional socket options that may not be present in Envoy source code or
     * precompiled binaries. The socket options can be updated for a listener when
     * :ref:`enable_reuse_port &lt;envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port&gt;`
     * is `true`. Otherwise, if socket options change during a listener update the update will be rejected
     * to make it clear that the options were not updated.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.SocketOption socket_options = 13;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.core.v3.SocketOption.Builder> 
         getSocketOptionsBuilderList() {
      return getSocketOptionsFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.SocketOption, io.envoyproxy.envoy.config.core.v3.SocketOption.Builder, io.envoyproxy.envoy.config.core.v3.SocketOptionOrBuilder> 
        getSocketOptionsFieldBuilder() {
      if (socketOptionsBuilder_ == null) {
        socketOptionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.SocketOption, io.envoyproxy.envoy.config.core.v3.SocketOption.Builder, io.envoyproxy.envoy.config.core.v3.SocketOptionOrBuilder>(
                socketOptions_,
                ((bitField0_ & 0x00020000) != 0),
                getParentForChildren(),
                isClean());
        socketOptions_ = null;
      }
      return socketOptionsBuilder_;
    }

    private com.google.protobuf.UInt32Value tcpFastOpenQueueLength_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> tcpFastOpenQueueLengthBuilder_;
    /**
     * <pre>
     * Whether the listener should accept TCP Fast Open (TFO) connections.
     * When this flag is set to a value greater than 0, the option TCP_FASTOPEN is enabled on
     * the socket, with a queue length of the specified size
     * (see `details in RFC7413 &lt;https://tools.ietf.org/html/rfc7413#section-5.1&gt;`_).
     * When this flag is set to 0, the option TCP_FASTOPEN is disabled on the socket.
     * When this flag is not set (default), the socket is not modified,
     * i.e. the option is neither enabled nor disabled.
     * On Linux, the net.ipv4.tcp_fastopen kernel parameter must include flag 0x2 to enable
     * TCP_FASTOPEN.
     * See `ip-sysctl.txt &lt;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt&gt;`_.
     * On macOS, only values of 0, 1, and unset are valid; other values may result in an error.
     * To set the queue length on macOS, set the net.inet.tcp.fastopen_backlog kernel parameter.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value tcp_fast_open_queue_length = 12;</code>
     * @return Whether the tcpFastOpenQueueLength field is set.
     */
    public boolean hasTcpFastOpenQueueLength() {
      return ((bitField0_ & 0x00040000) != 0);
    }
    /**
     * <pre>
     * Whether the listener should accept TCP Fast Open (TFO) connections.
     * When this flag is set to a value greater than 0, the option TCP_FASTOPEN is enabled on
     * the socket, with a queue length of the specified size
     * (see `details in RFC7413 &lt;https://tools.ietf.org/html/rfc7413#section-5.1&gt;`_).
     * When this flag is set to 0, the option TCP_FASTOPEN is disabled on the socket.
     * When this flag is not set (default), the socket is not modified,
     * i.e. the option is neither enabled nor disabled.
     * On Linux, the net.ipv4.tcp_fastopen kernel parameter must include flag 0x2 to enable
     * TCP_FASTOPEN.
     * See `ip-sysctl.txt &lt;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt&gt;`_.
     * On macOS, only values of 0, 1, and unset are valid; other values may result in an error.
     * To set the queue length on macOS, set the net.inet.tcp.fastopen_backlog kernel parameter.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value tcp_fast_open_queue_length = 12;</code>
     * @return The tcpFastOpenQueueLength.
     */
    public com.google.protobuf.UInt32Value getTcpFastOpenQueueLength() {
      if (tcpFastOpenQueueLengthBuilder_ == null) {
        return tcpFastOpenQueueLength_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : tcpFastOpenQueueLength_;
      } else {
        return tcpFastOpenQueueLengthBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Whether the listener should accept TCP Fast Open (TFO) connections.
     * When this flag is set to a value greater than 0, the option TCP_FASTOPEN is enabled on
     * the socket, with a queue length of the specified size
     * (see `details in RFC7413 &lt;https://tools.ietf.org/html/rfc7413#section-5.1&gt;`_).
     * When this flag is set to 0, the option TCP_FASTOPEN is disabled on the socket.
     * When this flag is not set (default), the socket is not modified,
     * i.e. the option is neither enabled nor disabled.
     * On Linux, the net.ipv4.tcp_fastopen kernel parameter must include flag 0x2 to enable
     * TCP_FASTOPEN.
     * See `ip-sysctl.txt &lt;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt&gt;`_.
     * On macOS, only values of 0, 1, and unset are valid; other values may result in an error.
     * To set the queue length on macOS, set the net.inet.tcp.fastopen_backlog kernel parameter.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value tcp_fast_open_queue_length = 12;</code>
     */
    public Builder setTcpFastOpenQueueLength(com.google.protobuf.UInt32Value value) {
      if (tcpFastOpenQueueLengthBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        tcpFastOpenQueueLength_ = value;
      } else {
        tcpFastOpenQueueLengthBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00040000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the listener should accept TCP Fast Open (TFO) connections.
     * When this flag is set to a value greater than 0, the option TCP_FASTOPEN is enabled on
     * the socket, with a queue length of the specified size
     * (see `details in RFC7413 &lt;https://tools.ietf.org/html/rfc7413#section-5.1&gt;`_).
     * When this flag is set to 0, the option TCP_FASTOPEN is disabled on the socket.
     * When this flag is not set (default), the socket is not modified,
     * i.e. the option is neither enabled nor disabled.
     * On Linux, the net.ipv4.tcp_fastopen kernel parameter must include flag 0x2 to enable
     * TCP_FASTOPEN.
     * See `ip-sysctl.txt &lt;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt&gt;`_.
     * On macOS, only values of 0, 1, and unset are valid; other values may result in an error.
     * To set the queue length on macOS, set the net.inet.tcp.fastopen_backlog kernel parameter.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value tcp_fast_open_queue_length = 12;</code>
     */
    public Builder setTcpFastOpenQueueLength(
        com.google.protobuf.UInt32Value.Builder builderForValue) {
      if (tcpFastOpenQueueLengthBuilder_ == null) {
        tcpFastOpenQueueLength_ = builderForValue.build();
      } else {
        tcpFastOpenQueueLengthBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00040000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the listener should accept TCP Fast Open (TFO) connections.
     * When this flag is set to a value greater than 0, the option TCP_FASTOPEN is enabled on
     * the socket, with a queue length of the specified size
     * (see `details in RFC7413 &lt;https://tools.ietf.org/html/rfc7413#section-5.1&gt;`_).
     * When this flag is set to 0, the option TCP_FASTOPEN is disabled on the socket.
     * When this flag is not set (default), the socket is not modified,
     * i.e. the option is neither enabled nor disabled.
     * On Linux, the net.ipv4.tcp_fastopen kernel parameter must include flag 0x2 to enable
     * TCP_FASTOPEN.
     * See `ip-sysctl.txt &lt;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt&gt;`_.
     * On macOS, only values of 0, 1, and unset are valid; other values may result in an error.
     * To set the queue length on macOS, set the net.inet.tcp.fastopen_backlog kernel parameter.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value tcp_fast_open_queue_length = 12;</code>
     */
    public Builder mergeTcpFastOpenQueueLength(com.google.protobuf.UInt32Value value) {
      if (tcpFastOpenQueueLengthBuilder_ == null) {
        if (((bitField0_ & 0x00040000) != 0) &&
          tcpFastOpenQueueLength_ != null &&
          tcpFastOpenQueueLength_ != com.google.protobuf.UInt32Value.getDefaultInstance()) {
          getTcpFastOpenQueueLengthBuilder().mergeFrom(value);
        } else {
          tcpFastOpenQueueLength_ = value;
        }
      } else {
        tcpFastOpenQueueLengthBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00040000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the listener should accept TCP Fast Open (TFO) connections.
     * When this flag is set to a value greater than 0, the option TCP_FASTOPEN is enabled on
     * the socket, with a queue length of the specified size
     * (see `details in RFC7413 &lt;https://tools.ietf.org/html/rfc7413#section-5.1&gt;`_).
     * When this flag is set to 0, the option TCP_FASTOPEN is disabled on the socket.
     * When this flag is not set (default), the socket is not modified,
     * i.e. the option is neither enabled nor disabled.
     * On Linux, the net.ipv4.tcp_fastopen kernel parameter must include flag 0x2 to enable
     * TCP_FASTOPEN.
     * See `ip-sysctl.txt &lt;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt&gt;`_.
     * On macOS, only values of 0, 1, and unset are valid; other values may result in an error.
     * To set the queue length on macOS, set the net.inet.tcp.fastopen_backlog kernel parameter.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value tcp_fast_open_queue_length = 12;</code>
     */
    public Builder clearTcpFastOpenQueueLength() {
      bitField0_ = (bitField0_ & ~0x00040000);
      tcpFastOpenQueueLength_ = null;
      if (tcpFastOpenQueueLengthBuilder_ != null) {
        tcpFastOpenQueueLengthBuilder_.dispose();
        tcpFastOpenQueueLengthBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the listener should accept TCP Fast Open (TFO) connections.
     * When this flag is set to a value greater than 0, the option TCP_FASTOPEN is enabled on
     * the socket, with a queue length of the specified size
     * (see `details in RFC7413 &lt;https://tools.ietf.org/html/rfc7413#section-5.1&gt;`_).
     * When this flag is set to 0, the option TCP_FASTOPEN is disabled on the socket.
     * When this flag is not set (default), the socket is not modified,
     * i.e. the option is neither enabled nor disabled.
     * On Linux, the net.ipv4.tcp_fastopen kernel parameter must include flag 0x2 to enable
     * TCP_FASTOPEN.
     * See `ip-sysctl.txt &lt;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt&gt;`_.
     * On macOS, only values of 0, 1, and unset are valid; other values may result in an error.
     * To set the queue length on macOS, set the net.inet.tcp.fastopen_backlog kernel parameter.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value tcp_fast_open_queue_length = 12;</code>
     */
    public com.google.protobuf.UInt32Value.Builder getTcpFastOpenQueueLengthBuilder() {
      bitField0_ |= 0x00040000;
      onChanged();
      return getTcpFastOpenQueueLengthFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Whether the listener should accept TCP Fast Open (TFO) connections.
     * When this flag is set to a value greater than 0, the option TCP_FASTOPEN is enabled on
     * the socket, with a queue length of the specified size
     * (see `details in RFC7413 &lt;https://tools.ietf.org/html/rfc7413#section-5.1&gt;`_).
     * When this flag is set to 0, the option TCP_FASTOPEN is disabled on the socket.
     * When this flag is not set (default), the socket is not modified,
     * i.e. the option is neither enabled nor disabled.
     * On Linux, the net.ipv4.tcp_fastopen kernel parameter must include flag 0x2 to enable
     * TCP_FASTOPEN.
     * See `ip-sysctl.txt &lt;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt&gt;`_.
     * On macOS, only values of 0, 1, and unset are valid; other values may result in an error.
     * To set the queue length on macOS, set the net.inet.tcp.fastopen_backlog kernel parameter.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value tcp_fast_open_queue_length = 12;</code>
     */
    public com.google.protobuf.UInt32ValueOrBuilder getTcpFastOpenQueueLengthOrBuilder() {
      if (tcpFastOpenQueueLengthBuilder_ != null) {
        return tcpFastOpenQueueLengthBuilder_.getMessageOrBuilder();
      } else {
        return tcpFastOpenQueueLength_ == null ?
            com.google.protobuf.UInt32Value.getDefaultInstance() : tcpFastOpenQueueLength_;
      }
    }
    /**
     * <pre>
     * Whether the listener should accept TCP Fast Open (TFO) connections.
     * When this flag is set to a value greater than 0, the option TCP_FASTOPEN is enabled on
     * the socket, with a queue length of the specified size
     * (see `details in RFC7413 &lt;https://tools.ietf.org/html/rfc7413#section-5.1&gt;`_).
     * When this flag is set to 0, the option TCP_FASTOPEN is disabled on the socket.
     * When this flag is not set (default), the socket is not modified,
     * i.e. the option is neither enabled nor disabled.
     * On Linux, the net.ipv4.tcp_fastopen kernel parameter must include flag 0x2 to enable
     * TCP_FASTOPEN.
     * See `ip-sysctl.txt &lt;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt&gt;`_.
     * On macOS, only values of 0, 1, and unset are valid; other values may result in an error.
     * To set the queue length on macOS, set the net.inet.tcp.fastopen_backlog kernel parameter.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value tcp_fast_open_queue_length = 12;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
        getTcpFastOpenQueueLengthFieldBuilder() {
      if (tcpFastOpenQueueLengthBuilder_ == null) {
        tcpFastOpenQueueLengthBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                getTcpFastOpenQueueLength(),
                getParentForChildren(),
                isClean());
        tcpFastOpenQueueLength_ = null;
      }
      return tcpFastOpenQueueLengthBuilder_;
    }

    private int trafficDirection_ = 0;
    /**
     * <pre>
     * Specifies the intended direction of the traffic relative to the local Envoy.
     * This property is required on Windows for listeners using the original destination filter,
     * see :ref:`Original Destination &lt;config_listener_filters_original_dst&gt;`.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TrafficDirection traffic_direction = 16;</code>
     * @return The enum numeric value on the wire for trafficDirection.
     */
    @java.lang.Override public int getTrafficDirectionValue() {
      return trafficDirection_;
    }
    /**
     * <pre>
     * Specifies the intended direction of the traffic relative to the local Envoy.
     * This property is required on Windows for listeners using the original destination filter,
     * see :ref:`Original Destination &lt;config_listener_filters_original_dst&gt;`.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TrafficDirection traffic_direction = 16;</code>
     * @param value The enum numeric value on the wire for trafficDirection to set.
     * @return This builder for chaining.
     */
    public Builder setTrafficDirectionValue(int value) {
      trafficDirection_ = value;
      bitField0_ |= 0x00080000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Specifies the intended direction of the traffic relative to the local Envoy.
     * This property is required on Windows for listeners using the original destination filter,
     * see :ref:`Original Destination &lt;config_listener_filters_original_dst&gt;`.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TrafficDirection traffic_direction = 16;</code>
     * @return The trafficDirection.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.TrafficDirection getTrafficDirection() {
      io.envoyproxy.envoy.config.core.v3.TrafficDirection result = io.envoyproxy.envoy.config.core.v3.TrafficDirection.forNumber(trafficDirection_);
      return result == null ? io.envoyproxy.envoy.config.core.v3.TrafficDirection.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * Specifies the intended direction of the traffic relative to the local Envoy.
     * This property is required on Windows for listeners using the original destination filter,
     * see :ref:`Original Destination &lt;config_listener_filters_original_dst&gt;`.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TrafficDirection traffic_direction = 16;</code>
     * @param value The trafficDirection to set.
     * @return This builder for chaining.
     */
    public Builder setTrafficDirection(io.envoyproxy.envoy.config.core.v3.TrafficDirection value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00080000;
      trafficDirection_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Specifies the intended direction of the traffic relative to the local Envoy.
     * This property is required on Windows for listeners using the original destination filter,
     * see :ref:`Original Destination &lt;config_listener_filters_original_dst&gt;`.
     * </pre>
     *
     * <code>.envoy.config.core.v3.TrafficDirection traffic_direction = 16;</code>
     * @return This builder for chaining.
     */
    public Builder clearTrafficDirection() {
      bitField0_ = (bitField0_ & ~0x00080000);
      trafficDirection_ = 0;
      onChanged();
      return this;
    }

    private io.envoyproxy.envoy.config.listener.v3.UdpListenerConfig udpListenerConfig_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.listener.v3.UdpListenerConfig, io.envoyproxy.envoy.config.listener.v3.UdpListenerConfig.Builder, io.envoyproxy.envoy.config.listener.v3.UdpListenerConfigOrBuilder> udpListenerConfigBuilder_;
    /**
     * <pre>
     * If the protocol in the listener socket address in :ref:`protocol
     * &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`, this field specifies UDP
     * listener specific configuration.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.UdpListenerConfig udp_listener_config = 18;</code>
     * @return Whether the udpListenerConfig field is set.
     */
    public boolean hasUdpListenerConfig() {
      return ((bitField0_ & 0x00100000) != 0);
    }
    /**
     * <pre>
     * If the protocol in the listener socket address in :ref:`protocol
     * &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`, this field specifies UDP
     * listener specific configuration.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.UdpListenerConfig udp_listener_config = 18;</code>
     * @return The udpListenerConfig.
     */
    public io.envoyproxy.envoy.config.listener.v3.UdpListenerConfig getUdpListenerConfig() {
      if (udpListenerConfigBuilder_ == null) {
        return udpListenerConfig_ == null ? io.envoyproxy.envoy.config.listener.v3.UdpListenerConfig.getDefaultInstance() : udpListenerConfig_;
      } else {
        return udpListenerConfigBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * If the protocol in the listener socket address in :ref:`protocol
     * &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`, this field specifies UDP
     * listener specific configuration.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.UdpListenerConfig udp_listener_config = 18;</code>
     */
    public Builder setUdpListenerConfig(io.envoyproxy.envoy.config.listener.v3.UdpListenerConfig value) {
      if (udpListenerConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        udpListenerConfig_ = value;
      } else {
        udpListenerConfigBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00100000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If the protocol in the listener socket address in :ref:`protocol
     * &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`, this field specifies UDP
     * listener specific configuration.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.UdpListenerConfig udp_listener_config = 18;</code>
     */
    public Builder setUdpListenerConfig(
        io.envoyproxy.envoy.config.listener.v3.UdpListenerConfig.Builder builderForValue) {
      if (udpListenerConfigBuilder_ == null) {
        udpListenerConfig_ = builderForValue.build();
      } else {
        udpListenerConfigBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00100000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If the protocol in the listener socket address in :ref:`protocol
     * &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`, this field specifies UDP
     * listener specific configuration.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.UdpListenerConfig udp_listener_config = 18;</code>
     */
    public Builder mergeUdpListenerConfig(io.envoyproxy.envoy.config.listener.v3.UdpListenerConfig value) {
      if (udpListenerConfigBuilder_ == null) {
        if (((bitField0_ & 0x00100000) != 0) &&
          udpListenerConfig_ != null &&
          udpListenerConfig_ != io.envoyproxy.envoy.config.listener.v3.UdpListenerConfig.getDefaultInstance()) {
          getUdpListenerConfigBuilder().mergeFrom(value);
        } else {
          udpListenerConfig_ = value;
        }
      } else {
        udpListenerConfigBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00100000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If the protocol in the listener socket address in :ref:`protocol
     * &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`, this field specifies UDP
     * listener specific configuration.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.UdpListenerConfig udp_listener_config = 18;</code>
     */
    public Builder clearUdpListenerConfig() {
      bitField0_ = (bitField0_ & ~0x00100000);
      udpListenerConfig_ = null;
      if (udpListenerConfigBuilder_ != null) {
        udpListenerConfigBuilder_.dispose();
        udpListenerConfigBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If the protocol in the listener socket address in :ref:`protocol
     * &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`, this field specifies UDP
     * listener specific configuration.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.UdpListenerConfig udp_listener_config = 18;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.UdpListenerConfig.Builder getUdpListenerConfigBuilder() {
      bitField0_ |= 0x00100000;
      onChanged();
      return getUdpListenerConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * If the protocol in the listener socket address in :ref:`protocol
     * &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`, this field specifies UDP
     * listener specific configuration.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.UdpListenerConfig udp_listener_config = 18;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.UdpListenerConfigOrBuilder getUdpListenerConfigOrBuilder() {
      if (udpListenerConfigBuilder_ != null) {
        return udpListenerConfigBuilder_.getMessageOrBuilder();
      } else {
        return udpListenerConfig_ == null ?
            io.envoyproxy.envoy.config.listener.v3.UdpListenerConfig.getDefaultInstance() : udpListenerConfig_;
      }
    }
    /**
     * <pre>
     * If the protocol in the listener socket address in :ref:`protocol
     * &lt;envoy_v3_api_field_config.core.v3.SocketAddress.protocol&gt;` is :ref:`UDP
     * &lt;envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP&gt;`, this field specifies UDP
     * listener specific configuration.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.UdpListenerConfig udp_listener_config = 18;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.listener.v3.UdpListenerConfig, io.envoyproxy.envoy.config.listener.v3.UdpListenerConfig.Builder, io.envoyproxy.envoy.config.listener.v3.UdpListenerConfigOrBuilder> 
        getUdpListenerConfigFieldBuilder() {
      if (udpListenerConfigBuilder_ == null) {
        udpListenerConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.listener.v3.UdpListenerConfig, io.envoyproxy.envoy.config.listener.v3.UdpListenerConfig.Builder, io.envoyproxy.envoy.config.listener.v3.UdpListenerConfigOrBuilder>(
                getUdpListenerConfig(),
                getParentForChildren(),
                isClean());
        udpListenerConfig_ = null;
      }
      return udpListenerConfigBuilder_;
    }

    private io.envoyproxy.envoy.config.listener.v3.ApiListener apiListener_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.listener.v3.ApiListener, io.envoyproxy.envoy.config.listener.v3.ApiListener.Builder, io.envoyproxy.envoy.config.listener.v3.ApiListenerOrBuilder> apiListenerBuilder_;
    /**
     * <pre>
     * Used to represent an API listener, which is used in non-proxy clients. The type of API
     * exposed to the non-proxy application depends on the type of API listener.
     * When this field is set, no other field except for :ref:`name&lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`
     * should be set.
     * .. note::
     *  Currently only one ApiListener can be installed; and it can only be done via bootstrap config,
     *  not LDS.
     * [#next-major-version: In the v3 API, instead of this messy approach where the socket
     * listener fields are directly in the top-level Listener message and the API listener types
     * are in the ApiListener message, the socket listener messages should be in their own message,
     * and the top-level Listener should essentially be a oneof that selects between the
     * socket listener and the various types of API listener. That way, a given Listener message
     * can structurally only contain the fields of the relevant type.]
     * </pre>
     *
     * <code>.envoy.config.listener.v3.ApiListener api_listener = 19;</code>
     * @return Whether the apiListener field is set.
     */
    public boolean hasApiListener() {
      return ((bitField0_ & 0x00200000) != 0);
    }
    /**
     * <pre>
     * Used to represent an API listener, which is used in non-proxy clients. The type of API
     * exposed to the non-proxy application depends on the type of API listener.
     * When this field is set, no other field except for :ref:`name&lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`
     * should be set.
     * .. note::
     *  Currently only one ApiListener can be installed; and it can only be done via bootstrap config,
     *  not LDS.
     * [#next-major-version: In the v3 API, instead of this messy approach where the socket
     * listener fields are directly in the top-level Listener message and the API listener types
     * are in the ApiListener message, the socket listener messages should be in their own message,
     * and the top-level Listener should essentially be a oneof that selects between the
     * socket listener and the various types of API listener. That way, a given Listener message
     * can structurally only contain the fields of the relevant type.]
     * </pre>
     *
     * <code>.envoy.config.listener.v3.ApiListener api_listener = 19;</code>
     * @return The apiListener.
     */
    public io.envoyproxy.envoy.config.listener.v3.ApiListener getApiListener() {
      if (apiListenerBuilder_ == null) {
        return apiListener_ == null ? io.envoyproxy.envoy.config.listener.v3.ApiListener.getDefaultInstance() : apiListener_;
      } else {
        return apiListenerBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Used to represent an API listener, which is used in non-proxy clients. The type of API
     * exposed to the non-proxy application depends on the type of API listener.
     * When this field is set, no other field except for :ref:`name&lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`
     * should be set.
     * .. note::
     *  Currently only one ApiListener can be installed; and it can only be done via bootstrap config,
     *  not LDS.
     * [#next-major-version: In the v3 API, instead of this messy approach where the socket
     * listener fields are directly in the top-level Listener message and the API listener types
     * are in the ApiListener message, the socket listener messages should be in their own message,
     * and the top-level Listener should essentially be a oneof that selects between the
     * socket listener and the various types of API listener. That way, a given Listener message
     * can structurally only contain the fields of the relevant type.]
     * </pre>
     *
     * <code>.envoy.config.listener.v3.ApiListener api_listener = 19;</code>
     */
    public Builder setApiListener(io.envoyproxy.envoy.config.listener.v3.ApiListener value) {
      if (apiListenerBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        apiListener_ = value;
      } else {
        apiListenerBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00200000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Used to represent an API listener, which is used in non-proxy clients. The type of API
     * exposed to the non-proxy application depends on the type of API listener.
     * When this field is set, no other field except for :ref:`name&lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`
     * should be set.
     * .. note::
     *  Currently only one ApiListener can be installed; and it can only be done via bootstrap config,
     *  not LDS.
     * [#next-major-version: In the v3 API, instead of this messy approach where the socket
     * listener fields are directly in the top-level Listener message and the API listener types
     * are in the ApiListener message, the socket listener messages should be in their own message,
     * and the top-level Listener should essentially be a oneof that selects between the
     * socket listener and the various types of API listener. That way, a given Listener message
     * can structurally only contain the fields of the relevant type.]
     * </pre>
     *
     * <code>.envoy.config.listener.v3.ApiListener api_listener = 19;</code>
     */
    public Builder setApiListener(
        io.envoyproxy.envoy.config.listener.v3.ApiListener.Builder builderForValue) {
      if (apiListenerBuilder_ == null) {
        apiListener_ = builderForValue.build();
      } else {
        apiListenerBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00200000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Used to represent an API listener, which is used in non-proxy clients. The type of API
     * exposed to the non-proxy application depends on the type of API listener.
     * When this field is set, no other field except for :ref:`name&lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`
     * should be set.
     * .. note::
     *  Currently only one ApiListener can be installed; and it can only be done via bootstrap config,
     *  not LDS.
     * [#next-major-version: In the v3 API, instead of this messy approach where the socket
     * listener fields are directly in the top-level Listener message and the API listener types
     * are in the ApiListener message, the socket listener messages should be in their own message,
     * and the top-level Listener should essentially be a oneof that selects between the
     * socket listener and the various types of API listener. That way, a given Listener message
     * can structurally only contain the fields of the relevant type.]
     * </pre>
     *
     * <code>.envoy.config.listener.v3.ApiListener api_listener = 19;</code>
     */
    public Builder mergeApiListener(io.envoyproxy.envoy.config.listener.v3.ApiListener value) {
      if (apiListenerBuilder_ == null) {
        if (((bitField0_ & 0x00200000) != 0) &&
          apiListener_ != null &&
          apiListener_ != io.envoyproxy.envoy.config.listener.v3.ApiListener.getDefaultInstance()) {
          getApiListenerBuilder().mergeFrom(value);
        } else {
          apiListener_ = value;
        }
      } else {
        apiListenerBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00200000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Used to represent an API listener, which is used in non-proxy clients. The type of API
     * exposed to the non-proxy application depends on the type of API listener.
     * When this field is set, no other field except for :ref:`name&lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`
     * should be set.
     * .. note::
     *  Currently only one ApiListener can be installed; and it can only be done via bootstrap config,
     *  not LDS.
     * [#next-major-version: In the v3 API, instead of this messy approach where the socket
     * listener fields are directly in the top-level Listener message and the API listener types
     * are in the ApiListener message, the socket listener messages should be in their own message,
     * and the top-level Listener should essentially be a oneof that selects between the
     * socket listener and the various types of API listener. That way, a given Listener message
     * can structurally only contain the fields of the relevant type.]
     * </pre>
     *
     * <code>.envoy.config.listener.v3.ApiListener api_listener = 19;</code>
     */
    public Builder clearApiListener() {
      bitField0_ = (bitField0_ & ~0x00200000);
      apiListener_ = null;
      if (apiListenerBuilder_ != null) {
        apiListenerBuilder_.dispose();
        apiListenerBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Used to represent an API listener, which is used in non-proxy clients. The type of API
     * exposed to the non-proxy application depends on the type of API listener.
     * When this field is set, no other field except for :ref:`name&lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`
     * should be set.
     * .. note::
     *  Currently only one ApiListener can be installed; and it can only be done via bootstrap config,
     *  not LDS.
     * [#next-major-version: In the v3 API, instead of this messy approach where the socket
     * listener fields are directly in the top-level Listener message and the API listener types
     * are in the ApiListener message, the socket listener messages should be in their own message,
     * and the top-level Listener should essentially be a oneof that selects between the
     * socket listener and the various types of API listener. That way, a given Listener message
     * can structurally only contain the fields of the relevant type.]
     * </pre>
     *
     * <code>.envoy.config.listener.v3.ApiListener api_listener = 19;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.ApiListener.Builder getApiListenerBuilder() {
      bitField0_ |= 0x00200000;
      onChanged();
      return getApiListenerFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Used to represent an API listener, which is used in non-proxy clients. The type of API
     * exposed to the non-proxy application depends on the type of API listener.
     * When this field is set, no other field except for :ref:`name&lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`
     * should be set.
     * .. note::
     *  Currently only one ApiListener can be installed; and it can only be done via bootstrap config,
     *  not LDS.
     * [#next-major-version: In the v3 API, instead of this messy approach where the socket
     * listener fields are directly in the top-level Listener message and the API listener types
     * are in the ApiListener message, the socket listener messages should be in their own message,
     * and the top-level Listener should essentially be a oneof that selects between the
     * socket listener and the various types of API listener. That way, a given Listener message
     * can structurally only contain the fields of the relevant type.]
     * </pre>
     *
     * <code>.envoy.config.listener.v3.ApiListener api_listener = 19;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.ApiListenerOrBuilder getApiListenerOrBuilder() {
      if (apiListenerBuilder_ != null) {
        return apiListenerBuilder_.getMessageOrBuilder();
      } else {
        return apiListener_ == null ?
            io.envoyproxy.envoy.config.listener.v3.ApiListener.getDefaultInstance() : apiListener_;
      }
    }
    /**
     * <pre>
     * Used to represent an API listener, which is used in non-proxy clients. The type of API
     * exposed to the non-proxy application depends on the type of API listener.
     * When this field is set, no other field except for :ref:`name&lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`
     * should be set.
     * .. note::
     *  Currently only one ApiListener can be installed; and it can only be done via bootstrap config,
     *  not LDS.
     * [#next-major-version: In the v3 API, instead of this messy approach where the socket
     * listener fields are directly in the top-level Listener message and the API listener types
     * are in the ApiListener message, the socket listener messages should be in their own message,
     * and the top-level Listener should essentially be a oneof that selects between the
     * socket listener and the various types of API listener. That way, a given Listener message
     * can structurally only contain the fields of the relevant type.]
     * </pre>
     *
     * <code>.envoy.config.listener.v3.ApiListener api_listener = 19;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.listener.v3.ApiListener, io.envoyproxy.envoy.config.listener.v3.ApiListener.Builder, io.envoyproxy.envoy.config.listener.v3.ApiListenerOrBuilder> 
        getApiListenerFieldBuilder() {
      if (apiListenerBuilder_ == null) {
        apiListenerBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.listener.v3.ApiListener, io.envoyproxy.envoy.config.listener.v3.ApiListener.Builder, io.envoyproxy.envoy.config.listener.v3.ApiListenerOrBuilder>(
                getApiListener(),
                getParentForChildren(),
                isClean());
        apiListener_ = null;
      }
      return apiListenerBuilder_;
    }

    private io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig connectionBalanceConfig_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig, io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.Builder, io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfigOrBuilder> connectionBalanceConfigBuilder_;
    /**
     * <pre>
     * The listener's connection balancer configuration, currently only applicable to TCP listeners.
     * If no configuration is specified, Envoy will not attempt to balance active connections between
     * worker threads.
     * In the scenario that the listener X redirects all the connections to the listeners Y1 and Y2
     * by setting :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;` in X
     * and :ref:`bind_to_port &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;` to false in Y1 and Y2,
     * it is recommended to disable the balance config in listener X to avoid the cost of balancing, and
     * enable the balance config in Y1 and Y2 to balance the connections among the workers.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig connection_balance_config = 20;</code>
     * @return Whether the connectionBalanceConfig field is set.
     */
    public boolean hasConnectionBalanceConfig() {
      return ((bitField0_ & 0x00400000) != 0);
    }
    /**
     * <pre>
     * The listener's connection balancer configuration, currently only applicable to TCP listeners.
     * If no configuration is specified, Envoy will not attempt to balance active connections between
     * worker threads.
     * In the scenario that the listener X redirects all the connections to the listeners Y1 and Y2
     * by setting :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;` in X
     * and :ref:`bind_to_port &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;` to false in Y1 and Y2,
     * it is recommended to disable the balance config in listener X to avoid the cost of balancing, and
     * enable the balance config in Y1 and Y2 to balance the connections among the workers.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig connection_balance_config = 20;</code>
     * @return The connectionBalanceConfig.
     */
    public io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig getConnectionBalanceConfig() {
      if (connectionBalanceConfigBuilder_ == null) {
        return connectionBalanceConfig_ == null ? io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.getDefaultInstance() : connectionBalanceConfig_;
      } else {
        return connectionBalanceConfigBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The listener's connection balancer configuration, currently only applicable to TCP listeners.
     * If no configuration is specified, Envoy will not attempt to balance active connections between
     * worker threads.
     * In the scenario that the listener X redirects all the connections to the listeners Y1 and Y2
     * by setting :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;` in X
     * and :ref:`bind_to_port &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;` to false in Y1 and Y2,
     * it is recommended to disable the balance config in listener X to avoid the cost of balancing, and
     * enable the balance config in Y1 and Y2 to balance the connections among the workers.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig connection_balance_config = 20;</code>
     */
    public Builder setConnectionBalanceConfig(io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig value) {
      if (connectionBalanceConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        connectionBalanceConfig_ = value;
      } else {
        connectionBalanceConfigBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00400000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The listener's connection balancer configuration, currently only applicable to TCP listeners.
     * If no configuration is specified, Envoy will not attempt to balance active connections between
     * worker threads.
     * In the scenario that the listener X redirects all the connections to the listeners Y1 and Y2
     * by setting :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;` in X
     * and :ref:`bind_to_port &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;` to false in Y1 and Y2,
     * it is recommended to disable the balance config in listener X to avoid the cost of balancing, and
     * enable the balance config in Y1 and Y2 to balance the connections among the workers.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig connection_balance_config = 20;</code>
     */
    public Builder setConnectionBalanceConfig(
        io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.Builder builderForValue) {
      if (connectionBalanceConfigBuilder_ == null) {
        connectionBalanceConfig_ = builderForValue.build();
      } else {
        connectionBalanceConfigBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00400000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The listener's connection balancer configuration, currently only applicable to TCP listeners.
     * If no configuration is specified, Envoy will not attempt to balance active connections between
     * worker threads.
     * In the scenario that the listener X redirects all the connections to the listeners Y1 and Y2
     * by setting :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;` in X
     * and :ref:`bind_to_port &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;` to false in Y1 and Y2,
     * it is recommended to disable the balance config in listener X to avoid the cost of balancing, and
     * enable the balance config in Y1 and Y2 to balance the connections among the workers.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig connection_balance_config = 20;</code>
     */
    public Builder mergeConnectionBalanceConfig(io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig value) {
      if (connectionBalanceConfigBuilder_ == null) {
        if (((bitField0_ & 0x00400000) != 0) &&
          connectionBalanceConfig_ != null &&
          connectionBalanceConfig_ != io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.getDefaultInstance()) {
          getConnectionBalanceConfigBuilder().mergeFrom(value);
        } else {
          connectionBalanceConfig_ = value;
        }
      } else {
        connectionBalanceConfigBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00400000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The listener's connection balancer configuration, currently only applicable to TCP listeners.
     * If no configuration is specified, Envoy will not attempt to balance active connections between
     * worker threads.
     * In the scenario that the listener X redirects all the connections to the listeners Y1 and Y2
     * by setting :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;` in X
     * and :ref:`bind_to_port &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;` to false in Y1 and Y2,
     * it is recommended to disable the balance config in listener X to avoid the cost of balancing, and
     * enable the balance config in Y1 and Y2 to balance the connections among the workers.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig connection_balance_config = 20;</code>
     */
    public Builder clearConnectionBalanceConfig() {
      bitField0_ = (bitField0_ & ~0x00400000);
      connectionBalanceConfig_ = null;
      if (connectionBalanceConfigBuilder_ != null) {
        connectionBalanceConfigBuilder_.dispose();
        connectionBalanceConfigBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The listener's connection balancer configuration, currently only applicable to TCP listeners.
     * If no configuration is specified, Envoy will not attempt to balance active connections between
     * worker threads.
     * In the scenario that the listener X redirects all the connections to the listeners Y1 and Y2
     * by setting :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;` in X
     * and :ref:`bind_to_port &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;` to false in Y1 and Y2,
     * it is recommended to disable the balance config in listener X to avoid the cost of balancing, and
     * enable the balance config in Y1 and Y2 to balance the connections among the workers.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig connection_balance_config = 20;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.Builder getConnectionBalanceConfigBuilder() {
      bitField0_ |= 0x00400000;
      onChanged();
      return getConnectionBalanceConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The listener's connection balancer configuration, currently only applicable to TCP listeners.
     * If no configuration is specified, Envoy will not attempt to balance active connections between
     * worker threads.
     * In the scenario that the listener X redirects all the connections to the listeners Y1 and Y2
     * by setting :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;` in X
     * and :ref:`bind_to_port &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;` to false in Y1 and Y2,
     * it is recommended to disable the balance config in listener X to avoid the cost of balancing, and
     * enable the balance config in Y1 and Y2 to balance the connections among the workers.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig connection_balance_config = 20;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfigOrBuilder getConnectionBalanceConfigOrBuilder() {
      if (connectionBalanceConfigBuilder_ != null) {
        return connectionBalanceConfigBuilder_.getMessageOrBuilder();
      } else {
        return connectionBalanceConfig_ == null ?
            io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.getDefaultInstance() : connectionBalanceConfig_;
      }
    }
    /**
     * <pre>
     * The listener's connection balancer configuration, currently only applicable to TCP listeners.
     * If no configuration is specified, Envoy will not attempt to balance active connections between
     * worker threads.
     * In the scenario that the listener X redirects all the connections to the listeners Y1 and Y2
     * by setting :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;` in X
     * and :ref:`bind_to_port &lt;envoy_v3_api_field_config.listener.v3.Listener.bind_to_port&gt;` to false in Y1 and Y2,
     * it is recommended to disable the balance config in listener X to avoid the cost of balancing, and
     * enable the balance config in Y1 and Y2 to balance the connections among the workers.
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.ConnectionBalanceConfig connection_balance_config = 20;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig, io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.Builder, io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfigOrBuilder> 
        getConnectionBalanceConfigFieldBuilder() {
      if (connectionBalanceConfigBuilder_ == null) {
        connectionBalanceConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig, io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfig.Builder, io.envoyproxy.envoy.config.listener.v3.Listener.ConnectionBalanceConfigOrBuilder>(
                getConnectionBalanceConfig(),
                getParentForChildren(),
                isClean());
        connectionBalanceConfig_ = null;
      }
      return connectionBalanceConfigBuilder_;
    }

    private boolean reusePort_ ;
    /**
     * <pre>
     * Deprecated. Use ``enable_reuse_port`` instead.
     * </pre>
     *
     * <code>bool reuse_port = 21 [deprecated = true, (.envoy.annotations.deprecated_at_minor_version) = "3.0"];</code>
     * @deprecated envoy.config.listener.v3.Listener.reuse_port is deprecated.
     *     See envoy/config/listener/v3/listener.proto;l=307
     * @return The reusePort.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean getReusePort() {
      return reusePort_;
    }
    /**
     * <pre>
     * Deprecated. Use ``enable_reuse_port`` instead.
     * </pre>
     *
     * <code>bool reuse_port = 21 [deprecated = true, (.envoy.annotations.deprecated_at_minor_version) = "3.0"];</code>
     * @deprecated envoy.config.listener.v3.Listener.reuse_port is deprecated.
     *     See envoy/config/listener/v3/listener.proto;l=307
     * @param value The reusePort to set.
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder setReusePort(boolean value) {
      
      reusePort_ = value;
      bitField0_ |= 0x00800000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Deprecated. Use ``enable_reuse_port`` instead.
     * </pre>
     *
     * <code>bool reuse_port = 21 [deprecated = true, (.envoy.annotations.deprecated_at_minor_version) = "3.0"];</code>
     * @deprecated envoy.config.listener.v3.Listener.reuse_port is deprecated.
     *     See envoy/config/listener/v3/listener.proto;l=307
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder clearReusePort() {
      bitField0_ = (bitField0_ & ~0x00800000);
      reusePort_ = false;
      onChanged();
      return this;
    }

    private com.google.protobuf.BoolValue enableReusePort_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> enableReusePortBuilder_;
    /**
     * <pre>
     * When this flag is set to true, listeners set the ``SO_REUSEPORT`` socket option and
     * create one socket for each worker thread. This makes inbound connections
     * distribute among worker threads roughly evenly in cases where there are a high number
     * of connections. When this flag is set to false, all worker threads share one socket. This field
     * defaults to true. The change of field will be rejected during an listener update when the
     * runtime flag ``envoy.reloadable_features.enable_update_listener_socket_options`` is enabled.
     * Otherwise, the update of this field will be ignored quietly.
     * .. attention::
     *   Although this field defaults to true, it has different behavior on different platforms. See
     *   the following text for more information.
     * * On Linux, reuse_port is respected for both TCP and UDP listeners. It also works correctly
     *   with hot restart.
     * * On macOS, reuse_port for TCP does not do what it does on Linux. Instead of load balancing,
     *   the last socket wins and receives all connections/packets. For TCP, reuse_port is force
     *   disabled and the user is warned. For UDP, it is enabled, but only one worker will receive
     *   packets. For QUIC/H3, SW routing will send packets to other workers. For "raw" UDP, only
     *   a single worker will currently receive packets.
     * * On Windows, reuse_port for TCP has undefined behavior. It is force disabled and the user
     *   is warned similar to macOS. It is left enabled for UDP with undefined behavior currently.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue enable_reuse_port = 29;</code>
     * @return Whether the enableReusePort field is set.
     */
    public boolean hasEnableReusePort() {
      return ((bitField0_ & 0x01000000) != 0);
    }
    /**
     * <pre>
     * When this flag is set to true, listeners set the ``SO_REUSEPORT`` socket option and
     * create one socket for each worker thread. This makes inbound connections
     * distribute among worker threads roughly evenly in cases where there are a high number
     * of connections. When this flag is set to false, all worker threads share one socket. This field
     * defaults to true. The change of field will be rejected during an listener update when the
     * runtime flag ``envoy.reloadable_features.enable_update_listener_socket_options`` is enabled.
     * Otherwise, the update of this field will be ignored quietly.
     * .. attention::
     *   Although this field defaults to true, it has different behavior on different platforms. See
     *   the following text for more information.
     * * On Linux, reuse_port is respected for both TCP and UDP listeners. It also works correctly
     *   with hot restart.
     * * On macOS, reuse_port for TCP does not do what it does on Linux. Instead of load balancing,
     *   the last socket wins and receives all connections/packets. For TCP, reuse_port is force
     *   disabled and the user is warned. For UDP, it is enabled, but only one worker will receive
     *   packets. For QUIC/H3, SW routing will send packets to other workers. For "raw" UDP, only
     *   a single worker will currently receive packets.
     * * On Windows, reuse_port for TCP has undefined behavior. It is force disabled and the user
     *   is warned similar to macOS. It is left enabled for UDP with undefined behavior currently.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue enable_reuse_port = 29;</code>
     * @return The enableReusePort.
     */
    public com.google.protobuf.BoolValue getEnableReusePort() {
      if (enableReusePortBuilder_ == null) {
        return enableReusePort_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : enableReusePort_;
      } else {
        return enableReusePortBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * When this flag is set to true, listeners set the ``SO_REUSEPORT`` socket option and
     * create one socket for each worker thread. This makes inbound connections
     * distribute among worker threads roughly evenly in cases where there are a high number
     * of connections. When this flag is set to false, all worker threads share one socket. This field
     * defaults to true. The change of field will be rejected during an listener update when the
     * runtime flag ``envoy.reloadable_features.enable_update_listener_socket_options`` is enabled.
     * Otherwise, the update of this field will be ignored quietly.
     * .. attention::
     *   Although this field defaults to true, it has different behavior on different platforms. See
     *   the following text for more information.
     * * On Linux, reuse_port is respected for both TCP and UDP listeners. It also works correctly
     *   with hot restart.
     * * On macOS, reuse_port for TCP does not do what it does on Linux. Instead of load balancing,
     *   the last socket wins and receives all connections/packets. For TCP, reuse_port is force
     *   disabled and the user is warned. For UDP, it is enabled, but only one worker will receive
     *   packets. For QUIC/H3, SW routing will send packets to other workers. For "raw" UDP, only
     *   a single worker will currently receive packets.
     * * On Windows, reuse_port for TCP has undefined behavior. It is force disabled and the user
     *   is warned similar to macOS. It is left enabled for UDP with undefined behavior currently.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue enable_reuse_port = 29;</code>
     */
    public Builder setEnableReusePort(com.google.protobuf.BoolValue value) {
      if (enableReusePortBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        enableReusePort_ = value;
      } else {
        enableReusePortBuilder_.setMessage(value);
      }
      bitField0_ |= 0x01000000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * When this flag is set to true, listeners set the ``SO_REUSEPORT`` socket option and
     * create one socket for each worker thread. This makes inbound connections
     * distribute among worker threads roughly evenly in cases where there are a high number
     * of connections. When this flag is set to false, all worker threads share one socket. This field
     * defaults to true. The change of field will be rejected during an listener update when the
     * runtime flag ``envoy.reloadable_features.enable_update_listener_socket_options`` is enabled.
     * Otherwise, the update of this field will be ignored quietly.
     * .. attention::
     *   Although this field defaults to true, it has different behavior on different platforms. See
     *   the following text for more information.
     * * On Linux, reuse_port is respected for both TCP and UDP listeners. It also works correctly
     *   with hot restart.
     * * On macOS, reuse_port for TCP does not do what it does on Linux. Instead of load balancing,
     *   the last socket wins and receives all connections/packets. For TCP, reuse_port is force
     *   disabled and the user is warned. For UDP, it is enabled, but only one worker will receive
     *   packets. For QUIC/H3, SW routing will send packets to other workers. For "raw" UDP, only
     *   a single worker will currently receive packets.
     * * On Windows, reuse_port for TCP has undefined behavior. It is force disabled and the user
     *   is warned similar to macOS. It is left enabled for UDP with undefined behavior currently.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue enable_reuse_port = 29;</code>
     */
    public Builder setEnableReusePort(
        com.google.protobuf.BoolValue.Builder builderForValue) {
      if (enableReusePortBuilder_ == null) {
        enableReusePort_ = builderForValue.build();
      } else {
        enableReusePortBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x01000000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * When this flag is set to true, listeners set the ``SO_REUSEPORT`` socket option and
     * create one socket for each worker thread. This makes inbound connections
     * distribute among worker threads roughly evenly in cases where there are a high number
     * of connections. When this flag is set to false, all worker threads share one socket. This field
     * defaults to true. The change of field will be rejected during an listener update when the
     * runtime flag ``envoy.reloadable_features.enable_update_listener_socket_options`` is enabled.
     * Otherwise, the update of this field will be ignored quietly.
     * .. attention::
     *   Although this field defaults to true, it has different behavior on different platforms. See
     *   the following text for more information.
     * * On Linux, reuse_port is respected for both TCP and UDP listeners. It also works correctly
     *   with hot restart.
     * * On macOS, reuse_port for TCP does not do what it does on Linux. Instead of load balancing,
     *   the last socket wins and receives all connections/packets. For TCP, reuse_port is force
     *   disabled and the user is warned. For UDP, it is enabled, but only one worker will receive
     *   packets. For QUIC/H3, SW routing will send packets to other workers. For "raw" UDP, only
     *   a single worker will currently receive packets.
     * * On Windows, reuse_port for TCP has undefined behavior. It is force disabled and the user
     *   is warned similar to macOS. It is left enabled for UDP with undefined behavior currently.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue enable_reuse_port = 29;</code>
     */
    public Builder mergeEnableReusePort(com.google.protobuf.BoolValue value) {
      if (enableReusePortBuilder_ == null) {
        if (((bitField0_ & 0x01000000) != 0) &&
          enableReusePort_ != null &&
          enableReusePort_ != com.google.protobuf.BoolValue.getDefaultInstance()) {
          getEnableReusePortBuilder().mergeFrom(value);
        } else {
          enableReusePort_ = value;
        }
      } else {
        enableReusePortBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x01000000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * When this flag is set to true, listeners set the ``SO_REUSEPORT`` socket option and
     * create one socket for each worker thread. This makes inbound connections
     * distribute among worker threads roughly evenly in cases where there are a high number
     * of connections. When this flag is set to false, all worker threads share one socket. This field
     * defaults to true. The change of field will be rejected during an listener update when the
     * runtime flag ``envoy.reloadable_features.enable_update_listener_socket_options`` is enabled.
     * Otherwise, the update of this field will be ignored quietly.
     * .. attention::
     *   Although this field defaults to true, it has different behavior on different platforms. See
     *   the following text for more information.
     * * On Linux, reuse_port is respected for both TCP and UDP listeners. It also works correctly
     *   with hot restart.
     * * On macOS, reuse_port for TCP does not do what it does on Linux. Instead of load balancing,
     *   the last socket wins and receives all connections/packets. For TCP, reuse_port is force
     *   disabled and the user is warned. For UDP, it is enabled, but only one worker will receive
     *   packets. For QUIC/H3, SW routing will send packets to other workers. For "raw" UDP, only
     *   a single worker will currently receive packets.
     * * On Windows, reuse_port for TCP has undefined behavior. It is force disabled and the user
     *   is warned similar to macOS. It is left enabled for UDP with undefined behavior currently.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue enable_reuse_port = 29;</code>
     */
    public Builder clearEnableReusePort() {
      bitField0_ = (bitField0_ & ~0x01000000);
      enableReusePort_ = null;
      if (enableReusePortBuilder_ != null) {
        enableReusePortBuilder_.dispose();
        enableReusePortBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * When this flag is set to true, listeners set the ``SO_REUSEPORT`` socket option and
     * create one socket for each worker thread. This makes inbound connections
     * distribute among worker threads roughly evenly in cases where there are a high number
     * of connections. When this flag is set to false, all worker threads share one socket. This field
     * defaults to true. The change of field will be rejected during an listener update when the
     * runtime flag ``envoy.reloadable_features.enable_update_listener_socket_options`` is enabled.
     * Otherwise, the update of this field will be ignored quietly.
     * .. attention::
     *   Although this field defaults to true, it has different behavior on different platforms. See
     *   the following text for more information.
     * * On Linux, reuse_port is respected for both TCP and UDP listeners. It also works correctly
     *   with hot restart.
     * * On macOS, reuse_port for TCP does not do what it does on Linux. Instead of load balancing,
     *   the last socket wins and receives all connections/packets. For TCP, reuse_port is force
     *   disabled and the user is warned. For UDP, it is enabled, but only one worker will receive
     *   packets. For QUIC/H3, SW routing will send packets to other workers. For "raw" UDP, only
     *   a single worker will currently receive packets.
     * * On Windows, reuse_port for TCP has undefined behavior. It is force disabled and the user
     *   is warned similar to macOS. It is left enabled for UDP with undefined behavior currently.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue enable_reuse_port = 29;</code>
     */
    public com.google.protobuf.BoolValue.Builder getEnableReusePortBuilder() {
      bitField0_ |= 0x01000000;
      onChanged();
      return getEnableReusePortFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * When this flag is set to true, listeners set the ``SO_REUSEPORT`` socket option and
     * create one socket for each worker thread. This makes inbound connections
     * distribute among worker threads roughly evenly in cases where there are a high number
     * of connections. When this flag is set to false, all worker threads share one socket. This field
     * defaults to true. The change of field will be rejected during an listener update when the
     * runtime flag ``envoy.reloadable_features.enable_update_listener_socket_options`` is enabled.
     * Otherwise, the update of this field will be ignored quietly.
     * .. attention::
     *   Although this field defaults to true, it has different behavior on different platforms. See
     *   the following text for more information.
     * * On Linux, reuse_port is respected for both TCP and UDP listeners. It also works correctly
     *   with hot restart.
     * * On macOS, reuse_port for TCP does not do what it does on Linux. Instead of load balancing,
     *   the last socket wins and receives all connections/packets. For TCP, reuse_port is force
     *   disabled and the user is warned. For UDP, it is enabled, but only one worker will receive
     *   packets. For QUIC/H3, SW routing will send packets to other workers. For "raw" UDP, only
     *   a single worker will currently receive packets.
     * * On Windows, reuse_port for TCP has undefined behavior. It is force disabled and the user
     *   is warned similar to macOS. It is left enabled for UDP with undefined behavior currently.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue enable_reuse_port = 29;</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getEnableReusePortOrBuilder() {
      if (enableReusePortBuilder_ != null) {
        return enableReusePortBuilder_.getMessageOrBuilder();
      } else {
        return enableReusePort_ == null ?
            com.google.protobuf.BoolValue.getDefaultInstance() : enableReusePort_;
      }
    }
    /**
     * <pre>
     * When this flag is set to true, listeners set the ``SO_REUSEPORT`` socket option and
     * create one socket for each worker thread. This makes inbound connections
     * distribute among worker threads roughly evenly in cases where there are a high number
     * of connections. When this flag is set to false, all worker threads share one socket. This field
     * defaults to true. The change of field will be rejected during an listener update when the
     * runtime flag ``envoy.reloadable_features.enable_update_listener_socket_options`` is enabled.
     * Otherwise, the update of this field will be ignored quietly.
     * .. attention::
     *   Although this field defaults to true, it has different behavior on different platforms. See
     *   the following text for more information.
     * * On Linux, reuse_port is respected for both TCP and UDP listeners. It also works correctly
     *   with hot restart.
     * * On macOS, reuse_port for TCP does not do what it does on Linux. Instead of load balancing,
     *   the last socket wins and receives all connections/packets. For TCP, reuse_port is force
     *   disabled and the user is warned. For UDP, it is enabled, but only one worker will receive
     *   packets. For QUIC/H3, SW routing will send packets to other workers. For "raw" UDP, only
     *   a single worker will currently receive packets.
     * * On Windows, reuse_port for TCP has undefined behavior. It is force disabled and the user
     *   is warned similar to macOS. It is left enabled for UDP with undefined behavior currently.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue enable_reuse_port = 29;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
        getEnableReusePortFieldBuilder() {
      if (enableReusePortBuilder_ == null) {
        enableReusePortBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                getEnableReusePort(),
                getParentForChildren(),
                isClean());
        enableReusePort_ = null;
      }
      return enableReusePortBuilder_;
    }

    private java.util.List<io.envoyproxy.envoy.config.accesslog.v3.AccessLog> accessLog_ =
      java.util.Collections.emptyList();
    private void ensureAccessLogIsMutable() {
      if (!((bitField0_ & 0x02000000) != 0)) {
        accessLog_ = new java.util.ArrayList<io.envoyproxy.envoy.config.accesslog.v3.AccessLog>(accessLog_);
        bitField0_ |= 0x02000000;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.accesslog.v3.AccessLog, io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder, io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder> accessLogBuilder_;

    /**
     * <pre>
     * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
     * emitted by this listener.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.accesslog.v3.AccessLog> getAccessLogList() {
      if (accessLogBuilder_ == null) {
        return java.util.Collections.unmodifiableList(accessLog_);
      } else {
        return accessLogBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
     * emitted by this listener.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
     */
    public int getAccessLogCount() {
      if (accessLogBuilder_ == null) {
        return accessLog_.size();
      } else {
        return accessLogBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
     * emitted by this listener.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
     */
    public io.envoyproxy.envoy.config.accesslog.v3.AccessLog getAccessLog(int index) {
      if (accessLogBuilder_ == null) {
        return accessLog_.get(index);
      } else {
        return accessLogBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
     * emitted by this listener.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
     */
    public Builder setAccessLog(
        int index, io.envoyproxy.envoy.config.accesslog.v3.AccessLog value) {
      if (accessLogBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAccessLogIsMutable();
        accessLog_.set(index, value);
        onChanged();
      } else {
        accessLogBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
     * emitted by this listener.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
     */
    public Builder setAccessLog(
        int index, io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder builderForValue) {
      if (accessLogBuilder_ == null) {
        ensureAccessLogIsMutable();
        accessLog_.set(index, builderForValue.build());
        onChanged();
      } else {
        accessLogBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
     * emitted by this listener.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
     */
    public Builder addAccessLog(io.envoyproxy.envoy.config.accesslog.v3.AccessLog value) {
      if (accessLogBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAccessLogIsMutable();
        accessLog_.add(value);
        onChanged();
      } else {
        accessLogBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
     * emitted by this listener.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
     */
    public Builder addAccessLog(
        int index, io.envoyproxy.envoy.config.accesslog.v3.AccessLog value) {
      if (accessLogBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAccessLogIsMutable();
        accessLog_.add(index, value);
        onChanged();
      } else {
        accessLogBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
     * emitted by this listener.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
     */
    public Builder addAccessLog(
        io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder builderForValue) {
      if (accessLogBuilder_ == null) {
        ensureAccessLogIsMutable();
        accessLog_.add(builderForValue.build());
        onChanged();
      } else {
        accessLogBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
     * emitted by this listener.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
     */
    public Builder addAccessLog(
        int index, io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder builderForValue) {
      if (accessLogBuilder_ == null) {
        ensureAccessLogIsMutable();
        accessLog_.add(index, builderForValue.build());
        onChanged();
      } else {
        accessLogBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
     * emitted by this listener.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
     */
    public Builder addAllAccessLog(
        java.lang.Iterable<? extends io.envoyproxy.envoy.config.accesslog.v3.AccessLog> values) {
      if (accessLogBuilder_ == null) {
        ensureAccessLogIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, accessLog_);
        onChanged();
      } else {
        accessLogBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
     * emitted by this listener.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
     */
    public Builder clearAccessLog() {
      if (accessLogBuilder_ == null) {
        accessLog_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x02000000);
        onChanged();
      } else {
        accessLogBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
     * emitted by this listener.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
     */
    public Builder removeAccessLog(int index) {
      if (accessLogBuilder_ == null) {
        ensureAccessLogIsMutable();
        accessLog_.remove(index);
        onChanged();
      } else {
        accessLogBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
     * emitted by this listener.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
     */
    public io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder getAccessLogBuilder(
        int index) {
      return getAccessLogFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
     * emitted by this listener.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
     */
    public io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder getAccessLogOrBuilder(
        int index) {
      if (accessLogBuilder_ == null) {
        return accessLog_.get(index);  } else {
        return accessLogBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
     * emitted by this listener.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
     */
    public java.util.List<? extends io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder> 
         getAccessLogOrBuilderList() {
      if (accessLogBuilder_ != null) {
        return accessLogBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(accessLog_);
      }
    }
    /**
     * <pre>
     * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
     * emitted by this listener.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
     */
    public io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder addAccessLogBuilder() {
      return getAccessLogFieldBuilder().addBuilder(
          io.envoyproxy.envoy.config.accesslog.v3.AccessLog.getDefaultInstance());
    }
    /**
     * <pre>
     * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
     * emitted by this listener.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
     */
    public io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder addAccessLogBuilder(
        int index) {
      return getAccessLogFieldBuilder().addBuilder(
          index, io.envoyproxy.envoy.config.accesslog.v3.AccessLog.getDefaultInstance());
    }
    /**
     * <pre>
     * Configuration for :ref:`access logs &lt;arch_overview_access_logs&gt;`
     * emitted by this listener.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 22;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder> 
         getAccessLogBuilderList() {
      return getAccessLogFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.accesslog.v3.AccessLog, io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder, io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder> 
        getAccessLogFieldBuilder() {
      if (accessLogBuilder_ == null) {
        accessLogBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.envoyproxy.envoy.config.accesslog.v3.AccessLog, io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder, io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder>(
                accessLog_,
                ((bitField0_ & 0x02000000) != 0),
                getParentForChildren(),
                isClean());
        accessLog_ = null;
      }
      return accessLogBuilder_;
    }

    private com.google.protobuf.UInt32Value tcpBacklogSize_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> tcpBacklogSizeBuilder_;
    /**
     * <pre>
     * The maximum length a tcp listener's pending connections queue can grow to. If no value is
     * provided net.core.somaxconn will be used on Linux and 128 otherwise.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value tcp_backlog_size = 24;</code>
     * @return Whether the tcpBacklogSize field is set.
     */
    public boolean hasTcpBacklogSize() {
      return ((bitField0_ & 0x04000000) != 0);
    }
    /**
     * <pre>
     * The maximum length a tcp listener's pending connections queue can grow to. If no value is
     * provided net.core.somaxconn will be used on Linux and 128 otherwise.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value tcp_backlog_size = 24;</code>
     * @return The tcpBacklogSize.
     */
    public com.google.protobuf.UInt32Value getTcpBacklogSize() {
      if (tcpBacklogSizeBuilder_ == null) {
        return tcpBacklogSize_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : tcpBacklogSize_;
      } else {
        return tcpBacklogSizeBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The maximum length a tcp listener's pending connections queue can grow to. If no value is
     * provided net.core.somaxconn will be used on Linux and 128 otherwise.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value tcp_backlog_size = 24;</code>
     */
    public Builder setTcpBacklogSize(com.google.protobuf.UInt32Value value) {
      if (tcpBacklogSizeBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        tcpBacklogSize_ = value;
      } else {
        tcpBacklogSizeBuilder_.setMessage(value);
      }
      bitField0_ |= 0x04000000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The maximum length a tcp listener's pending connections queue can grow to. If no value is
     * provided net.core.somaxconn will be used on Linux and 128 otherwise.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value tcp_backlog_size = 24;</code>
     */
    public Builder setTcpBacklogSize(
        com.google.protobuf.UInt32Value.Builder builderForValue) {
      if (tcpBacklogSizeBuilder_ == null) {
        tcpBacklogSize_ = builderForValue.build();
      } else {
        tcpBacklogSizeBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x04000000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The maximum length a tcp listener's pending connections queue can grow to. If no value is
     * provided net.core.somaxconn will be used on Linux and 128 otherwise.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value tcp_backlog_size = 24;</code>
     */
    public Builder mergeTcpBacklogSize(com.google.protobuf.UInt32Value value) {
      if (tcpBacklogSizeBuilder_ == null) {
        if (((bitField0_ & 0x04000000) != 0) &&
          tcpBacklogSize_ != null &&
          tcpBacklogSize_ != com.google.protobuf.UInt32Value.getDefaultInstance()) {
          getTcpBacklogSizeBuilder().mergeFrom(value);
        } else {
          tcpBacklogSize_ = value;
        }
      } else {
        tcpBacklogSizeBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x04000000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The maximum length a tcp listener's pending connections queue can grow to. If no value is
     * provided net.core.somaxconn will be used on Linux and 128 otherwise.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value tcp_backlog_size = 24;</code>
     */
    public Builder clearTcpBacklogSize() {
      bitField0_ = (bitField0_ & ~0x04000000);
      tcpBacklogSize_ = null;
      if (tcpBacklogSizeBuilder_ != null) {
        tcpBacklogSizeBuilder_.dispose();
        tcpBacklogSizeBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The maximum length a tcp listener's pending connections queue can grow to. If no value is
     * provided net.core.somaxconn will be used on Linux and 128 otherwise.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value tcp_backlog_size = 24;</code>
     */
    public com.google.protobuf.UInt32Value.Builder getTcpBacklogSizeBuilder() {
      bitField0_ |= 0x04000000;
      onChanged();
      return getTcpBacklogSizeFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The maximum length a tcp listener's pending connections queue can grow to. If no value is
     * provided net.core.somaxconn will be used on Linux and 128 otherwise.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value tcp_backlog_size = 24;</code>
     */
    public com.google.protobuf.UInt32ValueOrBuilder getTcpBacklogSizeOrBuilder() {
      if (tcpBacklogSizeBuilder_ != null) {
        return tcpBacklogSizeBuilder_.getMessageOrBuilder();
      } else {
        return tcpBacklogSize_ == null ?
            com.google.protobuf.UInt32Value.getDefaultInstance() : tcpBacklogSize_;
      }
    }
    /**
     * <pre>
     * The maximum length a tcp listener's pending connections queue can grow to. If no value is
     * provided net.core.somaxconn will be used on Linux and 128 otherwise.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value tcp_backlog_size = 24;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
        getTcpBacklogSizeFieldBuilder() {
      if (tcpBacklogSizeBuilder_ == null) {
        tcpBacklogSizeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                getTcpBacklogSize(),
                getParentForChildren(),
                isClean());
        tcpBacklogSize_ = null;
      }
      return tcpBacklogSizeBuilder_;
    }

    private com.google.protobuf.BoolValue bindToPort_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> bindToPortBuilder_;
    /**
     * <pre>
     * Whether the listener should bind to the port. A listener that doesn't
     * bind can only receive connections redirected from other listeners that set
     * :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;`
     * to true. Default is true.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue bind_to_port = 26;</code>
     * @return Whether the bindToPort field is set.
     */
    public boolean hasBindToPort() {
      return ((bitField0_ & 0x08000000) != 0);
    }
    /**
     * <pre>
     * Whether the listener should bind to the port. A listener that doesn't
     * bind can only receive connections redirected from other listeners that set
     * :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;`
     * to true. Default is true.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue bind_to_port = 26;</code>
     * @return The bindToPort.
     */
    public com.google.protobuf.BoolValue getBindToPort() {
      if (bindToPortBuilder_ == null) {
        return bindToPort_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : bindToPort_;
      } else {
        return bindToPortBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Whether the listener should bind to the port. A listener that doesn't
     * bind can only receive connections redirected from other listeners that set
     * :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;`
     * to true. Default is true.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue bind_to_port = 26;</code>
     */
    public Builder setBindToPort(com.google.protobuf.BoolValue value) {
      if (bindToPortBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        bindToPort_ = value;
      } else {
        bindToPortBuilder_.setMessage(value);
      }
      bitField0_ |= 0x08000000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the listener should bind to the port. A listener that doesn't
     * bind can only receive connections redirected from other listeners that set
     * :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;`
     * to true. Default is true.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue bind_to_port = 26;</code>
     */
    public Builder setBindToPort(
        com.google.protobuf.BoolValue.Builder builderForValue) {
      if (bindToPortBuilder_ == null) {
        bindToPort_ = builderForValue.build();
      } else {
        bindToPortBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x08000000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the listener should bind to the port. A listener that doesn't
     * bind can only receive connections redirected from other listeners that set
     * :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;`
     * to true. Default is true.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue bind_to_port = 26;</code>
     */
    public Builder mergeBindToPort(com.google.protobuf.BoolValue value) {
      if (bindToPortBuilder_ == null) {
        if (((bitField0_ & 0x08000000) != 0) &&
          bindToPort_ != null &&
          bindToPort_ != com.google.protobuf.BoolValue.getDefaultInstance()) {
          getBindToPortBuilder().mergeFrom(value);
        } else {
          bindToPort_ = value;
        }
      } else {
        bindToPortBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x08000000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the listener should bind to the port. A listener that doesn't
     * bind can only receive connections redirected from other listeners that set
     * :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;`
     * to true. Default is true.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue bind_to_port = 26;</code>
     */
    public Builder clearBindToPort() {
      bitField0_ = (bitField0_ & ~0x08000000);
      bindToPort_ = null;
      if (bindToPortBuilder_ != null) {
        bindToPortBuilder_.dispose();
        bindToPortBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the listener should bind to the port. A listener that doesn't
     * bind can only receive connections redirected from other listeners that set
     * :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;`
     * to true. Default is true.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue bind_to_port = 26;</code>
     */
    public com.google.protobuf.BoolValue.Builder getBindToPortBuilder() {
      bitField0_ |= 0x08000000;
      onChanged();
      return getBindToPortFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Whether the listener should bind to the port. A listener that doesn't
     * bind can only receive connections redirected from other listeners that set
     * :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;`
     * to true. Default is true.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue bind_to_port = 26;</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getBindToPortOrBuilder() {
      if (bindToPortBuilder_ != null) {
        return bindToPortBuilder_.getMessageOrBuilder();
      } else {
        return bindToPort_ == null ?
            com.google.protobuf.BoolValue.getDefaultInstance() : bindToPort_;
      }
    }
    /**
     * <pre>
     * Whether the listener should bind to the port. A listener that doesn't
     * bind can only receive connections redirected from other listeners that set
     * :ref:`use_original_dst &lt;envoy_v3_api_field_config.listener.v3.Listener.use_original_dst&gt;`
     * to true. Default is true.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue bind_to_port = 26;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
        getBindToPortFieldBuilder() {
      if (bindToPortBuilder_ == null) {
        bindToPortBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                getBindToPort(),
                getParentForChildren(),
                isClean());
        bindToPort_ = null;
      }
      return bindToPortBuilder_;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig, io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig.Builder, io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfigOrBuilder> internalListenerBuilder_;
    /**
     * <pre>
     * Used to represent an internal listener which does not listen on OSI L4 address but can be used by the
     * :ref:`envoy cluster &lt;envoy_v3_api_msg_config.cluster.v3.Cluster&gt;` to create a user space connection to.
     * The internal listener acts as a TCP listener. It supports listener filters and network filter chains.
     * Upstream clusters refer to the internal listeners by their :ref:`name
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`. :ref:`Address
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.address&gt;` must not be set on the internal listeners.
     * There are some limitations that are derived from the implementation. The known limitations include:
     * * :ref:`ConnectionBalanceConfig &lt;envoy_v3_api_msg_config.listener.v3.Listener.ConnectionBalanceConfig&gt;` is not
     *   allowed because both the cluster connection and the listener connection must be owned by the same dispatcher.
     * * :ref:`tcp_backlog_size &lt;envoy_v3_api_field_config.listener.v3.Listener.tcp_backlog_size&gt;`
     * * :ref:`freebind &lt;envoy_v3_api_field_config.listener.v3.Listener.freebind&gt;`
     * * :ref:`transparent &lt;envoy_v3_api_field_config.listener.v3.Listener.transparent&gt;`
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.InternalListenerConfig internal_listener = 27;</code>
     * @return Whether the internalListener field is set.
     */
    @java.lang.Override
    public boolean hasInternalListener() {
      return listenerSpecifierCase_ == 27;
    }
    /**
     * <pre>
     * Used to represent an internal listener which does not listen on OSI L4 address but can be used by the
     * :ref:`envoy cluster &lt;envoy_v3_api_msg_config.cluster.v3.Cluster&gt;` to create a user space connection to.
     * The internal listener acts as a TCP listener. It supports listener filters and network filter chains.
     * Upstream clusters refer to the internal listeners by their :ref:`name
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`. :ref:`Address
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.address&gt;` must not be set on the internal listeners.
     * There are some limitations that are derived from the implementation. The known limitations include:
     * * :ref:`ConnectionBalanceConfig &lt;envoy_v3_api_msg_config.listener.v3.Listener.ConnectionBalanceConfig&gt;` is not
     *   allowed because both the cluster connection and the listener connection must be owned by the same dispatcher.
     * * :ref:`tcp_backlog_size &lt;envoy_v3_api_field_config.listener.v3.Listener.tcp_backlog_size&gt;`
     * * :ref:`freebind &lt;envoy_v3_api_field_config.listener.v3.Listener.freebind&gt;`
     * * :ref:`transparent &lt;envoy_v3_api_field_config.listener.v3.Listener.transparent&gt;`
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.InternalListenerConfig internal_listener = 27;</code>
     * @return The internalListener.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig getInternalListener() {
      if (internalListenerBuilder_ == null) {
        if (listenerSpecifierCase_ == 27) {
          return (io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig) listenerSpecifier_;
        }
        return io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig.getDefaultInstance();
      } else {
        if (listenerSpecifierCase_ == 27) {
          return internalListenerBuilder_.getMessage();
        }
        return io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * Used to represent an internal listener which does not listen on OSI L4 address but can be used by the
     * :ref:`envoy cluster &lt;envoy_v3_api_msg_config.cluster.v3.Cluster&gt;` to create a user space connection to.
     * The internal listener acts as a TCP listener. It supports listener filters and network filter chains.
     * Upstream clusters refer to the internal listeners by their :ref:`name
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`. :ref:`Address
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.address&gt;` must not be set on the internal listeners.
     * There are some limitations that are derived from the implementation. The known limitations include:
     * * :ref:`ConnectionBalanceConfig &lt;envoy_v3_api_msg_config.listener.v3.Listener.ConnectionBalanceConfig&gt;` is not
     *   allowed because both the cluster connection and the listener connection must be owned by the same dispatcher.
     * * :ref:`tcp_backlog_size &lt;envoy_v3_api_field_config.listener.v3.Listener.tcp_backlog_size&gt;`
     * * :ref:`freebind &lt;envoy_v3_api_field_config.listener.v3.Listener.freebind&gt;`
     * * :ref:`transparent &lt;envoy_v3_api_field_config.listener.v3.Listener.transparent&gt;`
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.InternalListenerConfig internal_listener = 27;</code>
     */
    public Builder setInternalListener(io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig value) {
      if (internalListenerBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        listenerSpecifier_ = value;
        onChanged();
      } else {
        internalListenerBuilder_.setMessage(value);
      }
      listenerSpecifierCase_ = 27;
      return this;
    }
    /**
     * <pre>
     * Used to represent an internal listener which does not listen on OSI L4 address but can be used by the
     * :ref:`envoy cluster &lt;envoy_v3_api_msg_config.cluster.v3.Cluster&gt;` to create a user space connection to.
     * The internal listener acts as a TCP listener. It supports listener filters and network filter chains.
     * Upstream clusters refer to the internal listeners by their :ref:`name
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`. :ref:`Address
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.address&gt;` must not be set on the internal listeners.
     * There are some limitations that are derived from the implementation. The known limitations include:
     * * :ref:`ConnectionBalanceConfig &lt;envoy_v3_api_msg_config.listener.v3.Listener.ConnectionBalanceConfig&gt;` is not
     *   allowed because both the cluster connection and the listener connection must be owned by the same dispatcher.
     * * :ref:`tcp_backlog_size &lt;envoy_v3_api_field_config.listener.v3.Listener.tcp_backlog_size&gt;`
     * * :ref:`freebind &lt;envoy_v3_api_field_config.listener.v3.Listener.freebind&gt;`
     * * :ref:`transparent &lt;envoy_v3_api_field_config.listener.v3.Listener.transparent&gt;`
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.InternalListenerConfig internal_listener = 27;</code>
     */
    public Builder setInternalListener(
        io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig.Builder builderForValue) {
      if (internalListenerBuilder_ == null) {
        listenerSpecifier_ = builderForValue.build();
        onChanged();
      } else {
        internalListenerBuilder_.setMessage(builderForValue.build());
      }
      listenerSpecifierCase_ = 27;
      return this;
    }
    /**
     * <pre>
     * Used to represent an internal listener which does not listen on OSI L4 address but can be used by the
     * :ref:`envoy cluster &lt;envoy_v3_api_msg_config.cluster.v3.Cluster&gt;` to create a user space connection to.
     * The internal listener acts as a TCP listener. It supports listener filters and network filter chains.
     * Upstream clusters refer to the internal listeners by their :ref:`name
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`. :ref:`Address
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.address&gt;` must not be set on the internal listeners.
     * There are some limitations that are derived from the implementation. The known limitations include:
     * * :ref:`ConnectionBalanceConfig &lt;envoy_v3_api_msg_config.listener.v3.Listener.ConnectionBalanceConfig&gt;` is not
     *   allowed because both the cluster connection and the listener connection must be owned by the same dispatcher.
     * * :ref:`tcp_backlog_size &lt;envoy_v3_api_field_config.listener.v3.Listener.tcp_backlog_size&gt;`
     * * :ref:`freebind &lt;envoy_v3_api_field_config.listener.v3.Listener.freebind&gt;`
     * * :ref:`transparent &lt;envoy_v3_api_field_config.listener.v3.Listener.transparent&gt;`
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.InternalListenerConfig internal_listener = 27;</code>
     */
    public Builder mergeInternalListener(io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig value) {
      if (internalListenerBuilder_ == null) {
        if (listenerSpecifierCase_ == 27 &&
            listenerSpecifier_ != io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig.getDefaultInstance()) {
          listenerSpecifier_ = io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig.newBuilder((io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig) listenerSpecifier_)
              .mergeFrom(value).buildPartial();
        } else {
          listenerSpecifier_ = value;
        }
        onChanged();
      } else {
        if (listenerSpecifierCase_ == 27) {
          internalListenerBuilder_.mergeFrom(value);
        } else {
          internalListenerBuilder_.setMessage(value);
        }
      }
      listenerSpecifierCase_ = 27;
      return this;
    }
    /**
     * <pre>
     * Used to represent an internal listener which does not listen on OSI L4 address but can be used by the
     * :ref:`envoy cluster &lt;envoy_v3_api_msg_config.cluster.v3.Cluster&gt;` to create a user space connection to.
     * The internal listener acts as a TCP listener. It supports listener filters and network filter chains.
     * Upstream clusters refer to the internal listeners by their :ref:`name
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`. :ref:`Address
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.address&gt;` must not be set on the internal listeners.
     * There are some limitations that are derived from the implementation. The known limitations include:
     * * :ref:`ConnectionBalanceConfig &lt;envoy_v3_api_msg_config.listener.v3.Listener.ConnectionBalanceConfig&gt;` is not
     *   allowed because both the cluster connection and the listener connection must be owned by the same dispatcher.
     * * :ref:`tcp_backlog_size &lt;envoy_v3_api_field_config.listener.v3.Listener.tcp_backlog_size&gt;`
     * * :ref:`freebind &lt;envoy_v3_api_field_config.listener.v3.Listener.freebind&gt;`
     * * :ref:`transparent &lt;envoy_v3_api_field_config.listener.v3.Listener.transparent&gt;`
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.InternalListenerConfig internal_listener = 27;</code>
     */
    public Builder clearInternalListener() {
      if (internalListenerBuilder_ == null) {
        if (listenerSpecifierCase_ == 27) {
          listenerSpecifierCase_ = 0;
          listenerSpecifier_ = null;
          onChanged();
        }
      } else {
        if (listenerSpecifierCase_ == 27) {
          listenerSpecifierCase_ = 0;
          listenerSpecifier_ = null;
        }
        internalListenerBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * Used to represent an internal listener which does not listen on OSI L4 address but can be used by the
     * :ref:`envoy cluster &lt;envoy_v3_api_msg_config.cluster.v3.Cluster&gt;` to create a user space connection to.
     * The internal listener acts as a TCP listener. It supports listener filters and network filter chains.
     * Upstream clusters refer to the internal listeners by their :ref:`name
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`. :ref:`Address
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.address&gt;` must not be set on the internal listeners.
     * There are some limitations that are derived from the implementation. The known limitations include:
     * * :ref:`ConnectionBalanceConfig &lt;envoy_v3_api_msg_config.listener.v3.Listener.ConnectionBalanceConfig&gt;` is not
     *   allowed because both the cluster connection and the listener connection must be owned by the same dispatcher.
     * * :ref:`tcp_backlog_size &lt;envoy_v3_api_field_config.listener.v3.Listener.tcp_backlog_size&gt;`
     * * :ref:`freebind &lt;envoy_v3_api_field_config.listener.v3.Listener.freebind&gt;`
     * * :ref:`transparent &lt;envoy_v3_api_field_config.listener.v3.Listener.transparent&gt;`
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.InternalListenerConfig internal_listener = 27;</code>
     */
    public io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig.Builder getInternalListenerBuilder() {
      return getInternalListenerFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Used to represent an internal listener which does not listen on OSI L4 address but can be used by the
     * :ref:`envoy cluster &lt;envoy_v3_api_msg_config.cluster.v3.Cluster&gt;` to create a user space connection to.
     * The internal listener acts as a TCP listener. It supports listener filters and network filter chains.
     * Upstream clusters refer to the internal listeners by their :ref:`name
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`. :ref:`Address
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.address&gt;` must not be set on the internal listeners.
     * There are some limitations that are derived from the implementation. The known limitations include:
     * * :ref:`ConnectionBalanceConfig &lt;envoy_v3_api_msg_config.listener.v3.Listener.ConnectionBalanceConfig&gt;` is not
     *   allowed because both the cluster connection and the listener connection must be owned by the same dispatcher.
     * * :ref:`tcp_backlog_size &lt;envoy_v3_api_field_config.listener.v3.Listener.tcp_backlog_size&gt;`
     * * :ref:`freebind &lt;envoy_v3_api_field_config.listener.v3.Listener.freebind&gt;`
     * * :ref:`transparent &lt;envoy_v3_api_field_config.listener.v3.Listener.transparent&gt;`
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.InternalListenerConfig internal_listener = 27;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfigOrBuilder getInternalListenerOrBuilder() {
      if ((listenerSpecifierCase_ == 27) && (internalListenerBuilder_ != null)) {
        return internalListenerBuilder_.getMessageOrBuilder();
      } else {
        if (listenerSpecifierCase_ == 27) {
          return (io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig) listenerSpecifier_;
        }
        return io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * Used to represent an internal listener which does not listen on OSI L4 address but can be used by the
     * :ref:`envoy cluster &lt;envoy_v3_api_msg_config.cluster.v3.Cluster&gt;` to create a user space connection to.
     * The internal listener acts as a TCP listener. It supports listener filters and network filter chains.
     * Upstream clusters refer to the internal listeners by their :ref:`name
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.name&gt;`. :ref:`Address
     * &lt;envoy_v3_api_field_config.listener.v3.Listener.address&gt;` must not be set on the internal listeners.
     * There are some limitations that are derived from the implementation. The known limitations include:
     * * :ref:`ConnectionBalanceConfig &lt;envoy_v3_api_msg_config.listener.v3.Listener.ConnectionBalanceConfig&gt;` is not
     *   allowed because both the cluster connection and the listener connection must be owned by the same dispatcher.
     * * :ref:`tcp_backlog_size &lt;envoy_v3_api_field_config.listener.v3.Listener.tcp_backlog_size&gt;`
     * * :ref:`freebind &lt;envoy_v3_api_field_config.listener.v3.Listener.freebind&gt;`
     * * :ref:`transparent &lt;envoy_v3_api_field_config.listener.v3.Listener.transparent&gt;`
     * </pre>
     *
     * <code>.envoy.config.listener.v3.Listener.InternalListenerConfig internal_listener = 27;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig, io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig.Builder, io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfigOrBuilder> 
        getInternalListenerFieldBuilder() {
      if (internalListenerBuilder_ == null) {
        if (!(listenerSpecifierCase_ == 27)) {
          listenerSpecifier_ = io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig.getDefaultInstance();
        }
        internalListenerBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig, io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig.Builder, io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfigOrBuilder>(
                (io.envoyproxy.envoy.config.listener.v3.Listener.InternalListenerConfig) listenerSpecifier_,
                getParentForChildren(),
                isClean());
        listenerSpecifier_ = null;
      }
      listenerSpecifierCase_ = 27;
      onChanged();
      return internalListenerBuilder_;
    }

    private boolean enableMptcp_ ;
    /**
     * <pre>
     * Enable MPTCP (multi-path TCP) on this listener. Clients will be allowed to establish
     * MPTCP connections. Non-MPTCP clients will fall back to regular TCP.
     * </pre>
     *
     * <code>bool enable_mptcp = 30;</code>
     * @return The enableMptcp.
     */
    @java.lang.Override
    public boolean getEnableMptcp() {
      return enableMptcp_;
    }
    /**
     * <pre>
     * Enable MPTCP (multi-path TCP) on this listener. Clients will be allowed to establish
     * MPTCP connections. Non-MPTCP clients will fall back to regular TCP.
     * </pre>
     *
     * <code>bool enable_mptcp = 30;</code>
     * @param value The enableMptcp to set.
     * @return This builder for chaining.
     */
    public Builder setEnableMptcp(boolean value) {
      
      enableMptcp_ = value;
      bitField0_ |= 0x20000000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Enable MPTCP (multi-path TCP) on this listener. Clients will be allowed to establish
     * MPTCP connections. Non-MPTCP clients will fall back to regular TCP.
     * </pre>
     *
     * <code>bool enable_mptcp = 30;</code>
     * @return This builder for chaining.
     */
    public Builder clearEnableMptcp() {
      bitField0_ = (bitField0_ & ~0x20000000);
      enableMptcp_ = false;
      onChanged();
      return this;
    }

    private boolean ignoreGlobalConnLimit_ ;
    /**
     * <pre>
     * Whether the listener should limit connections based upon the value of
     * :ref:`global_downstream_max_connections &lt;config_overload_manager_limiting_connections&gt;`.
     * </pre>
     *
     * <code>bool ignore_global_conn_limit = 31;</code>
     * @return The ignoreGlobalConnLimit.
     */
    @java.lang.Override
    public boolean getIgnoreGlobalConnLimit() {
      return ignoreGlobalConnLimit_;
    }
    /**
     * <pre>
     * Whether the listener should limit connections based upon the value of
     * :ref:`global_downstream_max_connections &lt;config_overload_manager_limiting_connections&gt;`.
     * </pre>
     *
     * <code>bool ignore_global_conn_limit = 31;</code>
     * @param value The ignoreGlobalConnLimit to set.
     * @return This builder for chaining.
     */
    public Builder setIgnoreGlobalConnLimit(boolean value) {
      
      ignoreGlobalConnLimit_ = value;
      bitField0_ |= 0x40000000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the listener should limit connections based upon the value of
     * :ref:`global_downstream_max_connections &lt;config_overload_manager_limiting_connections&gt;`.
     * </pre>
     *
     * <code>bool ignore_global_conn_limit = 31;</code>
     * @return This builder for chaining.
     */
    public Builder clearIgnoreGlobalConnLimit() {
      bitField0_ = (bitField0_ & ~0x40000000);
      ignoreGlobalConnLimit_ = false;
      onChanged();
      return this;
    }
    @java.lang.Override
    public final Builder setUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }


    // @@protoc_insertion_point(builder_scope:envoy.config.listener.v3.Listener)
  }

  // @@protoc_insertion_point(class_scope:envoy.config.listener.v3.Listener)
  private static final io.envoyproxy.envoy.config.listener.v3.Listener DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.listener.v3.Listener();
  }

  public static io.envoyproxy.envoy.config.listener.v3.Listener getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<Listener>
      PARSER = new com.google.protobuf.AbstractParser<Listener>() {
    @java.lang.Override
    public Listener parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      Builder builder = newBuilder();
      try {
        builder.mergeFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(builder.buildPartial());
      } catch (com.google.protobuf.UninitializedMessageException e) {
        throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e)
            .setUnfinishedMessage(builder.buildPartial());
      }
      return builder.buildPartial();
    }
  };

  public static com.google.protobuf.Parser<Listener> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<Listener> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public io.envoyproxy.envoy.config.listener.v3.Listener getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}

