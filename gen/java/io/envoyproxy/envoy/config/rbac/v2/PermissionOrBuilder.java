// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/config/rbac/v2/rbac.proto

package io.envoyproxy.envoy.config.rbac.v2;

public interface PermissionOrBuilder extends
    // @@protoc_insertion_point(interface_extends:envoy.config.rbac.v2.Permission)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * A set of rules that all must match in order to define the action.
   * </pre>
   *
   * <code>.envoy.config.rbac.v2.Permission.Set and_rules = 1;</code>
   * @return Whether the andRules field is set.
   */
  boolean hasAndRules();
  /**
   * <pre>
   * A set of rules that all must match in order to define the action.
   * </pre>
   *
   * <code>.envoy.config.rbac.v2.Permission.Set and_rules = 1;</code>
   * @return The andRules.
   */
  io.envoyproxy.envoy.config.rbac.v2.Permission.Set getAndRules();
  /**
   * <pre>
   * A set of rules that all must match in order to define the action.
   * </pre>
   *
   * <code>.envoy.config.rbac.v2.Permission.Set and_rules = 1;</code>
   */
  io.envoyproxy.envoy.config.rbac.v2.Permission.SetOrBuilder getAndRulesOrBuilder();

  /**
   * <pre>
   * A set of rules where at least one must match in order to define the action.
   * </pre>
   *
   * <code>.envoy.config.rbac.v2.Permission.Set or_rules = 2;</code>
   * @return Whether the orRules field is set.
   */
  boolean hasOrRules();
  /**
   * <pre>
   * A set of rules where at least one must match in order to define the action.
   * </pre>
   *
   * <code>.envoy.config.rbac.v2.Permission.Set or_rules = 2;</code>
   * @return The orRules.
   */
  io.envoyproxy.envoy.config.rbac.v2.Permission.Set getOrRules();
  /**
   * <pre>
   * A set of rules where at least one must match in order to define the action.
   * </pre>
   *
   * <code>.envoy.config.rbac.v2.Permission.Set or_rules = 2;</code>
   */
  io.envoyproxy.envoy.config.rbac.v2.Permission.SetOrBuilder getOrRulesOrBuilder();

  /**
   * <pre>
   * When any is set, it matches any action.
   * </pre>
   *
   * <code>bool any = 3 [(.validate.rules) = { ... }</code>
   * @return Whether the any field is set.
   */
  boolean hasAny();
  /**
   * <pre>
   * When any is set, it matches any action.
   * </pre>
   *
   * <code>bool any = 3 [(.validate.rules) = { ... }</code>
   * @return The any.
   */
  boolean getAny();

  /**
   * <pre>
   * A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
   * available for HTTP request.
   * Note: the pseudo-header :path includes the query and fragment string. Use the `url_path`
   * field if you want to match the URL path without the query and fragment string.
   * </pre>
   *
   * <code>.envoy.api.v2.route.HeaderMatcher header = 4;</code>
   * @return Whether the header field is set.
   */
  boolean hasHeader();
  /**
   * <pre>
   * A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
   * available for HTTP request.
   * Note: the pseudo-header :path includes the query and fragment string. Use the `url_path`
   * field if you want to match the URL path without the query and fragment string.
   * </pre>
   *
   * <code>.envoy.api.v2.route.HeaderMatcher header = 4;</code>
   * @return The header.
   */
  io.envoyproxy.envoy.api.v2.route.HeaderMatcher getHeader();
  /**
   * <pre>
   * A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
   * available for HTTP request.
   * Note: the pseudo-header :path includes the query and fragment string. Use the `url_path`
   * field if you want to match the URL path without the query and fragment string.
   * </pre>
   *
   * <code>.envoy.api.v2.route.HeaderMatcher header = 4;</code>
   */
  io.envoyproxy.envoy.api.v2.route.HeaderMatcherOrBuilder getHeaderOrBuilder();

  /**
   * <pre>
   * A URL path on the incoming HTTP request. Only available for HTTP.
   * </pre>
   *
   * <code>.envoy.type.matcher.PathMatcher url_path = 10;</code>
   * @return Whether the urlPath field is set.
   */
  boolean hasUrlPath();
  /**
   * <pre>
   * A URL path on the incoming HTTP request. Only available for HTTP.
   * </pre>
   *
   * <code>.envoy.type.matcher.PathMatcher url_path = 10;</code>
   * @return The urlPath.
   */
  io.envoyproxy.envoy.type.matcher.PathMatcher getUrlPath();
  /**
   * <pre>
   * A URL path on the incoming HTTP request. Only available for HTTP.
   * </pre>
   *
   * <code>.envoy.type.matcher.PathMatcher url_path = 10;</code>
   */
  io.envoyproxy.envoy.type.matcher.PathMatcherOrBuilder getUrlPathOrBuilder();

  /**
   * <pre>
   * A CIDR block that describes the destination IP.
   * </pre>
   *
   * <code>.envoy.api.v2.core.CidrRange destination_ip = 5;</code>
   * @return Whether the destinationIp field is set.
   */
  boolean hasDestinationIp();
  /**
   * <pre>
   * A CIDR block that describes the destination IP.
   * </pre>
   *
   * <code>.envoy.api.v2.core.CidrRange destination_ip = 5;</code>
   * @return The destinationIp.
   */
  io.envoyproxy.envoy.api.v2.core.CidrRange getDestinationIp();
  /**
   * <pre>
   * A CIDR block that describes the destination IP.
   * </pre>
   *
   * <code>.envoy.api.v2.core.CidrRange destination_ip = 5;</code>
   */
  io.envoyproxy.envoy.api.v2.core.CidrRangeOrBuilder getDestinationIpOrBuilder();

  /**
   * <pre>
   * A port number that describes the destination port connecting to.
   * </pre>
   *
   * <code>uint32 destination_port = 6 [(.validate.rules) = { ... }</code>
   * @return Whether the destinationPort field is set.
   */
  boolean hasDestinationPort();
  /**
   * <pre>
   * A port number that describes the destination port connecting to.
   * </pre>
   *
   * <code>uint32 destination_port = 6 [(.validate.rules) = { ... }</code>
   * @return The destinationPort.
   */
  int getDestinationPort();

  /**
   * <pre>
   * Metadata that describes additional information about the action.
   * </pre>
   *
   * <code>.envoy.type.matcher.MetadataMatcher metadata = 7;</code>
   * @return Whether the metadata field is set.
   */
  boolean hasMetadata();
  /**
   * <pre>
   * Metadata that describes additional information about the action.
   * </pre>
   *
   * <code>.envoy.type.matcher.MetadataMatcher metadata = 7;</code>
   * @return The metadata.
   */
  io.envoyproxy.envoy.type.matcher.MetadataMatcher getMetadata();
  /**
   * <pre>
   * Metadata that describes additional information about the action.
   * </pre>
   *
   * <code>.envoy.type.matcher.MetadataMatcher metadata = 7;</code>
   */
  io.envoyproxy.envoy.type.matcher.MetadataMatcherOrBuilder getMetadataOrBuilder();

  /**
   * <pre>
   * Negates matching the provided permission. For instance, if the value of `not_rule` would
   * match, this permission would not match. Conversely, if the value of `not_rule` would not
   * match, this permission would match.
   * </pre>
   *
   * <code>.envoy.config.rbac.v2.Permission not_rule = 8;</code>
   * @return Whether the notRule field is set.
   */
  boolean hasNotRule();
  /**
   * <pre>
   * Negates matching the provided permission. For instance, if the value of `not_rule` would
   * match, this permission would not match. Conversely, if the value of `not_rule` would not
   * match, this permission would match.
   * </pre>
   *
   * <code>.envoy.config.rbac.v2.Permission not_rule = 8;</code>
   * @return The notRule.
   */
  io.envoyproxy.envoy.config.rbac.v2.Permission getNotRule();
  /**
   * <pre>
   * Negates matching the provided permission. For instance, if the value of `not_rule` would
   * match, this permission would not match. Conversely, if the value of `not_rule` would not
   * match, this permission would match.
   * </pre>
   *
   * <code>.envoy.config.rbac.v2.Permission not_rule = 8;</code>
   */
  io.envoyproxy.envoy.config.rbac.v2.PermissionOrBuilder getNotRuleOrBuilder();

  /**
   * <pre>
   * The request server from the client's connection request. This is
   * typically TLS SNI.
   * .. attention::
   *   The behavior of this field may be affected by how Envoy is configured
   *   as explained below.
   *   * If the :ref:`TLS Inspector &lt;config_listener_filters_tls_inspector&gt;`
   *     filter is not added, and if a `FilterChainMatch` is not defined for
   *     the :ref:`server name &lt;envoy_api_field_listener.FilterChainMatch.server_names&gt;`,
   *     a TLS connection's requested SNI server name will be treated as if it
   *     wasn't present.
   *   * A :ref:`listener filter &lt;arch_overview_listener_filters&gt;` may
   *     overwrite a connection's requested server name within Envoy.
   * Please refer to :ref:`this FAQ entry &lt;faq_how_to_setup_sni&gt;` to learn to
   * setup SNI.
   * </pre>
   *
   * <code>.envoy.type.matcher.StringMatcher requested_server_name = 9;</code>
   * @return Whether the requestedServerName field is set.
   */
  boolean hasRequestedServerName();
  /**
   * <pre>
   * The request server from the client's connection request. This is
   * typically TLS SNI.
   * .. attention::
   *   The behavior of this field may be affected by how Envoy is configured
   *   as explained below.
   *   * If the :ref:`TLS Inspector &lt;config_listener_filters_tls_inspector&gt;`
   *     filter is not added, and if a `FilterChainMatch` is not defined for
   *     the :ref:`server name &lt;envoy_api_field_listener.FilterChainMatch.server_names&gt;`,
   *     a TLS connection's requested SNI server name will be treated as if it
   *     wasn't present.
   *   * A :ref:`listener filter &lt;arch_overview_listener_filters&gt;` may
   *     overwrite a connection's requested server name within Envoy.
   * Please refer to :ref:`this FAQ entry &lt;faq_how_to_setup_sni&gt;` to learn to
   * setup SNI.
   * </pre>
   *
   * <code>.envoy.type.matcher.StringMatcher requested_server_name = 9;</code>
   * @return The requestedServerName.
   */
  io.envoyproxy.envoy.type.matcher.StringMatcher getRequestedServerName();
  /**
   * <pre>
   * The request server from the client's connection request. This is
   * typically TLS SNI.
   * .. attention::
   *   The behavior of this field may be affected by how Envoy is configured
   *   as explained below.
   *   * If the :ref:`TLS Inspector &lt;config_listener_filters_tls_inspector&gt;`
   *     filter is not added, and if a `FilterChainMatch` is not defined for
   *     the :ref:`server name &lt;envoy_api_field_listener.FilterChainMatch.server_names&gt;`,
   *     a TLS connection's requested SNI server name will be treated as if it
   *     wasn't present.
   *   * A :ref:`listener filter &lt;arch_overview_listener_filters&gt;` may
   *     overwrite a connection's requested server name within Envoy.
   * Please refer to :ref:`this FAQ entry &lt;faq_how_to_setup_sni&gt;` to learn to
   * setup SNI.
   * </pre>
   *
   * <code>.envoy.type.matcher.StringMatcher requested_server_name = 9;</code>
   */
  io.envoyproxy.envoy.type.matcher.StringMatcherOrBuilder getRequestedServerNameOrBuilder();

  public io.envoyproxy.envoy.config.rbac.v2.Permission.RuleCase getRuleCase();
}
