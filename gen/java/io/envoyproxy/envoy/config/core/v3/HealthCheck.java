// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/config/core/v3/health_check.proto

package io.envoyproxy.envoy.config.core.v3;

/**
 * <pre>
 * [#next-free-field: 25]
 * </pre>
 *
 * Protobuf type {@code envoy.config.core.v3.HealthCheck}
 */
public final class HealthCheck extends
    com.google.protobuf.GeneratedMessageV3 implements
    // @@protoc_insertion_point(message_implements:envoy.config.core.v3.HealthCheck)
    HealthCheckOrBuilder {
private static final long serialVersionUID = 0L;
  // Use HealthCheck.newBuilder() to construct.
  private HealthCheck(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }
  private HealthCheck() {
    eventLogPath_ = "";
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(
      UnusedPrivateParameter unused) {
    return new HealthCheck();
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet
  getUnknownFields() {
    return this.unknownFields;
  }
  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            io.envoyproxy.envoy.config.core.v3.HealthCheck.class, io.envoyproxy.envoy.config.core.v3.HealthCheck.Builder.class);
  }

  public interface PayloadOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.config.core.v3.HealthCheck.Payload)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Hex encoded payload. E.g., "000000FF".
     * </pre>
     *
     * <code>string text = 1 [(.validate.rules) = { ... }</code>
     * @return Whether the text field is set.
     */
    boolean hasText();
    /**
     * <pre>
     * Hex encoded payload. E.g., "000000FF".
     * </pre>
     *
     * <code>string text = 1 [(.validate.rules) = { ... }</code>
     * @return The text.
     */
    java.lang.String getText();
    /**
     * <pre>
     * Hex encoded payload. E.g., "000000FF".
     * </pre>
     *
     * <code>string text = 1 [(.validate.rules) = { ... }</code>
     * @return The bytes for text.
     */
    com.google.protobuf.ByteString
        getTextBytes();

    /**
     * <pre>
     * Binary payload.
     * </pre>
     *
     * <code>bytes binary = 2;</code>
     * @return Whether the binary field is set.
     */
    boolean hasBinary();
    /**
     * <pre>
     * Binary payload.
     * </pre>
     *
     * <code>bytes binary = 2;</code>
     * @return The binary.
     */
    com.google.protobuf.ByteString getBinary();

    public io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.PayloadCase getPayloadCase();
  }
  /**
   * <pre>
   * Describes the encoding of the payload bytes in the payload.
   * </pre>
   *
   * Protobuf type {@code envoy.config.core.v3.HealthCheck.Payload}
   */
  public static final class Payload extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.config.core.v3.HealthCheck.Payload)
      PayloadOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Payload.newBuilder() to construct.
    private Payload(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Payload() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Payload();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_Payload_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_Payload_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.class, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder.class);
    }

    private int payloadCase_ = 0;
    private java.lang.Object payload_;
    public enum PayloadCase
        implements com.google.protobuf.Internal.EnumLite,
            com.google.protobuf.AbstractMessage.InternalOneOfEnum {
      TEXT(1),
      BINARY(2),
      PAYLOAD_NOT_SET(0);
      private final int value;
      private PayloadCase(int value) {
        this.value = value;
      }
      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static PayloadCase valueOf(int value) {
        return forNumber(value);
      }

      public static PayloadCase forNumber(int value) {
        switch (value) {
          case 1: return TEXT;
          case 2: return BINARY;
          case 0: return PAYLOAD_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public PayloadCase
    getPayloadCase() {
      return PayloadCase.forNumber(
          payloadCase_);
    }

    public static final int TEXT_FIELD_NUMBER = 1;
    /**
     * <pre>
     * Hex encoded payload. E.g., "000000FF".
     * </pre>
     *
     * <code>string text = 1 [(.validate.rules) = { ... }</code>
     * @return Whether the text field is set.
     */
    public boolean hasText() {
      return payloadCase_ == 1;
    }
    /**
     * <pre>
     * Hex encoded payload. E.g., "000000FF".
     * </pre>
     *
     * <code>string text = 1 [(.validate.rules) = { ... }</code>
     * @return The text.
     */
    public java.lang.String getText() {
      java.lang.Object ref = "";
      if (payloadCase_ == 1) {
        ref = payload_;
      }
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (payloadCase_ == 1) {
          payload_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Hex encoded payload. E.g., "000000FF".
     * </pre>
     *
     * <code>string text = 1 [(.validate.rules) = { ... }</code>
     * @return The bytes for text.
     */
    public com.google.protobuf.ByteString
        getTextBytes() {
      java.lang.Object ref = "";
      if (payloadCase_ == 1) {
        ref = payload_;
      }
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        if (payloadCase_ == 1) {
          payload_ = b;
        }
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int BINARY_FIELD_NUMBER = 2;
    /**
     * <pre>
     * Binary payload.
     * </pre>
     *
     * <code>bytes binary = 2;</code>
     * @return Whether the binary field is set.
     */
    @java.lang.Override
    public boolean hasBinary() {
      return payloadCase_ == 2;
    }
    /**
     * <pre>
     * Binary payload.
     * </pre>
     *
     * <code>bytes binary = 2;</code>
     * @return The binary.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getBinary() {
      if (payloadCase_ == 2) {
        return (com.google.protobuf.ByteString) payload_;
      }
      return com.google.protobuf.ByteString.EMPTY;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (payloadCase_ == 1) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, payload_);
      }
      if (payloadCase_ == 2) {
        output.writeBytes(
            2, (com.google.protobuf.ByteString) payload_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (payloadCase_ == 1) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, payload_);
      }
      if (payloadCase_ == 2) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(
              2, (com.google.protobuf.ByteString) payload_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload other = (io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload) obj;

      if (!getPayloadCase().equals(other.getPayloadCase())) return false;
      switch (payloadCase_) {
        case 1:
          if (!getText()
              .equals(other.getText())) return false;
          break;
        case 2:
          if (!getBinary()
              .equals(other.getBinary())) return false;
          break;
        case 0:
        default:
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      switch (payloadCase_) {
        case 1:
          hash = (37 * hash) + TEXT_FIELD_NUMBER;
          hash = (53 * hash) + getText().hashCode();
          break;
        case 2:
          hash = (37 * hash) + BINARY_FIELD_NUMBER;
          hash = (53 * hash) + getBinary().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Describes the encoding of the payload bytes in the payload.
     * </pre>
     *
     * Protobuf type {@code envoy.config.core.v3.HealthCheck.Payload}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.config.core.v3.HealthCheck.Payload)
        io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_Payload_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_Payload_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.class, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        payloadCase_ = 0;
        payload_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_Payload_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload getDefaultInstanceForType() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload build() {
        io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload buildPartial() {
        io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload result = new io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        buildPartialOneofs(result);
        onBuilt();
        return result;
      }

      private void buildPartial0(io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload result) {
        int from_bitField0_ = bitField0_;
      }

      private void buildPartialOneofs(io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload result) {
        result.payloadCase_ = payloadCase_;
        result.payload_ = this.payload_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload) {
          return mergeFrom((io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload other) {
        if (other == io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.getDefaultInstance()) return this;
        switch (other.getPayloadCase()) {
          case TEXT: {
            payloadCase_ = 1;
            payload_ = other.payload_;
            onChanged();
            break;
          }
          case BINARY: {
            setBinary(other.getBinary());
            break;
          }
          case PAYLOAD_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                java.lang.String s = input.readStringRequireUtf8();
                payloadCase_ = 1;
                payload_ = s;
                break;
              } // case 10
              case 18: {
                payload_ = input.readBytes();
                payloadCase_ = 2;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int payloadCase_ = 0;
      private java.lang.Object payload_;
      public PayloadCase
          getPayloadCase() {
        return PayloadCase.forNumber(
            payloadCase_);
      }

      public Builder clearPayload() {
        payloadCase_ = 0;
        payload_ = null;
        onChanged();
        return this;
      }

      private int bitField0_;

      /**
       * <pre>
       * Hex encoded payload. E.g., "000000FF".
       * </pre>
       *
       * <code>string text = 1 [(.validate.rules) = { ... }</code>
       * @return Whether the text field is set.
       */
      @java.lang.Override
      public boolean hasText() {
        return payloadCase_ == 1;
      }
      /**
       * <pre>
       * Hex encoded payload. E.g., "000000FF".
       * </pre>
       *
       * <code>string text = 1 [(.validate.rules) = { ... }</code>
       * @return The text.
       */
      @java.lang.Override
      public java.lang.String getText() {
        java.lang.Object ref = "";
        if (payloadCase_ == 1) {
          ref = payload_;
        }
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (payloadCase_ == 1) {
            payload_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Hex encoded payload. E.g., "000000FF".
       * </pre>
       *
       * <code>string text = 1 [(.validate.rules) = { ... }</code>
       * @return The bytes for text.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getTextBytes() {
        java.lang.Object ref = "";
        if (payloadCase_ == 1) {
          ref = payload_;
        }
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          if (payloadCase_ == 1) {
            payload_ = b;
          }
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Hex encoded payload. E.g., "000000FF".
       * </pre>
       *
       * <code>string text = 1 [(.validate.rules) = { ... }</code>
       * @param value The text to set.
       * @return This builder for chaining.
       */
      public Builder setText(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        payloadCase_ = 1;
        payload_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Hex encoded payload. E.g., "000000FF".
       * </pre>
       *
       * <code>string text = 1 [(.validate.rules) = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearText() {
        if (payloadCase_ == 1) {
          payloadCase_ = 0;
          payload_ = null;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Hex encoded payload. E.g., "000000FF".
       * </pre>
       *
       * <code>string text = 1 [(.validate.rules) = { ... }</code>
       * @param value The bytes for text to set.
       * @return This builder for chaining.
       */
      public Builder setTextBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        payloadCase_ = 1;
        payload_ = value;
        onChanged();
        return this;
      }

      /**
       * <pre>
       * Binary payload.
       * </pre>
       *
       * <code>bytes binary = 2;</code>
       * @return Whether the binary field is set.
       */
      public boolean hasBinary() {
        return payloadCase_ == 2;
      }
      /**
       * <pre>
       * Binary payload.
       * </pre>
       *
       * <code>bytes binary = 2;</code>
       * @return The binary.
       */
      public com.google.protobuf.ByteString getBinary() {
        if (payloadCase_ == 2) {
          return (com.google.protobuf.ByteString) payload_;
        }
        return com.google.protobuf.ByteString.EMPTY;
      }
      /**
       * <pre>
       * Binary payload.
       * </pre>
       *
       * <code>bytes binary = 2;</code>
       * @param value The binary to set.
       * @return This builder for chaining.
       */
      public Builder setBinary(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        payloadCase_ = 2;
        payload_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Binary payload.
       * </pre>
       *
       * <code>bytes binary = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearBinary() {
        if (payloadCase_ == 2) {
          payloadCase_ = 0;
          payload_ = null;
          onChanged();
        }
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.config.core.v3.HealthCheck.Payload)
    }

    // @@protoc_insertion_point(class_scope:envoy.config.core.v3.HealthCheck.Payload)
    private static final io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload();
    }

    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Payload>
        PARSER = new com.google.protobuf.AbstractParser<Payload>() {
      @java.lang.Override
      public Payload parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Payload> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Payload> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface HttpHealthCheckOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.config.core.v3.HealthCheck.HttpHealthCheck)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The value of the host header in the HTTP health check request. If
     * left empty (default value), the name of the cluster this health check is associated
     * with will be used. The host header can be customized for a specific endpoint by setting the
     * :ref:`hostname &lt;envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname&gt;` field.
     * </pre>
     *
     * <code>string host = 1 [(.validate.rules) = { ... }</code>
     * @return The host.
     */
    java.lang.String getHost();
    /**
     * <pre>
     * The value of the host header in the HTTP health check request. If
     * left empty (default value), the name of the cluster this health check is associated
     * with will be used. The host header can be customized for a specific endpoint by setting the
     * :ref:`hostname &lt;envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname&gt;` field.
     * </pre>
     *
     * <code>string host = 1 [(.validate.rules) = { ... }</code>
     * @return The bytes for host.
     */
    com.google.protobuf.ByteString
        getHostBytes();

    /**
     * <pre>
     * Specifies the HTTP path that will be requested during health checking. For example
     * ``/healthcheck``.
     * </pre>
     *
     * <code>string path = 2 [(.validate.rules) = { ... }</code>
     * @return The path.
     */
    java.lang.String getPath();
    /**
     * <pre>
     * Specifies the HTTP path that will be requested during health checking. For example
     * ``/healthcheck``.
     * </pre>
     *
     * <code>string path = 2 [(.validate.rules) = { ... }</code>
     * @return The bytes for path.
     */
    com.google.protobuf.ByteString
        getPathBytes();

    /**
     * <pre>
     * [#not-implemented-hide:] HTTP specific payload.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.Payload send = 3;</code>
     * @return Whether the send field is set.
     */
    boolean hasSend();
    /**
     * <pre>
     * [#not-implemented-hide:] HTTP specific payload.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.Payload send = 3;</code>
     * @return The send.
     */
    io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload getSend();
    /**
     * <pre>
     * [#not-implemented-hide:] HTTP specific payload.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.Payload send = 3;</code>
     */
    io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder getSendOrBuilder();

    /**
     * <pre>
     * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
     * If it is set, both the expected response check and status code determine the health check.
     * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
     * and in the order specified, but not necessarily contiguous.
     * .. note::
     *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
     *   The default buffer size is 1024 bytes when it is not set.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
     */
    java.util.List<io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload> 
        getReceiveList();
    /**
     * <pre>
     * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
     * If it is set, both the expected response check and status code determine the health check.
     * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
     * and in the order specified, but not necessarily contiguous.
     * .. note::
     *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
     *   The default buffer size is 1024 bytes when it is not set.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
     */
    io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload getReceive(int index);
    /**
     * <pre>
     * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
     * If it is set, both the expected response check and status code determine the health check.
     * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
     * and in the order specified, but not necessarily contiguous.
     * .. note::
     *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
     *   The default buffer size is 1024 bytes when it is not set.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
     */
    int getReceiveCount();
    /**
     * <pre>
     * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
     * If it is set, both the expected response check and status code determine the health check.
     * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
     * and in the order specified, but not necessarily contiguous.
     * .. note::
     *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
     *   The default buffer size is 1024 bytes when it is not set.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
     */
    java.util.List<? extends io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder> 
        getReceiveOrBuilderList();
    /**
     * <pre>
     * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
     * If it is set, both the expected response check and status code determine the health check.
     * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
     * and in the order specified, but not necessarily contiguous.
     * .. note::
     *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
     *   The default buffer size is 1024 bytes when it is not set.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
     */
    io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder getReceiveOrBuilder(
        int index);

    /**
     * <pre>
     * Specifies the size of response buffer in bytes that is used to Payload match.
     * The default value is 1024. Setting to 0 implies that the Payload will be matched against the entire response.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value response_buffer_size = 14 [(.validate.rules) = { ... }</code>
     * @return Whether the responseBufferSize field is set.
     */
    boolean hasResponseBufferSize();
    /**
     * <pre>
     * Specifies the size of response buffer in bytes that is used to Payload match.
     * The default value is 1024. Setting to 0 implies that the Payload will be matched against the entire response.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value response_buffer_size = 14 [(.validate.rules) = { ... }</code>
     * @return The responseBufferSize.
     */
    com.google.protobuf.UInt64Value getResponseBufferSize();
    /**
     * <pre>
     * Specifies the size of response buffer in bytes that is used to Payload match.
     * The default value is 1024. Setting to 0 implies that the Payload will be matched against the entire response.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value response_buffer_size = 14 [(.validate.rules) = { ... }</code>
     */
    com.google.protobuf.UInt64ValueOrBuilder getResponseBufferSizeOrBuilder();

    /**
     * <pre>
     * Specifies a list of HTTP headers that should be added to each request that is sent to the
     * health checked cluster. For more information, including details on header value syntax, see
     * the documentation on :ref:`custom request headers
     * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
     */
    java.util.List<io.envoyproxy.envoy.config.core.v3.HeaderValueOption> 
        getRequestHeadersToAddList();
    /**
     * <pre>
     * Specifies a list of HTTP headers that should be added to each request that is sent to the
     * health checked cluster. For more information, including details on header value syntax, see
     * the documentation on :ref:`custom request headers
     * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
     */
    io.envoyproxy.envoy.config.core.v3.HeaderValueOption getRequestHeadersToAdd(int index);
    /**
     * <pre>
     * Specifies a list of HTTP headers that should be added to each request that is sent to the
     * health checked cluster. For more information, including details on header value syntax, see
     * the documentation on :ref:`custom request headers
     * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
     */
    int getRequestHeadersToAddCount();
    /**
     * <pre>
     * Specifies a list of HTTP headers that should be added to each request that is sent to the
     * health checked cluster. For more information, including details on header value syntax, see
     * the documentation on :ref:`custom request headers
     * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
     */
    java.util.List<? extends io.envoyproxy.envoy.config.core.v3.HeaderValueOptionOrBuilder> 
        getRequestHeadersToAddOrBuilderList();
    /**
     * <pre>
     * Specifies a list of HTTP headers that should be added to each request that is sent to the
     * health checked cluster. For more information, including details on header value syntax, see
     * the documentation on :ref:`custom request headers
     * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
     */
    io.envoyproxy.envoy.config.core.v3.HeaderValueOptionOrBuilder getRequestHeadersToAddOrBuilder(
        int index);

    /**
     * <pre>
     * Specifies a list of HTTP headers that should be removed from each request that is sent to the
     * health checked cluster.
     * </pre>
     *
     * <code>repeated string request_headers_to_remove = 8 [(.validate.rules) = { ... }</code>
     * @return A list containing the requestHeadersToRemove.
     */
    java.util.List<java.lang.String>
        getRequestHeadersToRemoveList();
    /**
     * <pre>
     * Specifies a list of HTTP headers that should be removed from each request that is sent to the
     * health checked cluster.
     * </pre>
     *
     * <code>repeated string request_headers_to_remove = 8 [(.validate.rules) = { ... }</code>
     * @return The count of requestHeadersToRemove.
     */
    int getRequestHeadersToRemoveCount();
    /**
     * <pre>
     * Specifies a list of HTTP headers that should be removed from each request that is sent to the
     * health checked cluster.
     * </pre>
     *
     * <code>repeated string request_headers_to_remove = 8 [(.validate.rules) = { ... }</code>
     * @param index The index of the element to return.
     * @return The requestHeadersToRemove at the given index.
     */
    java.lang.String getRequestHeadersToRemove(int index);
    /**
     * <pre>
     * Specifies a list of HTTP headers that should be removed from each request that is sent to the
     * health checked cluster.
     * </pre>
     *
     * <code>repeated string request_headers_to_remove = 8 [(.validate.rules) = { ... }</code>
     * @param index The index of the value to return.
     * @return The bytes of the requestHeadersToRemove at the given index.
     */
    com.google.protobuf.ByteString
        getRequestHeadersToRemoveBytes(int index);

    /**
     * <pre>
     * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
     * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
     * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
     * range are required. Only statuses in the range [100, 600) are allowed.
     * </pre>
     *
     * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
     */
    java.util.List<io.envoyproxy.envoy.type.v3.Int64Range> 
        getExpectedStatusesList();
    /**
     * <pre>
     * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
     * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
     * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
     * range are required. Only statuses in the range [100, 600) are allowed.
     * </pre>
     *
     * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
     */
    io.envoyproxy.envoy.type.v3.Int64Range getExpectedStatuses(int index);
    /**
     * <pre>
     * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
     * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
     * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
     * range are required. Only statuses in the range [100, 600) are allowed.
     * </pre>
     *
     * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
     */
    int getExpectedStatusesCount();
    /**
     * <pre>
     * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
     * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
     * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
     * range are required. Only statuses in the range [100, 600) are allowed.
     * </pre>
     *
     * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
     */
    java.util.List<? extends io.envoyproxy.envoy.type.v3.Int64RangeOrBuilder> 
        getExpectedStatusesOrBuilderList();
    /**
     * <pre>
     * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
     * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
     * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
     * range are required. Only statuses in the range [100, 600) are allowed.
     * </pre>
     *
     * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
     */
    io.envoyproxy.envoy.type.v3.Int64RangeOrBuilder getExpectedStatusesOrBuilder(
        int index);

    /**
     * <pre>
     * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
     * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
     * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
     * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
     * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
     * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
     * be considered a successful health check. By default all responses not in
     * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
     * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
     * non-200 response will result in the host being marked unhealthy.
     * </pre>
     *
     * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
     */
    java.util.List<io.envoyproxy.envoy.type.v3.Int64Range> 
        getRetriableStatusesList();
    /**
     * <pre>
     * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
     * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
     * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
     * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
     * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
     * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
     * be considered a successful health check. By default all responses not in
     * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
     * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
     * non-200 response will result in the host being marked unhealthy.
     * </pre>
     *
     * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
     */
    io.envoyproxy.envoy.type.v3.Int64Range getRetriableStatuses(int index);
    /**
     * <pre>
     * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
     * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
     * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
     * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
     * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
     * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
     * be considered a successful health check. By default all responses not in
     * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
     * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
     * non-200 response will result in the host being marked unhealthy.
     * </pre>
     *
     * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
     */
    int getRetriableStatusesCount();
    /**
     * <pre>
     * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
     * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
     * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
     * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
     * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
     * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
     * be considered a successful health check. By default all responses not in
     * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
     * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
     * non-200 response will result in the host being marked unhealthy.
     * </pre>
     *
     * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
     */
    java.util.List<? extends io.envoyproxy.envoy.type.v3.Int64RangeOrBuilder> 
        getRetriableStatusesOrBuilderList();
    /**
     * <pre>
     * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
     * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
     * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
     * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
     * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
     * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
     * be considered a successful health check. By default all responses not in
     * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
     * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
     * non-200 response will result in the host being marked unhealthy.
     * </pre>
     *
     * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
     */
    io.envoyproxy.envoy.type.v3.Int64RangeOrBuilder getRetriableStatusesOrBuilder(
        int index);

    /**
     * <pre>
     * Use specified application protocol for health checks.
     * </pre>
     *
     * <code>.envoy.type.v3.CodecClientType codec_client_type = 10 [(.validate.rules) = { ... }</code>
     * @return The enum numeric value on the wire for codecClientType.
     */
    int getCodecClientTypeValue();
    /**
     * <pre>
     * Use specified application protocol for health checks.
     * </pre>
     *
     * <code>.envoy.type.v3.CodecClientType codec_client_type = 10 [(.validate.rules) = { ... }</code>
     * @return The codecClientType.
     */
    io.envoyproxy.envoy.type.v3.CodecClientType getCodecClientType();

    /**
     * <pre>
     * An optional service name parameter which is used to validate the identity of
     * the health checked cluster using a :ref:`StringMatcher
     * &lt;envoy_v3_api_msg_type.matcher.v3.StringMatcher&gt;`. See the :ref:`architecture overview
     * &lt;arch_overview_health_checking_identity&gt;` for more information.
     * </pre>
     *
     * <code>.envoy.type.matcher.v3.StringMatcher service_name_matcher = 11;</code>
     * @return Whether the serviceNameMatcher field is set.
     */
    boolean hasServiceNameMatcher();
    /**
     * <pre>
     * An optional service name parameter which is used to validate the identity of
     * the health checked cluster using a :ref:`StringMatcher
     * &lt;envoy_v3_api_msg_type.matcher.v3.StringMatcher&gt;`. See the :ref:`architecture overview
     * &lt;arch_overview_health_checking_identity&gt;` for more information.
     * </pre>
     *
     * <code>.envoy.type.matcher.v3.StringMatcher service_name_matcher = 11;</code>
     * @return The serviceNameMatcher.
     */
    io.envoyproxy.envoy.type.matcher.v3.StringMatcher getServiceNameMatcher();
    /**
     * <pre>
     * An optional service name parameter which is used to validate the identity of
     * the health checked cluster using a :ref:`StringMatcher
     * &lt;envoy_v3_api_msg_type.matcher.v3.StringMatcher&gt;`. See the :ref:`architecture overview
     * &lt;arch_overview_health_checking_identity&gt;` for more information.
     * </pre>
     *
     * <code>.envoy.type.matcher.v3.StringMatcher service_name_matcher = 11;</code>
     */
    io.envoyproxy.envoy.type.matcher.v3.StringMatcherOrBuilder getServiceNameMatcherOrBuilder();

    /**
     * <pre>
     * HTTP Method that will be used for health checking, default is "GET".
     * GET, HEAD, POST, PUT, DELETE, OPTIONS, TRACE, PATCH methods are supported, but making request body is not supported.
     * CONNECT method is disallowed because it is not appropriate for health check request.
     * If a non-200 response is expected by the method, it needs to be set in :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`.
     * </pre>
     *
     * <code>.envoy.config.core.v3.RequestMethod method = 13 [(.validate.rules) = { ... }</code>
     * @return The enum numeric value on the wire for method.
     */
    int getMethodValue();
    /**
     * <pre>
     * HTTP Method that will be used for health checking, default is "GET".
     * GET, HEAD, POST, PUT, DELETE, OPTIONS, TRACE, PATCH methods are supported, but making request body is not supported.
     * CONNECT method is disallowed because it is not appropriate for health check request.
     * If a non-200 response is expected by the method, it needs to be set in :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`.
     * </pre>
     *
     * <code>.envoy.config.core.v3.RequestMethod method = 13 [(.validate.rules) = { ... }</code>
     * @return The method.
     */
    io.envoyproxy.envoy.config.core.v3.RequestMethod getMethod();
  }
  /**
   * <pre>
   * [#next-free-field: 15]
   * </pre>
   *
   * Protobuf type {@code envoy.config.core.v3.HealthCheck.HttpHealthCheck}
   */
  public static final class HttpHealthCheck extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.config.core.v3.HealthCheck.HttpHealthCheck)
      HttpHealthCheckOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use HttpHealthCheck.newBuilder() to construct.
    private HttpHealthCheck(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private HttpHealthCheck() {
      host_ = "";
      path_ = "";
      receive_ = java.util.Collections.emptyList();
      requestHeadersToAdd_ = java.util.Collections.emptyList();
      requestHeadersToRemove_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      expectedStatuses_ = java.util.Collections.emptyList();
      retriableStatuses_ = java.util.Collections.emptyList();
      codecClientType_ = 0;
      method_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new HttpHealthCheck();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_HttpHealthCheck_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_HttpHealthCheck_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck.class, io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck.Builder.class);
    }

    public static final int HOST_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object host_ = "";
    /**
     * <pre>
     * The value of the host header in the HTTP health check request. If
     * left empty (default value), the name of the cluster this health check is associated
     * with will be used. The host header can be customized for a specific endpoint by setting the
     * :ref:`hostname &lt;envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname&gt;` field.
     * </pre>
     *
     * <code>string host = 1 [(.validate.rules) = { ... }</code>
     * @return The host.
     */
    @java.lang.Override
    public java.lang.String getHost() {
      java.lang.Object ref = host_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        host_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The value of the host header in the HTTP health check request. If
     * left empty (default value), the name of the cluster this health check is associated
     * with will be used. The host header can be customized for a specific endpoint by setting the
     * :ref:`hostname &lt;envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname&gt;` field.
     * </pre>
     *
     * <code>string host = 1 [(.validate.rules) = { ... }</code>
     * @return The bytes for host.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getHostBytes() {
      java.lang.Object ref = host_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        host_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PATH_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object path_ = "";
    /**
     * <pre>
     * Specifies the HTTP path that will be requested during health checking. For example
     * ``/healthcheck``.
     * </pre>
     *
     * <code>string path = 2 [(.validate.rules) = { ... }</code>
     * @return The path.
     */
    @java.lang.Override
    public java.lang.String getPath() {
      java.lang.Object ref = path_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        path_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Specifies the HTTP path that will be requested during health checking. For example
     * ``/healthcheck``.
     * </pre>
     *
     * <code>string path = 2 [(.validate.rules) = { ... }</code>
     * @return The bytes for path.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPathBytes() {
      java.lang.Object ref = path_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        path_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SEND_FIELD_NUMBER = 3;
    private io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload send_;
    /**
     * <pre>
     * [#not-implemented-hide:] HTTP specific payload.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.Payload send = 3;</code>
     * @return Whether the send field is set.
     */
    @java.lang.Override
    public boolean hasSend() {
      return send_ != null;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] HTTP specific payload.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.Payload send = 3;</code>
     * @return The send.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload getSend() {
      return send_ == null ? io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.getDefaultInstance() : send_;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] HTTP specific payload.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.Payload send = 3;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder getSendOrBuilder() {
      return send_ == null ? io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.getDefaultInstance() : send_;
    }

    public static final int RECEIVE_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private java.util.List<io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload> receive_;
    /**
     * <pre>
     * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
     * If it is set, both the expected response check and status code determine the health check.
     * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
     * and in the order specified, but not necessarily contiguous.
     * .. note::
     *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
     *   The default buffer size is 1024 bytes when it is not set.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
     */
    @java.lang.Override
    public java.util.List<io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload> getReceiveList() {
      return receive_;
    }
    /**
     * <pre>
     * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
     * If it is set, both the expected response check and status code determine the health check.
     * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
     * and in the order specified, but not necessarily contiguous.
     * .. note::
     *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
     *   The default buffer size is 1024 bytes when it is not set.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder> 
        getReceiveOrBuilderList() {
      return receive_;
    }
    /**
     * <pre>
     * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
     * If it is set, both the expected response check and status code determine the health check.
     * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
     * and in the order specified, but not necessarily contiguous.
     * .. note::
     *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
     *   The default buffer size is 1024 bytes when it is not set.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
     */
    @java.lang.Override
    public int getReceiveCount() {
      return receive_.size();
    }
    /**
     * <pre>
     * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
     * If it is set, both the expected response check and status code determine the health check.
     * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
     * and in the order specified, but not necessarily contiguous.
     * .. note::
     *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
     *   The default buffer size is 1024 bytes when it is not set.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload getReceive(int index) {
      return receive_.get(index);
    }
    /**
     * <pre>
     * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
     * If it is set, both the expected response check and status code determine the health check.
     * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
     * and in the order specified, but not necessarily contiguous.
     * .. note::
     *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
     *   The default buffer size is 1024 bytes when it is not set.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder getReceiveOrBuilder(
        int index) {
      return receive_.get(index);
    }

    public static final int RESPONSE_BUFFER_SIZE_FIELD_NUMBER = 14;
    private com.google.protobuf.UInt64Value responseBufferSize_;
    /**
     * <pre>
     * Specifies the size of response buffer in bytes that is used to Payload match.
     * The default value is 1024. Setting to 0 implies that the Payload will be matched against the entire response.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value response_buffer_size = 14 [(.validate.rules) = { ... }</code>
     * @return Whether the responseBufferSize field is set.
     */
    @java.lang.Override
    public boolean hasResponseBufferSize() {
      return responseBufferSize_ != null;
    }
    /**
     * <pre>
     * Specifies the size of response buffer in bytes that is used to Payload match.
     * The default value is 1024. Setting to 0 implies that the Payload will be matched against the entire response.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value response_buffer_size = 14 [(.validate.rules) = { ... }</code>
     * @return The responseBufferSize.
     */
    @java.lang.Override
    public com.google.protobuf.UInt64Value getResponseBufferSize() {
      return responseBufferSize_ == null ? com.google.protobuf.UInt64Value.getDefaultInstance() : responseBufferSize_;
    }
    /**
     * <pre>
     * Specifies the size of response buffer in bytes that is used to Payload match.
     * The default value is 1024. Setting to 0 implies that the Payload will be matched against the entire response.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value response_buffer_size = 14 [(.validate.rules) = { ... }</code>
     */
    @java.lang.Override
    public com.google.protobuf.UInt64ValueOrBuilder getResponseBufferSizeOrBuilder() {
      return responseBufferSize_ == null ? com.google.protobuf.UInt64Value.getDefaultInstance() : responseBufferSize_;
    }

    public static final int REQUEST_HEADERS_TO_ADD_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private java.util.List<io.envoyproxy.envoy.config.core.v3.HeaderValueOption> requestHeadersToAdd_;
    /**
     * <pre>
     * Specifies a list of HTTP headers that should be added to each request that is sent to the
     * health checked cluster. For more information, including details on header value syntax, see
     * the documentation on :ref:`custom request headers
     * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
     */
    @java.lang.Override
    public java.util.List<io.envoyproxy.envoy.config.core.v3.HeaderValueOption> getRequestHeadersToAddList() {
      return requestHeadersToAdd_;
    }
    /**
     * <pre>
     * Specifies a list of HTTP headers that should be added to each request that is sent to the
     * health checked cluster. For more information, including details on header value syntax, see
     * the documentation on :ref:`custom request headers
     * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.envoyproxy.envoy.config.core.v3.HeaderValueOptionOrBuilder> 
        getRequestHeadersToAddOrBuilderList() {
      return requestHeadersToAdd_;
    }
    /**
     * <pre>
     * Specifies a list of HTTP headers that should be added to each request that is sent to the
     * health checked cluster. For more information, including details on header value syntax, see
     * the documentation on :ref:`custom request headers
     * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
     */
    @java.lang.Override
    public int getRequestHeadersToAddCount() {
      return requestHeadersToAdd_.size();
    }
    /**
     * <pre>
     * Specifies a list of HTTP headers that should be added to each request that is sent to the
     * health checked cluster. For more information, including details on header value syntax, see
     * the documentation on :ref:`custom request headers
     * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HeaderValueOption getRequestHeadersToAdd(int index) {
      return requestHeadersToAdd_.get(index);
    }
    /**
     * <pre>
     * Specifies a list of HTTP headers that should be added to each request that is sent to the
     * health checked cluster. For more information, including details on header value syntax, see
     * the documentation on :ref:`custom request headers
     * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HeaderValueOptionOrBuilder getRequestHeadersToAddOrBuilder(
        int index) {
      return requestHeadersToAdd_.get(index);
    }

    public static final int REQUEST_HEADERS_TO_REMOVE_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringList requestHeadersToRemove_;
    /**
     * <pre>
     * Specifies a list of HTTP headers that should be removed from each request that is sent to the
     * health checked cluster.
     * </pre>
     *
     * <code>repeated string request_headers_to_remove = 8 [(.validate.rules) = { ... }</code>
     * @return A list containing the requestHeadersToRemove.
     */
    public com.google.protobuf.ProtocolStringList
        getRequestHeadersToRemoveList() {
      return requestHeadersToRemove_;
    }
    /**
     * <pre>
     * Specifies a list of HTTP headers that should be removed from each request that is sent to the
     * health checked cluster.
     * </pre>
     *
     * <code>repeated string request_headers_to_remove = 8 [(.validate.rules) = { ... }</code>
     * @return The count of requestHeadersToRemove.
     */
    public int getRequestHeadersToRemoveCount() {
      return requestHeadersToRemove_.size();
    }
    /**
     * <pre>
     * Specifies a list of HTTP headers that should be removed from each request that is sent to the
     * health checked cluster.
     * </pre>
     *
     * <code>repeated string request_headers_to_remove = 8 [(.validate.rules) = { ... }</code>
     * @param index The index of the element to return.
     * @return The requestHeadersToRemove at the given index.
     */
    public java.lang.String getRequestHeadersToRemove(int index) {
      return requestHeadersToRemove_.get(index);
    }
    /**
     * <pre>
     * Specifies a list of HTTP headers that should be removed from each request that is sent to the
     * health checked cluster.
     * </pre>
     *
     * <code>repeated string request_headers_to_remove = 8 [(.validate.rules) = { ... }</code>
     * @param index The index of the value to return.
     * @return The bytes of the requestHeadersToRemove at the given index.
     */
    public com.google.protobuf.ByteString
        getRequestHeadersToRemoveBytes(int index) {
      return requestHeadersToRemove_.getByteString(index);
    }

    public static final int EXPECTED_STATUSES_FIELD_NUMBER = 9;
    @SuppressWarnings("serial")
    private java.util.List<io.envoyproxy.envoy.type.v3.Int64Range> expectedStatuses_;
    /**
     * <pre>
     * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
     * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
     * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
     * range are required. Only statuses in the range [100, 600) are allowed.
     * </pre>
     *
     * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
     */
    @java.lang.Override
    public java.util.List<io.envoyproxy.envoy.type.v3.Int64Range> getExpectedStatusesList() {
      return expectedStatuses_;
    }
    /**
     * <pre>
     * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
     * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
     * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
     * range are required. Only statuses in the range [100, 600) are allowed.
     * </pre>
     *
     * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.envoyproxy.envoy.type.v3.Int64RangeOrBuilder> 
        getExpectedStatusesOrBuilderList() {
      return expectedStatuses_;
    }
    /**
     * <pre>
     * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
     * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
     * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
     * range are required. Only statuses in the range [100, 600) are allowed.
     * </pre>
     *
     * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
     */
    @java.lang.Override
    public int getExpectedStatusesCount() {
      return expectedStatuses_.size();
    }
    /**
     * <pre>
     * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
     * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
     * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
     * range are required. Only statuses in the range [100, 600) are allowed.
     * </pre>
     *
     * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.v3.Int64Range getExpectedStatuses(int index) {
      return expectedStatuses_.get(index);
    }
    /**
     * <pre>
     * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
     * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
     * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
     * range are required. Only statuses in the range [100, 600) are allowed.
     * </pre>
     *
     * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.v3.Int64RangeOrBuilder getExpectedStatusesOrBuilder(
        int index) {
      return expectedStatuses_.get(index);
    }

    public static final int RETRIABLE_STATUSES_FIELD_NUMBER = 12;
    @SuppressWarnings("serial")
    private java.util.List<io.envoyproxy.envoy.type.v3.Int64Range> retriableStatuses_;
    /**
     * <pre>
     * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
     * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
     * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
     * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
     * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
     * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
     * be considered a successful health check. By default all responses not in
     * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
     * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
     * non-200 response will result in the host being marked unhealthy.
     * </pre>
     *
     * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
     */
    @java.lang.Override
    public java.util.List<io.envoyproxy.envoy.type.v3.Int64Range> getRetriableStatusesList() {
      return retriableStatuses_;
    }
    /**
     * <pre>
     * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
     * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
     * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
     * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
     * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
     * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
     * be considered a successful health check. By default all responses not in
     * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
     * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
     * non-200 response will result in the host being marked unhealthy.
     * </pre>
     *
     * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.envoyproxy.envoy.type.v3.Int64RangeOrBuilder> 
        getRetriableStatusesOrBuilderList() {
      return retriableStatuses_;
    }
    /**
     * <pre>
     * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
     * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
     * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
     * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
     * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
     * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
     * be considered a successful health check. By default all responses not in
     * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
     * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
     * non-200 response will result in the host being marked unhealthy.
     * </pre>
     *
     * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
     */
    @java.lang.Override
    public int getRetriableStatusesCount() {
      return retriableStatuses_.size();
    }
    /**
     * <pre>
     * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
     * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
     * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
     * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
     * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
     * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
     * be considered a successful health check. By default all responses not in
     * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
     * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
     * non-200 response will result in the host being marked unhealthy.
     * </pre>
     *
     * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.v3.Int64Range getRetriableStatuses(int index) {
      return retriableStatuses_.get(index);
    }
    /**
     * <pre>
     * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
     * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
     * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
     * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
     * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
     * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
     * be considered a successful health check. By default all responses not in
     * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
     * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
     * non-200 response will result in the host being marked unhealthy.
     * </pre>
     *
     * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.v3.Int64RangeOrBuilder getRetriableStatusesOrBuilder(
        int index) {
      return retriableStatuses_.get(index);
    }

    public static final int CODEC_CLIENT_TYPE_FIELD_NUMBER = 10;
    private int codecClientType_ = 0;
    /**
     * <pre>
     * Use specified application protocol for health checks.
     * </pre>
     *
     * <code>.envoy.type.v3.CodecClientType codec_client_type = 10 [(.validate.rules) = { ... }</code>
     * @return The enum numeric value on the wire for codecClientType.
     */
    @java.lang.Override public int getCodecClientTypeValue() {
      return codecClientType_;
    }
    /**
     * <pre>
     * Use specified application protocol for health checks.
     * </pre>
     *
     * <code>.envoy.type.v3.CodecClientType codec_client_type = 10 [(.validate.rules) = { ... }</code>
     * @return The codecClientType.
     */
    @java.lang.Override public io.envoyproxy.envoy.type.v3.CodecClientType getCodecClientType() {
      io.envoyproxy.envoy.type.v3.CodecClientType result = io.envoyproxy.envoy.type.v3.CodecClientType.forNumber(codecClientType_);
      return result == null ? io.envoyproxy.envoy.type.v3.CodecClientType.UNRECOGNIZED : result;
    }

    public static final int SERVICE_NAME_MATCHER_FIELD_NUMBER = 11;
    private io.envoyproxy.envoy.type.matcher.v3.StringMatcher serviceNameMatcher_;
    /**
     * <pre>
     * An optional service name parameter which is used to validate the identity of
     * the health checked cluster using a :ref:`StringMatcher
     * &lt;envoy_v3_api_msg_type.matcher.v3.StringMatcher&gt;`. See the :ref:`architecture overview
     * &lt;arch_overview_health_checking_identity&gt;` for more information.
     * </pre>
     *
     * <code>.envoy.type.matcher.v3.StringMatcher service_name_matcher = 11;</code>
     * @return Whether the serviceNameMatcher field is set.
     */
    @java.lang.Override
    public boolean hasServiceNameMatcher() {
      return serviceNameMatcher_ != null;
    }
    /**
     * <pre>
     * An optional service name parameter which is used to validate the identity of
     * the health checked cluster using a :ref:`StringMatcher
     * &lt;envoy_v3_api_msg_type.matcher.v3.StringMatcher&gt;`. See the :ref:`architecture overview
     * &lt;arch_overview_health_checking_identity&gt;` for more information.
     * </pre>
     *
     * <code>.envoy.type.matcher.v3.StringMatcher service_name_matcher = 11;</code>
     * @return The serviceNameMatcher.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.matcher.v3.StringMatcher getServiceNameMatcher() {
      return serviceNameMatcher_ == null ? io.envoyproxy.envoy.type.matcher.v3.StringMatcher.getDefaultInstance() : serviceNameMatcher_;
    }
    /**
     * <pre>
     * An optional service name parameter which is used to validate the identity of
     * the health checked cluster using a :ref:`StringMatcher
     * &lt;envoy_v3_api_msg_type.matcher.v3.StringMatcher&gt;`. See the :ref:`architecture overview
     * &lt;arch_overview_health_checking_identity&gt;` for more information.
     * </pre>
     *
     * <code>.envoy.type.matcher.v3.StringMatcher service_name_matcher = 11;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.matcher.v3.StringMatcherOrBuilder getServiceNameMatcherOrBuilder() {
      return serviceNameMatcher_ == null ? io.envoyproxy.envoy.type.matcher.v3.StringMatcher.getDefaultInstance() : serviceNameMatcher_;
    }

    public static final int METHOD_FIELD_NUMBER = 13;
    private int method_ = 0;
    /**
     * <pre>
     * HTTP Method that will be used for health checking, default is "GET".
     * GET, HEAD, POST, PUT, DELETE, OPTIONS, TRACE, PATCH methods are supported, but making request body is not supported.
     * CONNECT method is disallowed because it is not appropriate for health check request.
     * If a non-200 response is expected by the method, it needs to be set in :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`.
     * </pre>
     *
     * <code>.envoy.config.core.v3.RequestMethod method = 13 [(.validate.rules) = { ... }</code>
     * @return The enum numeric value on the wire for method.
     */
    @java.lang.Override public int getMethodValue() {
      return method_;
    }
    /**
     * <pre>
     * HTTP Method that will be used for health checking, default is "GET".
     * GET, HEAD, POST, PUT, DELETE, OPTIONS, TRACE, PATCH methods are supported, but making request body is not supported.
     * CONNECT method is disallowed because it is not appropriate for health check request.
     * If a non-200 response is expected by the method, it needs to be set in :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`.
     * </pre>
     *
     * <code>.envoy.config.core.v3.RequestMethod method = 13 [(.validate.rules) = { ... }</code>
     * @return The method.
     */
    @java.lang.Override public io.envoyproxy.envoy.config.core.v3.RequestMethod getMethod() {
      io.envoyproxy.envoy.config.core.v3.RequestMethod result = io.envoyproxy.envoy.config.core.v3.RequestMethod.forNumber(method_);
      return result == null ? io.envoyproxy.envoy.config.core.v3.RequestMethod.UNRECOGNIZED : result;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(host_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, host_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(path_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, path_);
      }
      if (send_ != null) {
        output.writeMessage(3, getSend());
      }
      for (int i = 0; i < receive_.size(); i++) {
        output.writeMessage(4, receive_.get(i));
      }
      for (int i = 0; i < requestHeadersToAdd_.size(); i++) {
        output.writeMessage(6, requestHeadersToAdd_.get(i));
      }
      for (int i = 0; i < requestHeadersToRemove_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 8, requestHeadersToRemove_.getRaw(i));
      }
      for (int i = 0; i < expectedStatuses_.size(); i++) {
        output.writeMessage(9, expectedStatuses_.get(i));
      }
      if (codecClientType_ != io.envoyproxy.envoy.type.v3.CodecClientType.HTTP1.getNumber()) {
        output.writeEnum(10, codecClientType_);
      }
      if (serviceNameMatcher_ != null) {
        output.writeMessage(11, getServiceNameMatcher());
      }
      for (int i = 0; i < retriableStatuses_.size(); i++) {
        output.writeMessage(12, retriableStatuses_.get(i));
      }
      if (method_ != io.envoyproxy.envoy.config.core.v3.RequestMethod.METHOD_UNSPECIFIED.getNumber()) {
        output.writeEnum(13, method_);
      }
      if (responseBufferSize_ != null) {
        output.writeMessage(14, getResponseBufferSize());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(host_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, host_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(path_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, path_);
      }
      if (send_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getSend());
      }
      for (int i = 0; i < receive_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, receive_.get(i));
      }
      for (int i = 0; i < requestHeadersToAdd_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, requestHeadersToAdd_.get(i));
      }
      {
        int dataSize = 0;
        for (int i = 0; i < requestHeadersToRemove_.size(); i++) {
          dataSize += computeStringSizeNoTag(requestHeadersToRemove_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getRequestHeadersToRemoveList().size();
      }
      for (int i = 0; i < expectedStatuses_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, expectedStatuses_.get(i));
      }
      if (codecClientType_ != io.envoyproxy.envoy.type.v3.CodecClientType.HTTP1.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(10, codecClientType_);
      }
      if (serviceNameMatcher_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, getServiceNameMatcher());
      }
      for (int i = 0; i < retriableStatuses_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(12, retriableStatuses_.get(i));
      }
      if (method_ != io.envoyproxy.envoy.config.core.v3.RequestMethod.METHOD_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(13, method_);
      }
      if (responseBufferSize_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(14, getResponseBufferSize());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck other = (io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck) obj;

      if (!getHost()
          .equals(other.getHost())) return false;
      if (!getPath()
          .equals(other.getPath())) return false;
      if (hasSend() != other.hasSend()) return false;
      if (hasSend()) {
        if (!getSend()
            .equals(other.getSend())) return false;
      }
      if (!getReceiveList()
          .equals(other.getReceiveList())) return false;
      if (hasResponseBufferSize() != other.hasResponseBufferSize()) return false;
      if (hasResponseBufferSize()) {
        if (!getResponseBufferSize()
            .equals(other.getResponseBufferSize())) return false;
      }
      if (!getRequestHeadersToAddList()
          .equals(other.getRequestHeadersToAddList())) return false;
      if (!getRequestHeadersToRemoveList()
          .equals(other.getRequestHeadersToRemoveList())) return false;
      if (!getExpectedStatusesList()
          .equals(other.getExpectedStatusesList())) return false;
      if (!getRetriableStatusesList()
          .equals(other.getRetriableStatusesList())) return false;
      if (codecClientType_ != other.codecClientType_) return false;
      if (hasServiceNameMatcher() != other.hasServiceNameMatcher()) return false;
      if (hasServiceNameMatcher()) {
        if (!getServiceNameMatcher()
            .equals(other.getServiceNameMatcher())) return false;
      }
      if (method_ != other.method_) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + HOST_FIELD_NUMBER;
      hash = (53 * hash) + getHost().hashCode();
      hash = (37 * hash) + PATH_FIELD_NUMBER;
      hash = (53 * hash) + getPath().hashCode();
      if (hasSend()) {
        hash = (37 * hash) + SEND_FIELD_NUMBER;
        hash = (53 * hash) + getSend().hashCode();
      }
      if (getReceiveCount() > 0) {
        hash = (37 * hash) + RECEIVE_FIELD_NUMBER;
        hash = (53 * hash) + getReceiveList().hashCode();
      }
      if (hasResponseBufferSize()) {
        hash = (37 * hash) + RESPONSE_BUFFER_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getResponseBufferSize().hashCode();
      }
      if (getRequestHeadersToAddCount() > 0) {
        hash = (37 * hash) + REQUEST_HEADERS_TO_ADD_FIELD_NUMBER;
        hash = (53 * hash) + getRequestHeadersToAddList().hashCode();
      }
      if (getRequestHeadersToRemoveCount() > 0) {
        hash = (37 * hash) + REQUEST_HEADERS_TO_REMOVE_FIELD_NUMBER;
        hash = (53 * hash) + getRequestHeadersToRemoveList().hashCode();
      }
      if (getExpectedStatusesCount() > 0) {
        hash = (37 * hash) + EXPECTED_STATUSES_FIELD_NUMBER;
        hash = (53 * hash) + getExpectedStatusesList().hashCode();
      }
      if (getRetriableStatusesCount() > 0) {
        hash = (37 * hash) + RETRIABLE_STATUSES_FIELD_NUMBER;
        hash = (53 * hash) + getRetriableStatusesList().hashCode();
      }
      hash = (37 * hash) + CODEC_CLIENT_TYPE_FIELD_NUMBER;
      hash = (53 * hash) + codecClientType_;
      if (hasServiceNameMatcher()) {
        hash = (37 * hash) + SERVICE_NAME_MATCHER_FIELD_NUMBER;
        hash = (53 * hash) + getServiceNameMatcher().hashCode();
      }
      hash = (37 * hash) + METHOD_FIELD_NUMBER;
      hash = (53 * hash) + method_;
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * [#next-free-field: 15]
     * </pre>
     *
     * Protobuf type {@code envoy.config.core.v3.HealthCheck.HttpHealthCheck}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.config.core.v3.HealthCheck.HttpHealthCheck)
        io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheckOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_HttpHealthCheck_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_HttpHealthCheck_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck.class, io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        host_ = "";
        path_ = "";
        send_ = null;
        if (sendBuilder_ != null) {
          sendBuilder_.dispose();
          sendBuilder_ = null;
        }
        if (receiveBuilder_ == null) {
          receive_ = java.util.Collections.emptyList();
        } else {
          receive_ = null;
          receiveBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        responseBufferSize_ = null;
        if (responseBufferSizeBuilder_ != null) {
          responseBufferSizeBuilder_.dispose();
          responseBufferSizeBuilder_ = null;
        }
        if (requestHeadersToAddBuilder_ == null) {
          requestHeadersToAdd_ = java.util.Collections.emptyList();
        } else {
          requestHeadersToAdd_ = null;
          requestHeadersToAddBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        requestHeadersToRemove_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000040);
        if (expectedStatusesBuilder_ == null) {
          expectedStatuses_ = java.util.Collections.emptyList();
        } else {
          expectedStatuses_ = null;
          expectedStatusesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000080);
        if (retriableStatusesBuilder_ == null) {
          retriableStatuses_ = java.util.Collections.emptyList();
        } else {
          retriableStatuses_ = null;
          retriableStatusesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000100);
        codecClientType_ = 0;
        serviceNameMatcher_ = null;
        if (serviceNameMatcherBuilder_ != null) {
          serviceNameMatcherBuilder_.dispose();
          serviceNameMatcherBuilder_ = null;
        }
        method_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_HttpHealthCheck_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck getDefaultInstanceForType() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck build() {
        io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck buildPartial() {
        io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck result = new io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck result) {
        if (receiveBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0)) {
            receive_ = java.util.Collections.unmodifiableList(receive_);
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.receive_ = receive_;
        } else {
          result.receive_ = receiveBuilder_.build();
        }
        if (requestHeadersToAddBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0)) {
            requestHeadersToAdd_ = java.util.Collections.unmodifiableList(requestHeadersToAdd_);
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.requestHeadersToAdd_ = requestHeadersToAdd_;
        } else {
          result.requestHeadersToAdd_ = requestHeadersToAddBuilder_.build();
        }
        if (((bitField0_ & 0x00000040) != 0)) {
          requestHeadersToRemove_ = requestHeadersToRemove_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000040);
        }
        result.requestHeadersToRemove_ = requestHeadersToRemove_;
        if (expectedStatusesBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0)) {
            expectedStatuses_ = java.util.Collections.unmodifiableList(expectedStatuses_);
            bitField0_ = (bitField0_ & ~0x00000080);
          }
          result.expectedStatuses_ = expectedStatuses_;
        } else {
          result.expectedStatuses_ = expectedStatusesBuilder_.build();
        }
        if (retriableStatusesBuilder_ == null) {
          if (((bitField0_ & 0x00000100) != 0)) {
            retriableStatuses_ = java.util.Collections.unmodifiableList(retriableStatuses_);
            bitField0_ = (bitField0_ & ~0x00000100);
          }
          result.retriableStatuses_ = retriableStatuses_;
        } else {
          result.retriableStatuses_ = retriableStatusesBuilder_.build();
        }
      }

      private void buildPartial0(io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.host_ = host_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.path_ = path_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.send_ = sendBuilder_ == null
              ? send_
              : sendBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.responseBufferSize_ = responseBufferSizeBuilder_ == null
              ? responseBufferSize_
              : responseBufferSizeBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.codecClientType_ = codecClientType_;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.serviceNameMatcher_ = serviceNameMatcherBuilder_ == null
              ? serviceNameMatcher_
              : serviceNameMatcherBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.method_ = method_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck) {
          return mergeFrom((io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck other) {
        if (other == io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck.getDefaultInstance()) return this;
        if (!other.getHost().isEmpty()) {
          host_ = other.host_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (!other.getPath().isEmpty()) {
          path_ = other.path_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasSend()) {
          mergeSend(other.getSend());
        }
        if (receiveBuilder_ == null) {
          if (!other.receive_.isEmpty()) {
            if (receive_.isEmpty()) {
              receive_ = other.receive_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureReceiveIsMutable();
              receive_.addAll(other.receive_);
            }
            onChanged();
          }
        } else {
          if (!other.receive_.isEmpty()) {
            if (receiveBuilder_.isEmpty()) {
              receiveBuilder_.dispose();
              receiveBuilder_ = null;
              receive_ = other.receive_;
              bitField0_ = (bitField0_ & ~0x00000008);
              receiveBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getReceiveFieldBuilder() : null;
            } else {
              receiveBuilder_.addAllMessages(other.receive_);
            }
          }
        }
        if (other.hasResponseBufferSize()) {
          mergeResponseBufferSize(other.getResponseBufferSize());
        }
        if (requestHeadersToAddBuilder_ == null) {
          if (!other.requestHeadersToAdd_.isEmpty()) {
            if (requestHeadersToAdd_.isEmpty()) {
              requestHeadersToAdd_ = other.requestHeadersToAdd_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensureRequestHeadersToAddIsMutable();
              requestHeadersToAdd_.addAll(other.requestHeadersToAdd_);
            }
            onChanged();
          }
        } else {
          if (!other.requestHeadersToAdd_.isEmpty()) {
            if (requestHeadersToAddBuilder_.isEmpty()) {
              requestHeadersToAddBuilder_.dispose();
              requestHeadersToAddBuilder_ = null;
              requestHeadersToAdd_ = other.requestHeadersToAdd_;
              bitField0_ = (bitField0_ & ~0x00000020);
              requestHeadersToAddBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getRequestHeadersToAddFieldBuilder() : null;
            } else {
              requestHeadersToAddBuilder_.addAllMessages(other.requestHeadersToAdd_);
            }
          }
        }
        if (!other.requestHeadersToRemove_.isEmpty()) {
          if (requestHeadersToRemove_.isEmpty()) {
            requestHeadersToRemove_ = other.requestHeadersToRemove_;
            bitField0_ = (bitField0_ & ~0x00000040);
          } else {
            ensureRequestHeadersToRemoveIsMutable();
            requestHeadersToRemove_.addAll(other.requestHeadersToRemove_);
          }
          onChanged();
        }
        if (expectedStatusesBuilder_ == null) {
          if (!other.expectedStatuses_.isEmpty()) {
            if (expectedStatuses_.isEmpty()) {
              expectedStatuses_ = other.expectedStatuses_;
              bitField0_ = (bitField0_ & ~0x00000080);
            } else {
              ensureExpectedStatusesIsMutable();
              expectedStatuses_.addAll(other.expectedStatuses_);
            }
            onChanged();
          }
        } else {
          if (!other.expectedStatuses_.isEmpty()) {
            if (expectedStatusesBuilder_.isEmpty()) {
              expectedStatusesBuilder_.dispose();
              expectedStatusesBuilder_ = null;
              expectedStatuses_ = other.expectedStatuses_;
              bitField0_ = (bitField0_ & ~0x00000080);
              expectedStatusesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getExpectedStatusesFieldBuilder() : null;
            } else {
              expectedStatusesBuilder_.addAllMessages(other.expectedStatuses_);
            }
          }
        }
        if (retriableStatusesBuilder_ == null) {
          if (!other.retriableStatuses_.isEmpty()) {
            if (retriableStatuses_.isEmpty()) {
              retriableStatuses_ = other.retriableStatuses_;
              bitField0_ = (bitField0_ & ~0x00000100);
            } else {
              ensureRetriableStatusesIsMutable();
              retriableStatuses_.addAll(other.retriableStatuses_);
            }
            onChanged();
          }
        } else {
          if (!other.retriableStatuses_.isEmpty()) {
            if (retriableStatusesBuilder_.isEmpty()) {
              retriableStatusesBuilder_.dispose();
              retriableStatusesBuilder_ = null;
              retriableStatuses_ = other.retriableStatuses_;
              bitField0_ = (bitField0_ & ~0x00000100);
              retriableStatusesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getRetriableStatusesFieldBuilder() : null;
            } else {
              retriableStatusesBuilder_.addAllMessages(other.retriableStatuses_);
            }
          }
        }
        if (other.codecClientType_ != 0) {
          setCodecClientTypeValue(other.getCodecClientTypeValue());
        }
        if (other.hasServiceNameMatcher()) {
          mergeServiceNameMatcher(other.getServiceNameMatcher());
        }
        if (other.method_ != 0) {
          setMethodValue(other.getMethodValue());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                host_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                path_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getSendFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload m =
                    input.readMessage(
                        io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.parser(),
                        extensionRegistry);
                if (receiveBuilder_ == null) {
                  ensureReceiveIsMutable();
                  receive_.add(m);
                } else {
                  receiveBuilder_.addMessage(m);
                }
                break;
              } // case 34
              case 50: {
                io.envoyproxy.envoy.config.core.v3.HeaderValueOption m =
                    input.readMessage(
                        io.envoyproxy.envoy.config.core.v3.HeaderValueOption.parser(),
                        extensionRegistry);
                if (requestHeadersToAddBuilder_ == null) {
                  ensureRequestHeadersToAddIsMutable();
                  requestHeadersToAdd_.add(m);
                } else {
                  requestHeadersToAddBuilder_.addMessage(m);
                }
                break;
              } // case 50
              case 66: {
                java.lang.String s = input.readStringRequireUtf8();
                ensureRequestHeadersToRemoveIsMutable();
                requestHeadersToRemove_.add(s);
                break;
              } // case 66
              case 74: {
                io.envoyproxy.envoy.type.v3.Int64Range m =
                    input.readMessage(
                        io.envoyproxy.envoy.type.v3.Int64Range.parser(),
                        extensionRegistry);
                if (expectedStatusesBuilder_ == null) {
                  ensureExpectedStatusesIsMutable();
                  expectedStatuses_.add(m);
                } else {
                  expectedStatusesBuilder_.addMessage(m);
                }
                break;
              } // case 74
              case 80: {
                codecClientType_ = input.readEnum();
                bitField0_ |= 0x00000200;
                break;
              } // case 80
              case 90: {
                input.readMessage(
                    getServiceNameMatcherFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000400;
                break;
              } // case 90
              case 98: {
                io.envoyproxy.envoy.type.v3.Int64Range m =
                    input.readMessage(
                        io.envoyproxy.envoy.type.v3.Int64Range.parser(),
                        extensionRegistry);
                if (retriableStatusesBuilder_ == null) {
                  ensureRetriableStatusesIsMutable();
                  retriableStatuses_.add(m);
                } else {
                  retriableStatusesBuilder_.addMessage(m);
                }
                break;
              } // case 98
              case 104: {
                method_ = input.readEnum();
                bitField0_ |= 0x00000800;
                break;
              } // case 104
              case 114: {
                input.readMessage(
                    getResponseBufferSizeFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000010;
                break;
              } // case 114
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object host_ = "";
      /**
       * <pre>
       * The value of the host header in the HTTP health check request. If
       * left empty (default value), the name of the cluster this health check is associated
       * with will be used. The host header can be customized for a specific endpoint by setting the
       * :ref:`hostname &lt;envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname&gt;` field.
       * </pre>
       *
       * <code>string host = 1 [(.validate.rules) = { ... }</code>
       * @return The host.
       */
      public java.lang.String getHost() {
        java.lang.Object ref = host_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          host_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The value of the host header in the HTTP health check request. If
       * left empty (default value), the name of the cluster this health check is associated
       * with will be used. The host header can be customized for a specific endpoint by setting the
       * :ref:`hostname &lt;envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname&gt;` field.
       * </pre>
       *
       * <code>string host = 1 [(.validate.rules) = { ... }</code>
       * @return The bytes for host.
       */
      public com.google.protobuf.ByteString
          getHostBytes() {
        java.lang.Object ref = host_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          host_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The value of the host header in the HTTP health check request. If
       * left empty (default value), the name of the cluster this health check is associated
       * with will be used. The host header can be customized for a specific endpoint by setting the
       * :ref:`hostname &lt;envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname&gt;` field.
       * </pre>
       *
       * <code>string host = 1 [(.validate.rules) = { ... }</code>
       * @param value The host to set.
       * @return This builder for chaining.
       */
      public Builder setHost(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        host_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The value of the host header in the HTTP health check request. If
       * left empty (default value), the name of the cluster this health check is associated
       * with will be used. The host header can be customized for a specific endpoint by setting the
       * :ref:`hostname &lt;envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname&gt;` field.
       * </pre>
       *
       * <code>string host = 1 [(.validate.rules) = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearHost() {
        host_ = getDefaultInstance().getHost();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The value of the host header in the HTTP health check request. If
       * left empty (default value), the name of the cluster this health check is associated
       * with will be used. The host header can be customized for a specific endpoint by setting the
       * :ref:`hostname &lt;envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname&gt;` field.
       * </pre>
       *
       * <code>string host = 1 [(.validate.rules) = { ... }</code>
       * @param value The bytes for host to set.
       * @return This builder for chaining.
       */
      public Builder setHostBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        host_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object path_ = "";
      /**
       * <pre>
       * Specifies the HTTP path that will be requested during health checking. For example
       * ``/healthcheck``.
       * </pre>
       *
       * <code>string path = 2 [(.validate.rules) = { ... }</code>
       * @return The path.
       */
      public java.lang.String getPath() {
        java.lang.Object ref = path_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          path_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Specifies the HTTP path that will be requested during health checking. For example
       * ``/healthcheck``.
       * </pre>
       *
       * <code>string path = 2 [(.validate.rules) = { ... }</code>
       * @return The bytes for path.
       */
      public com.google.protobuf.ByteString
          getPathBytes() {
        java.lang.Object ref = path_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          path_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Specifies the HTTP path that will be requested during health checking. For example
       * ``/healthcheck``.
       * </pre>
       *
       * <code>string path = 2 [(.validate.rules) = { ... }</code>
       * @param value The path to set.
       * @return This builder for chaining.
       */
      public Builder setPath(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        path_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the HTTP path that will be requested during health checking. For example
       * ``/healthcheck``.
       * </pre>
       *
       * <code>string path = 2 [(.validate.rules) = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearPath() {
        path_ = getDefaultInstance().getPath();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the HTTP path that will be requested during health checking. For example
       * ``/healthcheck``.
       * </pre>
       *
       * <code>string path = 2 [(.validate.rules) = { ... }</code>
       * @param value The bytes for path to set.
       * @return This builder for chaining.
       */
      public Builder setPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        path_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload send_;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder> sendBuilder_;
      /**
       * <pre>
       * [#not-implemented-hide:] HTTP specific payload.
       * </pre>
       *
       * <code>.envoy.config.core.v3.HealthCheck.Payload send = 3;</code>
       * @return Whether the send field is set.
       */
      public boolean hasSend() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * [#not-implemented-hide:] HTTP specific payload.
       * </pre>
       *
       * <code>.envoy.config.core.v3.HealthCheck.Payload send = 3;</code>
       * @return The send.
       */
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload getSend() {
        if (sendBuilder_ == null) {
          return send_ == null ? io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.getDefaultInstance() : send_;
        } else {
          return sendBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * [#not-implemented-hide:] HTTP specific payload.
       * </pre>
       *
       * <code>.envoy.config.core.v3.HealthCheck.Payload send = 3;</code>
       */
      public Builder setSend(io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload value) {
        if (sendBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          send_ = value;
        } else {
          sendBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] HTTP specific payload.
       * </pre>
       *
       * <code>.envoy.config.core.v3.HealthCheck.Payload send = 3;</code>
       */
      public Builder setSend(
          io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder builderForValue) {
        if (sendBuilder_ == null) {
          send_ = builderForValue.build();
        } else {
          sendBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] HTTP specific payload.
       * </pre>
       *
       * <code>.envoy.config.core.v3.HealthCheck.Payload send = 3;</code>
       */
      public Builder mergeSend(io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload value) {
        if (sendBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            send_ != null &&
            send_ != io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.getDefaultInstance()) {
            getSendBuilder().mergeFrom(value);
          } else {
            send_ = value;
          }
        } else {
          sendBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] HTTP specific payload.
       * </pre>
       *
       * <code>.envoy.config.core.v3.HealthCheck.Payload send = 3;</code>
       */
      public Builder clearSend() {
        bitField0_ = (bitField0_ & ~0x00000004);
        send_ = null;
        if (sendBuilder_ != null) {
          sendBuilder_.dispose();
          sendBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] HTTP specific payload.
       * </pre>
       *
       * <code>.envoy.config.core.v3.HealthCheck.Payload send = 3;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder getSendBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getSendFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * [#not-implemented-hide:] HTTP specific payload.
       * </pre>
       *
       * <code>.envoy.config.core.v3.HealthCheck.Payload send = 3;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder getSendOrBuilder() {
        if (sendBuilder_ != null) {
          return sendBuilder_.getMessageOrBuilder();
        } else {
          return send_ == null ?
              io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.getDefaultInstance() : send_;
        }
      }
      /**
       * <pre>
       * [#not-implemented-hide:] HTTP specific payload.
       * </pre>
       *
       * <code>.envoy.config.core.v3.HealthCheck.Payload send = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder> 
          getSendFieldBuilder() {
        if (sendBuilder_ == null) {
          sendBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder>(
                  getSend(),
                  getParentForChildren(),
                  isClean());
          send_ = null;
        }
        return sendBuilder_;
      }

      private java.util.List<io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload> receive_ =
        java.util.Collections.emptyList();
      private void ensureReceiveIsMutable() {
        if (!((bitField0_ & 0x00000008) != 0)) {
          receive_ = new java.util.ArrayList<io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload>(receive_);
          bitField0_ |= 0x00000008;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder> receiveBuilder_;

      /**
       * <pre>
       * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
       * If it is set, both the expected response check and status code determine the health check.
       * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
       * and in the order specified, but not necessarily contiguous.
       * .. note::
       *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
       *   The default buffer size is 1024 bytes when it is not set.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
       */
      public java.util.List<io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload> getReceiveList() {
        if (receiveBuilder_ == null) {
          return java.util.Collections.unmodifiableList(receive_);
        } else {
          return receiveBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
       * If it is set, both the expected response check and status code determine the health check.
       * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
       * and in the order specified, but not necessarily contiguous.
       * .. note::
       *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
       *   The default buffer size is 1024 bytes when it is not set.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
       */
      public int getReceiveCount() {
        if (receiveBuilder_ == null) {
          return receive_.size();
        } else {
          return receiveBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
       * If it is set, both the expected response check and status code determine the health check.
       * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
       * and in the order specified, but not necessarily contiguous.
       * .. note::
       *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
       *   The default buffer size is 1024 bytes when it is not set.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload getReceive(int index) {
        if (receiveBuilder_ == null) {
          return receive_.get(index);
        } else {
          return receiveBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
       * If it is set, both the expected response check and status code determine the health check.
       * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
       * and in the order specified, but not necessarily contiguous.
       * .. note::
       *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
       *   The default buffer size is 1024 bytes when it is not set.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
       */
      public Builder setReceive(
          int index, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload value) {
        if (receiveBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureReceiveIsMutable();
          receive_.set(index, value);
          onChanged();
        } else {
          receiveBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
       * If it is set, both the expected response check and status code determine the health check.
       * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
       * and in the order specified, but not necessarily contiguous.
       * .. note::
       *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
       *   The default buffer size is 1024 bytes when it is not set.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
       */
      public Builder setReceive(
          int index, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder builderForValue) {
        if (receiveBuilder_ == null) {
          ensureReceiveIsMutable();
          receive_.set(index, builderForValue.build());
          onChanged();
        } else {
          receiveBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
       * If it is set, both the expected response check and status code determine the health check.
       * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
       * and in the order specified, but not necessarily contiguous.
       * .. note::
       *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
       *   The default buffer size is 1024 bytes when it is not set.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
       */
      public Builder addReceive(io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload value) {
        if (receiveBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureReceiveIsMutable();
          receive_.add(value);
          onChanged();
        } else {
          receiveBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
       * If it is set, both the expected response check and status code determine the health check.
       * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
       * and in the order specified, but not necessarily contiguous.
       * .. note::
       *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
       *   The default buffer size is 1024 bytes when it is not set.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
       */
      public Builder addReceive(
          int index, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload value) {
        if (receiveBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureReceiveIsMutable();
          receive_.add(index, value);
          onChanged();
        } else {
          receiveBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
       * If it is set, both the expected response check and status code determine the health check.
       * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
       * and in the order specified, but not necessarily contiguous.
       * .. note::
       *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
       *   The default buffer size is 1024 bytes when it is not set.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
       */
      public Builder addReceive(
          io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder builderForValue) {
        if (receiveBuilder_ == null) {
          ensureReceiveIsMutable();
          receive_.add(builderForValue.build());
          onChanged();
        } else {
          receiveBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
       * If it is set, both the expected response check and status code determine the health check.
       * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
       * and in the order specified, but not necessarily contiguous.
       * .. note::
       *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
       *   The default buffer size is 1024 bytes when it is not set.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
       */
      public Builder addReceive(
          int index, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder builderForValue) {
        if (receiveBuilder_ == null) {
          ensureReceiveIsMutable();
          receive_.add(index, builderForValue.build());
          onChanged();
        } else {
          receiveBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
       * If it is set, both the expected response check and status code determine the health check.
       * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
       * and in the order specified, but not necessarily contiguous.
       * .. note::
       *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
       *   The default buffer size is 1024 bytes when it is not set.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
       */
      public Builder addAllReceive(
          java.lang.Iterable<? extends io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload> values) {
        if (receiveBuilder_ == null) {
          ensureReceiveIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, receive_);
          onChanged();
        } else {
          receiveBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
       * If it is set, both the expected response check and status code determine the health check.
       * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
       * and in the order specified, but not necessarily contiguous.
       * .. note::
       *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
       *   The default buffer size is 1024 bytes when it is not set.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
       */
      public Builder clearReceive() {
        if (receiveBuilder_ == null) {
          receive_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
        } else {
          receiveBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
       * If it is set, both the expected response check and status code determine the health check.
       * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
       * and in the order specified, but not necessarily contiguous.
       * .. note::
       *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
       *   The default buffer size is 1024 bytes when it is not set.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
       */
      public Builder removeReceive(int index) {
        if (receiveBuilder_ == null) {
          ensureReceiveIsMutable();
          receive_.remove(index);
          onChanged();
        } else {
          receiveBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
       * If it is set, both the expected response check and status code determine the health check.
       * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
       * and in the order specified, but not necessarily contiguous.
       * .. note::
       *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
       *   The default buffer size is 1024 bytes when it is not set.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder getReceiveBuilder(
          int index) {
        return getReceiveFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
       * If it is set, both the expected response check and status code determine the health check.
       * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
       * and in the order specified, but not necessarily contiguous.
       * .. note::
       *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
       *   The default buffer size is 1024 bytes when it is not set.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder getReceiveOrBuilder(
          int index) {
        if (receiveBuilder_ == null) {
          return receive_.get(index);  } else {
          return receiveBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
       * If it is set, both the expected response check and status code determine the health check.
       * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
       * and in the order specified, but not necessarily contiguous.
       * .. note::
       *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
       *   The default buffer size is 1024 bytes when it is not set.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
       */
      public java.util.List<? extends io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder> 
           getReceiveOrBuilderList() {
        if (receiveBuilder_ != null) {
          return receiveBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(receive_);
        }
      }
      /**
       * <pre>
       * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
       * If it is set, both the expected response check and status code determine the health check.
       * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
       * and in the order specified, but not necessarily contiguous.
       * .. note::
       *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
       *   The default buffer size is 1024 bytes when it is not set.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder addReceiveBuilder() {
        return getReceiveFieldBuilder().addBuilder(
            io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
       * If it is set, both the expected response check and status code determine the health check.
       * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
       * and in the order specified, but not necessarily contiguous.
       * .. note::
       *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
       *   The default buffer size is 1024 bytes when it is not set.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder addReceiveBuilder(
          int index) {
        return getReceiveFieldBuilder().addBuilder(
            index, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
       * If it is set, both the expected response check and status code determine the health check.
       * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
       * and in the order specified, but not necessarily contiguous.
       * .. note::
       *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
       *   The default buffer size is 1024 bytes when it is not set.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 4;</code>
       */
      public java.util.List<io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder> 
           getReceiveBuilderList() {
        return getReceiveFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder> 
          getReceiveFieldBuilder() {
        if (receiveBuilder_ == null) {
          receiveBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder>(
                  receive_,
                  ((bitField0_ & 0x00000008) != 0),
                  getParentForChildren(),
                  isClean());
          receive_ = null;
        }
        return receiveBuilder_;
      }

      private com.google.protobuf.UInt64Value responseBufferSize_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.UInt64Value, com.google.protobuf.UInt64Value.Builder, com.google.protobuf.UInt64ValueOrBuilder> responseBufferSizeBuilder_;
      /**
       * <pre>
       * Specifies the size of response buffer in bytes that is used to Payload match.
       * The default value is 1024. Setting to 0 implies that the Payload will be matched against the entire response.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value response_buffer_size = 14 [(.validate.rules) = { ... }</code>
       * @return Whether the responseBufferSize field is set.
       */
      public boolean hasResponseBufferSize() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Specifies the size of response buffer in bytes that is used to Payload match.
       * The default value is 1024. Setting to 0 implies that the Payload will be matched against the entire response.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value response_buffer_size = 14 [(.validate.rules) = { ... }</code>
       * @return The responseBufferSize.
       */
      public com.google.protobuf.UInt64Value getResponseBufferSize() {
        if (responseBufferSizeBuilder_ == null) {
          return responseBufferSize_ == null ? com.google.protobuf.UInt64Value.getDefaultInstance() : responseBufferSize_;
        } else {
          return responseBufferSizeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specifies the size of response buffer in bytes that is used to Payload match.
       * The default value is 1024. Setting to 0 implies that the Payload will be matched against the entire response.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value response_buffer_size = 14 [(.validate.rules) = { ... }</code>
       */
      public Builder setResponseBufferSize(com.google.protobuf.UInt64Value value) {
        if (responseBufferSizeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          responseBufferSize_ = value;
        } else {
          responseBufferSizeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the size of response buffer in bytes that is used to Payload match.
       * The default value is 1024. Setting to 0 implies that the Payload will be matched against the entire response.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value response_buffer_size = 14 [(.validate.rules) = { ... }</code>
       */
      public Builder setResponseBufferSize(
          com.google.protobuf.UInt64Value.Builder builderForValue) {
        if (responseBufferSizeBuilder_ == null) {
          responseBufferSize_ = builderForValue.build();
        } else {
          responseBufferSizeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the size of response buffer in bytes that is used to Payload match.
       * The default value is 1024. Setting to 0 implies that the Payload will be matched against the entire response.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value response_buffer_size = 14 [(.validate.rules) = { ... }</code>
       */
      public Builder mergeResponseBufferSize(com.google.protobuf.UInt64Value value) {
        if (responseBufferSizeBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0) &&
            responseBufferSize_ != null &&
            responseBufferSize_ != com.google.protobuf.UInt64Value.getDefaultInstance()) {
            getResponseBufferSizeBuilder().mergeFrom(value);
          } else {
            responseBufferSize_ = value;
          }
        } else {
          responseBufferSizeBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the size of response buffer in bytes that is used to Payload match.
       * The default value is 1024. Setting to 0 implies that the Payload will be matched against the entire response.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value response_buffer_size = 14 [(.validate.rules) = { ... }</code>
       */
      public Builder clearResponseBufferSize() {
        bitField0_ = (bitField0_ & ~0x00000010);
        responseBufferSize_ = null;
        if (responseBufferSizeBuilder_ != null) {
          responseBufferSizeBuilder_.dispose();
          responseBufferSizeBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the size of response buffer in bytes that is used to Payload match.
       * The default value is 1024. Setting to 0 implies that the Payload will be matched against the entire response.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value response_buffer_size = 14 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.UInt64Value.Builder getResponseBufferSizeBuilder() {
        bitField0_ |= 0x00000010;
        onChanged();
        return getResponseBufferSizeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specifies the size of response buffer in bytes that is used to Payload match.
       * The default value is 1024. Setting to 0 implies that the Payload will be matched against the entire response.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value response_buffer_size = 14 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.UInt64ValueOrBuilder getResponseBufferSizeOrBuilder() {
        if (responseBufferSizeBuilder_ != null) {
          return responseBufferSizeBuilder_.getMessageOrBuilder();
        } else {
          return responseBufferSize_ == null ?
              com.google.protobuf.UInt64Value.getDefaultInstance() : responseBufferSize_;
        }
      }
      /**
       * <pre>
       * Specifies the size of response buffer in bytes that is used to Payload match.
       * The default value is 1024. Setting to 0 implies that the Payload will be matched against the entire response.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value response_buffer_size = 14 [(.validate.rules) = { ... }</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.UInt64Value, com.google.protobuf.UInt64Value.Builder, com.google.protobuf.UInt64ValueOrBuilder> 
          getResponseBufferSizeFieldBuilder() {
        if (responseBufferSizeBuilder_ == null) {
          responseBufferSizeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.UInt64Value, com.google.protobuf.UInt64Value.Builder, com.google.protobuf.UInt64ValueOrBuilder>(
                  getResponseBufferSize(),
                  getParentForChildren(),
                  isClean());
          responseBufferSize_ = null;
        }
        return responseBufferSizeBuilder_;
      }

      private java.util.List<io.envoyproxy.envoy.config.core.v3.HeaderValueOption> requestHeadersToAdd_ =
        java.util.Collections.emptyList();
      private void ensureRequestHeadersToAddIsMutable() {
        if (!((bitField0_ & 0x00000020) != 0)) {
          requestHeadersToAdd_ = new java.util.ArrayList<io.envoyproxy.envoy.config.core.v3.HeaderValueOption>(requestHeadersToAdd_);
          bitField0_ |= 0x00000020;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.config.core.v3.HeaderValueOption, io.envoyproxy.envoy.config.core.v3.HeaderValueOption.Builder, io.envoyproxy.envoy.config.core.v3.HeaderValueOptionOrBuilder> requestHeadersToAddBuilder_;

      /**
       * <pre>
       * Specifies a list of HTTP headers that should be added to each request that is sent to the
       * health checked cluster. For more information, including details on header value syntax, see
       * the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
       */
      public java.util.List<io.envoyproxy.envoy.config.core.v3.HeaderValueOption> getRequestHeadersToAddList() {
        if (requestHeadersToAddBuilder_ == null) {
          return java.util.Collections.unmodifiableList(requestHeadersToAdd_);
        } else {
          return requestHeadersToAddBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be added to each request that is sent to the
       * health checked cluster. For more information, including details on header value syntax, see
       * the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
       */
      public int getRequestHeadersToAddCount() {
        if (requestHeadersToAddBuilder_ == null) {
          return requestHeadersToAdd_.size();
        } else {
          return requestHeadersToAddBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be added to each request that is sent to the
       * health checked cluster. For more information, including details on header value syntax, see
       * the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HeaderValueOption getRequestHeadersToAdd(int index) {
        if (requestHeadersToAddBuilder_ == null) {
          return requestHeadersToAdd_.get(index);
        } else {
          return requestHeadersToAddBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be added to each request that is sent to the
       * health checked cluster. For more information, including details on header value syntax, see
       * the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
       */
      public Builder setRequestHeadersToAdd(
          int index, io.envoyproxy.envoy.config.core.v3.HeaderValueOption value) {
        if (requestHeadersToAddBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRequestHeadersToAddIsMutable();
          requestHeadersToAdd_.set(index, value);
          onChanged();
        } else {
          requestHeadersToAddBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be added to each request that is sent to the
       * health checked cluster. For more information, including details on header value syntax, see
       * the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
       */
      public Builder setRequestHeadersToAdd(
          int index, io.envoyproxy.envoy.config.core.v3.HeaderValueOption.Builder builderForValue) {
        if (requestHeadersToAddBuilder_ == null) {
          ensureRequestHeadersToAddIsMutable();
          requestHeadersToAdd_.set(index, builderForValue.build());
          onChanged();
        } else {
          requestHeadersToAddBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be added to each request that is sent to the
       * health checked cluster. For more information, including details on header value syntax, see
       * the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
       */
      public Builder addRequestHeadersToAdd(io.envoyproxy.envoy.config.core.v3.HeaderValueOption value) {
        if (requestHeadersToAddBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRequestHeadersToAddIsMutable();
          requestHeadersToAdd_.add(value);
          onChanged();
        } else {
          requestHeadersToAddBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be added to each request that is sent to the
       * health checked cluster. For more information, including details on header value syntax, see
       * the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
       */
      public Builder addRequestHeadersToAdd(
          int index, io.envoyproxy.envoy.config.core.v3.HeaderValueOption value) {
        if (requestHeadersToAddBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRequestHeadersToAddIsMutable();
          requestHeadersToAdd_.add(index, value);
          onChanged();
        } else {
          requestHeadersToAddBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be added to each request that is sent to the
       * health checked cluster. For more information, including details on header value syntax, see
       * the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
       */
      public Builder addRequestHeadersToAdd(
          io.envoyproxy.envoy.config.core.v3.HeaderValueOption.Builder builderForValue) {
        if (requestHeadersToAddBuilder_ == null) {
          ensureRequestHeadersToAddIsMutable();
          requestHeadersToAdd_.add(builderForValue.build());
          onChanged();
        } else {
          requestHeadersToAddBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be added to each request that is sent to the
       * health checked cluster. For more information, including details on header value syntax, see
       * the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
       */
      public Builder addRequestHeadersToAdd(
          int index, io.envoyproxy.envoy.config.core.v3.HeaderValueOption.Builder builderForValue) {
        if (requestHeadersToAddBuilder_ == null) {
          ensureRequestHeadersToAddIsMutable();
          requestHeadersToAdd_.add(index, builderForValue.build());
          onChanged();
        } else {
          requestHeadersToAddBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be added to each request that is sent to the
       * health checked cluster. For more information, including details on header value syntax, see
       * the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
       */
      public Builder addAllRequestHeadersToAdd(
          java.lang.Iterable<? extends io.envoyproxy.envoy.config.core.v3.HeaderValueOption> values) {
        if (requestHeadersToAddBuilder_ == null) {
          ensureRequestHeadersToAddIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, requestHeadersToAdd_);
          onChanged();
        } else {
          requestHeadersToAddBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be added to each request that is sent to the
       * health checked cluster. For more information, including details on header value syntax, see
       * the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
       */
      public Builder clearRequestHeadersToAdd() {
        if (requestHeadersToAddBuilder_ == null) {
          requestHeadersToAdd_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
        } else {
          requestHeadersToAddBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be added to each request that is sent to the
       * health checked cluster. For more information, including details on header value syntax, see
       * the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
       */
      public Builder removeRequestHeadersToAdd(int index) {
        if (requestHeadersToAddBuilder_ == null) {
          ensureRequestHeadersToAddIsMutable();
          requestHeadersToAdd_.remove(index);
          onChanged();
        } else {
          requestHeadersToAddBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be added to each request that is sent to the
       * health checked cluster. For more information, including details on header value syntax, see
       * the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HeaderValueOption.Builder getRequestHeadersToAddBuilder(
          int index) {
        return getRequestHeadersToAddFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be added to each request that is sent to the
       * health checked cluster. For more information, including details on header value syntax, see
       * the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HeaderValueOptionOrBuilder getRequestHeadersToAddOrBuilder(
          int index) {
        if (requestHeadersToAddBuilder_ == null) {
          return requestHeadersToAdd_.get(index);  } else {
          return requestHeadersToAddBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be added to each request that is sent to the
       * health checked cluster. For more information, including details on header value syntax, see
       * the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
       */
      public java.util.List<? extends io.envoyproxy.envoy.config.core.v3.HeaderValueOptionOrBuilder> 
           getRequestHeadersToAddOrBuilderList() {
        if (requestHeadersToAddBuilder_ != null) {
          return requestHeadersToAddBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(requestHeadersToAdd_);
        }
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be added to each request that is sent to the
       * health checked cluster. For more information, including details on header value syntax, see
       * the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HeaderValueOption.Builder addRequestHeadersToAddBuilder() {
        return getRequestHeadersToAddFieldBuilder().addBuilder(
            io.envoyproxy.envoy.config.core.v3.HeaderValueOption.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be added to each request that is sent to the
       * health checked cluster. For more information, including details on header value syntax, see
       * the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HeaderValueOption.Builder addRequestHeadersToAddBuilder(
          int index) {
        return getRequestHeadersToAddFieldBuilder().addBuilder(
            index, io.envoyproxy.envoy.config.core.v3.HeaderValueOption.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be added to each request that is sent to the
       * health checked cluster. For more information, including details on header value syntax, see
       * the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6 [(.validate.rules) = { ... }</code>
       */
      public java.util.List<io.envoyproxy.envoy.config.core.v3.HeaderValueOption.Builder> 
           getRequestHeadersToAddBuilderList() {
        return getRequestHeadersToAddFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.config.core.v3.HeaderValueOption, io.envoyproxy.envoy.config.core.v3.HeaderValueOption.Builder, io.envoyproxy.envoy.config.core.v3.HeaderValueOptionOrBuilder> 
          getRequestHeadersToAddFieldBuilder() {
        if (requestHeadersToAddBuilder_ == null) {
          requestHeadersToAddBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.envoyproxy.envoy.config.core.v3.HeaderValueOption, io.envoyproxy.envoy.config.core.v3.HeaderValueOption.Builder, io.envoyproxy.envoy.config.core.v3.HeaderValueOptionOrBuilder>(
                  requestHeadersToAdd_,
                  ((bitField0_ & 0x00000020) != 0),
                  getParentForChildren(),
                  isClean());
          requestHeadersToAdd_ = null;
        }
        return requestHeadersToAddBuilder_;
      }

      private com.google.protobuf.LazyStringList requestHeadersToRemove_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureRequestHeadersToRemoveIsMutable() {
        if (!((bitField0_ & 0x00000040) != 0)) {
          requestHeadersToRemove_ = new com.google.protobuf.LazyStringArrayList(requestHeadersToRemove_);
          bitField0_ |= 0x00000040;
         }
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be removed from each request that is sent to the
       * health checked cluster.
       * </pre>
       *
       * <code>repeated string request_headers_to_remove = 8 [(.validate.rules) = { ... }</code>
       * @return A list containing the requestHeadersToRemove.
       */
      public com.google.protobuf.ProtocolStringList
          getRequestHeadersToRemoveList() {
        return requestHeadersToRemove_.getUnmodifiableView();
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be removed from each request that is sent to the
       * health checked cluster.
       * </pre>
       *
       * <code>repeated string request_headers_to_remove = 8 [(.validate.rules) = { ... }</code>
       * @return The count of requestHeadersToRemove.
       */
      public int getRequestHeadersToRemoveCount() {
        return requestHeadersToRemove_.size();
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be removed from each request that is sent to the
       * health checked cluster.
       * </pre>
       *
       * <code>repeated string request_headers_to_remove = 8 [(.validate.rules) = { ... }</code>
       * @param index The index of the element to return.
       * @return The requestHeadersToRemove at the given index.
       */
      public java.lang.String getRequestHeadersToRemove(int index) {
        return requestHeadersToRemove_.get(index);
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be removed from each request that is sent to the
       * health checked cluster.
       * </pre>
       *
       * <code>repeated string request_headers_to_remove = 8 [(.validate.rules) = { ... }</code>
       * @param index The index of the value to return.
       * @return The bytes of the requestHeadersToRemove at the given index.
       */
      public com.google.protobuf.ByteString
          getRequestHeadersToRemoveBytes(int index) {
        return requestHeadersToRemove_.getByteString(index);
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be removed from each request that is sent to the
       * health checked cluster.
       * </pre>
       *
       * <code>repeated string request_headers_to_remove = 8 [(.validate.rules) = { ... }</code>
       * @param index The index to set the value at.
       * @param value The requestHeadersToRemove to set.
       * @return This builder for chaining.
       */
      public Builder setRequestHeadersToRemove(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureRequestHeadersToRemoveIsMutable();
        requestHeadersToRemove_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be removed from each request that is sent to the
       * health checked cluster.
       * </pre>
       *
       * <code>repeated string request_headers_to_remove = 8 [(.validate.rules) = { ... }</code>
       * @param value The requestHeadersToRemove to add.
       * @return This builder for chaining.
       */
      public Builder addRequestHeadersToRemove(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureRequestHeadersToRemoveIsMutable();
        requestHeadersToRemove_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be removed from each request that is sent to the
       * health checked cluster.
       * </pre>
       *
       * <code>repeated string request_headers_to_remove = 8 [(.validate.rules) = { ... }</code>
       * @param values The requestHeadersToRemove to add.
       * @return This builder for chaining.
       */
      public Builder addAllRequestHeadersToRemove(
          java.lang.Iterable<java.lang.String> values) {
        ensureRequestHeadersToRemoveIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, requestHeadersToRemove_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be removed from each request that is sent to the
       * health checked cluster.
       * </pre>
       *
       * <code>repeated string request_headers_to_remove = 8 [(.validate.rules) = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearRequestHeadersToRemove() {
        requestHeadersToRemove_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000040);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP headers that should be removed from each request that is sent to the
       * health checked cluster.
       * </pre>
       *
       * <code>repeated string request_headers_to_remove = 8 [(.validate.rules) = { ... }</code>
       * @param value The bytes of the requestHeadersToRemove to add.
       * @return This builder for chaining.
       */
      public Builder addRequestHeadersToRemoveBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        ensureRequestHeadersToRemoveIsMutable();
        requestHeadersToRemove_.add(value);
        onChanged();
        return this;
      }

      private java.util.List<io.envoyproxy.envoy.type.v3.Int64Range> expectedStatuses_ =
        java.util.Collections.emptyList();
      private void ensureExpectedStatusesIsMutable() {
        if (!((bitField0_ & 0x00000080) != 0)) {
          expectedStatuses_ = new java.util.ArrayList<io.envoyproxy.envoy.type.v3.Int64Range>(expectedStatuses_);
          bitField0_ |= 0x00000080;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.type.v3.Int64Range, io.envoyproxy.envoy.type.v3.Int64Range.Builder, io.envoyproxy.envoy.type.v3.Int64RangeOrBuilder> expectedStatusesBuilder_;

      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
       * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
       * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
       * range are required. Only statuses in the range [100, 600) are allowed.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
       */
      public java.util.List<io.envoyproxy.envoy.type.v3.Int64Range> getExpectedStatusesList() {
        if (expectedStatusesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(expectedStatuses_);
        } else {
          return expectedStatusesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
       * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
       * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
       * range are required. Only statuses in the range [100, 600) are allowed.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
       */
      public int getExpectedStatusesCount() {
        if (expectedStatusesBuilder_ == null) {
          return expectedStatuses_.size();
        } else {
          return expectedStatusesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
       * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
       * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
       * range are required. Only statuses in the range [100, 600) are allowed.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
       */
      public io.envoyproxy.envoy.type.v3.Int64Range getExpectedStatuses(int index) {
        if (expectedStatusesBuilder_ == null) {
          return expectedStatuses_.get(index);
        } else {
          return expectedStatusesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
       * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
       * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
       * range are required. Only statuses in the range [100, 600) are allowed.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
       */
      public Builder setExpectedStatuses(
          int index, io.envoyproxy.envoy.type.v3.Int64Range value) {
        if (expectedStatusesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExpectedStatusesIsMutable();
          expectedStatuses_.set(index, value);
          onChanged();
        } else {
          expectedStatusesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
       * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
       * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
       * range are required. Only statuses in the range [100, 600) are allowed.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
       */
      public Builder setExpectedStatuses(
          int index, io.envoyproxy.envoy.type.v3.Int64Range.Builder builderForValue) {
        if (expectedStatusesBuilder_ == null) {
          ensureExpectedStatusesIsMutable();
          expectedStatuses_.set(index, builderForValue.build());
          onChanged();
        } else {
          expectedStatusesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
       * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
       * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
       * range are required. Only statuses in the range [100, 600) are allowed.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
       */
      public Builder addExpectedStatuses(io.envoyproxy.envoy.type.v3.Int64Range value) {
        if (expectedStatusesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExpectedStatusesIsMutable();
          expectedStatuses_.add(value);
          onChanged();
        } else {
          expectedStatusesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
       * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
       * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
       * range are required. Only statuses in the range [100, 600) are allowed.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
       */
      public Builder addExpectedStatuses(
          int index, io.envoyproxy.envoy.type.v3.Int64Range value) {
        if (expectedStatusesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExpectedStatusesIsMutable();
          expectedStatuses_.add(index, value);
          onChanged();
        } else {
          expectedStatusesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
       * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
       * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
       * range are required. Only statuses in the range [100, 600) are allowed.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
       */
      public Builder addExpectedStatuses(
          io.envoyproxy.envoy.type.v3.Int64Range.Builder builderForValue) {
        if (expectedStatusesBuilder_ == null) {
          ensureExpectedStatusesIsMutable();
          expectedStatuses_.add(builderForValue.build());
          onChanged();
        } else {
          expectedStatusesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
       * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
       * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
       * range are required. Only statuses in the range [100, 600) are allowed.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
       */
      public Builder addExpectedStatuses(
          int index, io.envoyproxy.envoy.type.v3.Int64Range.Builder builderForValue) {
        if (expectedStatusesBuilder_ == null) {
          ensureExpectedStatusesIsMutable();
          expectedStatuses_.add(index, builderForValue.build());
          onChanged();
        } else {
          expectedStatusesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
       * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
       * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
       * range are required. Only statuses in the range [100, 600) are allowed.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
       */
      public Builder addAllExpectedStatuses(
          java.lang.Iterable<? extends io.envoyproxy.envoy.type.v3.Int64Range> values) {
        if (expectedStatusesBuilder_ == null) {
          ensureExpectedStatusesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, expectedStatuses_);
          onChanged();
        } else {
          expectedStatusesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
       * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
       * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
       * range are required. Only statuses in the range [100, 600) are allowed.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
       */
      public Builder clearExpectedStatuses() {
        if (expectedStatusesBuilder_ == null) {
          expectedStatuses_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000080);
          onChanged();
        } else {
          expectedStatusesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
       * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
       * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
       * range are required. Only statuses in the range [100, 600) are allowed.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
       */
      public Builder removeExpectedStatuses(int index) {
        if (expectedStatusesBuilder_ == null) {
          ensureExpectedStatusesIsMutable();
          expectedStatuses_.remove(index);
          onChanged();
        } else {
          expectedStatusesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
       * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
       * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
       * range are required. Only statuses in the range [100, 600) are allowed.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
       */
      public io.envoyproxy.envoy.type.v3.Int64Range.Builder getExpectedStatusesBuilder(
          int index) {
        return getExpectedStatusesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
       * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
       * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
       * range are required. Only statuses in the range [100, 600) are allowed.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
       */
      public io.envoyproxy.envoy.type.v3.Int64RangeOrBuilder getExpectedStatusesOrBuilder(
          int index) {
        if (expectedStatusesBuilder_ == null) {
          return expectedStatuses_.get(index);  } else {
          return expectedStatusesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
       * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
       * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
       * range are required. Only statuses in the range [100, 600) are allowed.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
       */
      public java.util.List<? extends io.envoyproxy.envoy.type.v3.Int64RangeOrBuilder> 
           getExpectedStatusesOrBuilderList() {
        if (expectedStatusesBuilder_ != null) {
          return expectedStatusesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(expectedStatuses_);
        }
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
       * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
       * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
       * range are required. Only statuses in the range [100, 600) are allowed.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
       */
      public io.envoyproxy.envoy.type.v3.Int64Range.Builder addExpectedStatusesBuilder() {
        return getExpectedStatusesFieldBuilder().addBuilder(
            io.envoyproxy.envoy.type.v3.Int64Range.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
       * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
       * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
       * range are required. Only statuses in the range [100, 600) are allowed.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
       */
      public io.envoyproxy.envoy.type.v3.Int64Range.Builder addExpectedStatusesBuilder(
          int index) {
        return getExpectedStatusesFieldBuilder().addBuilder(
            index, io.envoyproxy.envoy.type.v3.Int64Range.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
       * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
       * semantics of :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each
       * range are required. Only statuses in the range [100, 600) are allowed.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range expected_statuses = 9;</code>
       */
      public java.util.List<io.envoyproxy.envoy.type.v3.Int64Range.Builder> 
           getExpectedStatusesBuilderList() {
        return getExpectedStatusesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.type.v3.Int64Range, io.envoyproxy.envoy.type.v3.Int64Range.Builder, io.envoyproxy.envoy.type.v3.Int64RangeOrBuilder> 
          getExpectedStatusesFieldBuilder() {
        if (expectedStatusesBuilder_ == null) {
          expectedStatusesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.envoyproxy.envoy.type.v3.Int64Range, io.envoyproxy.envoy.type.v3.Int64Range.Builder, io.envoyproxy.envoy.type.v3.Int64RangeOrBuilder>(
                  expectedStatuses_,
                  ((bitField0_ & 0x00000080) != 0),
                  getParentForChildren(),
                  isClean());
          expectedStatuses_ = null;
        }
        return expectedStatusesBuilder_;
      }

      private java.util.List<io.envoyproxy.envoy.type.v3.Int64Range> retriableStatuses_ =
        java.util.Collections.emptyList();
      private void ensureRetriableStatusesIsMutable() {
        if (!((bitField0_ & 0x00000100) != 0)) {
          retriableStatuses_ = new java.util.ArrayList<io.envoyproxy.envoy.type.v3.Int64Range>(retriableStatuses_);
          bitField0_ |= 0x00000100;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.type.v3.Int64Range, io.envoyproxy.envoy.type.v3.Int64Range.Builder, io.envoyproxy.envoy.type.v3.Int64RangeOrBuilder> retriableStatusesBuilder_;

      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
       * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
       * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
       * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
       * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
       * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
       * be considered a successful health check. By default all responses not in
       * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
       * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
       * non-200 response will result in the host being marked unhealthy.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
       */
      public java.util.List<io.envoyproxy.envoy.type.v3.Int64Range> getRetriableStatusesList() {
        if (retriableStatusesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(retriableStatuses_);
        } else {
          return retriableStatusesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
       * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
       * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
       * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
       * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
       * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
       * be considered a successful health check. By default all responses not in
       * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
       * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
       * non-200 response will result in the host being marked unhealthy.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
       */
      public int getRetriableStatusesCount() {
        if (retriableStatusesBuilder_ == null) {
          return retriableStatuses_.size();
        } else {
          return retriableStatusesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
       * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
       * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
       * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
       * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
       * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
       * be considered a successful health check. By default all responses not in
       * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
       * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
       * non-200 response will result in the host being marked unhealthy.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
       */
      public io.envoyproxy.envoy.type.v3.Int64Range getRetriableStatuses(int index) {
        if (retriableStatusesBuilder_ == null) {
          return retriableStatuses_.get(index);
        } else {
          return retriableStatusesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
       * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
       * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
       * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
       * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
       * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
       * be considered a successful health check. By default all responses not in
       * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
       * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
       * non-200 response will result in the host being marked unhealthy.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
       */
      public Builder setRetriableStatuses(
          int index, io.envoyproxy.envoy.type.v3.Int64Range value) {
        if (retriableStatusesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRetriableStatusesIsMutable();
          retriableStatuses_.set(index, value);
          onChanged();
        } else {
          retriableStatusesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
       * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
       * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
       * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
       * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
       * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
       * be considered a successful health check. By default all responses not in
       * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
       * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
       * non-200 response will result in the host being marked unhealthy.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
       */
      public Builder setRetriableStatuses(
          int index, io.envoyproxy.envoy.type.v3.Int64Range.Builder builderForValue) {
        if (retriableStatusesBuilder_ == null) {
          ensureRetriableStatusesIsMutable();
          retriableStatuses_.set(index, builderForValue.build());
          onChanged();
        } else {
          retriableStatusesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
       * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
       * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
       * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
       * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
       * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
       * be considered a successful health check. By default all responses not in
       * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
       * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
       * non-200 response will result in the host being marked unhealthy.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
       */
      public Builder addRetriableStatuses(io.envoyproxy.envoy.type.v3.Int64Range value) {
        if (retriableStatusesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRetriableStatusesIsMutable();
          retriableStatuses_.add(value);
          onChanged();
        } else {
          retriableStatusesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
       * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
       * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
       * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
       * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
       * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
       * be considered a successful health check. By default all responses not in
       * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
       * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
       * non-200 response will result in the host being marked unhealthy.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
       */
      public Builder addRetriableStatuses(
          int index, io.envoyproxy.envoy.type.v3.Int64Range value) {
        if (retriableStatusesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRetriableStatusesIsMutable();
          retriableStatuses_.add(index, value);
          onChanged();
        } else {
          retriableStatusesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
       * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
       * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
       * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
       * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
       * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
       * be considered a successful health check. By default all responses not in
       * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
       * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
       * non-200 response will result in the host being marked unhealthy.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
       */
      public Builder addRetriableStatuses(
          io.envoyproxy.envoy.type.v3.Int64Range.Builder builderForValue) {
        if (retriableStatusesBuilder_ == null) {
          ensureRetriableStatusesIsMutable();
          retriableStatuses_.add(builderForValue.build());
          onChanged();
        } else {
          retriableStatusesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
       * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
       * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
       * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
       * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
       * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
       * be considered a successful health check. By default all responses not in
       * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
       * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
       * non-200 response will result in the host being marked unhealthy.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
       */
      public Builder addRetriableStatuses(
          int index, io.envoyproxy.envoy.type.v3.Int64Range.Builder builderForValue) {
        if (retriableStatusesBuilder_ == null) {
          ensureRetriableStatusesIsMutable();
          retriableStatuses_.add(index, builderForValue.build());
          onChanged();
        } else {
          retriableStatusesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
       * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
       * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
       * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
       * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
       * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
       * be considered a successful health check. By default all responses not in
       * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
       * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
       * non-200 response will result in the host being marked unhealthy.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
       */
      public Builder addAllRetriableStatuses(
          java.lang.Iterable<? extends io.envoyproxy.envoy.type.v3.Int64Range> values) {
        if (retriableStatusesBuilder_ == null) {
          ensureRetriableStatusesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, retriableStatuses_);
          onChanged();
        } else {
          retriableStatusesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
       * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
       * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
       * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
       * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
       * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
       * be considered a successful health check. By default all responses not in
       * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
       * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
       * non-200 response will result in the host being marked unhealthy.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
       */
      public Builder clearRetriableStatuses() {
        if (retriableStatusesBuilder_ == null) {
          retriableStatuses_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000100);
          onChanged();
        } else {
          retriableStatusesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
       * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
       * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
       * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
       * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
       * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
       * be considered a successful health check. By default all responses not in
       * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
       * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
       * non-200 response will result in the host being marked unhealthy.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
       */
      public Builder removeRetriableStatuses(int index) {
        if (retriableStatusesBuilder_ == null) {
          ensureRetriableStatusesIsMutable();
          retriableStatuses_.remove(index);
          onChanged();
        } else {
          retriableStatusesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
       * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
       * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
       * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
       * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
       * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
       * be considered a successful health check. By default all responses not in
       * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
       * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
       * non-200 response will result in the host being marked unhealthy.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
       */
      public io.envoyproxy.envoy.type.v3.Int64Range.Builder getRetriableStatusesBuilder(
          int index) {
        return getRetriableStatusesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
       * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
       * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
       * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
       * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
       * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
       * be considered a successful health check. By default all responses not in
       * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
       * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
       * non-200 response will result in the host being marked unhealthy.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
       */
      public io.envoyproxy.envoy.type.v3.Int64RangeOrBuilder getRetriableStatusesOrBuilder(
          int index) {
        if (retriableStatusesBuilder_ == null) {
          return retriableStatuses_.get(index);  } else {
          return retriableStatusesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
       * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
       * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
       * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
       * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
       * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
       * be considered a successful health check. By default all responses not in
       * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
       * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
       * non-200 response will result in the host being marked unhealthy.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
       */
      public java.util.List<? extends io.envoyproxy.envoy.type.v3.Int64RangeOrBuilder> 
           getRetriableStatusesOrBuilderList() {
        if (retriableStatusesBuilder_ != null) {
          return retriableStatusesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(retriableStatuses_);
        }
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
       * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
       * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
       * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
       * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
       * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
       * be considered a successful health check. By default all responses not in
       * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
       * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
       * non-200 response will result in the host being marked unhealthy.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
       */
      public io.envoyproxy.envoy.type.v3.Int64Range.Builder addRetriableStatusesBuilder() {
        return getRetriableStatusesFieldBuilder().addBuilder(
            io.envoyproxy.envoy.type.v3.Int64Range.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
       * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
       * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
       * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
       * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
       * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
       * be considered a successful health check. By default all responses not in
       * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
       * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
       * non-200 response will result in the host being marked unhealthy.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
       */
      public io.envoyproxy.envoy.type.v3.Int64Range.Builder addRetriableStatusesBuilder(
          int index) {
        return getRetriableStatusesFieldBuilder().addBuilder(
            index, io.envoyproxy.envoy.type.v3.Int64Range.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
       * will count towards the configured :ref:`unhealthy_threshold &lt;envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold&gt;`,
       * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
       * :ref:`Int64Range &lt;envoy_v3_api_msg_type.v3.Int64Range&gt;`. The start and end of each range are required.
       * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
       * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
       * be considered a successful health check. By default all responses not in
       * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;` will result in
       * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
       * non-200 response will result in the host being marked unhealthy.
       * </pre>
       *
       * <code>repeated .envoy.type.v3.Int64Range retriable_statuses = 12;</code>
       */
      public java.util.List<io.envoyproxy.envoy.type.v3.Int64Range.Builder> 
           getRetriableStatusesBuilderList() {
        return getRetriableStatusesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.type.v3.Int64Range, io.envoyproxy.envoy.type.v3.Int64Range.Builder, io.envoyproxy.envoy.type.v3.Int64RangeOrBuilder> 
          getRetriableStatusesFieldBuilder() {
        if (retriableStatusesBuilder_ == null) {
          retriableStatusesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.envoyproxy.envoy.type.v3.Int64Range, io.envoyproxy.envoy.type.v3.Int64Range.Builder, io.envoyproxy.envoy.type.v3.Int64RangeOrBuilder>(
                  retriableStatuses_,
                  ((bitField0_ & 0x00000100) != 0),
                  getParentForChildren(),
                  isClean());
          retriableStatuses_ = null;
        }
        return retriableStatusesBuilder_;
      }

      private int codecClientType_ = 0;
      /**
       * <pre>
       * Use specified application protocol for health checks.
       * </pre>
       *
       * <code>.envoy.type.v3.CodecClientType codec_client_type = 10 [(.validate.rules) = { ... }</code>
       * @return The enum numeric value on the wire for codecClientType.
       */
      @java.lang.Override public int getCodecClientTypeValue() {
        return codecClientType_;
      }
      /**
       * <pre>
       * Use specified application protocol for health checks.
       * </pre>
       *
       * <code>.envoy.type.v3.CodecClientType codec_client_type = 10 [(.validate.rules) = { ... }</code>
       * @param value The enum numeric value on the wire for codecClientType to set.
       * @return This builder for chaining.
       */
      public Builder setCodecClientTypeValue(int value) {
        codecClientType_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Use specified application protocol for health checks.
       * </pre>
       *
       * <code>.envoy.type.v3.CodecClientType codec_client_type = 10 [(.validate.rules) = { ... }</code>
       * @return The codecClientType.
       */
      @java.lang.Override
      public io.envoyproxy.envoy.type.v3.CodecClientType getCodecClientType() {
        io.envoyproxy.envoy.type.v3.CodecClientType result = io.envoyproxy.envoy.type.v3.CodecClientType.forNumber(codecClientType_);
        return result == null ? io.envoyproxy.envoy.type.v3.CodecClientType.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Use specified application protocol for health checks.
       * </pre>
       *
       * <code>.envoy.type.v3.CodecClientType codec_client_type = 10 [(.validate.rules) = { ... }</code>
       * @param value The codecClientType to set.
       * @return This builder for chaining.
       */
      public Builder setCodecClientType(io.envoyproxy.envoy.type.v3.CodecClientType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000200;
        codecClientType_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Use specified application protocol for health checks.
       * </pre>
       *
       * <code>.envoy.type.v3.CodecClientType codec_client_type = 10 [(.validate.rules) = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearCodecClientType() {
        bitField0_ = (bitField0_ & ~0x00000200);
        codecClientType_ = 0;
        onChanged();
        return this;
      }

      private io.envoyproxy.envoy.type.matcher.v3.StringMatcher serviceNameMatcher_;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.type.matcher.v3.StringMatcher, io.envoyproxy.envoy.type.matcher.v3.StringMatcher.Builder, io.envoyproxy.envoy.type.matcher.v3.StringMatcherOrBuilder> serviceNameMatcherBuilder_;
      /**
       * <pre>
       * An optional service name parameter which is used to validate the identity of
       * the health checked cluster using a :ref:`StringMatcher
       * &lt;envoy_v3_api_msg_type.matcher.v3.StringMatcher&gt;`. See the :ref:`architecture overview
       * &lt;arch_overview_health_checking_identity&gt;` for more information.
       * </pre>
       *
       * <code>.envoy.type.matcher.v3.StringMatcher service_name_matcher = 11;</code>
       * @return Whether the serviceNameMatcher field is set.
       */
      public boolean hasServiceNameMatcher() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * An optional service name parameter which is used to validate the identity of
       * the health checked cluster using a :ref:`StringMatcher
       * &lt;envoy_v3_api_msg_type.matcher.v3.StringMatcher&gt;`. See the :ref:`architecture overview
       * &lt;arch_overview_health_checking_identity&gt;` for more information.
       * </pre>
       *
       * <code>.envoy.type.matcher.v3.StringMatcher service_name_matcher = 11;</code>
       * @return The serviceNameMatcher.
       */
      public io.envoyproxy.envoy.type.matcher.v3.StringMatcher getServiceNameMatcher() {
        if (serviceNameMatcherBuilder_ == null) {
          return serviceNameMatcher_ == null ? io.envoyproxy.envoy.type.matcher.v3.StringMatcher.getDefaultInstance() : serviceNameMatcher_;
        } else {
          return serviceNameMatcherBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * An optional service name parameter which is used to validate the identity of
       * the health checked cluster using a :ref:`StringMatcher
       * &lt;envoy_v3_api_msg_type.matcher.v3.StringMatcher&gt;`. See the :ref:`architecture overview
       * &lt;arch_overview_health_checking_identity&gt;` for more information.
       * </pre>
       *
       * <code>.envoy.type.matcher.v3.StringMatcher service_name_matcher = 11;</code>
       */
      public Builder setServiceNameMatcher(io.envoyproxy.envoy.type.matcher.v3.StringMatcher value) {
        if (serviceNameMatcherBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          serviceNameMatcher_ = value;
        } else {
          serviceNameMatcherBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional service name parameter which is used to validate the identity of
       * the health checked cluster using a :ref:`StringMatcher
       * &lt;envoy_v3_api_msg_type.matcher.v3.StringMatcher&gt;`. See the :ref:`architecture overview
       * &lt;arch_overview_health_checking_identity&gt;` for more information.
       * </pre>
       *
       * <code>.envoy.type.matcher.v3.StringMatcher service_name_matcher = 11;</code>
       */
      public Builder setServiceNameMatcher(
          io.envoyproxy.envoy.type.matcher.v3.StringMatcher.Builder builderForValue) {
        if (serviceNameMatcherBuilder_ == null) {
          serviceNameMatcher_ = builderForValue.build();
        } else {
          serviceNameMatcherBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional service name parameter which is used to validate the identity of
       * the health checked cluster using a :ref:`StringMatcher
       * &lt;envoy_v3_api_msg_type.matcher.v3.StringMatcher&gt;`. See the :ref:`architecture overview
       * &lt;arch_overview_health_checking_identity&gt;` for more information.
       * </pre>
       *
       * <code>.envoy.type.matcher.v3.StringMatcher service_name_matcher = 11;</code>
       */
      public Builder mergeServiceNameMatcher(io.envoyproxy.envoy.type.matcher.v3.StringMatcher value) {
        if (serviceNameMatcherBuilder_ == null) {
          if (((bitField0_ & 0x00000400) != 0) &&
            serviceNameMatcher_ != null &&
            serviceNameMatcher_ != io.envoyproxy.envoy.type.matcher.v3.StringMatcher.getDefaultInstance()) {
            getServiceNameMatcherBuilder().mergeFrom(value);
          } else {
            serviceNameMatcher_ = value;
          }
        } else {
          serviceNameMatcherBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional service name parameter which is used to validate the identity of
       * the health checked cluster using a :ref:`StringMatcher
       * &lt;envoy_v3_api_msg_type.matcher.v3.StringMatcher&gt;`. See the :ref:`architecture overview
       * &lt;arch_overview_health_checking_identity&gt;` for more information.
       * </pre>
       *
       * <code>.envoy.type.matcher.v3.StringMatcher service_name_matcher = 11;</code>
       */
      public Builder clearServiceNameMatcher() {
        bitField0_ = (bitField0_ & ~0x00000400);
        serviceNameMatcher_ = null;
        if (serviceNameMatcherBuilder_ != null) {
          serviceNameMatcherBuilder_.dispose();
          serviceNameMatcherBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional service name parameter which is used to validate the identity of
       * the health checked cluster using a :ref:`StringMatcher
       * &lt;envoy_v3_api_msg_type.matcher.v3.StringMatcher&gt;`. See the :ref:`architecture overview
       * &lt;arch_overview_health_checking_identity&gt;` for more information.
       * </pre>
       *
       * <code>.envoy.type.matcher.v3.StringMatcher service_name_matcher = 11;</code>
       */
      public io.envoyproxy.envoy.type.matcher.v3.StringMatcher.Builder getServiceNameMatcherBuilder() {
        bitField0_ |= 0x00000400;
        onChanged();
        return getServiceNameMatcherFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * An optional service name parameter which is used to validate the identity of
       * the health checked cluster using a :ref:`StringMatcher
       * &lt;envoy_v3_api_msg_type.matcher.v3.StringMatcher&gt;`. See the :ref:`architecture overview
       * &lt;arch_overview_health_checking_identity&gt;` for more information.
       * </pre>
       *
       * <code>.envoy.type.matcher.v3.StringMatcher service_name_matcher = 11;</code>
       */
      public io.envoyproxy.envoy.type.matcher.v3.StringMatcherOrBuilder getServiceNameMatcherOrBuilder() {
        if (serviceNameMatcherBuilder_ != null) {
          return serviceNameMatcherBuilder_.getMessageOrBuilder();
        } else {
          return serviceNameMatcher_ == null ?
              io.envoyproxy.envoy.type.matcher.v3.StringMatcher.getDefaultInstance() : serviceNameMatcher_;
        }
      }
      /**
       * <pre>
       * An optional service name parameter which is used to validate the identity of
       * the health checked cluster using a :ref:`StringMatcher
       * &lt;envoy_v3_api_msg_type.matcher.v3.StringMatcher&gt;`. See the :ref:`architecture overview
       * &lt;arch_overview_health_checking_identity&gt;` for more information.
       * </pre>
       *
       * <code>.envoy.type.matcher.v3.StringMatcher service_name_matcher = 11;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.type.matcher.v3.StringMatcher, io.envoyproxy.envoy.type.matcher.v3.StringMatcher.Builder, io.envoyproxy.envoy.type.matcher.v3.StringMatcherOrBuilder> 
          getServiceNameMatcherFieldBuilder() {
        if (serviceNameMatcherBuilder_ == null) {
          serviceNameMatcherBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.envoyproxy.envoy.type.matcher.v3.StringMatcher, io.envoyproxy.envoy.type.matcher.v3.StringMatcher.Builder, io.envoyproxy.envoy.type.matcher.v3.StringMatcherOrBuilder>(
                  getServiceNameMatcher(),
                  getParentForChildren(),
                  isClean());
          serviceNameMatcher_ = null;
        }
        return serviceNameMatcherBuilder_;
      }

      private int method_ = 0;
      /**
       * <pre>
       * HTTP Method that will be used for health checking, default is "GET".
       * GET, HEAD, POST, PUT, DELETE, OPTIONS, TRACE, PATCH methods are supported, but making request body is not supported.
       * CONNECT method is disallowed because it is not appropriate for health check request.
       * If a non-200 response is expected by the method, it needs to be set in :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`.
       * </pre>
       *
       * <code>.envoy.config.core.v3.RequestMethod method = 13 [(.validate.rules) = { ... }</code>
       * @return The enum numeric value on the wire for method.
       */
      @java.lang.Override public int getMethodValue() {
        return method_;
      }
      /**
       * <pre>
       * HTTP Method that will be used for health checking, default is "GET".
       * GET, HEAD, POST, PUT, DELETE, OPTIONS, TRACE, PATCH methods are supported, but making request body is not supported.
       * CONNECT method is disallowed because it is not appropriate for health check request.
       * If a non-200 response is expected by the method, it needs to be set in :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`.
       * </pre>
       *
       * <code>.envoy.config.core.v3.RequestMethod method = 13 [(.validate.rules) = { ... }</code>
       * @param value The enum numeric value on the wire for method to set.
       * @return This builder for chaining.
       */
      public Builder setMethodValue(int value) {
        method_ = value;
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * HTTP Method that will be used for health checking, default is "GET".
       * GET, HEAD, POST, PUT, DELETE, OPTIONS, TRACE, PATCH methods are supported, but making request body is not supported.
       * CONNECT method is disallowed because it is not appropriate for health check request.
       * If a non-200 response is expected by the method, it needs to be set in :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`.
       * </pre>
       *
       * <code>.envoy.config.core.v3.RequestMethod method = 13 [(.validate.rules) = { ... }</code>
       * @return The method.
       */
      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.RequestMethod getMethod() {
        io.envoyproxy.envoy.config.core.v3.RequestMethod result = io.envoyproxy.envoy.config.core.v3.RequestMethod.forNumber(method_);
        return result == null ? io.envoyproxy.envoy.config.core.v3.RequestMethod.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * HTTP Method that will be used for health checking, default is "GET".
       * GET, HEAD, POST, PUT, DELETE, OPTIONS, TRACE, PATCH methods are supported, but making request body is not supported.
       * CONNECT method is disallowed because it is not appropriate for health check request.
       * If a non-200 response is expected by the method, it needs to be set in :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`.
       * </pre>
       *
       * <code>.envoy.config.core.v3.RequestMethod method = 13 [(.validate.rules) = { ... }</code>
       * @param value The method to set.
       * @return This builder for chaining.
       */
      public Builder setMethod(io.envoyproxy.envoy.config.core.v3.RequestMethod value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000800;
        method_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * HTTP Method that will be used for health checking, default is "GET".
       * GET, HEAD, POST, PUT, DELETE, OPTIONS, TRACE, PATCH methods are supported, but making request body is not supported.
       * CONNECT method is disallowed because it is not appropriate for health check request.
       * If a non-200 response is expected by the method, it needs to be set in :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`.
       * </pre>
       *
       * <code>.envoy.config.core.v3.RequestMethod method = 13 [(.validate.rules) = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearMethod() {
        bitField0_ = (bitField0_ & ~0x00000800);
        method_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.config.core.v3.HealthCheck.HttpHealthCheck)
    }

    // @@protoc_insertion_point(class_scope:envoy.config.core.v3.HealthCheck.HttpHealthCheck)
    private static final io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck();
    }

    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<HttpHealthCheck>
        PARSER = new com.google.protobuf.AbstractParser<HttpHealthCheck>() {
      @java.lang.Override
      public HttpHealthCheck parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<HttpHealthCheck> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<HttpHealthCheck> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TcpHealthCheckOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.config.core.v3.HealthCheck.TcpHealthCheck)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Empty payloads imply a connect-only health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.Payload send = 1;</code>
     * @return Whether the send field is set.
     */
    boolean hasSend();
    /**
     * <pre>
     * Empty payloads imply a connect-only health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.Payload send = 1;</code>
     * @return The send.
     */
    io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload getSend();
    /**
     * <pre>
     * Empty payloads imply a connect-only health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.Payload send = 1;</code>
     */
    io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder getSendOrBuilder();

    /**
     * <pre>
     * When checking the response, “fuzzy” matching is performed such that each
     * payload block must be found, and in the order specified, but not
     * necessarily contiguous.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
     */
    java.util.List<io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload> 
        getReceiveList();
    /**
     * <pre>
     * When checking the response, “fuzzy” matching is performed such that each
     * payload block must be found, and in the order specified, but not
     * necessarily contiguous.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
     */
    io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload getReceive(int index);
    /**
     * <pre>
     * When checking the response, “fuzzy” matching is performed such that each
     * payload block must be found, and in the order specified, but not
     * necessarily contiguous.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
     */
    int getReceiveCount();
    /**
     * <pre>
     * When checking the response, “fuzzy” matching is performed such that each
     * payload block must be found, and in the order specified, but not
     * necessarily contiguous.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
     */
    java.util.List<? extends io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder> 
        getReceiveOrBuilderList();
    /**
     * <pre>
     * When checking the response, “fuzzy” matching is performed such that each
     * payload block must be found, and in the order specified, but not
     * necessarily contiguous.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
     */
    io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder getReceiveOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code envoy.config.core.v3.HealthCheck.TcpHealthCheck}
   */
  public static final class TcpHealthCheck extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.config.core.v3.HealthCheck.TcpHealthCheck)
      TcpHealthCheckOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TcpHealthCheck.newBuilder() to construct.
    private TcpHealthCheck(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TcpHealthCheck() {
      receive_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new TcpHealthCheck();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_TcpHealthCheck_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_TcpHealthCheck_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck.class, io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck.Builder.class);
    }

    public static final int SEND_FIELD_NUMBER = 1;
    private io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload send_;
    /**
     * <pre>
     * Empty payloads imply a connect-only health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.Payload send = 1;</code>
     * @return Whether the send field is set.
     */
    @java.lang.Override
    public boolean hasSend() {
      return send_ != null;
    }
    /**
     * <pre>
     * Empty payloads imply a connect-only health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.Payload send = 1;</code>
     * @return The send.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload getSend() {
      return send_ == null ? io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.getDefaultInstance() : send_;
    }
    /**
     * <pre>
     * Empty payloads imply a connect-only health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.Payload send = 1;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder getSendOrBuilder() {
      return send_ == null ? io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.getDefaultInstance() : send_;
    }

    public static final int RECEIVE_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload> receive_;
    /**
     * <pre>
     * When checking the response, “fuzzy” matching is performed such that each
     * payload block must be found, and in the order specified, but not
     * necessarily contiguous.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload> getReceiveList() {
      return receive_;
    }
    /**
     * <pre>
     * When checking the response, “fuzzy” matching is performed such that each
     * payload block must be found, and in the order specified, but not
     * necessarily contiguous.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder> 
        getReceiveOrBuilderList() {
      return receive_;
    }
    /**
     * <pre>
     * When checking the response, “fuzzy” matching is performed such that each
     * payload block must be found, and in the order specified, but not
     * necessarily contiguous.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
     */
    @java.lang.Override
    public int getReceiveCount() {
      return receive_.size();
    }
    /**
     * <pre>
     * When checking the response, “fuzzy” matching is performed such that each
     * payload block must be found, and in the order specified, but not
     * necessarily contiguous.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload getReceive(int index) {
      return receive_.get(index);
    }
    /**
     * <pre>
     * When checking the response, “fuzzy” matching is performed such that each
     * payload block must be found, and in the order specified, but not
     * necessarily contiguous.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder getReceiveOrBuilder(
        int index) {
      return receive_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (send_ != null) {
        output.writeMessage(1, getSend());
      }
      for (int i = 0; i < receive_.size(); i++) {
        output.writeMessage(2, receive_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (send_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getSend());
      }
      for (int i = 0; i < receive_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, receive_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck other = (io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck) obj;

      if (hasSend() != other.hasSend()) return false;
      if (hasSend()) {
        if (!getSend()
            .equals(other.getSend())) return false;
      }
      if (!getReceiveList()
          .equals(other.getReceiveList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasSend()) {
        hash = (37 * hash) + SEND_FIELD_NUMBER;
        hash = (53 * hash) + getSend().hashCode();
      }
      if (getReceiveCount() > 0) {
        hash = (37 * hash) + RECEIVE_FIELD_NUMBER;
        hash = (53 * hash) + getReceiveList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code envoy.config.core.v3.HealthCheck.TcpHealthCheck}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.config.core.v3.HealthCheck.TcpHealthCheck)
        io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheckOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_TcpHealthCheck_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_TcpHealthCheck_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck.class, io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        send_ = null;
        if (sendBuilder_ != null) {
          sendBuilder_.dispose();
          sendBuilder_ = null;
        }
        if (receiveBuilder_ == null) {
          receive_ = java.util.Collections.emptyList();
        } else {
          receive_ = null;
          receiveBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_TcpHealthCheck_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck getDefaultInstanceForType() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck build() {
        io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck buildPartial() {
        io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck result = new io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck result) {
        if (receiveBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            receive_ = java.util.Collections.unmodifiableList(receive_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.receive_ = receive_;
        } else {
          result.receive_ = receiveBuilder_.build();
        }
      }

      private void buildPartial0(io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.send_ = sendBuilder_ == null
              ? send_
              : sendBuilder_.build();
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck) {
          return mergeFrom((io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck other) {
        if (other == io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck.getDefaultInstance()) return this;
        if (other.hasSend()) {
          mergeSend(other.getSend());
        }
        if (receiveBuilder_ == null) {
          if (!other.receive_.isEmpty()) {
            if (receive_.isEmpty()) {
              receive_ = other.receive_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureReceiveIsMutable();
              receive_.addAll(other.receive_);
            }
            onChanged();
          }
        } else {
          if (!other.receive_.isEmpty()) {
            if (receiveBuilder_.isEmpty()) {
              receiveBuilder_.dispose();
              receiveBuilder_ = null;
              receive_ = other.receive_;
              bitField0_ = (bitField0_ & ~0x00000002);
              receiveBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getReceiveFieldBuilder() : null;
            } else {
              receiveBuilder_.addAllMessages(other.receive_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getSendFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload m =
                    input.readMessage(
                        io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.parser(),
                        extensionRegistry);
                if (receiveBuilder_ == null) {
                  ensureReceiveIsMutable();
                  receive_.add(m);
                } else {
                  receiveBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload send_;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder> sendBuilder_;
      /**
       * <pre>
       * Empty payloads imply a connect-only health check.
       * </pre>
       *
       * <code>.envoy.config.core.v3.HealthCheck.Payload send = 1;</code>
       * @return Whether the send field is set.
       */
      public boolean hasSend() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Empty payloads imply a connect-only health check.
       * </pre>
       *
       * <code>.envoy.config.core.v3.HealthCheck.Payload send = 1;</code>
       * @return The send.
       */
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload getSend() {
        if (sendBuilder_ == null) {
          return send_ == null ? io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.getDefaultInstance() : send_;
        } else {
          return sendBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Empty payloads imply a connect-only health check.
       * </pre>
       *
       * <code>.envoy.config.core.v3.HealthCheck.Payload send = 1;</code>
       */
      public Builder setSend(io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload value) {
        if (sendBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          send_ = value;
        } else {
          sendBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Empty payloads imply a connect-only health check.
       * </pre>
       *
       * <code>.envoy.config.core.v3.HealthCheck.Payload send = 1;</code>
       */
      public Builder setSend(
          io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder builderForValue) {
        if (sendBuilder_ == null) {
          send_ = builderForValue.build();
        } else {
          sendBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Empty payloads imply a connect-only health check.
       * </pre>
       *
       * <code>.envoy.config.core.v3.HealthCheck.Payload send = 1;</code>
       */
      public Builder mergeSend(io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload value) {
        if (sendBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            send_ != null &&
            send_ != io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.getDefaultInstance()) {
            getSendBuilder().mergeFrom(value);
          } else {
            send_ = value;
          }
        } else {
          sendBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Empty payloads imply a connect-only health check.
       * </pre>
       *
       * <code>.envoy.config.core.v3.HealthCheck.Payload send = 1;</code>
       */
      public Builder clearSend() {
        bitField0_ = (bitField0_ & ~0x00000001);
        send_ = null;
        if (sendBuilder_ != null) {
          sendBuilder_.dispose();
          sendBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Empty payloads imply a connect-only health check.
       * </pre>
       *
       * <code>.envoy.config.core.v3.HealthCheck.Payload send = 1;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder getSendBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getSendFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Empty payloads imply a connect-only health check.
       * </pre>
       *
       * <code>.envoy.config.core.v3.HealthCheck.Payload send = 1;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder getSendOrBuilder() {
        if (sendBuilder_ != null) {
          return sendBuilder_.getMessageOrBuilder();
        } else {
          return send_ == null ?
              io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.getDefaultInstance() : send_;
        }
      }
      /**
       * <pre>
       * Empty payloads imply a connect-only health check.
       * </pre>
       *
       * <code>.envoy.config.core.v3.HealthCheck.Payload send = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder> 
          getSendFieldBuilder() {
        if (sendBuilder_ == null) {
          sendBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder>(
                  getSend(),
                  getParentForChildren(),
                  isClean());
          send_ = null;
        }
        return sendBuilder_;
      }

      private java.util.List<io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload> receive_ =
        java.util.Collections.emptyList();
      private void ensureReceiveIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          receive_ = new java.util.ArrayList<io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload>(receive_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder> receiveBuilder_;

      /**
       * <pre>
       * When checking the response, “fuzzy” matching is performed such that each
       * payload block must be found, and in the order specified, but not
       * necessarily contiguous.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
       */
      public java.util.List<io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload> getReceiveList() {
        if (receiveBuilder_ == null) {
          return java.util.Collections.unmodifiableList(receive_);
        } else {
          return receiveBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * When checking the response, “fuzzy” matching is performed such that each
       * payload block must be found, and in the order specified, but not
       * necessarily contiguous.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
       */
      public int getReceiveCount() {
        if (receiveBuilder_ == null) {
          return receive_.size();
        } else {
          return receiveBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * When checking the response, “fuzzy” matching is performed such that each
       * payload block must be found, and in the order specified, but not
       * necessarily contiguous.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload getReceive(int index) {
        if (receiveBuilder_ == null) {
          return receive_.get(index);
        } else {
          return receiveBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * When checking the response, “fuzzy” matching is performed such that each
       * payload block must be found, and in the order specified, but not
       * necessarily contiguous.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
       */
      public Builder setReceive(
          int index, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload value) {
        if (receiveBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureReceiveIsMutable();
          receive_.set(index, value);
          onChanged();
        } else {
          receiveBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * When checking the response, “fuzzy” matching is performed such that each
       * payload block must be found, and in the order specified, but not
       * necessarily contiguous.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
       */
      public Builder setReceive(
          int index, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder builderForValue) {
        if (receiveBuilder_ == null) {
          ensureReceiveIsMutable();
          receive_.set(index, builderForValue.build());
          onChanged();
        } else {
          receiveBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * When checking the response, “fuzzy” matching is performed such that each
       * payload block must be found, and in the order specified, but not
       * necessarily contiguous.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
       */
      public Builder addReceive(io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload value) {
        if (receiveBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureReceiveIsMutable();
          receive_.add(value);
          onChanged();
        } else {
          receiveBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * When checking the response, “fuzzy” matching is performed such that each
       * payload block must be found, and in the order specified, but not
       * necessarily contiguous.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
       */
      public Builder addReceive(
          int index, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload value) {
        if (receiveBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureReceiveIsMutable();
          receive_.add(index, value);
          onChanged();
        } else {
          receiveBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * When checking the response, “fuzzy” matching is performed such that each
       * payload block must be found, and in the order specified, but not
       * necessarily contiguous.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
       */
      public Builder addReceive(
          io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder builderForValue) {
        if (receiveBuilder_ == null) {
          ensureReceiveIsMutable();
          receive_.add(builderForValue.build());
          onChanged();
        } else {
          receiveBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * When checking the response, “fuzzy” matching is performed such that each
       * payload block must be found, and in the order specified, but not
       * necessarily contiguous.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
       */
      public Builder addReceive(
          int index, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder builderForValue) {
        if (receiveBuilder_ == null) {
          ensureReceiveIsMutable();
          receive_.add(index, builderForValue.build());
          onChanged();
        } else {
          receiveBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * When checking the response, “fuzzy” matching is performed such that each
       * payload block must be found, and in the order specified, but not
       * necessarily contiguous.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
       */
      public Builder addAllReceive(
          java.lang.Iterable<? extends io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload> values) {
        if (receiveBuilder_ == null) {
          ensureReceiveIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, receive_);
          onChanged();
        } else {
          receiveBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * When checking the response, “fuzzy” matching is performed such that each
       * payload block must be found, and in the order specified, but not
       * necessarily contiguous.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
       */
      public Builder clearReceive() {
        if (receiveBuilder_ == null) {
          receive_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          receiveBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * When checking the response, “fuzzy” matching is performed such that each
       * payload block must be found, and in the order specified, but not
       * necessarily contiguous.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
       */
      public Builder removeReceive(int index) {
        if (receiveBuilder_ == null) {
          ensureReceiveIsMutable();
          receive_.remove(index);
          onChanged();
        } else {
          receiveBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * When checking the response, “fuzzy” matching is performed such that each
       * payload block must be found, and in the order specified, but not
       * necessarily contiguous.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder getReceiveBuilder(
          int index) {
        return getReceiveFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * When checking the response, “fuzzy” matching is performed such that each
       * payload block must be found, and in the order specified, but not
       * necessarily contiguous.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder getReceiveOrBuilder(
          int index) {
        if (receiveBuilder_ == null) {
          return receive_.get(index);  } else {
          return receiveBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * When checking the response, “fuzzy” matching is performed such that each
       * payload block must be found, and in the order specified, but not
       * necessarily contiguous.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
       */
      public java.util.List<? extends io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder> 
           getReceiveOrBuilderList() {
        if (receiveBuilder_ != null) {
          return receiveBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(receive_);
        }
      }
      /**
       * <pre>
       * When checking the response, “fuzzy” matching is performed such that each
       * payload block must be found, and in the order specified, but not
       * necessarily contiguous.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder addReceiveBuilder() {
        return getReceiveFieldBuilder().addBuilder(
            io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.getDefaultInstance());
      }
      /**
       * <pre>
       * When checking the response, “fuzzy” matching is performed such that each
       * payload block must be found, and in the order specified, but not
       * necessarily contiguous.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder addReceiveBuilder(
          int index) {
        return getReceiveFieldBuilder().addBuilder(
            index, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.getDefaultInstance());
      }
      /**
       * <pre>
       * When checking the response, “fuzzy” matching is performed such that each
       * payload block must be found, and in the order specified, but not
       * necessarily contiguous.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HealthCheck.Payload receive = 2;</code>
       */
      public java.util.List<io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder> 
           getReceiveBuilderList() {
        return getReceiveFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder> 
          getReceiveFieldBuilder() {
        if (receiveBuilder_ == null) {
          receiveBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload, io.envoyproxy.envoy.config.core.v3.HealthCheck.Payload.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.PayloadOrBuilder>(
                  receive_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          receive_ = null;
        }
        return receiveBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.config.core.v3.HealthCheck.TcpHealthCheck)
    }

    // @@protoc_insertion_point(class_scope:envoy.config.core.v3.HealthCheck.TcpHealthCheck)
    private static final io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck();
    }

    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TcpHealthCheck>
        PARSER = new com.google.protobuf.AbstractParser<TcpHealthCheck>() {
      @java.lang.Override
      public TcpHealthCheck parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TcpHealthCheck> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TcpHealthCheck> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface RedisHealthCheckOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.config.core.v3.HealthCheck.RedisHealthCheck)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * If set, optionally perform ``EXISTS &lt;key&gt;`` instead of ``PING``. A return value
     * from Redis of 0 (does not exist) is considered a passing healthcheck. A return value other
     * than 0 is considered a failure. This allows the user to mark a Redis instance for maintenance
     * by setting the specified key to any value and waiting for traffic to drain.
     * </pre>
     *
     * <code>string key = 1;</code>
     * @return The key.
     */
    java.lang.String getKey();
    /**
     * <pre>
     * If set, optionally perform ``EXISTS &lt;key&gt;`` instead of ``PING``. A return value
     * from Redis of 0 (does not exist) is considered a passing healthcheck. A return value other
     * than 0 is considered a failure. This allows the user to mark a Redis instance for maintenance
     * by setting the specified key to any value and waiting for traffic to drain.
     * </pre>
     *
     * <code>string key = 1;</code>
     * @return The bytes for key.
     */
    com.google.protobuf.ByteString
        getKeyBytes();
  }
  /**
   * Protobuf type {@code envoy.config.core.v3.HealthCheck.RedisHealthCheck}
   */
  public static final class RedisHealthCheck extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.config.core.v3.HealthCheck.RedisHealthCheck)
      RedisHealthCheckOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use RedisHealthCheck.newBuilder() to construct.
    private RedisHealthCheck(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private RedisHealthCheck() {
      key_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new RedisHealthCheck();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_RedisHealthCheck_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_RedisHealthCheck_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck.class, io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck.Builder.class);
    }

    public static final int KEY_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object key_ = "";
    /**
     * <pre>
     * If set, optionally perform ``EXISTS &lt;key&gt;`` instead of ``PING``. A return value
     * from Redis of 0 (does not exist) is considered a passing healthcheck. A return value other
     * than 0 is considered a failure. This allows the user to mark a Redis instance for maintenance
     * by setting the specified key to any value and waiting for traffic to drain.
     * </pre>
     *
     * <code>string key = 1;</code>
     * @return The key.
     */
    @java.lang.Override
    public java.lang.String getKey() {
      java.lang.Object ref = key_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        key_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * If set, optionally perform ``EXISTS &lt;key&gt;`` instead of ``PING``. A return value
     * from Redis of 0 (does not exist) is considered a passing healthcheck. A return value other
     * than 0 is considered a failure. This allows the user to mark a Redis instance for maintenance
     * by setting the specified key to any value and waiting for traffic to drain.
     * </pre>
     *
     * <code>string key = 1;</code>
     * @return The bytes for key.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKeyBytes() {
      java.lang.Object ref = key_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        key_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(key_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, key_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(key_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, key_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck other = (io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck) obj;

      if (!getKey()
          .equals(other.getKey())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + KEY_FIELD_NUMBER;
      hash = (53 * hash) + getKey().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code envoy.config.core.v3.HealthCheck.RedisHealthCheck}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.config.core.v3.HealthCheck.RedisHealthCheck)
        io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheckOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_RedisHealthCheck_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_RedisHealthCheck_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck.class, io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        key_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_RedisHealthCheck_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck getDefaultInstanceForType() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck build() {
        io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck buildPartial() {
        io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck result = new io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.key_ = key_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck) {
          return mergeFrom((io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck other) {
        if (other == io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck.getDefaultInstance()) return this;
        if (!other.getKey().isEmpty()) {
          key_ = other.key_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                key_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object key_ = "";
      /**
       * <pre>
       * If set, optionally perform ``EXISTS &lt;key&gt;`` instead of ``PING``. A return value
       * from Redis of 0 (does not exist) is considered a passing healthcheck. A return value other
       * than 0 is considered a failure. This allows the user to mark a Redis instance for maintenance
       * by setting the specified key to any value and waiting for traffic to drain.
       * </pre>
       *
       * <code>string key = 1;</code>
       * @return The key.
       */
      public java.lang.String getKey() {
        java.lang.Object ref = key_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          key_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * If set, optionally perform ``EXISTS &lt;key&gt;`` instead of ``PING``. A return value
       * from Redis of 0 (does not exist) is considered a passing healthcheck. A return value other
       * than 0 is considered a failure. This allows the user to mark a Redis instance for maintenance
       * by setting the specified key to any value and waiting for traffic to drain.
       * </pre>
       *
       * <code>string key = 1;</code>
       * @return The bytes for key.
       */
      public com.google.protobuf.ByteString
          getKeyBytes() {
        java.lang.Object ref = key_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          key_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * If set, optionally perform ``EXISTS &lt;key&gt;`` instead of ``PING``. A return value
       * from Redis of 0 (does not exist) is considered a passing healthcheck. A return value other
       * than 0 is considered a failure. This allows the user to mark a Redis instance for maintenance
       * by setting the specified key to any value and waiting for traffic to drain.
       * </pre>
       *
       * <code>string key = 1;</code>
       * @param value The key to set.
       * @return This builder for chaining.
       */
      public Builder setKey(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        key_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If set, optionally perform ``EXISTS &lt;key&gt;`` instead of ``PING``. A return value
       * from Redis of 0 (does not exist) is considered a passing healthcheck. A return value other
       * than 0 is considered a failure. This allows the user to mark a Redis instance for maintenance
       * by setting the specified key to any value and waiting for traffic to drain.
       * </pre>
       *
       * <code>string key = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearKey() {
        key_ = getDefaultInstance().getKey();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If set, optionally perform ``EXISTS &lt;key&gt;`` instead of ``PING``. A return value
       * from Redis of 0 (does not exist) is considered a passing healthcheck. A return value other
       * than 0 is considered a failure. This allows the user to mark a Redis instance for maintenance
       * by setting the specified key to any value and waiting for traffic to drain.
       * </pre>
       *
       * <code>string key = 1;</code>
       * @param value The bytes for key to set.
       * @return This builder for chaining.
       */
      public Builder setKeyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        key_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.config.core.v3.HealthCheck.RedisHealthCheck)
    }

    // @@protoc_insertion_point(class_scope:envoy.config.core.v3.HealthCheck.RedisHealthCheck)
    private static final io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck();
    }

    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<RedisHealthCheck>
        PARSER = new com.google.protobuf.AbstractParser<RedisHealthCheck>() {
      @java.lang.Override
      public RedisHealthCheck parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<RedisHealthCheck> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<RedisHealthCheck> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.RedisHealthCheck getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GrpcHealthCheckOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.config.core.v3.HealthCheck.GrpcHealthCheck)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * An optional service name parameter which will be sent to gRPC service in
     * `grpc.health.v1.HealthCheckRequest
     * &lt;https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20&gt;`_.
     * message. See `gRPC health-checking overview
     * &lt;https://github.com/grpc/grpc/blob/master/doc/health-checking.md&gt;`_ for more information.
     * </pre>
     *
     * <code>string service_name = 1;</code>
     * @return The serviceName.
     */
    java.lang.String getServiceName();
    /**
     * <pre>
     * An optional service name parameter which will be sent to gRPC service in
     * `grpc.health.v1.HealthCheckRequest
     * &lt;https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20&gt;`_.
     * message. See `gRPC health-checking overview
     * &lt;https://github.com/grpc/grpc/blob/master/doc/health-checking.md&gt;`_ for more information.
     * </pre>
     *
     * <code>string service_name = 1;</code>
     * @return The bytes for serviceName.
     */
    com.google.protobuf.ByteString
        getServiceNameBytes();

    /**
     * <pre>
     * The value of the :authority header in the gRPC health check request. If
     * left empty (default value), the name of the cluster this health check is associated
     * with will be used. The authority header can be customized for a specific endpoint by setting
     * the :ref:`hostname &lt;envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname&gt;` field.
     * </pre>
     *
     * <code>string authority = 2 [(.validate.rules) = { ... }</code>
     * @return The authority.
     */
    java.lang.String getAuthority();
    /**
     * <pre>
     * The value of the :authority header in the gRPC health check request. If
     * left empty (default value), the name of the cluster this health check is associated
     * with will be used. The authority header can be customized for a specific endpoint by setting
     * the :ref:`hostname &lt;envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname&gt;` field.
     * </pre>
     *
     * <code>string authority = 2 [(.validate.rules) = { ... }</code>
     * @return The bytes for authority.
     */
    com.google.protobuf.ByteString
        getAuthorityBytes();

    /**
     * <pre>
     * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
     * that is sent to the health checked cluster. For more information, including details on header value syntax,
     * see the documentation on :ref:`custom request headers
     * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
     */
    java.util.List<io.envoyproxy.envoy.config.core.v3.HeaderValueOption> 
        getInitialMetadataList();
    /**
     * <pre>
     * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
     * that is sent to the health checked cluster. For more information, including details on header value syntax,
     * see the documentation on :ref:`custom request headers
     * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
     */
    io.envoyproxy.envoy.config.core.v3.HeaderValueOption getInitialMetadata(int index);
    /**
     * <pre>
     * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
     * that is sent to the health checked cluster. For more information, including details on header value syntax,
     * see the documentation on :ref:`custom request headers
     * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
     */
    int getInitialMetadataCount();
    /**
     * <pre>
     * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
     * that is sent to the health checked cluster. For more information, including details on header value syntax,
     * see the documentation on :ref:`custom request headers
     * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
     */
    java.util.List<? extends io.envoyproxy.envoy.config.core.v3.HeaderValueOptionOrBuilder> 
        getInitialMetadataOrBuilderList();
    /**
     * <pre>
     * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
     * that is sent to the health checked cluster. For more information, including details on header value syntax,
     * see the documentation on :ref:`custom request headers
     * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
     */
    io.envoyproxy.envoy.config.core.v3.HeaderValueOptionOrBuilder getInitialMetadataOrBuilder(
        int index);
  }
  /**
   * <pre>
   * `grpc.health.v1.Health
   * &lt;https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto&gt;`_-based
   * healthcheck. See `gRPC doc &lt;https://github.com/grpc/grpc/blob/master/doc/health-checking.md&gt;`_
   * for details.
   * </pre>
   *
   * Protobuf type {@code envoy.config.core.v3.HealthCheck.GrpcHealthCheck}
   */
  public static final class GrpcHealthCheck extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.config.core.v3.HealthCheck.GrpcHealthCheck)
      GrpcHealthCheckOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use GrpcHealthCheck.newBuilder() to construct.
    private GrpcHealthCheck(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private GrpcHealthCheck() {
      serviceName_ = "";
      authority_ = "";
      initialMetadata_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new GrpcHealthCheck();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_GrpcHealthCheck_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_GrpcHealthCheck_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck.class, io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck.Builder.class);
    }

    public static final int SERVICE_NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object serviceName_ = "";
    /**
     * <pre>
     * An optional service name parameter which will be sent to gRPC service in
     * `grpc.health.v1.HealthCheckRequest
     * &lt;https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20&gt;`_.
     * message. See `gRPC health-checking overview
     * &lt;https://github.com/grpc/grpc/blob/master/doc/health-checking.md&gt;`_ for more information.
     * </pre>
     *
     * <code>string service_name = 1;</code>
     * @return The serviceName.
     */
    @java.lang.Override
    public java.lang.String getServiceName() {
      java.lang.Object ref = serviceName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        serviceName_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * An optional service name parameter which will be sent to gRPC service in
     * `grpc.health.v1.HealthCheckRequest
     * &lt;https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20&gt;`_.
     * message. See `gRPC health-checking overview
     * &lt;https://github.com/grpc/grpc/blob/master/doc/health-checking.md&gt;`_ for more information.
     * </pre>
     *
     * <code>string service_name = 1;</code>
     * @return The bytes for serviceName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getServiceNameBytes() {
      java.lang.Object ref = serviceName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        serviceName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int AUTHORITY_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object authority_ = "";
    /**
     * <pre>
     * The value of the :authority header in the gRPC health check request. If
     * left empty (default value), the name of the cluster this health check is associated
     * with will be used. The authority header can be customized for a specific endpoint by setting
     * the :ref:`hostname &lt;envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname&gt;` field.
     * </pre>
     *
     * <code>string authority = 2 [(.validate.rules) = { ... }</code>
     * @return The authority.
     */
    @java.lang.Override
    public java.lang.String getAuthority() {
      java.lang.Object ref = authority_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        authority_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The value of the :authority header in the gRPC health check request. If
     * left empty (default value), the name of the cluster this health check is associated
     * with will be used. The authority header can be customized for a specific endpoint by setting
     * the :ref:`hostname &lt;envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname&gt;` field.
     * </pre>
     *
     * <code>string authority = 2 [(.validate.rules) = { ... }</code>
     * @return The bytes for authority.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAuthorityBytes() {
      java.lang.Object ref = authority_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        authority_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int INITIAL_METADATA_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private java.util.List<io.envoyproxy.envoy.config.core.v3.HeaderValueOption> initialMetadata_;
    /**
     * <pre>
     * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
     * that is sent to the health checked cluster. For more information, including details on header value syntax,
     * see the documentation on :ref:`custom request headers
     * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
     */
    @java.lang.Override
    public java.util.List<io.envoyproxy.envoy.config.core.v3.HeaderValueOption> getInitialMetadataList() {
      return initialMetadata_;
    }
    /**
     * <pre>
     * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
     * that is sent to the health checked cluster. For more information, including details on header value syntax,
     * see the documentation on :ref:`custom request headers
     * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.envoyproxy.envoy.config.core.v3.HeaderValueOptionOrBuilder> 
        getInitialMetadataOrBuilderList() {
      return initialMetadata_;
    }
    /**
     * <pre>
     * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
     * that is sent to the health checked cluster. For more information, including details on header value syntax,
     * see the documentation on :ref:`custom request headers
     * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
     */
    @java.lang.Override
    public int getInitialMetadataCount() {
      return initialMetadata_.size();
    }
    /**
     * <pre>
     * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
     * that is sent to the health checked cluster. For more information, including details on header value syntax,
     * see the documentation on :ref:`custom request headers
     * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HeaderValueOption getInitialMetadata(int index) {
      return initialMetadata_.get(index);
    }
    /**
     * <pre>
     * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
     * that is sent to the health checked cluster. For more information, including details on header value syntax,
     * see the documentation on :ref:`custom request headers
     * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HeaderValueOptionOrBuilder getInitialMetadataOrBuilder(
        int index) {
      return initialMetadata_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(serviceName_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, serviceName_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(authority_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, authority_);
      }
      for (int i = 0; i < initialMetadata_.size(); i++) {
        output.writeMessage(3, initialMetadata_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(serviceName_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, serviceName_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(authority_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, authority_);
      }
      for (int i = 0; i < initialMetadata_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, initialMetadata_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck other = (io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck) obj;

      if (!getServiceName()
          .equals(other.getServiceName())) return false;
      if (!getAuthority()
          .equals(other.getAuthority())) return false;
      if (!getInitialMetadataList()
          .equals(other.getInitialMetadataList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SERVICE_NAME_FIELD_NUMBER;
      hash = (53 * hash) + getServiceName().hashCode();
      hash = (37 * hash) + AUTHORITY_FIELD_NUMBER;
      hash = (53 * hash) + getAuthority().hashCode();
      if (getInitialMetadataCount() > 0) {
        hash = (37 * hash) + INITIAL_METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getInitialMetadataList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * `grpc.health.v1.Health
     * &lt;https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto&gt;`_-based
     * healthcheck. See `gRPC doc &lt;https://github.com/grpc/grpc/blob/master/doc/health-checking.md&gt;`_
     * for details.
     * </pre>
     *
     * Protobuf type {@code envoy.config.core.v3.HealthCheck.GrpcHealthCheck}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.config.core.v3.HealthCheck.GrpcHealthCheck)
        io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheckOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_GrpcHealthCheck_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_GrpcHealthCheck_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck.class, io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        serviceName_ = "";
        authority_ = "";
        if (initialMetadataBuilder_ == null) {
          initialMetadata_ = java.util.Collections.emptyList();
        } else {
          initialMetadata_ = null;
          initialMetadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_GrpcHealthCheck_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck getDefaultInstanceForType() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck build() {
        io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck buildPartial() {
        io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck result = new io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck result) {
        if (initialMetadataBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)) {
            initialMetadata_ = java.util.Collections.unmodifiableList(initialMetadata_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.initialMetadata_ = initialMetadata_;
        } else {
          result.initialMetadata_ = initialMetadataBuilder_.build();
        }
      }

      private void buildPartial0(io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.serviceName_ = serviceName_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.authority_ = authority_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck) {
          return mergeFrom((io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck other) {
        if (other == io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck.getDefaultInstance()) return this;
        if (!other.getServiceName().isEmpty()) {
          serviceName_ = other.serviceName_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (!other.getAuthority().isEmpty()) {
          authority_ = other.authority_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (initialMetadataBuilder_ == null) {
          if (!other.initialMetadata_.isEmpty()) {
            if (initialMetadata_.isEmpty()) {
              initialMetadata_ = other.initialMetadata_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureInitialMetadataIsMutable();
              initialMetadata_.addAll(other.initialMetadata_);
            }
            onChanged();
          }
        } else {
          if (!other.initialMetadata_.isEmpty()) {
            if (initialMetadataBuilder_.isEmpty()) {
              initialMetadataBuilder_.dispose();
              initialMetadataBuilder_ = null;
              initialMetadata_ = other.initialMetadata_;
              bitField0_ = (bitField0_ & ~0x00000004);
              initialMetadataBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getInitialMetadataFieldBuilder() : null;
            } else {
              initialMetadataBuilder_.addAllMessages(other.initialMetadata_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                serviceName_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                authority_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                io.envoyproxy.envoy.config.core.v3.HeaderValueOption m =
                    input.readMessage(
                        io.envoyproxy.envoy.config.core.v3.HeaderValueOption.parser(),
                        extensionRegistry);
                if (initialMetadataBuilder_ == null) {
                  ensureInitialMetadataIsMutable();
                  initialMetadata_.add(m);
                } else {
                  initialMetadataBuilder_.addMessage(m);
                }
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object serviceName_ = "";
      /**
       * <pre>
       * An optional service name parameter which will be sent to gRPC service in
       * `grpc.health.v1.HealthCheckRequest
       * &lt;https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20&gt;`_.
       * message. See `gRPC health-checking overview
       * &lt;https://github.com/grpc/grpc/blob/master/doc/health-checking.md&gt;`_ for more information.
       * </pre>
       *
       * <code>string service_name = 1;</code>
       * @return The serviceName.
       */
      public java.lang.String getServiceName() {
        java.lang.Object ref = serviceName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          serviceName_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * An optional service name parameter which will be sent to gRPC service in
       * `grpc.health.v1.HealthCheckRequest
       * &lt;https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20&gt;`_.
       * message. See `gRPC health-checking overview
       * &lt;https://github.com/grpc/grpc/blob/master/doc/health-checking.md&gt;`_ for more information.
       * </pre>
       *
       * <code>string service_name = 1;</code>
       * @return The bytes for serviceName.
       */
      public com.google.protobuf.ByteString
          getServiceNameBytes() {
        java.lang.Object ref = serviceName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          serviceName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * An optional service name parameter which will be sent to gRPC service in
       * `grpc.health.v1.HealthCheckRequest
       * &lt;https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20&gt;`_.
       * message. See `gRPC health-checking overview
       * &lt;https://github.com/grpc/grpc/blob/master/doc/health-checking.md&gt;`_ for more information.
       * </pre>
       *
       * <code>string service_name = 1;</code>
       * @param value The serviceName to set.
       * @return This builder for chaining.
       */
      public Builder setServiceName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        serviceName_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional service name parameter which will be sent to gRPC service in
       * `grpc.health.v1.HealthCheckRequest
       * &lt;https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20&gt;`_.
       * message. See `gRPC health-checking overview
       * &lt;https://github.com/grpc/grpc/blob/master/doc/health-checking.md&gt;`_ for more information.
       * </pre>
       *
       * <code>string service_name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearServiceName() {
        serviceName_ = getDefaultInstance().getServiceName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional service name parameter which will be sent to gRPC service in
       * `grpc.health.v1.HealthCheckRequest
       * &lt;https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20&gt;`_.
       * message. See `gRPC health-checking overview
       * &lt;https://github.com/grpc/grpc/blob/master/doc/health-checking.md&gt;`_ for more information.
       * </pre>
       *
       * <code>string service_name = 1;</code>
       * @param value The bytes for serviceName to set.
       * @return This builder for chaining.
       */
      public Builder setServiceNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        serviceName_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object authority_ = "";
      /**
       * <pre>
       * The value of the :authority header in the gRPC health check request. If
       * left empty (default value), the name of the cluster this health check is associated
       * with will be used. The authority header can be customized for a specific endpoint by setting
       * the :ref:`hostname &lt;envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname&gt;` field.
       * </pre>
       *
       * <code>string authority = 2 [(.validate.rules) = { ... }</code>
       * @return The authority.
       */
      public java.lang.String getAuthority() {
        java.lang.Object ref = authority_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          authority_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The value of the :authority header in the gRPC health check request. If
       * left empty (default value), the name of the cluster this health check is associated
       * with will be used. The authority header can be customized for a specific endpoint by setting
       * the :ref:`hostname &lt;envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname&gt;` field.
       * </pre>
       *
       * <code>string authority = 2 [(.validate.rules) = { ... }</code>
       * @return The bytes for authority.
       */
      public com.google.protobuf.ByteString
          getAuthorityBytes() {
        java.lang.Object ref = authority_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          authority_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The value of the :authority header in the gRPC health check request. If
       * left empty (default value), the name of the cluster this health check is associated
       * with will be used. The authority header can be customized for a specific endpoint by setting
       * the :ref:`hostname &lt;envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname&gt;` field.
       * </pre>
       *
       * <code>string authority = 2 [(.validate.rules) = { ... }</code>
       * @param value The authority to set.
       * @return This builder for chaining.
       */
      public Builder setAuthority(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        authority_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The value of the :authority header in the gRPC health check request. If
       * left empty (default value), the name of the cluster this health check is associated
       * with will be used. The authority header can be customized for a specific endpoint by setting
       * the :ref:`hostname &lt;envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname&gt;` field.
       * </pre>
       *
       * <code>string authority = 2 [(.validate.rules) = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearAuthority() {
        authority_ = getDefaultInstance().getAuthority();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The value of the :authority header in the gRPC health check request. If
       * left empty (default value), the name of the cluster this health check is associated
       * with will be used. The authority header can be customized for a specific endpoint by setting
       * the :ref:`hostname &lt;envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname&gt;` field.
       * </pre>
       *
       * <code>string authority = 2 [(.validate.rules) = { ... }</code>
       * @param value The bytes for authority to set.
       * @return This builder for chaining.
       */
      public Builder setAuthorityBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        authority_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.util.List<io.envoyproxy.envoy.config.core.v3.HeaderValueOption> initialMetadata_ =
        java.util.Collections.emptyList();
      private void ensureInitialMetadataIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          initialMetadata_ = new java.util.ArrayList<io.envoyproxy.envoy.config.core.v3.HeaderValueOption>(initialMetadata_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.config.core.v3.HeaderValueOption, io.envoyproxy.envoy.config.core.v3.HeaderValueOption.Builder, io.envoyproxy.envoy.config.core.v3.HeaderValueOptionOrBuilder> initialMetadataBuilder_;

      /**
       * <pre>
       * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
       * that is sent to the health checked cluster. For more information, including details on header value syntax,
       * see the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
       */
      public java.util.List<io.envoyproxy.envoy.config.core.v3.HeaderValueOption> getInitialMetadataList() {
        if (initialMetadataBuilder_ == null) {
          return java.util.Collections.unmodifiableList(initialMetadata_);
        } else {
          return initialMetadataBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
       * that is sent to the health checked cluster. For more information, including details on header value syntax,
       * see the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
       */
      public int getInitialMetadataCount() {
        if (initialMetadataBuilder_ == null) {
          return initialMetadata_.size();
        } else {
          return initialMetadataBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
       * that is sent to the health checked cluster. For more information, including details on header value syntax,
       * see the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HeaderValueOption getInitialMetadata(int index) {
        if (initialMetadataBuilder_ == null) {
          return initialMetadata_.get(index);
        } else {
          return initialMetadataBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
       * that is sent to the health checked cluster. For more information, including details on header value syntax,
       * see the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
       */
      public Builder setInitialMetadata(
          int index, io.envoyproxy.envoy.config.core.v3.HeaderValueOption value) {
        if (initialMetadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInitialMetadataIsMutable();
          initialMetadata_.set(index, value);
          onChanged();
        } else {
          initialMetadataBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
       * that is sent to the health checked cluster. For more information, including details on header value syntax,
       * see the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
       */
      public Builder setInitialMetadata(
          int index, io.envoyproxy.envoy.config.core.v3.HeaderValueOption.Builder builderForValue) {
        if (initialMetadataBuilder_ == null) {
          ensureInitialMetadataIsMutable();
          initialMetadata_.set(index, builderForValue.build());
          onChanged();
        } else {
          initialMetadataBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
       * that is sent to the health checked cluster. For more information, including details on header value syntax,
       * see the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
       */
      public Builder addInitialMetadata(io.envoyproxy.envoy.config.core.v3.HeaderValueOption value) {
        if (initialMetadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInitialMetadataIsMutable();
          initialMetadata_.add(value);
          onChanged();
        } else {
          initialMetadataBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
       * that is sent to the health checked cluster. For more information, including details on header value syntax,
       * see the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
       */
      public Builder addInitialMetadata(
          int index, io.envoyproxy.envoy.config.core.v3.HeaderValueOption value) {
        if (initialMetadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInitialMetadataIsMutable();
          initialMetadata_.add(index, value);
          onChanged();
        } else {
          initialMetadataBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
       * that is sent to the health checked cluster. For more information, including details on header value syntax,
       * see the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
       */
      public Builder addInitialMetadata(
          io.envoyproxy.envoy.config.core.v3.HeaderValueOption.Builder builderForValue) {
        if (initialMetadataBuilder_ == null) {
          ensureInitialMetadataIsMutable();
          initialMetadata_.add(builderForValue.build());
          onChanged();
        } else {
          initialMetadataBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
       * that is sent to the health checked cluster. For more information, including details on header value syntax,
       * see the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
       */
      public Builder addInitialMetadata(
          int index, io.envoyproxy.envoy.config.core.v3.HeaderValueOption.Builder builderForValue) {
        if (initialMetadataBuilder_ == null) {
          ensureInitialMetadataIsMutable();
          initialMetadata_.add(index, builderForValue.build());
          onChanged();
        } else {
          initialMetadataBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
       * that is sent to the health checked cluster. For more information, including details on header value syntax,
       * see the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
       */
      public Builder addAllInitialMetadata(
          java.lang.Iterable<? extends io.envoyproxy.envoy.config.core.v3.HeaderValueOption> values) {
        if (initialMetadataBuilder_ == null) {
          ensureInitialMetadataIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, initialMetadata_);
          onChanged();
        } else {
          initialMetadataBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
       * that is sent to the health checked cluster. For more information, including details on header value syntax,
       * see the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
       */
      public Builder clearInitialMetadata() {
        if (initialMetadataBuilder_ == null) {
          initialMetadata_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          initialMetadataBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
       * that is sent to the health checked cluster. For more information, including details on header value syntax,
       * see the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
       */
      public Builder removeInitialMetadata(int index) {
        if (initialMetadataBuilder_ == null) {
          ensureInitialMetadataIsMutable();
          initialMetadata_.remove(index);
          onChanged();
        } else {
          initialMetadataBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
       * that is sent to the health checked cluster. For more information, including details on header value syntax,
       * see the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HeaderValueOption.Builder getInitialMetadataBuilder(
          int index) {
        return getInitialMetadataFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
       * that is sent to the health checked cluster. For more information, including details on header value syntax,
       * see the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HeaderValueOptionOrBuilder getInitialMetadataOrBuilder(
          int index) {
        if (initialMetadataBuilder_ == null) {
          return initialMetadata_.get(index);  } else {
          return initialMetadataBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
       * that is sent to the health checked cluster. For more information, including details on header value syntax,
       * see the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
       */
      public java.util.List<? extends io.envoyproxy.envoy.config.core.v3.HeaderValueOptionOrBuilder> 
           getInitialMetadataOrBuilderList() {
        if (initialMetadataBuilder_ != null) {
          return initialMetadataBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(initialMetadata_);
        }
      }
      /**
       * <pre>
       * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
       * that is sent to the health checked cluster. For more information, including details on header value syntax,
       * see the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HeaderValueOption.Builder addInitialMetadataBuilder() {
        return getInitialMetadataFieldBuilder().addBuilder(
            io.envoyproxy.envoy.config.core.v3.HeaderValueOption.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
       * that is sent to the health checked cluster. For more information, including details on header value syntax,
       * see the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
       */
      public io.envoyproxy.envoy.config.core.v3.HeaderValueOption.Builder addInitialMetadataBuilder(
          int index) {
        return getInitialMetadataFieldBuilder().addBuilder(
            index, io.envoyproxy.envoy.config.core.v3.HeaderValueOption.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
       * that is sent to the health checked cluster. For more information, including details on header value syntax,
       * see the documentation on :ref:`custom request headers
       * &lt;config_http_conn_man_headers_custom_request_headers&gt;`.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.HeaderValueOption initial_metadata = 3 [(.validate.rules) = { ... }</code>
       */
      public java.util.List<io.envoyproxy.envoy.config.core.v3.HeaderValueOption.Builder> 
           getInitialMetadataBuilderList() {
        return getInitialMetadataFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.config.core.v3.HeaderValueOption, io.envoyproxy.envoy.config.core.v3.HeaderValueOption.Builder, io.envoyproxy.envoy.config.core.v3.HeaderValueOptionOrBuilder> 
          getInitialMetadataFieldBuilder() {
        if (initialMetadataBuilder_ == null) {
          initialMetadataBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.envoyproxy.envoy.config.core.v3.HeaderValueOption, io.envoyproxy.envoy.config.core.v3.HeaderValueOption.Builder, io.envoyproxy.envoy.config.core.v3.HeaderValueOptionOrBuilder>(
                  initialMetadata_,
                  ((bitField0_ & 0x00000004) != 0),
                  getParentForChildren(),
                  isClean());
          initialMetadata_ = null;
        }
        return initialMetadataBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.config.core.v3.HealthCheck.GrpcHealthCheck)
    }

    // @@protoc_insertion_point(class_scope:envoy.config.core.v3.HealthCheck.GrpcHealthCheck)
    private static final io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck();
    }

    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GrpcHealthCheck>
        PARSER = new com.google.protobuf.AbstractParser<GrpcHealthCheck>() {
      @java.lang.Override
      public GrpcHealthCheck parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<GrpcHealthCheck> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GrpcHealthCheck> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CustomHealthCheckOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.config.core.v3.HealthCheck.CustomHealthCheck)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The registered name of the custom health checker.
     * </pre>
     *
     * <code>string name = 1 [(.validate.rules) = { ... }</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * The registered name of the custom health checker.
     * </pre>
     *
     * <code>string name = 1 [(.validate.rules) = { ... }</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <code>.google.protobuf.Any typed_config = 3;</code>
     * @return Whether the typedConfig field is set.
     */
    boolean hasTypedConfig();
    /**
     * <code>.google.protobuf.Any typed_config = 3;</code>
     * @return The typedConfig.
     */
    com.google.protobuf.Any getTypedConfig();
    /**
     * <code>.google.protobuf.Any typed_config = 3;</code>
     */
    com.google.protobuf.AnyOrBuilder getTypedConfigOrBuilder();

    public io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck.ConfigTypeCase getConfigTypeCase();
  }
  /**
   * <pre>
   * Custom health check.
   * </pre>
   *
   * Protobuf type {@code envoy.config.core.v3.HealthCheck.CustomHealthCheck}
   */
  public static final class CustomHealthCheck extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.config.core.v3.HealthCheck.CustomHealthCheck)
      CustomHealthCheckOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CustomHealthCheck.newBuilder() to construct.
    private CustomHealthCheck(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CustomHealthCheck() {
      name_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new CustomHealthCheck();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_CustomHealthCheck_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_CustomHealthCheck_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck.class, io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck.Builder.class);
    }

    private int configTypeCase_ = 0;
    private java.lang.Object configType_;
    public enum ConfigTypeCase
        implements com.google.protobuf.Internal.EnumLite,
            com.google.protobuf.AbstractMessage.InternalOneOfEnum {
      TYPED_CONFIG(3),
      CONFIGTYPE_NOT_SET(0);
      private final int value;
      private ConfigTypeCase(int value) {
        this.value = value;
      }
      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ConfigTypeCase valueOf(int value) {
        return forNumber(value);
      }

      public static ConfigTypeCase forNumber(int value) {
        switch (value) {
          case 3: return TYPED_CONFIG;
          case 0: return CONFIGTYPE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public ConfigTypeCase
    getConfigTypeCase() {
      return ConfigTypeCase.forNumber(
          configTypeCase_);
    }

    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * The registered name of the custom health checker.
     * </pre>
     *
     * <code>string name = 1 [(.validate.rules) = { ... }</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The registered name of the custom health checker.
     * </pre>
     *
     * <code>string name = 1 [(.validate.rules) = { ... }</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TYPED_CONFIG_FIELD_NUMBER = 3;
    /**
     * <code>.google.protobuf.Any typed_config = 3;</code>
     * @return Whether the typedConfig field is set.
     */
    @java.lang.Override
    public boolean hasTypedConfig() {
      return configTypeCase_ == 3;
    }
    /**
     * <code>.google.protobuf.Any typed_config = 3;</code>
     * @return The typedConfig.
     */
    @java.lang.Override
    public com.google.protobuf.Any getTypedConfig() {
      if (configTypeCase_ == 3) {
         return (com.google.protobuf.Any) configType_;
      }
      return com.google.protobuf.Any.getDefaultInstance();
    }
    /**
     * <code>.google.protobuf.Any typed_config = 3;</code>
     */
    @java.lang.Override
    public com.google.protobuf.AnyOrBuilder getTypedConfigOrBuilder() {
      if (configTypeCase_ == 3) {
         return (com.google.protobuf.Any) configType_;
      }
      return com.google.protobuf.Any.getDefaultInstance();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (configTypeCase_ == 3) {
        output.writeMessage(3, (com.google.protobuf.Any) configType_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (configTypeCase_ == 3) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, (com.google.protobuf.Any) configType_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck other = (io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck) obj;

      if (!getName()
          .equals(other.getName())) return false;
      if (!getConfigTypeCase().equals(other.getConfigTypeCase())) return false;
      switch (configTypeCase_) {
        case 3:
          if (!getTypedConfig()
              .equals(other.getTypedConfig())) return false;
          break;
        case 0:
        default:
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      switch (configTypeCase_) {
        case 3:
          hash = (37 * hash) + TYPED_CONFIG_FIELD_NUMBER;
          hash = (53 * hash) + getTypedConfig().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Custom health check.
     * </pre>
     *
     * Protobuf type {@code envoy.config.core.v3.HealthCheck.CustomHealthCheck}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.config.core.v3.HealthCheck.CustomHealthCheck)
        io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheckOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_CustomHealthCheck_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_CustomHealthCheck_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck.class, io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        if (typedConfigBuilder_ != null) {
          typedConfigBuilder_.clear();
        }
        configTypeCase_ = 0;
        configType_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_CustomHealthCheck_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck getDefaultInstanceForType() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck build() {
        io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck buildPartial() {
        io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck result = new io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        buildPartialOneofs(result);
        onBuilt();
        return result;
      }

      private void buildPartial0(io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
        }
      }

      private void buildPartialOneofs(io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck result) {
        result.configTypeCase_ = configTypeCase_;
        result.configType_ = this.configType_;
        if (configTypeCase_ == 3 &&
            typedConfigBuilder_ != null) {
          result.configType_ = typedConfigBuilder_.build();
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck) {
          return mergeFrom((io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck other) {
        if (other == io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        switch (other.getConfigTypeCase()) {
          case TYPED_CONFIG: {
            mergeTypedConfig(other.getTypedConfig());
            break;
          }
          case CONFIGTYPE_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 26: {
                input.readMessage(
                    getTypedConfigFieldBuilder().getBuilder(),
                    extensionRegistry);
                configTypeCase_ = 3;
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int configTypeCase_ = 0;
      private java.lang.Object configType_;
      public ConfigTypeCase
          getConfigTypeCase() {
        return ConfigTypeCase.forNumber(
            configTypeCase_);
      }

      public Builder clearConfigType() {
        configTypeCase_ = 0;
        configType_ = null;
        onChanged();
        return this;
      }

      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The registered name of the custom health checker.
       * </pre>
       *
       * <code>string name = 1 [(.validate.rules) = { ... }</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The registered name of the custom health checker.
       * </pre>
       *
       * <code>string name = 1 [(.validate.rules) = { ... }</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The registered name of the custom health checker.
       * </pre>
       *
       * <code>string name = 1 [(.validate.rules) = { ... }</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The registered name of the custom health checker.
       * </pre>
       *
       * <code>string name = 1 [(.validate.rules) = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The registered name of the custom health checker.
       * </pre>
       *
       * <code>string name = 1 [(.validate.rules) = { ... }</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Any, com.google.protobuf.Any.Builder, com.google.protobuf.AnyOrBuilder> typedConfigBuilder_;
      /**
       * <code>.google.protobuf.Any typed_config = 3;</code>
       * @return Whether the typedConfig field is set.
       */
      @java.lang.Override
      public boolean hasTypedConfig() {
        return configTypeCase_ == 3;
      }
      /**
       * <code>.google.protobuf.Any typed_config = 3;</code>
       * @return The typedConfig.
       */
      @java.lang.Override
      public com.google.protobuf.Any getTypedConfig() {
        if (typedConfigBuilder_ == null) {
          if (configTypeCase_ == 3) {
            return (com.google.protobuf.Any) configType_;
          }
          return com.google.protobuf.Any.getDefaultInstance();
        } else {
          if (configTypeCase_ == 3) {
            return typedConfigBuilder_.getMessage();
          }
          return com.google.protobuf.Any.getDefaultInstance();
        }
      }
      /**
       * <code>.google.protobuf.Any typed_config = 3;</code>
       */
      public Builder setTypedConfig(com.google.protobuf.Any value) {
        if (typedConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          configType_ = value;
          onChanged();
        } else {
          typedConfigBuilder_.setMessage(value);
        }
        configTypeCase_ = 3;
        return this;
      }
      /**
       * <code>.google.protobuf.Any typed_config = 3;</code>
       */
      public Builder setTypedConfig(
          com.google.protobuf.Any.Builder builderForValue) {
        if (typedConfigBuilder_ == null) {
          configType_ = builderForValue.build();
          onChanged();
        } else {
          typedConfigBuilder_.setMessage(builderForValue.build());
        }
        configTypeCase_ = 3;
        return this;
      }
      /**
       * <code>.google.protobuf.Any typed_config = 3;</code>
       */
      public Builder mergeTypedConfig(com.google.protobuf.Any value) {
        if (typedConfigBuilder_ == null) {
          if (configTypeCase_ == 3 &&
              configType_ != com.google.protobuf.Any.getDefaultInstance()) {
            configType_ = com.google.protobuf.Any.newBuilder((com.google.protobuf.Any) configType_)
                .mergeFrom(value).buildPartial();
          } else {
            configType_ = value;
          }
          onChanged();
        } else {
          if (configTypeCase_ == 3) {
            typedConfigBuilder_.mergeFrom(value);
          } else {
            typedConfigBuilder_.setMessage(value);
          }
        }
        configTypeCase_ = 3;
        return this;
      }
      /**
       * <code>.google.protobuf.Any typed_config = 3;</code>
       */
      public Builder clearTypedConfig() {
        if (typedConfigBuilder_ == null) {
          if (configTypeCase_ == 3) {
            configTypeCase_ = 0;
            configType_ = null;
            onChanged();
          }
        } else {
          if (configTypeCase_ == 3) {
            configTypeCase_ = 0;
            configType_ = null;
          }
          typedConfigBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.google.protobuf.Any typed_config = 3;</code>
       */
      public com.google.protobuf.Any.Builder getTypedConfigBuilder() {
        return getTypedConfigFieldBuilder().getBuilder();
      }
      /**
       * <code>.google.protobuf.Any typed_config = 3;</code>
       */
      @java.lang.Override
      public com.google.protobuf.AnyOrBuilder getTypedConfigOrBuilder() {
        if ((configTypeCase_ == 3) && (typedConfigBuilder_ != null)) {
          return typedConfigBuilder_.getMessageOrBuilder();
        } else {
          if (configTypeCase_ == 3) {
            return (com.google.protobuf.Any) configType_;
          }
          return com.google.protobuf.Any.getDefaultInstance();
        }
      }
      /**
       * <code>.google.protobuf.Any typed_config = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Any, com.google.protobuf.Any.Builder, com.google.protobuf.AnyOrBuilder> 
          getTypedConfigFieldBuilder() {
        if (typedConfigBuilder_ == null) {
          if (!(configTypeCase_ == 3)) {
            configType_ = com.google.protobuf.Any.getDefaultInstance();
          }
          typedConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Any, com.google.protobuf.Any.Builder, com.google.protobuf.AnyOrBuilder>(
                  (com.google.protobuf.Any) configType_,
                  getParentForChildren(),
                  isClean());
          configType_ = null;
        }
        configTypeCase_ = 3;
        onChanged();
        return typedConfigBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.config.core.v3.HealthCheck.CustomHealthCheck)
    }

    // @@protoc_insertion_point(class_scope:envoy.config.core.v3.HealthCheck.CustomHealthCheck)
    private static final io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck();
    }

    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CustomHealthCheck>
        PARSER = new com.google.protobuf.AbstractParser<CustomHealthCheck>() {
      @java.lang.Override
      public CustomHealthCheck parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<CustomHealthCheck> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CustomHealthCheck> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TlsOptionsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.config.core.v3.HealthCheck.TlsOptions)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Specifies the ALPN protocols for health check connections. This is useful if the
     * corresponding upstream is using ALPN-based :ref:`FilterChainMatch
     * &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` along with different protocols for health checks
     * versus data connections. If empty, no ALPN protocols will be set on health check connections.
     * </pre>
     *
     * <code>repeated string alpn_protocols = 1;</code>
     * @return A list containing the alpnProtocols.
     */
    java.util.List<java.lang.String>
        getAlpnProtocolsList();
    /**
     * <pre>
     * Specifies the ALPN protocols for health check connections. This is useful if the
     * corresponding upstream is using ALPN-based :ref:`FilterChainMatch
     * &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` along with different protocols for health checks
     * versus data connections. If empty, no ALPN protocols will be set on health check connections.
     * </pre>
     *
     * <code>repeated string alpn_protocols = 1;</code>
     * @return The count of alpnProtocols.
     */
    int getAlpnProtocolsCount();
    /**
     * <pre>
     * Specifies the ALPN protocols for health check connections. This is useful if the
     * corresponding upstream is using ALPN-based :ref:`FilterChainMatch
     * &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` along with different protocols for health checks
     * versus data connections. If empty, no ALPN protocols will be set on health check connections.
     * </pre>
     *
     * <code>repeated string alpn_protocols = 1;</code>
     * @param index The index of the element to return.
     * @return The alpnProtocols at the given index.
     */
    java.lang.String getAlpnProtocols(int index);
    /**
     * <pre>
     * Specifies the ALPN protocols for health check connections. This is useful if the
     * corresponding upstream is using ALPN-based :ref:`FilterChainMatch
     * &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` along with different protocols for health checks
     * versus data connections. If empty, no ALPN protocols will be set on health check connections.
     * </pre>
     *
     * <code>repeated string alpn_protocols = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the alpnProtocols at the given index.
     */
    com.google.protobuf.ByteString
        getAlpnProtocolsBytes(int index);
  }
  /**
   * <pre>
   * Health checks occur over the transport socket specified for the cluster. This implies that if a
   * cluster is using a TLS-enabled transport socket, the health check will also occur over TLS.
   * This allows overriding the cluster TLS settings, just for health check connections.
   * </pre>
   *
   * Protobuf type {@code envoy.config.core.v3.HealthCheck.TlsOptions}
   */
  public static final class TlsOptions extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.config.core.v3.HealthCheck.TlsOptions)
      TlsOptionsOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TlsOptions.newBuilder() to construct.
    private TlsOptions(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TlsOptions() {
      alpnProtocols_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new TlsOptions();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_TlsOptions_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_TlsOptions_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions.class, io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions.Builder.class);
    }

    public static final int ALPN_PROTOCOLS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringList alpnProtocols_;
    /**
     * <pre>
     * Specifies the ALPN protocols for health check connections. This is useful if the
     * corresponding upstream is using ALPN-based :ref:`FilterChainMatch
     * &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` along with different protocols for health checks
     * versus data connections. If empty, no ALPN protocols will be set on health check connections.
     * </pre>
     *
     * <code>repeated string alpn_protocols = 1;</code>
     * @return A list containing the alpnProtocols.
     */
    public com.google.protobuf.ProtocolStringList
        getAlpnProtocolsList() {
      return alpnProtocols_;
    }
    /**
     * <pre>
     * Specifies the ALPN protocols for health check connections. This is useful if the
     * corresponding upstream is using ALPN-based :ref:`FilterChainMatch
     * &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` along with different protocols for health checks
     * versus data connections. If empty, no ALPN protocols will be set on health check connections.
     * </pre>
     *
     * <code>repeated string alpn_protocols = 1;</code>
     * @return The count of alpnProtocols.
     */
    public int getAlpnProtocolsCount() {
      return alpnProtocols_.size();
    }
    /**
     * <pre>
     * Specifies the ALPN protocols for health check connections. This is useful if the
     * corresponding upstream is using ALPN-based :ref:`FilterChainMatch
     * &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` along with different protocols for health checks
     * versus data connections. If empty, no ALPN protocols will be set on health check connections.
     * </pre>
     *
     * <code>repeated string alpn_protocols = 1;</code>
     * @param index The index of the element to return.
     * @return The alpnProtocols at the given index.
     */
    public java.lang.String getAlpnProtocols(int index) {
      return alpnProtocols_.get(index);
    }
    /**
     * <pre>
     * Specifies the ALPN protocols for health check connections. This is useful if the
     * corresponding upstream is using ALPN-based :ref:`FilterChainMatch
     * &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` along with different protocols for health checks
     * versus data connections. If empty, no ALPN protocols will be set on health check connections.
     * </pre>
     *
     * <code>repeated string alpn_protocols = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the alpnProtocols at the given index.
     */
    public com.google.protobuf.ByteString
        getAlpnProtocolsBytes(int index) {
      return alpnProtocols_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < alpnProtocols_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, alpnProtocols_.getRaw(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < alpnProtocols_.size(); i++) {
          dataSize += computeStringSizeNoTag(alpnProtocols_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getAlpnProtocolsList().size();
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions other = (io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions) obj;

      if (!getAlpnProtocolsList()
          .equals(other.getAlpnProtocolsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getAlpnProtocolsCount() > 0) {
        hash = (37 * hash) + ALPN_PROTOCOLS_FIELD_NUMBER;
        hash = (53 * hash) + getAlpnProtocolsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Health checks occur over the transport socket specified for the cluster. This implies that if a
     * cluster is using a TLS-enabled transport socket, the health check will also occur over TLS.
     * This allows overriding the cluster TLS settings, just for health check connections.
     * </pre>
     *
     * Protobuf type {@code envoy.config.core.v3.HealthCheck.TlsOptions}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.config.core.v3.HealthCheck.TlsOptions)
        io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptionsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_TlsOptions_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_TlsOptions_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions.class, io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        alpnProtocols_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_TlsOptions_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions getDefaultInstanceForType() {
        return io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions build() {
        io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions buildPartial() {
        io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions result = new io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions result) {
        if (((bitField0_ & 0x00000001) != 0)) {
          alpnProtocols_ = alpnProtocols_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.alpnProtocols_ = alpnProtocols_;
      }

      private void buildPartial0(io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions result) {
        int from_bitField0_ = bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions) {
          return mergeFrom((io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions other) {
        if (other == io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions.getDefaultInstance()) return this;
        if (!other.alpnProtocols_.isEmpty()) {
          if (alpnProtocols_.isEmpty()) {
            alpnProtocols_ = other.alpnProtocols_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureAlpnProtocolsIsMutable();
            alpnProtocols_.addAll(other.alpnProtocols_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                java.lang.String s = input.readStringRequireUtf8();
                ensureAlpnProtocolsIsMutable();
                alpnProtocols_.add(s);
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.LazyStringList alpnProtocols_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureAlpnProtocolsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          alpnProtocols_ = new com.google.protobuf.LazyStringArrayList(alpnProtocols_);
          bitField0_ |= 0x00000001;
         }
      }
      /**
       * <pre>
       * Specifies the ALPN protocols for health check connections. This is useful if the
       * corresponding upstream is using ALPN-based :ref:`FilterChainMatch
       * &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` along with different protocols for health checks
       * versus data connections. If empty, no ALPN protocols will be set on health check connections.
       * </pre>
       *
       * <code>repeated string alpn_protocols = 1;</code>
       * @return A list containing the alpnProtocols.
       */
      public com.google.protobuf.ProtocolStringList
          getAlpnProtocolsList() {
        return alpnProtocols_.getUnmodifiableView();
      }
      /**
       * <pre>
       * Specifies the ALPN protocols for health check connections. This is useful if the
       * corresponding upstream is using ALPN-based :ref:`FilterChainMatch
       * &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` along with different protocols for health checks
       * versus data connections. If empty, no ALPN protocols will be set on health check connections.
       * </pre>
       *
       * <code>repeated string alpn_protocols = 1;</code>
       * @return The count of alpnProtocols.
       */
      public int getAlpnProtocolsCount() {
        return alpnProtocols_.size();
      }
      /**
       * <pre>
       * Specifies the ALPN protocols for health check connections. This is useful if the
       * corresponding upstream is using ALPN-based :ref:`FilterChainMatch
       * &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` along with different protocols for health checks
       * versus data connections. If empty, no ALPN protocols will be set on health check connections.
       * </pre>
       *
       * <code>repeated string alpn_protocols = 1;</code>
       * @param index The index of the element to return.
       * @return The alpnProtocols at the given index.
       */
      public java.lang.String getAlpnProtocols(int index) {
        return alpnProtocols_.get(index);
      }
      /**
       * <pre>
       * Specifies the ALPN protocols for health check connections. This is useful if the
       * corresponding upstream is using ALPN-based :ref:`FilterChainMatch
       * &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` along with different protocols for health checks
       * versus data connections. If empty, no ALPN protocols will be set on health check connections.
       * </pre>
       *
       * <code>repeated string alpn_protocols = 1;</code>
       * @param index The index of the value to return.
       * @return The bytes of the alpnProtocols at the given index.
       */
      public com.google.protobuf.ByteString
          getAlpnProtocolsBytes(int index) {
        return alpnProtocols_.getByteString(index);
      }
      /**
       * <pre>
       * Specifies the ALPN protocols for health check connections. This is useful if the
       * corresponding upstream is using ALPN-based :ref:`FilterChainMatch
       * &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` along with different protocols for health checks
       * versus data connections. If empty, no ALPN protocols will be set on health check connections.
       * </pre>
       *
       * <code>repeated string alpn_protocols = 1;</code>
       * @param index The index to set the value at.
       * @param value The alpnProtocols to set.
       * @return This builder for chaining.
       */
      public Builder setAlpnProtocols(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAlpnProtocolsIsMutable();
        alpnProtocols_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the ALPN protocols for health check connections. This is useful if the
       * corresponding upstream is using ALPN-based :ref:`FilterChainMatch
       * &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` along with different protocols for health checks
       * versus data connections. If empty, no ALPN protocols will be set on health check connections.
       * </pre>
       *
       * <code>repeated string alpn_protocols = 1;</code>
       * @param value The alpnProtocols to add.
       * @return This builder for chaining.
       */
      public Builder addAlpnProtocols(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAlpnProtocolsIsMutable();
        alpnProtocols_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the ALPN protocols for health check connections. This is useful if the
       * corresponding upstream is using ALPN-based :ref:`FilterChainMatch
       * &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` along with different protocols for health checks
       * versus data connections. If empty, no ALPN protocols will be set on health check connections.
       * </pre>
       *
       * <code>repeated string alpn_protocols = 1;</code>
       * @param values The alpnProtocols to add.
       * @return This builder for chaining.
       */
      public Builder addAllAlpnProtocols(
          java.lang.Iterable<java.lang.String> values) {
        ensureAlpnProtocolsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, alpnProtocols_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the ALPN protocols for health check connections. This is useful if the
       * corresponding upstream is using ALPN-based :ref:`FilterChainMatch
       * &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` along with different protocols for health checks
       * versus data connections. If empty, no ALPN protocols will be set on health check connections.
       * </pre>
       *
       * <code>repeated string alpn_protocols = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearAlpnProtocols() {
        alpnProtocols_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Specifies the ALPN protocols for health check connections. This is useful if the
       * corresponding upstream is using ALPN-based :ref:`FilterChainMatch
       * &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch&gt;` along with different protocols for health checks
       * versus data connections. If empty, no ALPN protocols will be set on health check connections.
       * </pre>
       *
       * <code>repeated string alpn_protocols = 1;</code>
       * @param value The bytes of the alpnProtocols to add.
       * @return This builder for chaining.
       */
      public Builder addAlpnProtocolsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        ensureAlpnProtocolsIsMutable();
        alpnProtocols_.add(value);
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.config.core.v3.HealthCheck.TlsOptions)
    }

    // @@protoc_insertion_point(class_scope:envoy.config.core.v3.HealthCheck.TlsOptions)
    private static final io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions();
    }

    public static io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TlsOptions>
        PARSER = new com.google.protobuf.AbstractParser<TlsOptions>() {
      @java.lang.Override
      public TlsOptions parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TlsOptions> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TlsOptions> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private int healthCheckerCase_ = 0;
  private java.lang.Object healthChecker_;
  public enum HealthCheckerCase
      implements com.google.protobuf.Internal.EnumLite,
          com.google.protobuf.AbstractMessage.InternalOneOfEnum {
    HTTP_HEALTH_CHECK(8),
    TCP_HEALTH_CHECK(9),
    GRPC_HEALTH_CHECK(11),
    CUSTOM_HEALTH_CHECK(13),
    HEALTHCHECKER_NOT_SET(0);
    private final int value;
    private HealthCheckerCase(int value) {
      this.value = value;
    }
    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static HealthCheckerCase valueOf(int value) {
      return forNumber(value);
    }

    public static HealthCheckerCase forNumber(int value) {
      switch (value) {
        case 8: return HTTP_HEALTH_CHECK;
        case 9: return TCP_HEALTH_CHECK;
        case 11: return GRPC_HEALTH_CHECK;
        case 13: return CUSTOM_HEALTH_CHECK;
        case 0: return HEALTHCHECKER_NOT_SET;
        default: return null;
      }
    }
    public int getNumber() {
      return this.value;
    }
  };

  public HealthCheckerCase
  getHealthCheckerCase() {
    return HealthCheckerCase.forNumber(
        healthCheckerCase_);
  }

  public static final int TIMEOUT_FIELD_NUMBER = 1;
  private com.google.protobuf.Duration timeout_;
  /**
   * <pre>
   * The time to wait for a health check response. If the timeout is reached the
   * health check attempt will be considered a failure.
   * </pre>
   *
   * <code>.google.protobuf.Duration timeout = 1 [(.validate.rules) = { ... }</code>
   * @return Whether the timeout field is set.
   */
  @java.lang.Override
  public boolean hasTimeout() {
    return timeout_ != null;
  }
  /**
   * <pre>
   * The time to wait for a health check response. If the timeout is reached the
   * health check attempt will be considered a failure.
   * </pre>
   *
   * <code>.google.protobuf.Duration timeout = 1 [(.validate.rules) = { ... }</code>
   * @return The timeout.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getTimeout() {
    return timeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : timeout_;
  }
  /**
   * <pre>
   * The time to wait for a health check response. If the timeout is reached the
   * health check attempt will be considered a failure.
   * </pre>
   *
   * <code>.google.protobuf.Duration timeout = 1 [(.validate.rules) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getTimeoutOrBuilder() {
    return timeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : timeout_;
  }

  public static final int INTERVAL_FIELD_NUMBER = 2;
  private com.google.protobuf.Duration interval_;
  /**
   * <pre>
   * The interval between health checks.
   * </pre>
   *
   * <code>.google.protobuf.Duration interval = 2 [(.validate.rules) = { ... }</code>
   * @return Whether the interval field is set.
   */
  @java.lang.Override
  public boolean hasInterval() {
    return interval_ != null;
  }
  /**
   * <pre>
   * The interval between health checks.
   * </pre>
   *
   * <code>.google.protobuf.Duration interval = 2 [(.validate.rules) = { ... }</code>
   * @return The interval.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getInterval() {
    return interval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : interval_;
  }
  /**
   * <pre>
   * The interval between health checks.
   * </pre>
   *
   * <code>.google.protobuf.Duration interval = 2 [(.validate.rules) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getIntervalOrBuilder() {
    return interval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : interval_;
  }

  public static final int INITIAL_JITTER_FIELD_NUMBER = 20;
  private com.google.protobuf.Duration initialJitter_;
  /**
   * <pre>
   * An optional jitter amount in milliseconds. If specified, Envoy will start health
   * checking after for a random time in ms between 0 and initial_jitter. This only
   * applies to the first health check.
   * </pre>
   *
   * <code>.google.protobuf.Duration initial_jitter = 20;</code>
   * @return Whether the initialJitter field is set.
   */
  @java.lang.Override
  public boolean hasInitialJitter() {
    return initialJitter_ != null;
  }
  /**
   * <pre>
   * An optional jitter amount in milliseconds. If specified, Envoy will start health
   * checking after for a random time in ms between 0 and initial_jitter. This only
   * applies to the first health check.
   * </pre>
   *
   * <code>.google.protobuf.Duration initial_jitter = 20;</code>
   * @return The initialJitter.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getInitialJitter() {
    return initialJitter_ == null ? com.google.protobuf.Duration.getDefaultInstance() : initialJitter_;
  }
  /**
   * <pre>
   * An optional jitter amount in milliseconds. If specified, Envoy will start health
   * checking after for a random time in ms between 0 and initial_jitter. This only
   * applies to the first health check.
   * </pre>
   *
   * <code>.google.protobuf.Duration initial_jitter = 20;</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getInitialJitterOrBuilder() {
    return initialJitter_ == null ? com.google.protobuf.Duration.getDefaultInstance() : initialJitter_;
  }

  public static final int INTERVAL_JITTER_FIELD_NUMBER = 3;
  private com.google.protobuf.Duration intervalJitter_;
  /**
   * <pre>
   * An optional jitter amount in milliseconds. If specified, during every
   * interval Envoy will add interval_jitter to the wait time.
   * </pre>
   *
   * <code>.google.protobuf.Duration interval_jitter = 3;</code>
   * @return Whether the intervalJitter field is set.
   */
  @java.lang.Override
  public boolean hasIntervalJitter() {
    return intervalJitter_ != null;
  }
  /**
   * <pre>
   * An optional jitter amount in milliseconds. If specified, during every
   * interval Envoy will add interval_jitter to the wait time.
   * </pre>
   *
   * <code>.google.protobuf.Duration interval_jitter = 3;</code>
   * @return The intervalJitter.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getIntervalJitter() {
    return intervalJitter_ == null ? com.google.protobuf.Duration.getDefaultInstance() : intervalJitter_;
  }
  /**
   * <pre>
   * An optional jitter amount in milliseconds. If specified, during every
   * interval Envoy will add interval_jitter to the wait time.
   * </pre>
   *
   * <code>.google.protobuf.Duration interval_jitter = 3;</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getIntervalJitterOrBuilder() {
    return intervalJitter_ == null ? com.google.protobuf.Duration.getDefaultInstance() : intervalJitter_;
  }

  public static final int INTERVAL_JITTER_PERCENT_FIELD_NUMBER = 18;
  private int intervalJitterPercent_ = 0;
  /**
   * <pre>
   * An optional jitter amount as a percentage of interval_ms. If specified,
   * during every interval Envoy will add ``interval_ms`` *
   * ``interval_jitter_percent`` / 100 to the wait time.
   * If interval_jitter_ms and interval_jitter_percent are both set, both of
   * them will be used to increase the wait time.
   * </pre>
   *
   * <code>uint32 interval_jitter_percent = 18;</code>
   * @return The intervalJitterPercent.
   */
  @java.lang.Override
  public int getIntervalJitterPercent() {
    return intervalJitterPercent_;
  }

  public static final int UNHEALTHY_THRESHOLD_FIELD_NUMBER = 4;
  private com.google.protobuf.UInt32Value unhealthyThreshold_;
  /**
   * <pre>
   * The number of unhealthy health checks required before a host is marked
   * unhealthy. Note that for ``http`` health checking if a host responds with a code not in
   * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
   * or :ref:`retriable_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.retriable_statuses&gt;`,
   * this threshold is ignored and the host is considered immediately unhealthy.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value unhealthy_threshold = 4 [(.validate.rules) = { ... }</code>
   * @return Whether the unhealthyThreshold field is set.
   */
  @java.lang.Override
  public boolean hasUnhealthyThreshold() {
    return unhealthyThreshold_ != null;
  }
  /**
   * <pre>
   * The number of unhealthy health checks required before a host is marked
   * unhealthy. Note that for ``http`` health checking if a host responds with a code not in
   * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
   * or :ref:`retriable_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.retriable_statuses&gt;`,
   * this threshold is ignored and the host is considered immediately unhealthy.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value unhealthy_threshold = 4 [(.validate.rules) = { ... }</code>
   * @return The unhealthyThreshold.
   */
  @java.lang.Override
  public com.google.protobuf.UInt32Value getUnhealthyThreshold() {
    return unhealthyThreshold_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : unhealthyThreshold_;
  }
  /**
   * <pre>
   * The number of unhealthy health checks required before a host is marked
   * unhealthy. Note that for ``http`` health checking if a host responds with a code not in
   * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
   * or :ref:`retriable_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.retriable_statuses&gt;`,
   * this threshold is ignored and the host is considered immediately unhealthy.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value unhealthy_threshold = 4 [(.validate.rules) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.UInt32ValueOrBuilder getUnhealthyThresholdOrBuilder() {
    return unhealthyThreshold_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : unhealthyThreshold_;
  }

  public static final int HEALTHY_THRESHOLD_FIELD_NUMBER = 5;
  private com.google.protobuf.UInt32Value healthyThreshold_;
  /**
   * <pre>
   * The number of healthy health checks required before a host is marked
   * healthy. Note that during startup, only a single successful health check is
   * required to mark a host healthy.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value healthy_threshold = 5 [(.validate.rules) = { ... }</code>
   * @return Whether the healthyThreshold field is set.
   */
  @java.lang.Override
  public boolean hasHealthyThreshold() {
    return healthyThreshold_ != null;
  }
  /**
   * <pre>
   * The number of healthy health checks required before a host is marked
   * healthy. Note that during startup, only a single successful health check is
   * required to mark a host healthy.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value healthy_threshold = 5 [(.validate.rules) = { ... }</code>
   * @return The healthyThreshold.
   */
  @java.lang.Override
  public com.google.protobuf.UInt32Value getHealthyThreshold() {
    return healthyThreshold_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : healthyThreshold_;
  }
  /**
   * <pre>
   * The number of healthy health checks required before a host is marked
   * healthy. Note that during startup, only a single successful health check is
   * required to mark a host healthy.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value healthy_threshold = 5 [(.validate.rules) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.UInt32ValueOrBuilder getHealthyThresholdOrBuilder() {
    return healthyThreshold_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : healthyThreshold_;
  }

  public static final int ALT_PORT_FIELD_NUMBER = 6;
  private com.google.protobuf.UInt32Value altPort_;
  /**
   * <pre>
   * [#not-implemented-hide:] Non-serving port for health checking.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value alt_port = 6;</code>
   * @return Whether the altPort field is set.
   */
  @java.lang.Override
  public boolean hasAltPort() {
    return altPort_ != null;
  }
  /**
   * <pre>
   * [#not-implemented-hide:] Non-serving port for health checking.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value alt_port = 6;</code>
   * @return The altPort.
   */
  @java.lang.Override
  public com.google.protobuf.UInt32Value getAltPort() {
    return altPort_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : altPort_;
  }
  /**
   * <pre>
   * [#not-implemented-hide:] Non-serving port for health checking.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value alt_port = 6;</code>
   */
  @java.lang.Override
  public com.google.protobuf.UInt32ValueOrBuilder getAltPortOrBuilder() {
    return altPort_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : altPort_;
  }

  public static final int REUSE_CONNECTION_FIELD_NUMBER = 7;
  private com.google.protobuf.BoolValue reuseConnection_;
  /**
   * <pre>
   * Reuse health check connection between health checks. Default is true.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue reuse_connection = 7;</code>
   * @return Whether the reuseConnection field is set.
   */
  @java.lang.Override
  public boolean hasReuseConnection() {
    return reuseConnection_ != null;
  }
  /**
   * <pre>
   * Reuse health check connection between health checks. Default is true.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue reuse_connection = 7;</code>
   * @return The reuseConnection.
   */
  @java.lang.Override
  public com.google.protobuf.BoolValue getReuseConnection() {
    return reuseConnection_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : reuseConnection_;
  }
  /**
   * <pre>
   * Reuse health check connection between health checks. Default is true.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue reuse_connection = 7;</code>
   */
  @java.lang.Override
  public com.google.protobuf.BoolValueOrBuilder getReuseConnectionOrBuilder() {
    return reuseConnection_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : reuseConnection_;
  }

  public static final int HTTP_HEALTH_CHECK_FIELD_NUMBER = 8;
  /**
   * <pre>
   * HTTP health check.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HealthCheck.HttpHealthCheck http_health_check = 8;</code>
   * @return Whether the httpHealthCheck field is set.
   */
  @java.lang.Override
  public boolean hasHttpHealthCheck() {
    return healthCheckerCase_ == 8;
  }
  /**
   * <pre>
   * HTTP health check.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HealthCheck.HttpHealthCheck http_health_check = 8;</code>
   * @return The httpHealthCheck.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck getHttpHealthCheck() {
    if (healthCheckerCase_ == 8) {
       return (io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck) healthChecker_;
    }
    return io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck.getDefaultInstance();
  }
  /**
   * <pre>
   * HTTP health check.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HealthCheck.HttpHealthCheck http_health_check = 8;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheckOrBuilder getHttpHealthCheckOrBuilder() {
    if (healthCheckerCase_ == 8) {
       return (io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck) healthChecker_;
    }
    return io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck.getDefaultInstance();
  }

  public static final int TCP_HEALTH_CHECK_FIELD_NUMBER = 9;
  /**
   * <pre>
   * TCP health check.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HealthCheck.TcpHealthCheck tcp_health_check = 9;</code>
   * @return Whether the tcpHealthCheck field is set.
   */
  @java.lang.Override
  public boolean hasTcpHealthCheck() {
    return healthCheckerCase_ == 9;
  }
  /**
   * <pre>
   * TCP health check.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HealthCheck.TcpHealthCheck tcp_health_check = 9;</code>
   * @return The tcpHealthCheck.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck getTcpHealthCheck() {
    if (healthCheckerCase_ == 9) {
       return (io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck) healthChecker_;
    }
    return io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck.getDefaultInstance();
  }
  /**
   * <pre>
   * TCP health check.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HealthCheck.TcpHealthCheck tcp_health_check = 9;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheckOrBuilder getTcpHealthCheckOrBuilder() {
    if (healthCheckerCase_ == 9) {
       return (io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck) healthChecker_;
    }
    return io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck.getDefaultInstance();
  }

  public static final int GRPC_HEALTH_CHECK_FIELD_NUMBER = 11;
  /**
   * <pre>
   * gRPC health check.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HealthCheck.GrpcHealthCheck grpc_health_check = 11;</code>
   * @return Whether the grpcHealthCheck field is set.
   */
  @java.lang.Override
  public boolean hasGrpcHealthCheck() {
    return healthCheckerCase_ == 11;
  }
  /**
   * <pre>
   * gRPC health check.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HealthCheck.GrpcHealthCheck grpc_health_check = 11;</code>
   * @return The grpcHealthCheck.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck getGrpcHealthCheck() {
    if (healthCheckerCase_ == 11) {
       return (io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck) healthChecker_;
    }
    return io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck.getDefaultInstance();
  }
  /**
   * <pre>
   * gRPC health check.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HealthCheck.GrpcHealthCheck grpc_health_check = 11;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheckOrBuilder getGrpcHealthCheckOrBuilder() {
    if (healthCheckerCase_ == 11) {
       return (io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck) healthChecker_;
    }
    return io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck.getDefaultInstance();
  }

  public static final int CUSTOM_HEALTH_CHECK_FIELD_NUMBER = 13;
  /**
   * <pre>
   * Custom health check.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HealthCheck.CustomHealthCheck custom_health_check = 13;</code>
   * @return Whether the customHealthCheck field is set.
   */
  @java.lang.Override
  public boolean hasCustomHealthCheck() {
    return healthCheckerCase_ == 13;
  }
  /**
   * <pre>
   * Custom health check.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HealthCheck.CustomHealthCheck custom_health_check = 13;</code>
   * @return The customHealthCheck.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck getCustomHealthCheck() {
    if (healthCheckerCase_ == 13) {
       return (io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck) healthChecker_;
    }
    return io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck.getDefaultInstance();
  }
  /**
   * <pre>
   * Custom health check.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HealthCheck.CustomHealthCheck custom_health_check = 13;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheckOrBuilder getCustomHealthCheckOrBuilder() {
    if (healthCheckerCase_ == 13) {
       return (io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck) healthChecker_;
    }
    return io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck.getDefaultInstance();
  }

  public static final int NO_TRAFFIC_INTERVAL_FIELD_NUMBER = 12;
  private com.google.protobuf.Duration noTrafficInterval_;
  /**
   * <pre>
   * The "no traffic interval" is a special health check interval that is used when a cluster has
   * never had traffic routed to it. This lower interval allows cluster information to be kept up to
   * date, without sending a potentially large amount of active health checking traffic for no
   * reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the
   * standard health check interval that is defined. Note that this interval takes precedence over
   * any other.
   * The default value for "no traffic interval" is 60 seconds.
   * </pre>
   *
   * <code>.google.protobuf.Duration no_traffic_interval = 12 [(.validate.rules) = { ... }</code>
   * @return Whether the noTrafficInterval field is set.
   */
  @java.lang.Override
  public boolean hasNoTrafficInterval() {
    return noTrafficInterval_ != null;
  }
  /**
   * <pre>
   * The "no traffic interval" is a special health check interval that is used when a cluster has
   * never had traffic routed to it. This lower interval allows cluster information to be kept up to
   * date, without sending a potentially large amount of active health checking traffic for no
   * reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the
   * standard health check interval that is defined. Note that this interval takes precedence over
   * any other.
   * The default value for "no traffic interval" is 60 seconds.
   * </pre>
   *
   * <code>.google.protobuf.Duration no_traffic_interval = 12 [(.validate.rules) = { ... }</code>
   * @return The noTrafficInterval.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getNoTrafficInterval() {
    return noTrafficInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : noTrafficInterval_;
  }
  /**
   * <pre>
   * The "no traffic interval" is a special health check interval that is used when a cluster has
   * never had traffic routed to it. This lower interval allows cluster information to be kept up to
   * date, without sending a potentially large amount of active health checking traffic for no
   * reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the
   * standard health check interval that is defined. Note that this interval takes precedence over
   * any other.
   * The default value for "no traffic interval" is 60 seconds.
   * </pre>
   *
   * <code>.google.protobuf.Duration no_traffic_interval = 12 [(.validate.rules) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getNoTrafficIntervalOrBuilder() {
    return noTrafficInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : noTrafficInterval_;
  }

  public static final int NO_TRAFFIC_HEALTHY_INTERVAL_FIELD_NUMBER = 24;
  private com.google.protobuf.Duration noTrafficHealthyInterval_;
  /**
   * <pre>
   * The "no traffic healthy interval" is a special health check interval that
   * is used for hosts that are currently passing active health checking
   * (including new hosts) when the cluster has received no traffic.
   * This is useful for when we want to send frequent health checks with
   * ``no_traffic_interval`` but then revert to lower frequency ``no_traffic_healthy_interval`` once
   * a host in the cluster is marked as healthy.
   * Once a cluster has been used for traffic routing, Envoy will shift back to using the
   * standard health check interval that is defined.
   * If no_traffic_healthy_interval is not set, it will default to the
   * no traffic interval and send that interval regardless of health state.
   * </pre>
   *
   * <code>.google.protobuf.Duration no_traffic_healthy_interval = 24 [(.validate.rules) = { ... }</code>
   * @return Whether the noTrafficHealthyInterval field is set.
   */
  @java.lang.Override
  public boolean hasNoTrafficHealthyInterval() {
    return noTrafficHealthyInterval_ != null;
  }
  /**
   * <pre>
   * The "no traffic healthy interval" is a special health check interval that
   * is used for hosts that are currently passing active health checking
   * (including new hosts) when the cluster has received no traffic.
   * This is useful for when we want to send frequent health checks with
   * ``no_traffic_interval`` but then revert to lower frequency ``no_traffic_healthy_interval`` once
   * a host in the cluster is marked as healthy.
   * Once a cluster has been used for traffic routing, Envoy will shift back to using the
   * standard health check interval that is defined.
   * If no_traffic_healthy_interval is not set, it will default to the
   * no traffic interval and send that interval regardless of health state.
   * </pre>
   *
   * <code>.google.protobuf.Duration no_traffic_healthy_interval = 24 [(.validate.rules) = { ... }</code>
   * @return The noTrafficHealthyInterval.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getNoTrafficHealthyInterval() {
    return noTrafficHealthyInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : noTrafficHealthyInterval_;
  }
  /**
   * <pre>
   * The "no traffic healthy interval" is a special health check interval that
   * is used for hosts that are currently passing active health checking
   * (including new hosts) when the cluster has received no traffic.
   * This is useful for when we want to send frequent health checks with
   * ``no_traffic_interval`` but then revert to lower frequency ``no_traffic_healthy_interval`` once
   * a host in the cluster is marked as healthy.
   * Once a cluster has been used for traffic routing, Envoy will shift back to using the
   * standard health check interval that is defined.
   * If no_traffic_healthy_interval is not set, it will default to the
   * no traffic interval and send that interval regardless of health state.
   * </pre>
   *
   * <code>.google.protobuf.Duration no_traffic_healthy_interval = 24 [(.validate.rules) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getNoTrafficHealthyIntervalOrBuilder() {
    return noTrafficHealthyInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : noTrafficHealthyInterval_;
  }

  public static final int UNHEALTHY_INTERVAL_FIELD_NUMBER = 14;
  private com.google.protobuf.Duration unhealthyInterval_;
  /**
   * <pre>
   * The "unhealthy interval" is a health check interval that is used for hosts that are marked as
   * unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the
   * standard health check interval that is defined.
   * The default value for "unhealthy interval" is the same as "interval".
   * </pre>
   *
   * <code>.google.protobuf.Duration unhealthy_interval = 14 [(.validate.rules) = { ... }</code>
   * @return Whether the unhealthyInterval field is set.
   */
  @java.lang.Override
  public boolean hasUnhealthyInterval() {
    return unhealthyInterval_ != null;
  }
  /**
   * <pre>
   * The "unhealthy interval" is a health check interval that is used for hosts that are marked as
   * unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the
   * standard health check interval that is defined.
   * The default value for "unhealthy interval" is the same as "interval".
   * </pre>
   *
   * <code>.google.protobuf.Duration unhealthy_interval = 14 [(.validate.rules) = { ... }</code>
   * @return The unhealthyInterval.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getUnhealthyInterval() {
    return unhealthyInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : unhealthyInterval_;
  }
  /**
   * <pre>
   * The "unhealthy interval" is a health check interval that is used for hosts that are marked as
   * unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the
   * standard health check interval that is defined.
   * The default value for "unhealthy interval" is the same as "interval".
   * </pre>
   *
   * <code>.google.protobuf.Duration unhealthy_interval = 14 [(.validate.rules) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getUnhealthyIntervalOrBuilder() {
    return unhealthyInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : unhealthyInterval_;
  }

  public static final int UNHEALTHY_EDGE_INTERVAL_FIELD_NUMBER = 15;
  private com.google.protobuf.Duration unhealthyEdgeInterval_;
  /**
   * <pre>
   * The "unhealthy edge interval" is a special health check interval that is used for the first
   * health check right after a host is marked as unhealthy. For subsequent health checks
   * Envoy will shift back to using either "unhealthy interval" if present or the standard health
   * check interval that is defined.
   * The default value for "unhealthy edge interval" is the same as "unhealthy interval".
   * </pre>
   *
   * <code>.google.protobuf.Duration unhealthy_edge_interval = 15 [(.validate.rules) = { ... }</code>
   * @return Whether the unhealthyEdgeInterval field is set.
   */
  @java.lang.Override
  public boolean hasUnhealthyEdgeInterval() {
    return unhealthyEdgeInterval_ != null;
  }
  /**
   * <pre>
   * The "unhealthy edge interval" is a special health check interval that is used for the first
   * health check right after a host is marked as unhealthy. For subsequent health checks
   * Envoy will shift back to using either "unhealthy interval" if present or the standard health
   * check interval that is defined.
   * The default value for "unhealthy edge interval" is the same as "unhealthy interval".
   * </pre>
   *
   * <code>.google.protobuf.Duration unhealthy_edge_interval = 15 [(.validate.rules) = { ... }</code>
   * @return The unhealthyEdgeInterval.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getUnhealthyEdgeInterval() {
    return unhealthyEdgeInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : unhealthyEdgeInterval_;
  }
  /**
   * <pre>
   * The "unhealthy edge interval" is a special health check interval that is used for the first
   * health check right after a host is marked as unhealthy. For subsequent health checks
   * Envoy will shift back to using either "unhealthy interval" if present or the standard health
   * check interval that is defined.
   * The default value for "unhealthy edge interval" is the same as "unhealthy interval".
   * </pre>
   *
   * <code>.google.protobuf.Duration unhealthy_edge_interval = 15 [(.validate.rules) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getUnhealthyEdgeIntervalOrBuilder() {
    return unhealthyEdgeInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : unhealthyEdgeInterval_;
  }

  public static final int HEALTHY_EDGE_INTERVAL_FIELD_NUMBER = 16;
  private com.google.protobuf.Duration healthyEdgeInterval_;
  /**
   * <pre>
   * The "healthy edge interval" is a special health check interval that is used for the first
   * health check right after a host is marked as healthy. For subsequent health checks
   * Envoy will shift back to using the standard health check interval that is defined.
   * The default value for "healthy edge interval" is the same as the default interval.
   * </pre>
   *
   * <code>.google.protobuf.Duration healthy_edge_interval = 16 [(.validate.rules) = { ... }</code>
   * @return Whether the healthyEdgeInterval field is set.
   */
  @java.lang.Override
  public boolean hasHealthyEdgeInterval() {
    return healthyEdgeInterval_ != null;
  }
  /**
   * <pre>
   * The "healthy edge interval" is a special health check interval that is used for the first
   * health check right after a host is marked as healthy. For subsequent health checks
   * Envoy will shift back to using the standard health check interval that is defined.
   * The default value for "healthy edge interval" is the same as the default interval.
   * </pre>
   *
   * <code>.google.protobuf.Duration healthy_edge_interval = 16 [(.validate.rules) = { ... }</code>
   * @return The healthyEdgeInterval.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getHealthyEdgeInterval() {
    return healthyEdgeInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : healthyEdgeInterval_;
  }
  /**
   * <pre>
   * The "healthy edge interval" is a special health check interval that is used for the first
   * health check right after a host is marked as healthy. For subsequent health checks
   * Envoy will shift back to using the standard health check interval that is defined.
   * The default value for "healthy edge interval" is the same as the default interval.
   * </pre>
   *
   * <code>.google.protobuf.Duration healthy_edge_interval = 16 [(.validate.rules) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getHealthyEdgeIntervalOrBuilder() {
    return healthyEdgeInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : healthyEdgeInterval_;
  }

  public static final int EVENT_LOG_PATH_FIELD_NUMBER = 17;
  @SuppressWarnings("serial")
  private volatile java.lang.Object eventLogPath_ = "";
  /**
   * <pre>
   * Specifies the path to the :ref:`health check event log &lt;arch_overview_health_check_logging&gt;`.
   * If empty, no event log will be written.
   * </pre>
   *
   * <code>string event_log_path = 17;</code>
   * @return The eventLogPath.
   */
  @java.lang.Override
  public java.lang.String getEventLogPath() {
    java.lang.Object ref = eventLogPath_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      eventLogPath_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Specifies the path to the :ref:`health check event log &lt;arch_overview_health_check_logging&gt;`.
   * If empty, no event log will be written.
   * </pre>
   *
   * <code>string event_log_path = 17;</code>
   * @return The bytes for eventLogPath.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getEventLogPathBytes() {
    java.lang.Object ref = eventLogPath_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      eventLogPath_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int EVENT_SERVICE_FIELD_NUMBER = 22;
  private io.envoyproxy.envoy.config.core.v3.EventServiceConfig eventService_;
  /**
   * <pre>
   * [#not-implemented-hide:]
   * The gRPC service for the health check event service.
   * If empty, health check events won't be sent to a remote endpoint.
   * </pre>
   *
   * <code>.envoy.config.core.v3.EventServiceConfig event_service = 22;</code>
   * @return Whether the eventService field is set.
   */
  @java.lang.Override
  public boolean hasEventService() {
    return eventService_ != null;
  }
  /**
   * <pre>
   * [#not-implemented-hide:]
   * The gRPC service for the health check event service.
   * If empty, health check events won't be sent to a remote endpoint.
   * </pre>
   *
   * <code>.envoy.config.core.v3.EventServiceConfig event_service = 22;</code>
   * @return The eventService.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.EventServiceConfig getEventService() {
    return eventService_ == null ? io.envoyproxy.envoy.config.core.v3.EventServiceConfig.getDefaultInstance() : eventService_;
  }
  /**
   * <pre>
   * [#not-implemented-hide:]
   * The gRPC service for the health check event service.
   * If empty, health check events won't be sent to a remote endpoint.
   * </pre>
   *
   * <code>.envoy.config.core.v3.EventServiceConfig event_service = 22;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.EventServiceConfigOrBuilder getEventServiceOrBuilder() {
    return eventService_ == null ? io.envoyproxy.envoy.config.core.v3.EventServiceConfig.getDefaultInstance() : eventService_;
  }

  public static final int ALWAYS_LOG_HEALTH_CHECK_FAILURES_FIELD_NUMBER = 19;
  private boolean alwaysLogHealthCheckFailures_ = false;
  /**
   * <pre>
   * If set to true, health check failure events will always be logged. If set to false, only the
   * initial health check failure event will be logged.
   * The default value is false.
   * </pre>
   *
   * <code>bool always_log_health_check_failures = 19;</code>
   * @return The alwaysLogHealthCheckFailures.
   */
  @java.lang.Override
  public boolean getAlwaysLogHealthCheckFailures() {
    return alwaysLogHealthCheckFailures_;
  }

  public static final int TLS_OPTIONS_FIELD_NUMBER = 21;
  private io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions tlsOptions_;
  /**
   * <pre>
   * This allows overriding the cluster TLS settings, just for health check connections.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HealthCheck.TlsOptions tls_options = 21;</code>
   * @return Whether the tlsOptions field is set.
   */
  @java.lang.Override
  public boolean hasTlsOptions() {
    return tlsOptions_ != null;
  }
  /**
   * <pre>
   * This allows overriding the cluster TLS settings, just for health check connections.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HealthCheck.TlsOptions tls_options = 21;</code>
   * @return The tlsOptions.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions getTlsOptions() {
    return tlsOptions_ == null ? io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions.getDefaultInstance() : tlsOptions_;
  }
  /**
   * <pre>
   * This allows overriding the cluster TLS settings, just for health check connections.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HealthCheck.TlsOptions tls_options = 21;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptionsOrBuilder getTlsOptionsOrBuilder() {
    return tlsOptions_ == null ? io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions.getDefaultInstance() : tlsOptions_;
  }

  public static final int TRANSPORT_SOCKET_MATCH_CRITERIA_FIELD_NUMBER = 23;
  private com.google.protobuf.Struct transportSocketMatchCriteria_;
  /**
   * <pre>
   * Optional key/value pairs that will be used to match a transport socket from those specified in the cluster's
   * :ref:`tranport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`.
   * For example, the following match criteria
   * .. code-block:: yaml
   *  transport_socket_match_criteria:
   *    useMTLS: true
   * Will match the following :ref:`cluster socket match &lt;envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;`
   * .. code-block:: yaml
   *  transport_socket_matches:
   *  - name: "useMTLS"
   *    match:
   *      useMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   * If this field is set, then for health checks it will supersede an entry of ``envoy.transport_socket`` in the
   * :ref:`LbEndpoint.Metadata &lt;envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`.
   * This allows using different transport socket capabilities for health checking versus proxying to the
   * endpoint.
   * If the key/values pairs specified do not match any
   * :ref:`transport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`,
   * the cluster's :ref:`transport socket &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket&gt;`
   * will be used for health check socket configuration.
   * </pre>
   *
   * <code>.google.protobuf.Struct transport_socket_match_criteria = 23;</code>
   * @return Whether the transportSocketMatchCriteria field is set.
   */
  @java.lang.Override
  public boolean hasTransportSocketMatchCriteria() {
    return transportSocketMatchCriteria_ != null;
  }
  /**
   * <pre>
   * Optional key/value pairs that will be used to match a transport socket from those specified in the cluster's
   * :ref:`tranport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`.
   * For example, the following match criteria
   * .. code-block:: yaml
   *  transport_socket_match_criteria:
   *    useMTLS: true
   * Will match the following :ref:`cluster socket match &lt;envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;`
   * .. code-block:: yaml
   *  transport_socket_matches:
   *  - name: "useMTLS"
   *    match:
   *      useMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   * If this field is set, then for health checks it will supersede an entry of ``envoy.transport_socket`` in the
   * :ref:`LbEndpoint.Metadata &lt;envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`.
   * This allows using different transport socket capabilities for health checking versus proxying to the
   * endpoint.
   * If the key/values pairs specified do not match any
   * :ref:`transport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`,
   * the cluster's :ref:`transport socket &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket&gt;`
   * will be used for health check socket configuration.
   * </pre>
   *
   * <code>.google.protobuf.Struct transport_socket_match_criteria = 23;</code>
   * @return The transportSocketMatchCriteria.
   */
  @java.lang.Override
  public com.google.protobuf.Struct getTransportSocketMatchCriteria() {
    return transportSocketMatchCriteria_ == null ? com.google.protobuf.Struct.getDefaultInstance() : transportSocketMatchCriteria_;
  }
  /**
   * <pre>
   * Optional key/value pairs that will be used to match a transport socket from those specified in the cluster's
   * :ref:`tranport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`.
   * For example, the following match criteria
   * .. code-block:: yaml
   *  transport_socket_match_criteria:
   *    useMTLS: true
   * Will match the following :ref:`cluster socket match &lt;envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;`
   * .. code-block:: yaml
   *  transport_socket_matches:
   *  - name: "useMTLS"
   *    match:
   *      useMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   * If this field is set, then for health checks it will supersede an entry of ``envoy.transport_socket`` in the
   * :ref:`LbEndpoint.Metadata &lt;envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`.
   * This allows using different transport socket capabilities for health checking versus proxying to the
   * endpoint.
   * If the key/values pairs specified do not match any
   * :ref:`transport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`,
   * the cluster's :ref:`transport socket &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket&gt;`
   * will be used for health check socket configuration.
   * </pre>
   *
   * <code>.google.protobuf.Struct transport_socket_match_criteria = 23;</code>
   */
  @java.lang.Override
  public com.google.protobuf.StructOrBuilder getTransportSocketMatchCriteriaOrBuilder() {
    return transportSocketMatchCriteria_ == null ? com.google.protobuf.Struct.getDefaultInstance() : transportSocketMatchCriteria_;
  }

  private byte memoizedIsInitialized = -1;
  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (timeout_ != null) {
      output.writeMessage(1, getTimeout());
    }
    if (interval_ != null) {
      output.writeMessage(2, getInterval());
    }
    if (intervalJitter_ != null) {
      output.writeMessage(3, getIntervalJitter());
    }
    if (unhealthyThreshold_ != null) {
      output.writeMessage(4, getUnhealthyThreshold());
    }
    if (healthyThreshold_ != null) {
      output.writeMessage(5, getHealthyThreshold());
    }
    if (altPort_ != null) {
      output.writeMessage(6, getAltPort());
    }
    if (reuseConnection_ != null) {
      output.writeMessage(7, getReuseConnection());
    }
    if (healthCheckerCase_ == 8) {
      output.writeMessage(8, (io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck) healthChecker_);
    }
    if (healthCheckerCase_ == 9) {
      output.writeMessage(9, (io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck) healthChecker_);
    }
    if (healthCheckerCase_ == 11) {
      output.writeMessage(11, (io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck) healthChecker_);
    }
    if (noTrafficInterval_ != null) {
      output.writeMessage(12, getNoTrafficInterval());
    }
    if (healthCheckerCase_ == 13) {
      output.writeMessage(13, (io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck) healthChecker_);
    }
    if (unhealthyInterval_ != null) {
      output.writeMessage(14, getUnhealthyInterval());
    }
    if (unhealthyEdgeInterval_ != null) {
      output.writeMessage(15, getUnhealthyEdgeInterval());
    }
    if (healthyEdgeInterval_ != null) {
      output.writeMessage(16, getHealthyEdgeInterval());
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(eventLogPath_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 17, eventLogPath_);
    }
    if (intervalJitterPercent_ != 0) {
      output.writeUInt32(18, intervalJitterPercent_);
    }
    if (alwaysLogHealthCheckFailures_ != false) {
      output.writeBool(19, alwaysLogHealthCheckFailures_);
    }
    if (initialJitter_ != null) {
      output.writeMessage(20, getInitialJitter());
    }
    if (tlsOptions_ != null) {
      output.writeMessage(21, getTlsOptions());
    }
    if (eventService_ != null) {
      output.writeMessage(22, getEventService());
    }
    if (transportSocketMatchCriteria_ != null) {
      output.writeMessage(23, getTransportSocketMatchCriteria());
    }
    if (noTrafficHealthyInterval_ != null) {
      output.writeMessage(24, getNoTrafficHealthyInterval());
    }
    getUnknownFields().writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (timeout_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(1, getTimeout());
    }
    if (interval_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(2, getInterval());
    }
    if (intervalJitter_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(3, getIntervalJitter());
    }
    if (unhealthyThreshold_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(4, getUnhealthyThreshold());
    }
    if (healthyThreshold_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(5, getHealthyThreshold());
    }
    if (altPort_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(6, getAltPort());
    }
    if (reuseConnection_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(7, getReuseConnection());
    }
    if (healthCheckerCase_ == 8) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(8, (io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck) healthChecker_);
    }
    if (healthCheckerCase_ == 9) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(9, (io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck) healthChecker_);
    }
    if (healthCheckerCase_ == 11) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(11, (io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck) healthChecker_);
    }
    if (noTrafficInterval_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(12, getNoTrafficInterval());
    }
    if (healthCheckerCase_ == 13) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(13, (io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck) healthChecker_);
    }
    if (unhealthyInterval_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(14, getUnhealthyInterval());
    }
    if (unhealthyEdgeInterval_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(15, getUnhealthyEdgeInterval());
    }
    if (healthyEdgeInterval_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(16, getHealthyEdgeInterval());
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(eventLogPath_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(17, eventLogPath_);
    }
    if (intervalJitterPercent_ != 0) {
      size += com.google.protobuf.CodedOutputStream
        .computeUInt32Size(18, intervalJitterPercent_);
    }
    if (alwaysLogHealthCheckFailures_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(19, alwaysLogHealthCheckFailures_);
    }
    if (initialJitter_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(20, getInitialJitter());
    }
    if (tlsOptions_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(21, getTlsOptions());
    }
    if (eventService_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(22, getEventService());
    }
    if (transportSocketMatchCriteria_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(23, getTransportSocketMatchCriteria());
    }
    if (noTrafficHealthyInterval_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(24, getNoTrafficHealthyInterval());
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
     return true;
    }
    if (!(obj instanceof io.envoyproxy.envoy.config.core.v3.HealthCheck)) {
      return super.equals(obj);
    }
    io.envoyproxy.envoy.config.core.v3.HealthCheck other = (io.envoyproxy.envoy.config.core.v3.HealthCheck) obj;

    if (hasTimeout() != other.hasTimeout()) return false;
    if (hasTimeout()) {
      if (!getTimeout()
          .equals(other.getTimeout())) return false;
    }
    if (hasInterval() != other.hasInterval()) return false;
    if (hasInterval()) {
      if (!getInterval()
          .equals(other.getInterval())) return false;
    }
    if (hasInitialJitter() != other.hasInitialJitter()) return false;
    if (hasInitialJitter()) {
      if (!getInitialJitter()
          .equals(other.getInitialJitter())) return false;
    }
    if (hasIntervalJitter() != other.hasIntervalJitter()) return false;
    if (hasIntervalJitter()) {
      if (!getIntervalJitter()
          .equals(other.getIntervalJitter())) return false;
    }
    if (getIntervalJitterPercent()
        != other.getIntervalJitterPercent()) return false;
    if (hasUnhealthyThreshold() != other.hasUnhealthyThreshold()) return false;
    if (hasUnhealthyThreshold()) {
      if (!getUnhealthyThreshold()
          .equals(other.getUnhealthyThreshold())) return false;
    }
    if (hasHealthyThreshold() != other.hasHealthyThreshold()) return false;
    if (hasHealthyThreshold()) {
      if (!getHealthyThreshold()
          .equals(other.getHealthyThreshold())) return false;
    }
    if (hasAltPort() != other.hasAltPort()) return false;
    if (hasAltPort()) {
      if (!getAltPort()
          .equals(other.getAltPort())) return false;
    }
    if (hasReuseConnection() != other.hasReuseConnection()) return false;
    if (hasReuseConnection()) {
      if (!getReuseConnection()
          .equals(other.getReuseConnection())) return false;
    }
    if (hasNoTrafficInterval() != other.hasNoTrafficInterval()) return false;
    if (hasNoTrafficInterval()) {
      if (!getNoTrafficInterval()
          .equals(other.getNoTrafficInterval())) return false;
    }
    if (hasNoTrafficHealthyInterval() != other.hasNoTrafficHealthyInterval()) return false;
    if (hasNoTrafficHealthyInterval()) {
      if (!getNoTrafficHealthyInterval()
          .equals(other.getNoTrafficHealthyInterval())) return false;
    }
    if (hasUnhealthyInterval() != other.hasUnhealthyInterval()) return false;
    if (hasUnhealthyInterval()) {
      if (!getUnhealthyInterval()
          .equals(other.getUnhealthyInterval())) return false;
    }
    if (hasUnhealthyEdgeInterval() != other.hasUnhealthyEdgeInterval()) return false;
    if (hasUnhealthyEdgeInterval()) {
      if (!getUnhealthyEdgeInterval()
          .equals(other.getUnhealthyEdgeInterval())) return false;
    }
    if (hasHealthyEdgeInterval() != other.hasHealthyEdgeInterval()) return false;
    if (hasHealthyEdgeInterval()) {
      if (!getHealthyEdgeInterval()
          .equals(other.getHealthyEdgeInterval())) return false;
    }
    if (!getEventLogPath()
        .equals(other.getEventLogPath())) return false;
    if (hasEventService() != other.hasEventService()) return false;
    if (hasEventService()) {
      if (!getEventService()
          .equals(other.getEventService())) return false;
    }
    if (getAlwaysLogHealthCheckFailures()
        != other.getAlwaysLogHealthCheckFailures()) return false;
    if (hasTlsOptions() != other.hasTlsOptions()) return false;
    if (hasTlsOptions()) {
      if (!getTlsOptions()
          .equals(other.getTlsOptions())) return false;
    }
    if (hasTransportSocketMatchCriteria() != other.hasTransportSocketMatchCriteria()) return false;
    if (hasTransportSocketMatchCriteria()) {
      if (!getTransportSocketMatchCriteria()
          .equals(other.getTransportSocketMatchCriteria())) return false;
    }
    if (!getHealthCheckerCase().equals(other.getHealthCheckerCase())) return false;
    switch (healthCheckerCase_) {
      case 8:
        if (!getHttpHealthCheck()
            .equals(other.getHttpHealthCheck())) return false;
        break;
      case 9:
        if (!getTcpHealthCheck()
            .equals(other.getTcpHealthCheck())) return false;
        break;
      case 11:
        if (!getGrpcHealthCheck()
            .equals(other.getGrpcHealthCheck())) return false;
        break;
      case 13:
        if (!getCustomHealthCheck()
            .equals(other.getCustomHealthCheck())) return false;
        break;
      case 0:
      default:
    }
    if (!getUnknownFields().equals(other.getUnknownFields())) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    if (hasTimeout()) {
      hash = (37 * hash) + TIMEOUT_FIELD_NUMBER;
      hash = (53 * hash) + getTimeout().hashCode();
    }
    if (hasInterval()) {
      hash = (37 * hash) + INTERVAL_FIELD_NUMBER;
      hash = (53 * hash) + getInterval().hashCode();
    }
    if (hasInitialJitter()) {
      hash = (37 * hash) + INITIAL_JITTER_FIELD_NUMBER;
      hash = (53 * hash) + getInitialJitter().hashCode();
    }
    if (hasIntervalJitter()) {
      hash = (37 * hash) + INTERVAL_JITTER_FIELD_NUMBER;
      hash = (53 * hash) + getIntervalJitter().hashCode();
    }
    hash = (37 * hash) + INTERVAL_JITTER_PERCENT_FIELD_NUMBER;
    hash = (53 * hash) + getIntervalJitterPercent();
    if (hasUnhealthyThreshold()) {
      hash = (37 * hash) + UNHEALTHY_THRESHOLD_FIELD_NUMBER;
      hash = (53 * hash) + getUnhealthyThreshold().hashCode();
    }
    if (hasHealthyThreshold()) {
      hash = (37 * hash) + HEALTHY_THRESHOLD_FIELD_NUMBER;
      hash = (53 * hash) + getHealthyThreshold().hashCode();
    }
    if (hasAltPort()) {
      hash = (37 * hash) + ALT_PORT_FIELD_NUMBER;
      hash = (53 * hash) + getAltPort().hashCode();
    }
    if (hasReuseConnection()) {
      hash = (37 * hash) + REUSE_CONNECTION_FIELD_NUMBER;
      hash = (53 * hash) + getReuseConnection().hashCode();
    }
    if (hasNoTrafficInterval()) {
      hash = (37 * hash) + NO_TRAFFIC_INTERVAL_FIELD_NUMBER;
      hash = (53 * hash) + getNoTrafficInterval().hashCode();
    }
    if (hasNoTrafficHealthyInterval()) {
      hash = (37 * hash) + NO_TRAFFIC_HEALTHY_INTERVAL_FIELD_NUMBER;
      hash = (53 * hash) + getNoTrafficHealthyInterval().hashCode();
    }
    if (hasUnhealthyInterval()) {
      hash = (37 * hash) + UNHEALTHY_INTERVAL_FIELD_NUMBER;
      hash = (53 * hash) + getUnhealthyInterval().hashCode();
    }
    if (hasUnhealthyEdgeInterval()) {
      hash = (37 * hash) + UNHEALTHY_EDGE_INTERVAL_FIELD_NUMBER;
      hash = (53 * hash) + getUnhealthyEdgeInterval().hashCode();
    }
    if (hasHealthyEdgeInterval()) {
      hash = (37 * hash) + HEALTHY_EDGE_INTERVAL_FIELD_NUMBER;
      hash = (53 * hash) + getHealthyEdgeInterval().hashCode();
    }
    hash = (37 * hash) + EVENT_LOG_PATH_FIELD_NUMBER;
    hash = (53 * hash) + getEventLogPath().hashCode();
    if (hasEventService()) {
      hash = (37 * hash) + EVENT_SERVICE_FIELD_NUMBER;
      hash = (53 * hash) + getEventService().hashCode();
    }
    hash = (37 * hash) + ALWAYS_LOG_HEALTH_CHECK_FAILURES_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getAlwaysLogHealthCheckFailures());
    if (hasTlsOptions()) {
      hash = (37 * hash) + TLS_OPTIONS_FIELD_NUMBER;
      hash = (53 * hash) + getTlsOptions().hashCode();
    }
    if (hasTransportSocketMatchCriteria()) {
      hash = (37 * hash) + TRANSPORT_SOCKET_MATCH_CRITERIA_FIELD_NUMBER;
      hash = (53 * hash) + getTransportSocketMatchCriteria().hashCode();
    }
    switch (healthCheckerCase_) {
      case 8:
        hash = (37 * hash) + HTTP_HEALTH_CHECK_FIELD_NUMBER;
        hash = (53 * hash) + getHttpHealthCheck().hashCode();
        break;
      case 9:
        hash = (37 * hash) + TCP_HEALTH_CHECK_FIELD_NUMBER;
        hash = (53 * hash) + getTcpHealthCheck().hashCode();
        break;
      case 11:
        hash = (37 * hash) + GRPC_HEALTH_CHECK_FIELD_NUMBER;
        hash = (53 * hash) + getGrpcHealthCheck().hashCode();
        break;
      case 13:
        hash = (37 * hash) + CUSTOM_HEALTH_CHECK_FIELD_NUMBER;
        hash = (53 * hash) + getCustomHealthCheck().hashCode();
        break;
      case 0:
      default:
    }
    hash = (29 * hash) + getUnknownFields().hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static io.envoyproxy.envoy.config.core.v3.HealthCheck parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.envoyproxy.envoy.config.core.v3.HealthCheck parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.envoyproxy.envoy.config.core.v3.HealthCheck parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.envoyproxy.envoy.config.core.v3.HealthCheck parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.envoyproxy.envoy.config.core.v3.HealthCheck parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.envoyproxy.envoy.config.core.v3.HealthCheck parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.envoyproxy.envoy.config.core.v3.HealthCheck parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.envoyproxy.envoy.config.core.v3.HealthCheck parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.envoyproxy.envoy.config.core.v3.HealthCheck parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input);
  }
  public static io.envoyproxy.envoy.config.core.v3.HealthCheck parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.envoyproxy.envoy.config.core.v3.HealthCheck parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.envoyproxy.envoy.config.core.v3.HealthCheck parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(io.envoyproxy.envoy.config.core.v3.HealthCheck prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * <pre>
   * [#next-free-field: 25]
   * </pre>
   *
   * Protobuf type {@code envoy.config.core.v3.HealthCheck}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:envoy.config.core.v3.HealthCheck)
      io.envoyproxy.envoy.config.core.v3.HealthCheckOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.core.v3.HealthCheck.class, io.envoyproxy.envoy.config.core.v3.HealthCheck.Builder.class);
    }

    // Construct using io.envoyproxy.envoy.config.core.v3.HealthCheck.newBuilder()
    private Builder() {

    }

    private Builder(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);

    }
    @java.lang.Override
    public Builder clear() {
      super.clear();
      bitField0_ = 0;
      timeout_ = null;
      if (timeoutBuilder_ != null) {
        timeoutBuilder_.dispose();
        timeoutBuilder_ = null;
      }
      interval_ = null;
      if (intervalBuilder_ != null) {
        intervalBuilder_.dispose();
        intervalBuilder_ = null;
      }
      initialJitter_ = null;
      if (initialJitterBuilder_ != null) {
        initialJitterBuilder_.dispose();
        initialJitterBuilder_ = null;
      }
      intervalJitter_ = null;
      if (intervalJitterBuilder_ != null) {
        intervalJitterBuilder_.dispose();
        intervalJitterBuilder_ = null;
      }
      intervalJitterPercent_ = 0;
      unhealthyThreshold_ = null;
      if (unhealthyThresholdBuilder_ != null) {
        unhealthyThresholdBuilder_.dispose();
        unhealthyThresholdBuilder_ = null;
      }
      healthyThreshold_ = null;
      if (healthyThresholdBuilder_ != null) {
        healthyThresholdBuilder_.dispose();
        healthyThresholdBuilder_ = null;
      }
      altPort_ = null;
      if (altPortBuilder_ != null) {
        altPortBuilder_.dispose();
        altPortBuilder_ = null;
      }
      reuseConnection_ = null;
      if (reuseConnectionBuilder_ != null) {
        reuseConnectionBuilder_.dispose();
        reuseConnectionBuilder_ = null;
      }
      if (httpHealthCheckBuilder_ != null) {
        httpHealthCheckBuilder_.clear();
      }
      if (tcpHealthCheckBuilder_ != null) {
        tcpHealthCheckBuilder_.clear();
      }
      if (grpcHealthCheckBuilder_ != null) {
        grpcHealthCheckBuilder_.clear();
      }
      if (customHealthCheckBuilder_ != null) {
        customHealthCheckBuilder_.clear();
      }
      noTrafficInterval_ = null;
      if (noTrafficIntervalBuilder_ != null) {
        noTrafficIntervalBuilder_.dispose();
        noTrafficIntervalBuilder_ = null;
      }
      noTrafficHealthyInterval_ = null;
      if (noTrafficHealthyIntervalBuilder_ != null) {
        noTrafficHealthyIntervalBuilder_.dispose();
        noTrafficHealthyIntervalBuilder_ = null;
      }
      unhealthyInterval_ = null;
      if (unhealthyIntervalBuilder_ != null) {
        unhealthyIntervalBuilder_.dispose();
        unhealthyIntervalBuilder_ = null;
      }
      unhealthyEdgeInterval_ = null;
      if (unhealthyEdgeIntervalBuilder_ != null) {
        unhealthyEdgeIntervalBuilder_.dispose();
        unhealthyEdgeIntervalBuilder_ = null;
      }
      healthyEdgeInterval_ = null;
      if (healthyEdgeIntervalBuilder_ != null) {
        healthyEdgeIntervalBuilder_.dispose();
        healthyEdgeIntervalBuilder_ = null;
      }
      eventLogPath_ = "";
      eventService_ = null;
      if (eventServiceBuilder_ != null) {
        eventServiceBuilder_.dispose();
        eventServiceBuilder_ = null;
      }
      alwaysLogHealthCheckFailures_ = false;
      tlsOptions_ = null;
      if (tlsOptionsBuilder_ != null) {
        tlsOptionsBuilder_.dispose();
        tlsOptionsBuilder_ = null;
      }
      transportSocketMatchCriteria_ = null;
      if (transportSocketMatchCriteriaBuilder_ != null) {
        transportSocketMatchCriteriaBuilder_.dispose();
        transportSocketMatchCriteriaBuilder_ = null;
      }
      healthCheckerCase_ = 0;
      healthChecker_ = null;
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return io.envoyproxy.envoy.config.core.v3.HealthCheckProto.internal_static_envoy_config_core_v3_HealthCheck_descriptor;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck getDefaultInstanceForType() {
      return io.envoyproxy.envoy.config.core.v3.HealthCheck.getDefaultInstance();
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck build() {
      io.envoyproxy.envoy.config.core.v3.HealthCheck result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck buildPartial() {
      io.envoyproxy.envoy.config.core.v3.HealthCheck result = new io.envoyproxy.envoy.config.core.v3.HealthCheck(this);
      if (bitField0_ != 0) { buildPartial0(result); }
      buildPartialOneofs(result);
      onBuilt();
      return result;
    }

    private void buildPartial0(io.envoyproxy.envoy.config.core.v3.HealthCheck result) {
      int from_bitField0_ = bitField0_;
      if (((from_bitField0_ & 0x00000001) != 0)) {
        result.timeout_ = timeoutBuilder_ == null
            ? timeout_
            : timeoutBuilder_.build();
      }
      if (((from_bitField0_ & 0x00000002) != 0)) {
        result.interval_ = intervalBuilder_ == null
            ? interval_
            : intervalBuilder_.build();
      }
      if (((from_bitField0_ & 0x00000004) != 0)) {
        result.initialJitter_ = initialJitterBuilder_ == null
            ? initialJitter_
            : initialJitterBuilder_.build();
      }
      if (((from_bitField0_ & 0x00000008) != 0)) {
        result.intervalJitter_ = intervalJitterBuilder_ == null
            ? intervalJitter_
            : intervalJitterBuilder_.build();
      }
      if (((from_bitField0_ & 0x00000010) != 0)) {
        result.intervalJitterPercent_ = intervalJitterPercent_;
      }
      if (((from_bitField0_ & 0x00000020) != 0)) {
        result.unhealthyThreshold_ = unhealthyThresholdBuilder_ == null
            ? unhealthyThreshold_
            : unhealthyThresholdBuilder_.build();
      }
      if (((from_bitField0_ & 0x00000040) != 0)) {
        result.healthyThreshold_ = healthyThresholdBuilder_ == null
            ? healthyThreshold_
            : healthyThresholdBuilder_.build();
      }
      if (((from_bitField0_ & 0x00000080) != 0)) {
        result.altPort_ = altPortBuilder_ == null
            ? altPort_
            : altPortBuilder_.build();
      }
      if (((from_bitField0_ & 0x00000100) != 0)) {
        result.reuseConnection_ = reuseConnectionBuilder_ == null
            ? reuseConnection_
            : reuseConnectionBuilder_.build();
      }
      if (((from_bitField0_ & 0x00002000) != 0)) {
        result.noTrafficInterval_ = noTrafficIntervalBuilder_ == null
            ? noTrafficInterval_
            : noTrafficIntervalBuilder_.build();
      }
      if (((from_bitField0_ & 0x00004000) != 0)) {
        result.noTrafficHealthyInterval_ = noTrafficHealthyIntervalBuilder_ == null
            ? noTrafficHealthyInterval_
            : noTrafficHealthyIntervalBuilder_.build();
      }
      if (((from_bitField0_ & 0x00008000) != 0)) {
        result.unhealthyInterval_ = unhealthyIntervalBuilder_ == null
            ? unhealthyInterval_
            : unhealthyIntervalBuilder_.build();
      }
      if (((from_bitField0_ & 0x00010000) != 0)) {
        result.unhealthyEdgeInterval_ = unhealthyEdgeIntervalBuilder_ == null
            ? unhealthyEdgeInterval_
            : unhealthyEdgeIntervalBuilder_.build();
      }
      if (((from_bitField0_ & 0x00020000) != 0)) {
        result.healthyEdgeInterval_ = healthyEdgeIntervalBuilder_ == null
            ? healthyEdgeInterval_
            : healthyEdgeIntervalBuilder_.build();
      }
      if (((from_bitField0_ & 0x00040000) != 0)) {
        result.eventLogPath_ = eventLogPath_;
      }
      if (((from_bitField0_ & 0x00080000) != 0)) {
        result.eventService_ = eventServiceBuilder_ == null
            ? eventService_
            : eventServiceBuilder_.build();
      }
      if (((from_bitField0_ & 0x00100000) != 0)) {
        result.alwaysLogHealthCheckFailures_ = alwaysLogHealthCheckFailures_;
      }
      if (((from_bitField0_ & 0x00200000) != 0)) {
        result.tlsOptions_ = tlsOptionsBuilder_ == null
            ? tlsOptions_
            : tlsOptionsBuilder_.build();
      }
      if (((from_bitField0_ & 0x00400000) != 0)) {
        result.transportSocketMatchCriteria_ = transportSocketMatchCriteriaBuilder_ == null
            ? transportSocketMatchCriteria_
            : transportSocketMatchCriteriaBuilder_.build();
      }
    }

    private void buildPartialOneofs(io.envoyproxy.envoy.config.core.v3.HealthCheck result) {
      result.healthCheckerCase_ = healthCheckerCase_;
      result.healthChecker_ = this.healthChecker_;
      if (healthCheckerCase_ == 8 &&
          httpHealthCheckBuilder_ != null) {
        result.healthChecker_ = httpHealthCheckBuilder_.build();
      }
      if (healthCheckerCase_ == 9 &&
          tcpHealthCheckBuilder_ != null) {
        result.healthChecker_ = tcpHealthCheckBuilder_.build();
      }
      if (healthCheckerCase_ == 11 &&
          grpcHealthCheckBuilder_ != null) {
        result.healthChecker_ = grpcHealthCheckBuilder_.build();
      }
      if (healthCheckerCase_ == 13 &&
          customHealthCheckBuilder_ != null) {
        result.healthChecker_ = customHealthCheckBuilder_.build();
      }
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }
    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.setField(field, value);
    }
    @java.lang.Override
    public Builder clearField(
        com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }
    @java.lang.Override
    public Builder clearOneof(
        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }
    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }
    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }
    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof io.envoyproxy.envoy.config.core.v3.HealthCheck) {
        return mergeFrom((io.envoyproxy.envoy.config.core.v3.HealthCheck)other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(io.envoyproxy.envoy.config.core.v3.HealthCheck other) {
      if (other == io.envoyproxy.envoy.config.core.v3.HealthCheck.getDefaultInstance()) return this;
      if (other.hasTimeout()) {
        mergeTimeout(other.getTimeout());
      }
      if (other.hasInterval()) {
        mergeInterval(other.getInterval());
      }
      if (other.hasInitialJitter()) {
        mergeInitialJitter(other.getInitialJitter());
      }
      if (other.hasIntervalJitter()) {
        mergeIntervalJitter(other.getIntervalJitter());
      }
      if (other.getIntervalJitterPercent() != 0) {
        setIntervalJitterPercent(other.getIntervalJitterPercent());
      }
      if (other.hasUnhealthyThreshold()) {
        mergeUnhealthyThreshold(other.getUnhealthyThreshold());
      }
      if (other.hasHealthyThreshold()) {
        mergeHealthyThreshold(other.getHealthyThreshold());
      }
      if (other.hasAltPort()) {
        mergeAltPort(other.getAltPort());
      }
      if (other.hasReuseConnection()) {
        mergeReuseConnection(other.getReuseConnection());
      }
      if (other.hasNoTrafficInterval()) {
        mergeNoTrafficInterval(other.getNoTrafficInterval());
      }
      if (other.hasNoTrafficHealthyInterval()) {
        mergeNoTrafficHealthyInterval(other.getNoTrafficHealthyInterval());
      }
      if (other.hasUnhealthyInterval()) {
        mergeUnhealthyInterval(other.getUnhealthyInterval());
      }
      if (other.hasUnhealthyEdgeInterval()) {
        mergeUnhealthyEdgeInterval(other.getUnhealthyEdgeInterval());
      }
      if (other.hasHealthyEdgeInterval()) {
        mergeHealthyEdgeInterval(other.getHealthyEdgeInterval());
      }
      if (!other.getEventLogPath().isEmpty()) {
        eventLogPath_ = other.eventLogPath_;
        bitField0_ |= 0x00040000;
        onChanged();
      }
      if (other.hasEventService()) {
        mergeEventService(other.getEventService());
      }
      if (other.getAlwaysLogHealthCheckFailures() != false) {
        setAlwaysLogHealthCheckFailures(other.getAlwaysLogHealthCheckFailures());
      }
      if (other.hasTlsOptions()) {
        mergeTlsOptions(other.getTlsOptions());
      }
      if (other.hasTransportSocketMatchCriteria()) {
        mergeTransportSocketMatchCriteria(other.getTransportSocketMatchCriteria());
      }
      switch (other.getHealthCheckerCase()) {
        case HTTP_HEALTH_CHECK: {
          mergeHttpHealthCheck(other.getHttpHealthCheck());
          break;
        }
        case TCP_HEALTH_CHECK: {
          mergeTcpHealthCheck(other.getTcpHealthCheck());
          break;
        }
        case GRPC_HEALTH_CHECK: {
          mergeGrpcHealthCheck(other.getGrpcHealthCheck());
          break;
        }
        case CUSTOM_HEALTH_CHECK: {
          mergeCustomHealthCheck(other.getCustomHealthCheck());
          break;
        }
        case HEALTHCHECKER_NOT_SET: {
          break;
        }
      }
      this.mergeUnknownFields(other.getUnknownFields());
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              input.readMessage(
                  getTimeoutFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000001;
              break;
            } // case 10
            case 18: {
              input.readMessage(
                  getIntervalFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000002;
              break;
            } // case 18
            case 26: {
              input.readMessage(
                  getIntervalJitterFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000008;
              break;
            } // case 26
            case 34: {
              input.readMessage(
                  getUnhealthyThresholdFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000020;
              break;
            } // case 34
            case 42: {
              input.readMessage(
                  getHealthyThresholdFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000040;
              break;
            } // case 42
            case 50: {
              input.readMessage(
                  getAltPortFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000080;
              break;
            } // case 50
            case 58: {
              input.readMessage(
                  getReuseConnectionFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000100;
              break;
            } // case 58
            case 66: {
              input.readMessage(
                  getHttpHealthCheckFieldBuilder().getBuilder(),
                  extensionRegistry);
              healthCheckerCase_ = 8;
              break;
            } // case 66
            case 74: {
              input.readMessage(
                  getTcpHealthCheckFieldBuilder().getBuilder(),
                  extensionRegistry);
              healthCheckerCase_ = 9;
              break;
            } // case 74
            case 90: {
              input.readMessage(
                  getGrpcHealthCheckFieldBuilder().getBuilder(),
                  extensionRegistry);
              healthCheckerCase_ = 11;
              break;
            } // case 90
            case 98: {
              input.readMessage(
                  getNoTrafficIntervalFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00002000;
              break;
            } // case 98
            case 106: {
              input.readMessage(
                  getCustomHealthCheckFieldBuilder().getBuilder(),
                  extensionRegistry);
              healthCheckerCase_ = 13;
              break;
            } // case 106
            case 114: {
              input.readMessage(
                  getUnhealthyIntervalFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00008000;
              break;
            } // case 114
            case 122: {
              input.readMessage(
                  getUnhealthyEdgeIntervalFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00010000;
              break;
            } // case 122
            case 130: {
              input.readMessage(
                  getHealthyEdgeIntervalFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00020000;
              break;
            } // case 130
            case 138: {
              eventLogPath_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00040000;
              break;
            } // case 138
            case 144: {
              intervalJitterPercent_ = input.readUInt32();
              bitField0_ |= 0x00000010;
              break;
            } // case 144
            case 152: {
              alwaysLogHealthCheckFailures_ = input.readBool();
              bitField0_ |= 0x00100000;
              break;
            } // case 152
            case 162: {
              input.readMessage(
                  getInitialJitterFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000004;
              break;
            } // case 162
            case 170: {
              input.readMessage(
                  getTlsOptionsFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00200000;
              break;
            } // case 170
            case 178: {
              input.readMessage(
                  getEventServiceFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00080000;
              break;
            } // case 178
            case 186: {
              input.readMessage(
                  getTransportSocketMatchCriteriaFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00400000;
              break;
            } // case 186
            case 194: {
              input.readMessage(
                  getNoTrafficHealthyIntervalFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00004000;
              break;
            } // case 194
            default: {
              if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                done = true; // was an endgroup tag
              }
              break;
            } // default:
          } // switch (tag)
        } // while (!done)
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.unwrapIOException();
      } finally {
        onChanged();
      } // finally
      return this;
    }
    private int healthCheckerCase_ = 0;
    private java.lang.Object healthChecker_;
    public HealthCheckerCase
        getHealthCheckerCase() {
      return HealthCheckerCase.forNumber(
          healthCheckerCase_);
    }

    public Builder clearHealthChecker() {
      healthCheckerCase_ = 0;
      healthChecker_ = null;
      onChanged();
      return this;
    }

    private int bitField0_;

    private com.google.protobuf.Duration timeout_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> timeoutBuilder_;
    /**
     * <pre>
     * The time to wait for a health check response. If the timeout is reached the
     * health check attempt will be considered a failure.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 1 [(.validate.rules) = { ... }</code>
     * @return Whether the timeout field is set.
     */
    public boolean hasTimeout() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The time to wait for a health check response. If the timeout is reached the
     * health check attempt will be considered a failure.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 1 [(.validate.rules) = { ... }</code>
     * @return The timeout.
     */
    public com.google.protobuf.Duration getTimeout() {
      if (timeoutBuilder_ == null) {
        return timeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : timeout_;
      } else {
        return timeoutBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The time to wait for a health check response. If the timeout is reached the
     * health check attempt will be considered a failure.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 1 [(.validate.rules) = { ... }</code>
     */
    public Builder setTimeout(com.google.protobuf.Duration value) {
      if (timeoutBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        timeout_ = value;
      } else {
        timeoutBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000001;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The time to wait for a health check response. If the timeout is reached the
     * health check attempt will be considered a failure.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 1 [(.validate.rules) = { ... }</code>
     */
    public Builder setTimeout(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (timeoutBuilder_ == null) {
        timeout_ = builderForValue.build();
      } else {
        timeoutBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000001;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The time to wait for a health check response. If the timeout is reached the
     * health check attempt will be considered a failure.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 1 [(.validate.rules) = { ... }</code>
     */
    public Builder mergeTimeout(com.google.protobuf.Duration value) {
      if (timeoutBuilder_ == null) {
        if (((bitField0_ & 0x00000001) != 0) &&
          timeout_ != null &&
          timeout_ != com.google.protobuf.Duration.getDefaultInstance()) {
          getTimeoutBuilder().mergeFrom(value);
        } else {
          timeout_ = value;
        }
      } else {
        timeoutBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000001;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The time to wait for a health check response. If the timeout is reached the
     * health check attempt will be considered a failure.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 1 [(.validate.rules) = { ... }</code>
     */
    public Builder clearTimeout() {
      bitField0_ = (bitField0_ & ~0x00000001);
      timeout_ = null;
      if (timeoutBuilder_ != null) {
        timeoutBuilder_.dispose();
        timeoutBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The time to wait for a health check response. If the timeout is reached the
     * health check attempt will be considered a failure.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 1 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.Duration.Builder getTimeoutBuilder() {
      bitField0_ |= 0x00000001;
      onChanged();
      return getTimeoutFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The time to wait for a health check response. If the timeout is reached the
     * health check attempt will be considered a failure.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 1 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.DurationOrBuilder getTimeoutOrBuilder() {
      if (timeoutBuilder_ != null) {
        return timeoutBuilder_.getMessageOrBuilder();
      } else {
        return timeout_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : timeout_;
      }
    }
    /**
     * <pre>
     * The time to wait for a health check response. If the timeout is reached the
     * health check attempt will be considered a failure.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 1 [(.validate.rules) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getTimeoutFieldBuilder() {
      if (timeoutBuilder_ == null) {
        timeoutBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getTimeout(),
                getParentForChildren(),
                isClean());
        timeout_ = null;
      }
      return timeoutBuilder_;
    }

    private com.google.protobuf.Duration interval_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> intervalBuilder_;
    /**
     * <pre>
     * The interval between health checks.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval = 2 [(.validate.rules) = { ... }</code>
     * @return Whether the interval field is set.
     */
    public boolean hasInterval() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The interval between health checks.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval = 2 [(.validate.rules) = { ... }</code>
     * @return The interval.
     */
    public com.google.protobuf.Duration getInterval() {
      if (intervalBuilder_ == null) {
        return interval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : interval_;
      } else {
        return intervalBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The interval between health checks.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval = 2 [(.validate.rules) = { ... }</code>
     */
    public Builder setInterval(com.google.protobuf.Duration value) {
      if (intervalBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        interval_ = value;
      } else {
        intervalBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000002;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The interval between health checks.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval = 2 [(.validate.rules) = { ... }</code>
     */
    public Builder setInterval(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (intervalBuilder_ == null) {
        interval_ = builderForValue.build();
      } else {
        intervalBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000002;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The interval between health checks.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval = 2 [(.validate.rules) = { ... }</code>
     */
    public Builder mergeInterval(com.google.protobuf.Duration value) {
      if (intervalBuilder_ == null) {
        if (((bitField0_ & 0x00000002) != 0) &&
          interval_ != null &&
          interval_ != com.google.protobuf.Duration.getDefaultInstance()) {
          getIntervalBuilder().mergeFrom(value);
        } else {
          interval_ = value;
        }
      } else {
        intervalBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000002;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The interval between health checks.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval = 2 [(.validate.rules) = { ... }</code>
     */
    public Builder clearInterval() {
      bitField0_ = (bitField0_ & ~0x00000002);
      interval_ = null;
      if (intervalBuilder_ != null) {
        intervalBuilder_.dispose();
        intervalBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The interval between health checks.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval = 2 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.Duration.Builder getIntervalBuilder() {
      bitField0_ |= 0x00000002;
      onChanged();
      return getIntervalFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The interval between health checks.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval = 2 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.DurationOrBuilder getIntervalOrBuilder() {
      if (intervalBuilder_ != null) {
        return intervalBuilder_.getMessageOrBuilder();
      } else {
        return interval_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : interval_;
      }
    }
    /**
     * <pre>
     * The interval between health checks.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval = 2 [(.validate.rules) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getIntervalFieldBuilder() {
      if (intervalBuilder_ == null) {
        intervalBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getInterval(),
                getParentForChildren(),
                isClean());
        interval_ = null;
      }
      return intervalBuilder_;
    }

    private com.google.protobuf.Duration initialJitter_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> initialJitterBuilder_;
    /**
     * <pre>
     * An optional jitter amount in milliseconds. If specified, Envoy will start health
     * checking after for a random time in ms between 0 and initial_jitter. This only
     * applies to the first health check.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_jitter = 20;</code>
     * @return Whether the initialJitter field is set.
     */
    public boolean hasInitialJitter() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * An optional jitter amount in milliseconds. If specified, Envoy will start health
     * checking after for a random time in ms between 0 and initial_jitter. This only
     * applies to the first health check.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_jitter = 20;</code>
     * @return The initialJitter.
     */
    public com.google.protobuf.Duration getInitialJitter() {
      if (initialJitterBuilder_ == null) {
        return initialJitter_ == null ? com.google.protobuf.Duration.getDefaultInstance() : initialJitter_;
      } else {
        return initialJitterBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * An optional jitter amount in milliseconds. If specified, Envoy will start health
     * checking after for a random time in ms between 0 and initial_jitter. This only
     * applies to the first health check.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_jitter = 20;</code>
     */
    public Builder setInitialJitter(com.google.protobuf.Duration value) {
      if (initialJitterBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        initialJitter_ = value;
      } else {
        initialJitterBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000004;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * An optional jitter amount in milliseconds. If specified, Envoy will start health
     * checking after for a random time in ms between 0 and initial_jitter. This only
     * applies to the first health check.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_jitter = 20;</code>
     */
    public Builder setInitialJitter(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (initialJitterBuilder_ == null) {
        initialJitter_ = builderForValue.build();
      } else {
        initialJitterBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000004;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * An optional jitter amount in milliseconds. If specified, Envoy will start health
     * checking after for a random time in ms between 0 and initial_jitter. This only
     * applies to the first health check.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_jitter = 20;</code>
     */
    public Builder mergeInitialJitter(com.google.protobuf.Duration value) {
      if (initialJitterBuilder_ == null) {
        if (((bitField0_ & 0x00000004) != 0) &&
          initialJitter_ != null &&
          initialJitter_ != com.google.protobuf.Duration.getDefaultInstance()) {
          getInitialJitterBuilder().mergeFrom(value);
        } else {
          initialJitter_ = value;
        }
      } else {
        initialJitterBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000004;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * An optional jitter amount in milliseconds. If specified, Envoy will start health
     * checking after for a random time in ms between 0 and initial_jitter. This only
     * applies to the first health check.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_jitter = 20;</code>
     */
    public Builder clearInitialJitter() {
      bitField0_ = (bitField0_ & ~0x00000004);
      initialJitter_ = null;
      if (initialJitterBuilder_ != null) {
        initialJitterBuilder_.dispose();
        initialJitterBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * An optional jitter amount in milliseconds. If specified, Envoy will start health
     * checking after for a random time in ms between 0 and initial_jitter. This only
     * applies to the first health check.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_jitter = 20;</code>
     */
    public com.google.protobuf.Duration.Builder getInitialJitterBuilder() {
      bitField0_ |= 0x00000004;
      onChanged();
      return getInitialJitterFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * An optional jitter amount in milliseconds. If specified, Envoy will start health
     * checking after for a random time in ms between 0 and initial_jitter. This only
     * applies to the first health check.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_jitter = 20;</code>
     */
    public com.google.protobuf.DurationOrBuilder getInitialJitterOrBuilder() {
      if (initialJitterBuilder_ != null) {
        return initialJitterBuilder_.getMessageOrBuilder();
      } else {
        return initialJitter_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : initialJitter_;
      }
    }
    /**
     * <pre>
     * An optional jitter amount in milliseconds. If specified, Envoy will start health
     * checking after for a random time in ms between 0 and initial_jitter. This only
     * applies to the first health check.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_jitter = 20;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getInitialJitterFieldBuilder() {
      if (initialJitterBuilder_ == null) {
        initialJitterBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getInitialJitter(),
                getParentForChildren(),
                isClean());
        initialJitter_ = null;
      }
      return initialJitterBuilder_;
    }

    private com.google.protobuf.Duration intervalJitter_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> intervalJitterBuilder_;
    /**
     * <pre>
     * An optional jitter amount in milliseconds. If specified, during every
     * interval Envoy will add interval_jitter to the wait time.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval_jitter = 3;</code>
     * @return Whether the intervalJitter field is set.
     */
    public boolean hasIntervalJitter() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * An optional jitter amount in milliseconds. If specified, during every
     * interval Envoy will add interval_jitter to the wait time.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval_jitter = 3;</code>
     * @return The intervalJitter.
     */
    public com.google.protobuf.Duration getIntervalJitter() {
      if (intervalJitterBuilder_ == null) {
        return intervalJitter_ == null ? com.google.protobuf.Duration.getDefaultInstance() : intervalJitter_;
      } else {
        return intervalJitterBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * An optional jitter amount in milliseconds. If specified, during every
     * interval Envoy will add interval_jitter to the wait time.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval_jitter = 3;</code>
     */
    public Builder setIntervalJitter(com.google.protobuf.Duration value) {
      if (intervalJitterBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        intervalJitter_ = value;
      } else {
        intervalJitterBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000008;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * An optional jitter amount in milliseconds. If specified, during every
     * interval Envoy will add interval_jitter to the wait time.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval_jitter = 3;</code>
     */
    public Builder setIntervalJitter(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (intervalJitterBuilder_ == null) {
        intervalJitter_ = builderForValue.build();
      } else {
        intervalJitterBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000008;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * An optional jitter amount in milliseconds. If specified, during every
     * interval Envoy will add interval_jitter to the wait time.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval_jitter = 3;</code>
     */
    public Builder mergeIntervalJitter(com.google.protobuf.Duration value) {
      if (intervalJitterBuilder_ == null) {
        if (((bitField0_ & 0x00000008) != 0) &&
          intervalJitter_ != null &&
          intervalJitter_ != com.google.protobuf.Duration.getDefaultInstance()) {
          getIntervalJitterBuilder().mergeFrom(value);
        } else {
          intervalJitter_ = value;
        }
      } else {
        intervalJitterBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000008;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * An optional jitter amount in milliseconds. If specified, during every
     * interval Envoy will add interval_jitter to the wait time.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval_jitter = 3;</code>
     */
    public Builder clearIntervalJitter() {
      bitField0_ = (bitField0_ & ~0x00000008);
      intervalJitter_ = null;
      if (intervalJitterBuilder_ != null) {
        intervalJitterBuilder_.dispose();
        intervalJitterBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * An optional jitter amount in milliseconds. If specified, during every
     * interval Envoy will add interval_jitter to the wait time.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval_jitter = 3;</code>
     */
    public com.google.protobuf.Duration.Builder getIntervalJitterBuilder() {
      bitField0_ |= 0x00000008;
      onChanged();
      return getIntervalJitterFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * An optional jitter amount in milliseconds. If specified, during every
     * interval Envoy will add interval_jitter to the wait time.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval_jitter = 3;</code>
     */
    public com.google.protobuf.DurationOrBuilder getIntervalJitterOrBuilder() {
      if (intervalJitterBuilder_ != null) {
        return intervalJitterBuilder_.getMessageOrBuilder();
      } else {
        return intervalJitter_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : intervalJitter_;
      }
    }
    /**
     * <pre>
     * An optional jitter amount in milliseconds. If specified, during every
     * interval Envoy will add interval_jitter to the wait time.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval_jitter = 3;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getIntervalJitterFieldBuilder() {
      if (intervalJitterBuilder_ == null) {
        intervalJitterBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getIntervalJitter(),
                getParentForChildren(),
                isClean());
        intervalJitter_ = null;
      }
      return intervalJitterBuilder_;
    }

    private int intervalJitterPercent_ ;
    /**
     * <pre>
     * An optional jitter amount as a percentage of interval_ms. If specified,
     * during every interval Envoy will add ``interval_ms`` *
     * ``interval_jitter_percent`` / 100 to the wait time.
     * If interval_jitter_ms and interval_jitter_percent are both set, both of
     * them will be used to increase the wait time.
     * </pre>
     *
     * <code>uint32 interval_jitter_percent = 18;</code>
     * @return The intervalJitterPercent.
     */
    @java.lang.Override
    public int getIntervalJitterPercent() {
      return intervalJitterPercent_;
    }
    /**
     * <pre>
     * An optional jitter amount as a percentage of interval_ms. If specified,
     * during every interval Envoy will add ``interval_ms`` *
     * ``interval_jitter_percent`` / 100 to the wait time.
     * If interval_jitter_ms and interval_jitter_percent are both set, both of
     * them will be used to increase the wait time.
     * </pre>
     *
     * <code>uint32 interval_jitter_percent = 18;</code>
     * @param value The intervalJitterPercent to set.
     * @return This builder for chaining.
     */
    public Builder setIntervalJitterPercent(int value) {
      
      intervalJitterPercent_ = value;
      bitField0_ |= 0x00000010;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * An optional jitter amount as a percentage of interval_ms. If specified,
     * during every interval Envoy will add ``interval_ms`` *
     * ``interval_jitter_percent`` / 100 to the wait time.
     * If interval_jitter_ms and interval_jitter_percent are both set, both of
     * them will be used to increase the wait time.
     * </pre>
     *
     * <code>uint32 interval_jitter_percent = 18;</code>
     * @return This builder for chaining.
     */
    public Builder clearIntervalJitterPercent() {
      bitField0_ = (bitField0_ & ~0x00000010);
      intervalJitterPercent_ = 0;
      onChanged();
      return this;
    }

    private com.google.protobuf.UInt32Value unhealthyThreshold_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> unhealthyThresholdBuilder_;
    /**
     * <pre>
     * The number of unhealthy health checks required before a host is marked
     * unhealthy. Note that for ``http`` health checking if a host responds with a code not in
     * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
     * or :ref:`retriable_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.retriable_statuses&gt;`,
     * this threshold is ignored and the host is considered immediately unhealthy.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value unhealthy_threshold = 4 [(.validate.rules) = { ... }</code>
     * @return Whether the unhealthyThreshold field is set.
     */
    public boolean hasUnhealthyThreshold() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * The number of unhealthy health checks required before a host is marked
     * unhealthy. Note that for ``http`` health checking if a host responds with a code not in
     * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
     * or :ref:`retriable_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.retriable_statuses&gt;`,
     * this threshold is ignored and the host is considered immediately unhealthy.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value unhealthy_threshold = 4 [(.validate.rules) = { ... }</code>
     * @return The unhealthyThreshold.
     */
    public com.google.protobuf.UInt32Value getUnhealthyThreshold() {
      if (unhealthyThresholdBuilder_ == null) {
        return unhealthyThreshold_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : unhealthyThreshold_;
      } else {
        return unhealthyThresholdBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The number of unhealthy health checks required before a host is marked
     * unhealthy. Note that for ``http`` health checking if a host responds with a code not in
     * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
     * or :ref:`retriable_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.retriable_statuses&gt;`,
     * this threshold is ignored and the host is considered immediately unhealthy.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value unhealthy_threshold = 4 [(.validate.rules) = { ... }</code>
     */
    public Builder setUnhealthyThreshold(com.google.protobuf.UInt32Value value) {
      if (unhealthyThresholdBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        unhealthyThreshold_ = value;
      } else {
        unhealthyThresholdBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000020;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The number of unhealthy health checks required before a host is marked
     * unhealthy. Note that for ``http`` health checking if a host responds with a code not in
     * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
     * or :ref:`retriable_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.retriable_statuses&gt;`,
     * this threshold is ignored and the host is considered immediately unhealthy.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value unhealthy_threshold = 4 [(.validate.rules) = { ... }</code>
     */
    public Builder setUnhealthyThreshold(
        com.google.protobuf.UInt32Value.Builder builderForValue) {
      if (unhealthyThresholdBuilder_ == null) {
        unhealthyThreshold_ = builderForValue.build();
      } else {
        unhealthyThresholdBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000020;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The number of unhealthy health checks required before a host is marked
     * unhealthy. Note that for ``http`` health checking if a host responds with a code not in
     * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
     * or :ref:`retriable_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.retriable_statuses&gt;`,
     * this threshold is ignored and the host is considered immediately unhealthy.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value unhealthy_threshold = 4 [(.validate.rules) = { ... }</code>
     */
    public Builder mergeUnhealthyThreshold(com.google.protobuf.UInt32Value value) {
      if (unhealthyThresholdBuilder_ == null) {
        if (((bitField0_ & 0x00000020) != 0) &&
          unhealthyThreshold_ != null &&
          unhealthyThreshold_ != com.google.protobuf.UInt32Value.getDefaultInstance()) {
          getUnhealthyThresholdBuilder().mergeFrom(value);
        } else {
          unhealthyThreshold_ = value;
        }
      } else {
        unhealthyThresholdBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000020;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The number of unhealthy health checks required before a host is marked
     * unhealthy. Note that for ``http`` health checking if a host responds with a code not in
     * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
     * or :ref:`retriable_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.retriable_statuses&gt;`,
     * this threshold is ignored and the host is considered immediately unhealthy.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value unhealthy_threshold = 4 [(.validate.rules) = { ... }</code>
     */
    public Builder clearUnhealthyThreshold() {
      bitField0_ = (bitField0_ & ~0x00000020);
      unhealthyThreshold_ = null;
      if (unhealthyThresholdBuilder_ != null) {
        unhealthyThresholdBuilder_.dispose();
        unhealthyThresholdBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The number of unhealthy health checks required before a host is marked
     * unhealthy. Note that for ``http`` health checking if a host responds with a code not in
     * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
     * or :ref:`retriable_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.retriable_statuses&gt;`,
     * this threshold is ignored and the host is considered immediately unhealthy.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value unhealthy_threshold = 4 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.UInt32Value.Builder getUnhealthyThresholdBuilder() {
      bitField0_ |= 0x00000020;
      onChanged();
      return getUnhealthyThresholdFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The number of unhealthy health checks required before a host is marked
     * unhealthy. Note that for ``http`` health checking if a host responds with a code not in
     * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
     * or :ref:`retriable_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.retriable_statuses&gt;`,
     * this threshold is ignored and the host is considered immediately unhealthy.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value unhealthy_threshold = 4 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.UInt32ValueOrBuilder getUnhealthyThresholdOrBuilder() {
      if (unhealthyThresholdBuilder_ != null) {
        return unhealthyThresholdBuilder_.getMessageOrBuilder();
      } else {
        return unhealthyThreshold_ == null ?
            com.google.protobuf.UInt32Value.getDefaultInstance() : unhealthyThreshold_;
      }
    }
    /**
     * <pre>
     * The number of unhealthy health checks required before a host is marked
     * unhealthy. Note that for ``http`` health checking if a host responds with a code not in
     * :ref:`expected_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses&gt;`
     * or :ref:`retriable_statuses &lt;envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.retriable_statuses&gt;`,
     * this threshold is ignored and the host is considered immediately unhealthy.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value unhealthy_threshold = 4 [(.validate.rules) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
        getUnhealthyThresholdFieldBuilder() {
      if (unhealthyThresholdBuilder_ == null) {
        unhealthyThresholdBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                getUnhealthyThreshold(),
                getParentForChildren(),
                isClean());
        unhealthyThreshold_ = null;
      }
      return unhealthyThresholdBuilder_;
    }

    private com.google.protobuf.UInt32Value healthyThreshold_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> healthyThresholdBuilder_;
    /**
     * <pre>
     * The number of healthy health checks required before a host is marked
     * healthy. Note that during startup, only a single successful health check is
     * required to mark a host healthy.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value healthy_threshold = 5 [(.validate.rules) = { ... }</code>
     * @return Whether the healthyThreshold field is set.
     */
    public boolean hasHealthyThreshold() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * The number of healthy health checks required before a host is marked
     * healthy. Note that during startup, only a single successful health check is
     * required to mark a host healthy.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value healthy_threshold = 5 [(.validate.rules) = { ... }</code>
     * @return The healthyThreshold.
     */
    public com.google.protobuf.UInt32Value getHealthyThreshold() {
      if (healthyThresholdBuilder_ == null) {
        return healthyThreshold_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : healthyThreshold_;
      } else {
        return healthyThresholdBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The number of healthy health checks required before a host is marked
     * healthy. Note that during startup, only a single successful health check is
     * required to mark a host healthy.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value healthy_threshold = 5 [(.validate.rules) = { ... }</code>
     */
    public Builder setHealthyThreshold(com.google.protobuf.UInt32Value value) {
      if (healthyThresholdBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        healthyThreshold_ = value;
      } else {
        healthyThresholdBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000040;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The number of healthy health checks required before a host is marked
     * healthy. Note that during startup, only a single successful health check is
     * required to mark a host healthy.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value healthy_threshold = 5 [(.validate.rules) = { ... }</code>
     */
    public Builder setHealthyThreshold(
        com.google.protobuf.UInt32Value.Builder builderForValue) {
      if (healthyThresholdBuilder_ == null) {
        healthyThreshold_ = builderForValue.build();
      } else {
        healthyThresholdBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000040;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The number of healthy health checks required before a host is marked
     * healthy. Note that during startup, only a single successful health check is
     * required to mark a host healthy.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value healthy_threshold = 5 [(.validate.rules) = { ... }</code>
     */
    public Builder mergeHealthyThreshold(com.google.protobuf.UInt32Value value) {
      if (healthyThresholdBuilder_ == null) {
        if (((bitField0_ & 0x00000040) != 0) &&
          healthyThreshold_ != null &&
          healthyThreshold_ != com.google.protobuf.UInt32Value.getDefaultInstance()) {
          getHealthyThresholdBuilder().mergeFrom(value);
        } else {
          healthyThreshold_ = value;
        }
      } else {
        healthyThresholdBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000040;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The number of healthy health checks required before a host is marked
     * healthy. Note that during startup, only a single successful health check is
     * required to mark a host healthy.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value healthy_threshold = 5 [(.validate.rules) = { ... }</code>
     */
    public Builder clearHealthyThreshold() {
      bitField0_ = (bitField0_ & ~0x00000040);
      healthyThreshold_ = null;
      if (healthyThresholdBuilder_ != null) {
        healthyThresholdBuilder_.dispose();
        healthyThresholdBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The number of healthy health checks required before a host is marked
     * healthy. Note that during startup, only a single successful health check is
     * required to mark a host healthy.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value healthy_threshold = 5 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.UInt32Value.Builder getHealthyThresholdBuilder() {
      bitField0_ |= 0x00000040;
      onChanged();
      return getHealthyThresholdFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The number of healthy health checks required before a host is marked
     * healthy. Note that during startup, only a single successful health check is
     * required to mark a host healthy.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value healthy_threshold = 5 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.UInt32ValueOrBuilder getHealthyThresholdOrBuilder() {
      if (healthyThresholdBuilder_ != null) {
        return healthyThresholdBuilder_.getMessageOrBuilder();
      } else {
        return healthyThreshold_ == null ?
            com.google.protobuf.UInt32Value.getDefaultInstance() : healthyThreshold_;
      }
    }
    /**
     * <pre>
     * The number of healthy health checks required before a host is marked
     * healthy. Note that during startup, only a single successful health check is
     * required to mark a host healthy.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value healthy_threshold = 5 [(.validate.rules) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
        getHealthyThresholdFieldBuilder() {
      if (healthyThresholdBuilder_ == null) {
        healthyThresholdBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                getHealthyThreshold(),
                getParentForChildren(),
                isClean());
        healthyThreshold_ = null;
      }
      return healthyThresholdBuilder_;
    }

    private com.google.protobuf.UInt32Value altPort_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> altPortBuilder_;
    /**
     * <pre>
     * [#not-implemented-hide:] Non-serving port for health checking.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value alt_port = 6;</code>
     * @return Whether the altPort field is set.
     */
    public boolean hasAltPort() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Non-serving port for health checking.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value alt_port = 6;</code>
     * @return The altPort.
     */
    public com.google.protobuf.UInt32Value getAltPort() {
      if (altPortBuilder_ == null) {
        return altPort_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : altPort_;
      } else {
        return altPortBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Non-serving port for health checking.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value alt_port = 6;</code>
     */
    public Builder setAltPort(com.google.protobuf.UInt32Value value) {
      if (altPortBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        altPort_ = value;
      } else {
        altPortBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000080;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Non-serving port for health checking.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value alt_port = 6;</code>
     */
    public Builder setAltPort(
        com.google.protobuf.UInt32Value.Builder builderForValue) {
      if (altPortBuilder_ == null) {
        altPort_ = builderForValue.build();
      } else {
        altPortBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000080;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Non-serving port for health checking.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value alt_port = 6;</code>
     */
    public Builder mergeAltPort(com.google.protobuf.UInt32Value value) {
      if (altPortBuilder_ == null) {
        if (((bitField0_ & 0x00000080) != 0) &&
          altPort_ != null &&
          altPort_ != com.google.protobuf.UInt32Value.getDefaultInstance()) {
          getAltPortBuilder().mergeFrom(value);
        } else {
          altPort_ = value;
        }
      } else {
        altPortBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000080;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Non-serving port for health checking.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value alt_port = 6;</code>
     */
    public Builder clearAltPort() {
      bitField0_ = (bitField0_ & ~0x00000080);
      altPort_ = null;
      if (altPortBuilder_ != null) {
        altPortBuilder_.dispose();
        altPortBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Non-serving port for health checking.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value alt_port = 6;</code>
     */
    public com.google.protobuf.UInt32Value.Builder getAltPortBuilder() {
      bitField0_ |= 0x00000080;
      onChanged();
      return getAltPortFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Non-serving port for health checking.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value alt_port = 6;</code>
     */
    public com.google.protobuf.UInt32ValueOrBuilder getAltPortOrBuilder() {
      if (altPortBuilder_ != null) {
        return altPortBuilder_.getMessageOrBuilder();
      } else {
        return altPort_ == null ?
            com.google.protobuf.UInt32Value.getDefaultInstance() : altPort_;
      }
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Non-serving port for health checking.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value alt_port = 6;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
        getAltPortFieldBuilder() {
      if (altPortBuilder_ == null) {
        altPortBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                getAltPort(),
                getParentForChildren(),
                isClean());
        altPort_ = null;
      }
      return altPortBuilder_;
    }

    private com.google.protobuf.BoolValue reuseConnection_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> reuseConnectionBuilder_;
    /**
     * <pre>
     * Reuse health check connection between health checks. Default is true.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue reuse_connection = 7;</code>
     * @return Whether the reuseConnection field is set.
     */
    public boolean hasReuseConnection() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Reuse health check connection between health checks. Default is true.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue reuse_connection = 7;</code>
     * @return The reuseConnection.
     */
    public com.google.protobuf.BoolValue getReuseConnection() {
      if (reuseConnectionBuilder_ == null) {
        return reuseConnection_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : reuseConnection_;
      } else {
        return reuseConnectionBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Reuse health check connection between health checks. Default is true.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue reuse_connection = 7;</code>
     */
    public Builder setReuseConnection(com.google.protobuf.BoolValue value) {
      if (reuseConnectionBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        reuseConnection_ = value;
      } else {
        reuseConnectionBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000100;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Reuse health check connection between health checks. Default is true.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue reuse_connection = 7;</code>
     */
    public Builder setReuseConnection(
        com.google.protobuf.BoolValue.Builder builderForValue) {
      if (reuseConnectionBuilder_ == null) {
        reuseConnection_ = builderForValue.build();
      } else {
        reuseConnectionBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000100;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Reuse health check connection between health checks. Default is true.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue reuse_connection = 7;</code>
     */
    public Builder mergeReuseConnection(com.google.protobuf.BoolValue value) {
      if (reuseConnectionBuilder_ == null) {
        if (((bitField0_ & 0x00000100) != 0) &&
          reuseConnection_ != null &&
          reuseConnection_ != com.google.protobuf.BoolValue.getDefaultInstance()) {
          getReuseConnectionBuilder().mergeFrom(value);
        } else {
          reuseConnection_ = value;
        }
      } else {
        reuseConnectionBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000100;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Reuse health check connection between health checks. Default is true.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue reuse_connection = 7;</code>
     */
    public Builder clearReuseConnection() {
      bitField0_ = (bitField0_ & ~0x00000100);
      reuseConnection_ = null;
      if (reuseConnectionBuilder_ != null) {
        reuseConnectionBuilder_.dispose();
        reuseConnectionBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Reuse health check connection between health checks. Default is true.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue reuse_connection = 7;</code>
     */
    public com.google.protobuf.BoolValue.Builder getReuseConnectionBuilder() {
      bitField0_ |= 0x00000100;
      onChanged();
      return getReuseConnectionFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Reuse health check connection between health checks. Default is true.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue reuse_connection = 7;</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getReuseConnectionOrBuilder() {
      if (reuseConnectionBuilder_ != null) {
        return reuseConnectionBuilder_.getMessageOrBuilder();
      } else {
        return reuseConnection_ == null ?
            com.google.protobuf.BoolValue.getDefaultInstance() : reuseConnection_;
      }
    }
    /**
     * <pre>
     * Reuse health check connection between health checks. Default is true.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue reuse_connection = 7;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
        getReuseConnectionFieldBuilder() {
      if (reuseConnectionBuilder_ == null) {
        reuseConnectionBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                getReuseConnection(),
                getParentForChildren(),
                isClean());
        reuseConnection_ = null;
      }
      return reuseConnectionBuilder_;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck, io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheckOrBuilder> httpHealthCheckBuilder_;
    /**
     * <pre>
     * HTTP health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.HttpHealthCheck http_health_check = 8;</code>
     * @return Whether the httpHealthCheck field is set.
     */
    @java.lang.Override
    public boolean hasHttpHealthCheck() {
      return healthCheckerCase_ == 8;
    }
    /**
     * <pre>
     * HTTP health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.HttpHealthCheck http_health_check = 8;</code>
     * @return The httpHealthCheck.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck getHttpHealthCheck() {
      if (httpHealthCheckBuilder_ == null) {
        if (healthCheckerCase_ == 8) {
          return (io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck) healthChecker_;
        }
        return io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck.getDefaultInstance();
      } else {
        if (healthCheckerCase_ == 8) {
          return httpHealthCheckBuilder_.getMessage();
        }
        return io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * HTTP health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.HttpHealthCheck http_health_check = 8;</code>
     */
    public Builder setHttpHealthCheck(io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck value) {
      if (httpHealthCheckBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        healthChecker_ = value;
        onChanged();
      } else {
        httpHealthCheckBuilder_.setMessage(value);
      }
      healthCheckerCase_ = 8;
      return this;
    }
    /**
     * <pre>
     * HTTP health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.HttpHealthCheck http_health_check = 8;</code>
     */
    public Builder setHttpHealthCheck(
        io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck.Builder builderForValue) {
      if (httpHealthCheckBuilder_ == null) {
        healthChecker_ = builderForValue.build();
        onChanged();
      } else {
        httpHealthCheckBuilder_.setMessage(builderForValue.build());
      }
      healthCheckerCase_ = 8;
      return this;
    }
    /**
     * <pre>
     * HTTP health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.HttpHealthCheck http_health_check = 8;</code>
     */
    public Builder mergeHttpHealthCheck(io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck value) {
      if (httpHealthCheckBuilder_ == null) {
        if (healthCheckerCase_ == 8 &&
            healthChecker_ != io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck.getDefaultInstance()) {
          healthChecker_ = io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck.newBuilder((io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck) healthChecker_)
              .mergeFrom(value).buildPartial();
        } else {
          healthChecker_ = value;
        }
        onChanged();
      } else {
        if (healthCheckerCase_ == 8) {
          httpHealthCheckBuilder_.mergeFrom(value);
        } else {
          httpHealthCheckBuilder_.setMessage(value);
        }
      }
      healthCheckerCase_ = 8;
      return this;
    }
    /**
     * <pre>
     * HTTP health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.HttpHealthCheck http_health_check = 8;</code>
     */
    public Builder clearHttpHealthCheck() {
      if (httpHealthCheckBuilder_ == null) {
        if (healthCheckerCase_ == 8) {
          healthCheckerCase_ = 0;
          healthChecker_ = null;
          onChanged();
        }
      } else {
        if (healthCheckerCase_ == 8) {
          healthCheckerCase_ = 0;
          healthChecker_ = null;
        }
        httpHealthCheckBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * HTTP health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.HttpHealthCheck http_health_check = 8;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck.Builder getHttpHealthCheckBuilder() {
      return getHttpHealthCheckFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * HTTP health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.HttpHealthCheck http_health_check = 8;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheckOrBuilder getHttpHealthCheckOrBuilder() {
      if ((healthCheckerCase_ == 8) && (httpHealthCheckBuilder_ != null)) {
        return httpHealthCheckBuilder_.getMessageOrBuilder();
      } else {
        if (healthCheckerCase_ == 8) {
          return (io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck) healthChecker_;
        }
        return io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * HTTP health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.HttpHealthCheck http_health_check = 8;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck, io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheckOrBuilder> 
        getHttpHealthCheckFieldBuilder() {
      if (httpHealthCheckBuilder_ == null) {
        if (!(healthCheckerCase_ == 8)) {
          healthChecker_ = io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck.getDefaultInstance();
        }
        httpHealthCheckBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck, io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheckOrBuilder>(
                (io.envoyproxy.envoy.config.core.v3.HealthCheck.HttpHealthCheck) healthChecker_,
                getParentForChildren(),
                isClean());
        healthChecker_ = null;
      }
      healthCheckerCase_ = 8;
      onChanged();
      return httpHealthCheckBuilder_;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck, io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheckOrBuilder> tcpHealthCheckBuilder_;
    /**
     * <pre>
     * TCP health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.TcpHealthCheck tcp_health_check = 9;</code>
     * @return Whether the tcpHealthCheck field is set.
     */
    @java.lang.Override
    public boolean hasTcpHealthCheck() {
      return healthCheckerCase_ == 9;
    }
    /**
     * <pre>
     * TCP health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.TcpHealthCheck tcp_health_check = 9;</code>
     * @return The tcpHealthCheck.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck getTcpHealthCheck() {
      if (tcpHealthCheckBuilder_ == null) {
        if (healthCheckerCase_ == 9) {
          return (io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck) healthChecker_;
        }
        return io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck.getDefaultInstance();
      } else {
        if (healthCheckerCase_ == 9) {
          return tcpHealthCheckBuilder_.getMessage();
        }
        return io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * TCP health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.TcpHealthCheck tcp_health_check = 9;</code>
     */
    public Builder setTcpHealthCheck(io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck value) {
      if (tcpHealthCheckBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        healthChecker_ = value;
        onChanged();
      } else {
        tcpHealthCheckBuilder_.setMessage(value);
      }
      healthCheckerCase_ = 9;
      return this;
    }
    /**
     * <pre>
     * TCP health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.TcpHealthCheck tcp_health_check = 9;</code>
     */
    public Builder setTcpHealthCheck(
        io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck.Builder builderForValue) {
      if (tcpHealthCheckBuilder_ == null) {
        healthChecker_ = builderForValue.build();
        onChanged();
      } else {
        tcpHealthCheckBuilder_.setMessage(builderForValue.build());
      }
      healthCheckerCase_ = 9;
      return this;
    }
    /**
     * <pre>
     * TCP health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.TcpHealthCheck tcp_health_check = 9;</code>
     */
    public Builder mergeTcpHealthCheck(io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck value) {
      if (tcpHealthCheckBuilder_ == null) {
        if (healthCheckerCase_ == 9 &&
            healthChecker_ != io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck.getDefaultInstance()) {
          healthChecker_ = io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck.newBuilder((io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck) healthChecker_)
              .mergeFrom(value).buildPartial();
        } else {
          healthChecker_ = value;
        }
        onChanged();
      } else {
        if (healthCheckerCase_ == 9) {
          tcpHealthCheckBuilder_.mergeFrom(value);
        } else {
          tcpHealthCheckBuilder_.setMessage(value);
        }
      }
      healthCheckerCase_ = 9;
      return this;
    }
    /**
     * <pre>
     * TCP health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.TcpHealthCheck tcp_health_check = 9;</code>
     */
    public Builder clearTcpHealthCheck() {
      if (tcpHealthCheckBuilder_ == null) {
        if (healthCheckerCase_ == 9) {
          healthCheckerCase_ = 0;
          healthChecker_ = null;
          onChanged();
        }
      } else {
        if (healthCheckerCase_ == 9) {
          healthCheckerCase_ = 0;
          healthChecker_ = null;
        }
        tcpHealthCheckBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * TCP health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.TcpHealthCheck tcp_health_check = 9;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck.Builder getTcpHealthCheckBuilder() {
      return getTcpHealthCheckFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * TCP health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.TcpHealthCheck tcp_health_check = 9;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheckOrBuilder getTcpHealthCheckOrBuilder() {
      if ((healthCheckerCase_ == 9) && (tcpHealthCheckBuilder_ != null)) {
        return tcpHealthCheckBuilder_.getMessageOrBuilder();
      } else {
        if (healthCheckerCase_ == 9) {
          return (io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck) healthChecker_;
        }
        return io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * TCP health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.TcpHealthCheck tcp_health_check = 9;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck, io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheckOrBuilder> 
        getTcpHealthCheckFieldBuilder() {
      if (tcpHealthCheckBuilder_ == null) {
        if (!(healthCheckerCase_ == 9)) {
          healthChecker_ = io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck.getDefaultInstance();
        }
        tcpHealthCheckBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck, io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheckOrBuilder>(
                (io.envoyproxy.envoy.config.core.v3.HealthCheck.TcpHealthCheck) healthChecker_,
                getParentForChildren(),
                isClean());
        healthChecker_ = null;
      }
      healthCheckerCase_ = 9;
      onChanged();
      return tcpHealthCheckBuilder_;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck, io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheckOrBuilder> grpcHealthCheckBuilder_;
    /**
     * <pre>
     * gRPC health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.GrpcHealthCheck grpc_health_check = 11;</code>
     * @return Whether the grpcHealthCheck field is set.
     */
    @java.lang.Override
    public boolean hasGrpcHealthCheck() {
      return healthCheckerCase_ == 11;
    }
    /**
     * <pre>
     * gRPC health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.GrpcHealthCheck grpc_health_check = 11;</code>
     * @return The grpcHealthCheck.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck getGrpcHealthCheck() {
      if (grpcHealthCheckBuilder_ == null) {
        if (healthCheckerCase_ == 11) {
          return (io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck) healthChecker_;
        }
        return io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck.getDefaultInstance();
      } else {
        if (healthCheckerCase_ == 11) {
          return grpcHealthCheckBuilder_.getMessage();
        }
        return io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * gRPC health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.GrpcHealthCheck grpc_health_check = 11;</code>
     */
    public Builder setGrpcHealthCheck(io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck value) {
      if (grpcHealthCheckBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        healthChecker_ = value;
        onChanged();
      } else {
        grpcHealthCheckBuilder_.setMessage(value);
      }
      healthCheckerCase_ = 11;
      return this;
    }
    /**
     * <pre>
     * gRPC health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.GrpcHealthCheck grpc_health_check = 11;</code>
     */
    public Builder setGrpcHealthCheck(
        io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck.Builder builderForValue) {
      if (grpcHealthCheckBuilder_ == null) {
        healthChecker_ = builderForValue.build();
        onChanged();
      } else {
        grpcHealthCheckBuilder_.setMessage(builderForValue.build());
      }
      healthCheckerCase_ = 11;
      return this;
    }
    /**
     * <pre>
     * gRPC health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.GrpcHealthCheck grpc_health_check = 11;</code>
     */
    public Builder mergeGrpcHealthCheck(io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck value) {
      if (grpcHealthCheckBuilder_ == null) {
        if (healthCheckerCase_ == 11 &&
            healthChecker_ != io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck.getDefaultInstance()) {
          healthChecker_ = io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck.newBuilder((io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck) healthChecker_)
              .mergeFrom(value).buildPartial();
        } else {
          healthChecker_ = value;
        }
        onChanged();
      } else {
        if (healthCheckerCase_ == 11) {
          grpcHealthCheckBuilder_.mergeFrom(value);
        } else {
          grpcHealthCheckBuilder_.setMessage(value);
        }
      }
      healthCheckerCase_ = 11;
      return this;
    }
    /**
     * <pre>
     * gRPC health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.GrpcHealthCheck grpc_health_check = 11;</code>
     */
    public Builder clearGrpcHealthCheck() {
      if (grpcHealthCheckBuilder_ == null) {
        if (healthCheckerCase_ == 11) {
          healthCheckerCase_ = 0;
          healthChecker_ = null;
          onChanged();
        }
      } else {
        if (healthCheckerCase_ == 11) {
          healthCheckerCase_ = 0;
          healthChecker_ = null;
        }
        grpcHealthCheckBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * gRPC health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.GrpcHealthCheck grpc_health_check = 11;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck.Builder getGrpcHealthCheckBuilder() {
      return getGrpcHealthCheckFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * gRPC health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.GrpcHealthCheck grpc_health_check = 11;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheckOrBuilder getGrpcHealthCheckOrBuilder() {
      if ((healthCheckerCase_ == 11) && (grpcHealthCheckBuilder_ != null)) {
        return grpcHealthCheckBuilder_.getMessageOrBuilder();
      } else {
        if (healthCheckerCase_ == 11) {
          return (io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck) healthChecker_;
        }
        return io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * gRPC health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.GrpcHealthCheck grpc_health_check = 11;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck, io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheckOrBuilder> 
        getGrpcHealthCheckFieldBuilder() {
      if (grpcHealthCheckBuilder_ == null) {
        if (!(healthCheckerCase_ == 11)) {
          healthChecker_ = io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck.getDefaultInstance();
        }
        grpcHealthCheckBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck, io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheckOrBuilder>(
                (io.envoyproxy.envoy.config.core.v3.HealthCheck.GrpcHealthCheck) healthChecker_,
                getParentForChildren(),
                isClean());
        healthChecker_ = null;
      }
      healthCheckerCase_ = 11;
      onChanged();
      return grpcHealthCheckBuilder_;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck, io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheckOrBuilder> customHealthCheckBuilder_;
    /**
     * <pre>
     * Custom health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.CustomHealthCheck custom_health_check = 13;</code>
     * @return Whether the customHealthCheck field is set.
     */
    @java.lang.Override
    public boolean hasCustomHealthCheck() {
      return healthCheckerCase_ == 13;
    }
    /**
     * <pre>
     * Custom health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.CustomHealthCheck custom_health_check = 13;</code>
     * @return The customHealthCheck.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck getCustomHealthCheck() {
      if (customHealthCheckBuilder_ == null) {
        if (healthCheckerCase_ == 13) {
          return (io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck) healthChecker_;
        }
        return io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck.getDefaultInstance();
      } else {
        if (healthCheckerCase_ == 13) {
          return customHealthCheckBuilder_.getMessage();
        }
        return io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * Custom health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.CustomHealthCheck custom_health_check = 13;</code>
     */
    public Builder setCustomHealthCheck(io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck value) {
      if (customHealthCheckBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        healthChecker_ = value;
        onChanged();
      } else {
        customHealthCheckBuilder_.setMessage(value);
      }
      healthCheckerCase_ = 13;
      return this;
    }
    /**
     * <pre>
     * Custom health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.CustomHealthCheck custom_health_check = 13;</code>
     */
    public Builder setCustomHealthCheck(
        io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck.Builder builderForValue) {
      if (customHealthCheckBuilder_ == null) {
        healthChecker_ = builderForValue.build();
        onChanged();
      } else {
        customHealthCheckBuilder_.setMessage(builderForValue.build());
      }
      healthCheckerCase_ = 13;
      return this;
    }
    /**
     * <pre>
     * Custom health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.CustomHealthCheck custom_health_check = 13;</code>
     */
    public Builder mergeCustomHealthCheck(io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck value) {
      if (customHealthCheckBuilder_ == null) {
        if (healthCheckerCase_ == 13 &&
            healthChecker_ != io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck.getDefaultInstance()) {
          healthChecker_ = io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck.newBuilder((io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck) healthChecker_)
              .mergeFrom(value).buildPartial();
        } else {
          healthChecker_ = value;
        }
        onChanged();
      } else {
        if (healthCheckerCase_ == 13) {
          customHealthCheckBuilder_.mergeFrom(value);
        } else {
          customHealthCheckBuilder_.setMessage(value);
        }
      }
      healthCheckerCase_ = 13;
      return this;
    }
    /**
     * <pre>
     * Custom health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.CustomHealthCheck custom_health_check = 13;</code>
     */
    public Builder clearCustomHealthCheck() {
      if (customHealthCheckBuilder_ == null) {
        if (healthCheckerCase_ == 13) {
          healthCheckerCase_ = 0;
          healthChecker_ = null;
          onChanged();
        }
      } else {
        if (healthCheckerCase_ == 13) {
          healthCheckerCase_ = 0;
          healthChecker_ = null;
        }
        customHealthCheckBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * Custom health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.CustomHealthCheck custom_health_check = 13;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck.Builder getCustomHealthCheckBuilder() {
      return getCustomHealthCheckFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Custom health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.CustomHealthCheck custom_health_check = 13;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheckOrBuilder getCustomHealthCheckOrBuilder() {
      if ((healthCheckerCase_ == 13) && (customHealthCheckBuilder_ != null)) {
        return customHealthCheckBuilder_.getMessageOrBuilder();
      } else {
        if (healthCheckerCase_ == 13) {
          return (io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck) healthChecker_;
        }
        return io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * Custom health check.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.CustomHealthCheck custom_health_check = 13;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck, io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheckOrBuilder> 
        getCustomHealthCheckFieldBuilder() {
      if (customHealthCheckBuilder_ == null) {
        if (!(healthCheckerCase_ == 13)) {
          healthChecker_ = io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck.getDefaultInstance();
        }
        customHealthCheckBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck, io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheckOrBuilder>(
                (io.envoyproxy.envoy.config.core.v3.HealthCheck.CustomHealthCheck) healthChecker_,
                getParentForChildren(),
                isClean());
        healthChecker_ = null;
      }
      healthCheckerCase_ = 13;
      onChanged();
      return customHealthCheckBuilder_;
    }

    private com.google.protobuf.Duration noTrafficInterval_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> noTrafficIntervalBuilder_;
    /**
     * <pre>
     * The "no traffic interval" is a special health check interval that is used when a cluster has
     * never had traffic routed to it. This lower interval allows cluster information to be kept up to
     * date, without sending a potentially large amount of active health checking traffic for no
     * reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the
     * standard health check interval that is defined. Note that this interval takes precedence over
     * any other.
     * The default value for "no traffic interval" is 60 seconds.
     * </pre>
     *
     * <code>.google.protobuf.Duration no_traffic_interval = 12 [(.validate.rules) = { ... }</code>
     * @return Whether the noTrafficInterval field is set.
     */
    public boolean hasNoTrafficInterval() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * The "no traffic interval" is a special health check interval that is used when a cluster has
     * never had traffic routed to it. This lower interval allows cluster information to be kept up to
     * date, without sending a potentially large amount of active health checking traffic for no
     * reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the
     * standard health check interval that is defined. Note that this interval takes precedence over
     * any other.
     * The default value for "no traffic interval" is 60 seconds.
     * </pre>
     *
     * <code>.google.protobuf.Duration no_traffic_interval = 12 [(.validate.rules) = { ... }</code>
     * @return The noTrafficInterval.
     */
    public com.google.protobuf.Duration getNoTrafficInterval() {
      if (noTrafficIntervalBuilder_ == null) {
        return noTrafficInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : noTrafficInterval_;
      } else {
        return noTrafficIntervalBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The "no traffic interval" is a special health check interval that is used when a cluster has
     * never had traffic routed to it. This lower interval allows cluster information to be kept up to
     * date, without sending a potentially large amount of active health checking traffic for no
     * reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the
     * standard health check interval that is defined. Note that this interval takes precedence over
     * any other.
     * The default value for "no traffic interval" is 60 seconds.
     * </pre>
     *
     * <code>.google.protobuf.Duration no_traffic_interval = 12 [(.validate.rules) = { ... }</code>
     */
    public Builder setNoTrafficInterval(com.google.protobuf.Duration value) {
      if (noTrafficIntervalBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        noTrafficInterval_ = value;
      } else {
        noTrafficIntervalBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00002000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The "no traffic interval" is a special health check interval that is used when a cluster has
     * never had traffic routed to it. This lower interval allows cluster information to be kept up to
     * date, without sending a potentially large amount of active health checking traffic for no
     * reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the
     * standard health check interval that is defined. Note that this interval takes precedence over
     * any other.
     * The default value for "no traffic interval" is 60 seconds.
     * </pre>
     *
     * <code>.google.protobuf.Duration no_traffic_interval = 12 [(.validate.rules) = { ... }</code>
     */
    public Builder setNoTrafficInterval(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (noTrafficIntervalBuilder_ == null) {
        noTrafficInterval_ = builderForValue.build();
      } else {
        noTrafficIntervalBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00002000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The "no traffic interval" is a special health check interval that is used when a cluster has
     * never had traffic routed to it. This lower interval allows cluster information to be kept up to
     * date, without sending a potentially large amount of active health checking traffic for no
     * reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the
     * standard health check interval that is defined. Note that this interval takes precedence over
     * any other.
     * The default value for "no traffic interval" is 60 seconds.
     * </pre>
     *
     * <code>.google.protobuf.Duration no_traffic_interval = 12 [(.validate.rules) = { ... }</code>
     */
    public Builder mergeNoTrafficInterval(com.google.protobuf.Duration value) {
      if (noTrafficIntervalBuilder_ == null) {
        if (((bitField0_ & 0x00002000) != 0) &&
          noTrafficInterval_ != null &&
          noTrafficInterval_ != com.google.protobuf.Duration.getDefaultInstance()) {
          getNoTrafficIntervalBuilder().mergeFrom(value);
        } else {
          noTrafficInterval_ = value;
        }
      } else {
        noTrafficIntervalBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00002000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The "no traffic interval" is a special health check interval that is used when a cluster has
     * never had traffic routed to it. This lower interval allows cluster information to be kept up to
     * date, without sending a potentially large amount of active health checking traffic for no
     * reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the
     * standard health check interval that is defined. Note that this interval takes precedence over
     * any other.
     * The default value for "no traffic interval" is 60 seconds.
     * </pre>
     *
     * <code>.google.protobuf.Duration no_traffic_interval = 12 [(.validate.rules) = { ... }</code>
     */
    public Builder clearNoTrafficInterval() {
      bitField0_ = (bitField0_ & ~0x00002000);
      noTrafficInterval_ = null;
      if (noTrafficIntervalBuilder_ != null) {
        noTrafficIntervalBuilder_.dispose();
        noTrafficIntervalBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The "no traffic interval" is a special health check interval that is used when a cluster has
     * never had traffic routed to it. This lower interval allows cluster information to be kept up to
     * date, without sending a potentially large amount of active health checking traffic for no
     * reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the
     * standard health check interval that is defined. Note that this interval takes precedence over
     * any other.
     * The default value for "no traffic interval" is 60 seconds.
     * </pre>
     *
     * <code>.google.protobuf.Duration no_traffic_interval = 12 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.Duration.Builder getNoTrafficIntervalBuilder() {
      bitField0_ |= 0x00002000;
      onChanged();
      return getNoTrafficIntervalFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The "no traffic interval" is a special health check interval that is used when a cluster has
     * never had traffic routed to it. This lower interval allows cluster information to be kept up to
     * date, without sending a potentially large amount of active health checking traffic for no
     * reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the
     * standard health check interval that is defined. Note that this interval takes precedence over
     * any other.
     * The default value for "no traffic interval" is 60 seconds.
     * </pre>
     *
     * <code>.google.protobuf.Duration no_traffic_interval = 12 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.DurationOrBuilder getNoTrafficIntervalOrBuilder() {
      if (noTrafficIntervalBuilder_ != null) {
        return noTrafficIntervalBuilder_.getMessageOrBuilder();
      } else {
        return noTrafficInterval_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : noTrafficInterval_;
      }
    }
    /**
     * <pre>
     * The "no traffic interval" is a special health check interval that is used when a cluster has
     * never had traffic routed to it. This lower interval allows cluster information to be kept up to
     * date, without sending a potentially large amount of active health checking traffic for no
     * reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the
     * standard health check interval that is defined. Note that this interval takes precedence over
     * any other.
     * The default value for "no traffic interval" is 60 seconds.
     * </pre>
     *
     * <code>.google.protobuf.Duration no_traffic_interval = 12 [(.validate.rules) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getNoTrafficIntervalFieldBuilder() {
      if (noTrafficIntervalBuilder_ == null) {
        noTrafficIntervalBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getNoTrafficInterval(),
                getParentForChildren(),
                isClean());
        noTrafficInterval_ = null;
      }
      return noTrafficIntervalBuilder_;
    }

    private com.google.protobuf.Duration noTrafficHealthyInterval_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> noTrafficHealthyIntervalBuilder_;
    /**
     * <pre>
     * The "no traffic healthy interval" is a special health check interval that
     * is used for hosts that are currently passing active health checking
     * (including new hosts) when the cluster has received no traffic.
     * This is useful for when we want to send frequent health checks with
     * ``no_traffic_interval`` but then revert to lower frequency ``no_traffic_healthy_interval`` once
     * a host in the cluster is marked as healthy.
     * Once a cluster has been used for traffic routing, Envoy will shift back to using the
     * standard health check interval that is defined.
     * If no_traffic_healthy_interval is not set, it will default to the
     * no traffic interval and send that interval regardless of health state.
     * </pre>
     *
     * <code>.google.protobuf.Duration no_traffic_healthy_interval = 24 [(.validate.rules) = { ... }</code>
     * @return Whether the noTrafficHealthyInterval field is set.
     */
    public boolean hasNoTrafficHealthyInterval() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <pre>
     * The "no traffic healthy interval" is a special health check interval that
     * is used for hosts that are currently passing active health checking
     * (including new hosts) when the cluster has received no traffic.
     * This is useful for when we want to send frequent health checks with
     * ``no_traffic_interval`` but then revert to lower frequency ``no_traffic_healthy_interval`` once
     * a host in the cluster is marked as healthy.
     * Once a cluster has been used for traffic routing, Envoy will shift back to using the
     * standard health check interval that is defined.
     * If no_traffic_healthy_interval is not set, it will default to the
     * no traffic interval and send that interval regardless of health state.
     * </pre>
     *
     * <code>.google.protobuf.Duration no_traffic_healthy_interval = 24 [(.validate.rules) = { ... }</code>
     * @return The noTrafficHealthyInterval.
     */
    public com.google.protobuf.Duration getNoTrafficHealthyInterval() {
      if (noTrafficHealthyIntervalBuilder_ == null) {
        return noTrafficHealthyInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : noTrafficHealthyInterval_;
      } else {
        return noTrafficHealthyIntervalBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The "no traffic healthy interval" is a special health check interval that
     * is used for hosts that are currently passing active health checking
     * (including new hosts) when the cluster has received no traffic.
     * This is useful for when we want to send frequent health checks with
     * ``no_traffic_interval`` but then revert to lower frequency ``no_traffic_healthy_interval`` once
     * a host in the cluster is marked as healthy.
     * Once a cluster has been used for traffic routing, Envoy will shift back to using the
     * standard health check interval that is defined.
     * If no_traffic_healthy_interval is not set, it will default to the
     * no traffic interval and send that interval regardless of health state.
     * </pre>
     *
     * <code>.google.protobuf.Duration no_traffic_healthy_interval = 24 [(.validate.rules) = { ... }</code>
     */
    public Builder setNoTrafficHealthyInterval(com.google.protobuf.Duration value) {
      if (noTrafficHealthyIntervalBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        noTrafficHealthyInterval_ = value;
      } else {
        noTrafficHealthyIntervalBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00004000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The "no traffic healthy interval" is a special health check interval that
     * is used for hosts that are currently passing active health checking
     * (including new hosts) when the cluster has received no traffic.
     * This is useful for when we want to send frequent health checks with
     * ``no_traffic_interval`` but then revert to lower frequency ``no_traffic_healthy_interval`` once
     * a host in the cluster is marked as healthy.
     * Once a cluster has been used for traffic routing, Envoy will shift back to using the
     * standard health check interval that is defined.
     * If no_traffic_healthy_interval is not set, it will default to the
     * no traffic interval and send that interval regardless of health state.
     * </pre>
     *
     * <code>.google.protobuf.Duration no_traffic_healthy_interval = 24 [(.validate.rules) = { ... }</code>
     */
    public Builder setNoTrafficHealthyInterval(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (noTrafficHealthyIntervalBuilder_ == null) {
        noTrafficHealthyInterval_ = builderForValue.build();
      } else {
        noTrafficHealthyIntervalBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00004000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The "no traffic healthy interval" is a special health check interval that
     * is used for hosts that are currently passing active health checking
     * (including new hosts) when the cluster has received no traffic.
     * This is useful for when we want to send frequent health checks with
     * ``no_traffic_interval`` but then revert to lower frequency ``no_traffic_healthy_interval`` once
     * a host in the cluster is marked as healthy.
     * Once a cluster has been used for traffic routing, Envoy will shift back to using the
     * standard health check interval that is defined.
     * If no_traffic_healthy_interval is not set, it will default to the
     * no traffic interval and send that interval regardless of health state.
     * </pre>
     *
     * <code>.google.protobuf.Duration no_traffic_healthy_interval = 24 [(.validate.rules) = { ... }</code>
     */
    public Builder mergeNoTrafficHealthyInterval(com.google.protobuf.Duration value) {
      if (noTrafficHealthyIntervalBuilder_ == null) {
        if (((bitField0_ & 0x00004000) != 0) &&
          noTrafficHealthyInterval_ != null &&
          noTrafficHealthyInterval_ != com.google.protobuf.Duration.getDefaultInstance()) {
          getNoTrafficHealthyIntervalBuilder().mergeFrom(value);
        } else {
          noTrafficHealthyInterval_ = value;
        }
      } else {
        noTrafficHealthyIntervalBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00004000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The "no traffic healthy interval" is a special health check interval that
     * is used for hosts that are currently passing active health checking
     * (including new hosts) when the cluster has received no traffic.
     * This is useful for when we want to send frequent health checks with
     * ``no_traffic_interval`` but then revert to lower frequency ``no_traffic_healthy_interval`` once
     * a host in the cluster is marked as healthy.
     * Once a cluster has been used for traffic routing, Envoy will shift back to using the
     * standard health check interval that is defined.
     * If no_traffic_healthy_interval is not set, it will default to the
     * no traffic interval and send that interval regardless of health state.
     * </pre>
     *
     * <code>.google.protobuf.Duration no_traffic_healthy_interval = 24 [(.validate.rules) = { ... }</code>
     */
    public Builder clearNoTrafficHealthyInterval() {
      bitField0_ = (bitField0_ & ~0x00004000);
      noTrafficHealthyInterval_ = null;
      if (noTrafficHealthyIntervalBuilder_ != null) {
        noTrafficHealthyIntervalBuilder_.dispose();
        noTrafficHealthyIntervalBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The "no traffic healthy interval" is a special health check interval that
     * is used for hosts that are currently passing active health checking
     * (including new hosts) when the cluster has received no traffic.
     * This is useful for when we want to send frequent health checks with
     * ``no_traffic_interval`` but then revert to lower frequency ``no_traffic_healthy_interval`` once
     * a host in the cluster is marked as healthy.
     * Once a cluster has been used for traffic routing, Envoy will shift back to using the
     * standard health check interval that is defined.
     * If no_traffic_healthy_interval is not set, it will default to the
     * no traffic interval and send that interval regardless of health state.
     * </pre>
     *
     * <code>.google.protobuf.Duration no_traffic_healthy_interval = 24 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.Duration.Builder getNoTrafficHealthyIntervalBuilder() {
      bitField0_ |= 0x00004000;
      onChanged();
      return getNoTrafficHealthyIntervalFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The "no traffic healthy interval" is a special health check interval that
     * is used for hosts that are currently passing active health checking
     * (including new hosts) when the cluster has received no traffic.
     * This is useful for when we want to send frequent health checks with
     * ``no_traffic_interval`` but then revert to lower frequency ``no_traffic_healthy_interval`` once
     * a host in the cluster is marked as healthy.
     * Once a cluster has been used for traffic routing, Envoy will shift back to using the
     * standard health check interval that is defined.
     * If no_traffic_healthy_interval is not set, it will default to the
     * no traffic interval and send that interval regardless of health state.
     * </pre>
     *
     * <code>.google.protobuf.Duration no_traffic_healthy_interval = 24 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.DurationOrBuilder getNoTrafficHealthyIntervalOrBuilder() {
      if (noTrafficHealthyIntervalBuilder_ != null) {
        return noTrafficHealthyIntervalBuilder_.getMessageOrBuilder();
      } else {
        return noTrafficHealthyInterval_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : noTrafficHealthyInterval_;
      }
    }
    /**
     * <pre>
     * The "no traffic healthy interval" is a special health check interval that
     * is used for hosts that are currently passing active health checking
     * (including new hosts) when the cluster has received no traffic.
     * This is useful for when we want to send frequent health checks with
     * ``no_traffic_interval`` but then revert to lower frequency ``no_traffic_healthy_interval`` once
     * a host in the cluster is marked as healthy.
     * Once a cluster has been used for traffic routing, Envoy will shift back to using the
     * standard health check interval that is defined.
     * If no_traffic_healthy_interval is not set, it will default to the
     * no traffic interval and send that interval regardless of health state.
     * </pre>
     *
     * <code>.google.protobuf.Duration no_traffic_healthy_interval = 24 [(.validate.rules) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getNoTrafficHealthyIntervalFieldBuilder() {
      if (noTrafficHealthyIntervalBuilder_ == null) {
        noTrafficHealthyIntervalBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getNoTrafficHealthyInterval(),
                getParentForChildren(),
                isClean());
        noTrafficHealthyInterval_ = null;
      }
      return noTrafficHealthyIntervalBuilder_;
    }

    private com.google.protobuf.Duration unhealthyInterval_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> unhealthyIntervalBuilder_;
    /**
     * <pre>
     * The "unhealthy interval" is a health check interval that is used for hosts that are marked as
     * unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the
     * standard health check interval that is defined.
     * The default value for "unhealthy interval" is the same as "interval".
     * </pre>
     *
     * <code>.google.protobuf.Duration unhealthy_interval = 14 [(.validate.rules) = { ... }</code>
     * @return Whether the unhealthyInterval field is set.
     */
    public boolean hasUnhealthyInterval() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     * <pre>
     * The "unhealthy interval" is a health check interval that is used for hosts that are marked as
     * unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the
     * standard health check interval that is defined.
     * The default value for "unhealthy interval" is the same as "interval".
     * </pre>
     *
     * <code>.google.protobuf.Duration unhealthy_interval = 14 [(.validate.rules) = { ... }</code>
     * @return The unhealthyInterval.
     */
    public com.google.protobuf.Duration getUnhealthyInterval() {
      if (unhealthyIntervalBuilder_ == null) {
        return unhealthyInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : unhealthyInterval_;
      } else {
        return unhealthyIntervalBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The "unhealthy interval" is a health check interval that is used for hosts that are marked as
     * unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the
     * standard health check interval that is defined.
     * The default value for "unhealthy interval" is the same as "interval".
     * </pre>
     *
     * <code>.google.protobuf.Duration unhealthy_interval = 14 [(.validate.rules) = { ... }</code>
     */
    public Builder setUnhealthyInterval(com.google.protobuf.Duration value) {
      if (unhealthyIntervalBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        unhealthyInterval_ = value;
      } else {
        unhealthyIntervalBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00008000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The "unhealthy interval" is a health check interval that is used for hosts that are marked as
     * unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the
     * standard health check interval that is defined.
     * The default value for "unhealthy interval" is the same as "interval".
     * </pre>
     *
     * <code>.google.protobuf.Duration unhealthy_interval = 14 [(.validate.rules) = { ... }</code>
     */
    public Builder setUnhealthyInterval(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (unhealthyIntervalBuilder_ == null) {
        unhealthyInterval_ = builderForValue.build();
      } else {
        unhealthyIntervalBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00008000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The "unhealthy interval" is a health check interval that is used for hosts that are marked as
     * unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the
     * standard health check interval that is defined.
     * The default value for "unhealthy interval" is the same as "interval".
     * </pre>
     *
     * <code>.google.protobuf.Duration unhealthy_interval = 14 [(.validate.rules) = { ... }</code>
     */
    public Builder mergeUnhealthyInterval(com.google.protobuf.Duration value) {
      if (unhealthyIntervalBuilder_ == null) {
        if (((bitField0_ & 0x00008000) != 0) &&
          unhealthyInterval_ != null &&
          unhealthyInterval_ != com.google.protobuf.Duration.getDefaultInstance()) {
          getUnhealthyIntervalBuilder().mergeFrom(value);
        } else {
          unhealthyInterval_ = value;
        }
      } else {
        unhealthyIntervalBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00008000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The "unhealthy interval" is a health check interval that is used for hosts that are marked as
     * unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the
     * standard health check interval that is defined.
     * The default value for "unhealthy interval" is the same as "interval".
     * </pre>
     *
     * <code>.google.protobuf.Duration unhealthy_interval = 14 [(.validate.rules) = { ... }</code>
     */
    public Builder clearUnhealthyInterval() {
      bitField0_ = (bitField0_ & ~0x00008000);
      unhealthyInterval_ = null;
      if (unhealthyIntervalBuilder_ != null) {
        unhealthyIntervalBuilder_.dispose();
        unhealthyIntervalBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The "unhealthy interval" is a health check interval that is used for hosts that are marked as
     * unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the
     * standard health check interval that is defined.
     * The default value for "unhealthy interval" is the same as "interval".
     * </pre>
     *
     * <code>.google.protobuf.Duration unhealthy_interval = 14 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.Duration.Builder getUnhealthyIntervalBuilder() {
      bitField0_ |= 0x00008000;
      onChanged();
      return getUnhealthyIntervalFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The "unhealthy interval" is a health check interval that is used for hosts that are marked as
     * unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the
     * standard health check interval that is defined.
     * The default value for "unhealthy interval" is the same as "interval".
     * </pre>
     *
     * <code>.google.protobuf.Duration unhealthy_interval = 14 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.DurationOrBuilder getUnhealthyIntervalOrBuilder() {
      if (unhealthyIntervalBuilder_ != null) {
        return unhealthyIntervalBuilder_.getMessageOrBuilder();
      } else {
        return unhealthyInterval_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : unhealthyInterval_;
      }
    }
    /**
     * <pre>
     * The "unhealthy interval" is a health check interval that is used for hosts that are marked as
     * unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the
     * standard health check interval that is defined.
     * The default value for "unhealthy interval" is the same as "interval".
     * </pre>
     *
     * <code>.google.protobuf.Duration unhealthy_interval = 14 [(.validate.rules) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getUnhealthyIntervalFieldBuilder() {
      if (unhealthyIntervalBuilder_ == null) {
        unhealthyIntervalBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getUnhealthyInterval(),
                getParentForChildren(),
                isClean());
        unhealthyInterval_ = null;
      }
      return unhealthyIntervalBuilder_;
    }

    private com.google.protobuf.Duration unhealthyEdgeInterval_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> unhealthyEdgeIntervalBuilder_;
    /**
     * <pre>
     * The "unhealthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as unhealthy. For subsequent health checks
     * Envoy will shift back to using either "unhealthy interval" if present or the standard health
     * check interval that is defined.
     * The default value for "unhealthy edge interval" is the same as "unhealthy interval".
     * </pre>
     *
     * <code>.google.protobuf.Duration unhealthy_edge_interval = 15 [(.validate.rules) = { ... }</code>
     * @return Whether the unhealthyEdgeInterval field is set.
     */
    public boolean hasUnhealthyEdgeInterval() {
      return ((bitField0_ & 0x00010000) != 0);
    }
    /**
     * <pre>
     * The "unhealthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as unhealthy. For subsequent health checks
     * Envoy will shift back to using either "unhealthy interval" if present or the standard health
     * check interval that is defined.
     * The default value for "unhealthy edge interval" is the same as "unhealthy interval".
     * </pre>
     *
     * <code>.google.protobuf.Duration unhealthy_edge_interval = 15 [(.validate.rules) = { ... }</code>
     * @return The unhealthyEdgeInterval.
     */
    public com.google.protobuf.Duration getUnhealthyEdgeInterval() {
      if (unhealthyEdgeIntervalBuilder_ == null) {
        return unhealthyEdgeInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : unhealthyEdgeInterval_;
      } else {
        return unhealthyEdgeIntervalBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The "unhealthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as unhealthy. For subsequent health checks
     * Envoy will shift back to using either "unhealthy interval" if present or the standard health
     * check interval that is defined.
     * The default value for "unhealthy edge interval" is the same as "unhealthy interval".
     * </pre>
     *
     * <code>.google.protobuf.Duration unhealthy_edge_interval = 15 [(.validate.rules) = { ... }</code>
     */
    public Builder setUnhealthyEdgeInterval(com.google.protobuf.Duration value) {
      if (unhealthyEdgeIntervalBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        unhealthyEdgeInterval_ = value;
      } else {
        unhealthyEdgeIntervalBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00010000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The "unhealthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as unhealthy. For subsequent health checks
     * Envoy will shift back to using either "unhealthy interval" if present or the standard health
     * check interval that is defined.
     * The default value for "unhealthy edge interval" is the same as "unhealthy interval".
     * </pre>
     *
     * <code>.google.protobuf.Duration unhealthy_edge_interval = 15 [(.validate.rules) = { ... }</code>
     */
    public Builder setUnhealthyEdgeInterval(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (unhealthyEdgeIntervalBuilder_ == null) {
        unhealthyEdgeInterval_ = builderForValue.build();
      } else {
        unhealthyEdgeIntervalBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00010000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The "unhealthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as unhealthy. For subsequent health checks
     * Envoy will shift back to using either "unhealthy interval" if present or the standard health
     * check interval that is defined.
     * The default value for "unhealthy edge interval" is the same as "unhealthy interval".
     * </pre>
     *
     * <code>.google.protobuf.Duration unhealthy_edge_interval = 15 [(.validate.rules) = { ... }</code>
     */
    public Builder mergeUnhealthyEdgeInterval(com.google.protobuf.Duration value) {
      if (unhealthyEdgeIntervalBuilder_ == null) {
        if (((bitField0_ & 0x00010000) != 0) &&
          unhealthyEdgeInterval_ != null &&
          unhealthyEdgeInterval_ != com.google.protobuf.Duration.getDefaultInstance()) {
          getUnhealthyEdgeIntervalBuilder().mergeFrom(value);
        } else {
          unhealthyEdgeInterval_ = value;
        }
      } else {
        unhealthyEdgeIntervalBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00010000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The "unhealthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as unhealthy. For subsequent health checks
     * Envoy will shift back to using either "unhealthy interval" if present or the standard health
     * check interval that is defined.
     * The default value for "unhealthy edge interval" is the same as "unhealthy interval".
     * </pre>
     *
     * <code>.google.protobuf.Duration unhealthy_edge_interval = 15 [(.validate.rules) = { ... }</code>
     */
    public Builder clearUnhealthyEdgeInterval() {
      bitField0_ = (bitField0_ & ~0x00010000);
      unhealthyEdgeInterval_ = null;
      if (unhealthyEdgeIntervalBuilder_ != null) {
        unhealthyEdgeIntervalBuilder_.dispose();
        unhealthyEdgeIntervalBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The "unhealthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as unhealthy. For subsequent health checks
     * Envoy will shift back to using either "unhealthy interval" if present or the standard health
     * check interval that is defined.
     * The default value for "unhealthy edge interval" is the same as "unhealthy interval".
     * </pre>
     *
     * <code>.google.protobuf.Duration unhealthy_edge_interval = 15 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.Duration.Builder getUnhealthyEdgeIntervalBuilder() {
      bitField0_ |= 0x00010000;
      onChanged();
      return getUnhealthyEdgeIntervalFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The "unhealthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as unhealthy. For subsequent health checks
     * Envoy will shift back to using either "unhealthy interval" if present or the standard health
     * check interval that is defined.
     * The default value for "unhealthy edge interval" is the same as "unhealthy interval".
     * </pre>
     *
     * <code>.google.protobuf.Duration unhealthy_edge_interval = 15 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.DurationOrBuilder getUnhealthyEdgeIntervalOrBuilder() {
      if (unhealthyEdgeIntervalBuilder_ != null) {
        return unhealthyEdgeIntervalBuilder_.getMessageOrBuilder();
      } else {
        return unhealthyEdgeInterval_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : unhealthyEdgeInterval_;
      }
    }
    /**
     * <pre>
     * The "unhealthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as unhealthy. For subsequent health checks
     * Envoy will shift back to using either "unhealthy interval" if present or the standard health
     * check interval that is defined.
     * The default value for "unhealthy edge interval" is the same as "unhealthy interval".
     * </pre>
     *
     * <code>.google.protobuf.Duration unhealthy_edge_interval = 15 [(.validate.rules) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getUnhealthyEdgeIntervalFieldBuilder() {
      if (unhealthyEdgeIntervalBuilder_ == null) {
        unhealthyEdgeIntervalBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getUnhealthyEdgeInterval(),
                getParentForChildren(),
                isClean());
        unhealthyEdgeInterval_ = null;
      }
      return unhealthyEdgeIntervalBuilder_;
    }

    private com.google.protobuf.Duration healthyEdgeInterval_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> healthyEdgeIntervalBuilder_;
    /**
     * <pre>
     * The "healthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as healthy. For subsequent health checks
     * Envoy will shift back to using the standard health check interval that is defined.
     * The default value for "healthy edge interval" is the same as the default interval.
     * </pre>
     *
     * <code>.google.protobuf.Duration healthy_edge_interval = 16 [(.validate.rules) = { ... }</code>
     * @return Whether the healthyEdgeInterval field is set.
     */
    public boolean hasHealthyEdgeInterval() {
      return ((bitField0_ & 0x00020000) != 0);
    }
    /**
     * <pre>
     * The "healthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as healthy. For subsequent health checks
     * Envoy will shift back to using the standard health check interval that is defined.
     * The default value for "healthy edge interval" is the same as the default interval.
     * </pre>
     *
     * <code>.google.protobuf.Duration healthy_edge_interval = 16 [(.validate.rules) = { ... }</code>
     * @return The healthyEdgeInterval.
     */
    public com.google.protobuf.Duration getHealthyEdgeInterval() {
      if (healthyEdgeIntervalBuilder_ == null) {
        return healthyEdgeInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : healthyEdgeInterval_;
      } else {
        return healthyEdgeIntervalBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The "healthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as healthy. For subsequent health checks
     * Envoy will shift back to using the standard health check interval that is defined.
     * The default value for "healthy edge interval" is the same as the default interval.
     * </pre>
     *
     * <code>.google.protobuf.Duration healthy_edge_interval = 16 [(.validate.rules) = { ... }</code>
     */
    public Builder setHealthyEdgeInterval(com.google.protobuf.Duration value) {
      if (healthyEdgeIntervalBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        healthyEdgeInterval_ = value;
      } else {
        healthyEdgeIntervalBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00020000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The "healthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as healthy. For subsequent health checks
     * Envoy will shift back to using the standard health check interval that is defined.
     * The default value for "healthy edge interval" is the same as the default interval.
     * </pre>
     *
     * <code>.google.protobuf.Duration healthy_edge_interval = 16 [(.validate.rules) = { ... }</code>
     */
    public Builder setHealthyEdgeInterval(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (healthyEdgeIntervalBuilder_ == null) {
        healthyEdgeInterval_ = builderForValue.build();
      } else {
        healthyEdgeIntervalBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00020000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The "healthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as healthy. For subsequent health checks
     * Envoy will shift back to using the standard health check interval that is defined.
     * The default value for "healthy edge interval" is the same as the default interval.
     * </pre>
     *
     * <code>.google.protobuf.Duration healthy_edge_interval = 16 [(.validate.rules) = { ... }</code>
     */
    public Builder mergeHealthyEdgeInterval(com.google.protobuf.Duration value) {
      if (healthyEdgeIntervalBuilder_ == null) {
        if (((bitField0_ & 0x00020000) != 0) &&
          healthyEdgeInterval_ != null &&
          healthyEdgeInterval_ != com.google.protobuf.Duration.getDefaultInstance()) {
          getHealthyEdgeIntervalBuilder().mergeFrom(value);
        } else {
          healthyEdgeInterval_ = value;
        }
      } else {
        healthyEdgeIntervalBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00020000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The "healthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as healthy. For subsequent health checks
     * Envoy will shift back to using the standard health check interval that is defined.
     * The default value for "healthy edge interval" is the same as the default interval.
     * </pre>
     *
     * <code>.google.protobuf.Duration healthy_edge_interval = 16 [(.validate.rules) = { ... }</code>
     */
    public Builder clearHealthyEdgeInterval() {
      bitField0_ = (bitField0_ & ~0x00020000);
      healthyEdgeInterval_ = null;
      if (healthyEdgeIntervalBuilder_ != null) {
        healthyEdgeIntervalBuilder_.dispose();
        healthyEdgeIntervalBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The "healthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as healthy. For subsequent health checks
     * Envoy will shift back to using the standard health check interval that is defined.
     * The default value for "healthy edge interval" is the same as the default interval.
     * </pre>
     *
     * <code>.google.protobuf.Duration healthy_edge_interval = 16 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.Duration.Builder getHealthyEdgeIntervalBuilder() {
      bitField0_ |= 0x00020000;
      onChanged();
      return getHealthyEdgeIntervalFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The "healthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as healthy. For subsequent health checks
     * Envoy will shift back to using the standard health check interval that is defined.
     * The default value for "healthy edge interval" is the same as the default interval.
     * </pre>
     *
     * <code>.google.protobuf.Duration healthy_edge_interval = 16 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.DurationOrBuilder getHealthyEdgeIntervalOrBuilder() {
      if (healthyEdgeIntervalBuilder_ != null) {
        return healthyEdgeIntervalBuilder_.getMessageOrBuilder();
      } else {
        return healthyEdgeInterval_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : healthyEdgeInterval_;
      }
    }
    /**
     * <pre>
     * The "healthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as healthy. For subsequent health checks
     * Envoy will shift back to using the standard health check interval that is defined.
     * The default value for "healthy edge interval" is the same as the default interval.
     * </pre>
     *
     * <code>.google.protobuf.Duration healthy_edge_interval = 16 [(.validate.rules) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getHealthyEdgeIntervalFieldBuilder() {
      if (healthyEdgeIntervalBuilder_ == null) {
        healthyEdgeIntervalBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getHealthyEdgeInterval(),
                getParentForChildren(),
                isClean());
        healthyEdgeInterval_ = null;
      }
      return healthyEdgeIntervalBuilder_;
    }

    private java.lang.Object eventLogPath_ = "";
    /**
     * <pre>
     * Specifies the path to the :ref:`health check event log &lt;arch_overview_health_check_logging&gt;`.
     * If empty, no event log will be written.
     * </pre>
     *
     * <code>string event_log_path = 17;</code>
     * @return The eventLogPath.
     */
    public java.lang.String getEventLogPath() {
      java.lang.Object ref = eventLogPath_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        eventLogPath_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Specifies the path to the :ref:`health check event log &lt;arch_overview_health_check_logging&gt;`.
     * If empty, no event log will be written.
     * </pre>
     *
     * <code>string event_log_path = 17;</code>
     * @return The bytes for eventLogPath.
     */
    public com.google.protobuf.ByteString
        getEventLogPathBytes() {
      java.lang.Object ref = eventLogPath_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        eventLogPath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Specifies the path to the :ref:`health check event log &lt;arch_overview_health_check_logging&gt;`.
     * If empty, no event log will be written.
     * </pre>
     *
     * <code>string event_log_path = 17;</code>
     * @param value The eventLogPath to set.
     * @return This builder for chaining.
     */
    public Builder setEventLogPath(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      eventLogPath_ = value;
      bitField0_ |= 0x00040000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Specifies the path to the :ref:`health check event log &lt;arch_overview_health_check_logging&gt;`.
     * If empty, no event log will be written.
     * </pre>
     *
     * <code>string event_log_path = 17;</code>
     * @return This builder for chaining.
     */
    public Builder clearEventLogPath() {
      eventLogPath_ = getDefaultInstance().getEventLogPath();
      bitField0_ = (bitField0_ & ~0x00040000);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Specifies the path to the :ref:`health check event log &lt;arch_overview_health_check_logging&gt;`.
     * If empty, no event log will be written.
     * </pre>
     *
     * <code>string event_log_path = 17;</code>
     * @param value The bytes for eventLogPath to set.
     * @return This builder for chaining.
     */
    public Builder setEventLogPathBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      eventLogPath_ = value;
      bitField0_ |= 0x00040000;
      onChanged();
      return this;
    }

    private io.envoyproxy.envoy.config.core.v3.EventServiceConfig eventService_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.EventServiceConfig, io.envoyproxy.envoy.config.core.v3.EventServiceConfig.Builder, io.envoyproxy.envoy.config.core.v3.EventServiceConfigOrBuilder> eventServiceBuilder_;
    /**
     * <pre>
     * [#not-implemented-hide:]
     * The gRPC service for the health check event service.
     * If empty, health check events won't be sent to a remote endpoint.
     * </pre>
     *
     * <code>.envoy.config.core.v3.EventServiceConfig event_service = 22;</code>
     * @return Whether the eventService field is set.
     */
    public boolean hasEventService() {
      return ((bitField0_ & 0x00080000) != 0);
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * The gRPC service for the health check event service.
     * If empty, health check events won't be sent to a remote endpoint.
     * </pre>
     *
     * <code>.envoy.config.core.v3.EventServiceConfig event_service = 22;</code>
     * @return The eventService.
     */
    public io.envoyproxy.envoy.config.core.v3.EventServiceConfig getEventService() {
      if (eventServiceBuilder_ == null) {
        return eventService_ == null ? io.envoyproxy.envoy.config.core.v3.EventServiceConfig.getDefaultInstance() : eventService_;
      } else {
        return eventServiceBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * The gRPC service for the health check event service.
     * If empty, health check events won't be sent to a remote endpoint.
     * </pre>
     *
     * <code>.envoy.config.core.v3.EventServiceConfig event_service = 22;</code>
     */
    public Builder setEventService(io.envoyproxy.envoy.config.core.v3.EventServiceConfig value) {
      if (eventServiceBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        eventService_ = value;
      } else {
        eventServiceBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00080000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * The gRPC service for the health check event service.
     * If empty, health check events won't be sent to a remote endpoint.
     * </pre>
     *
     * <code>.envoy.config.core.v3.EventServiceConfig event_service = 22;</code>
     */
    public Builder setEventService(
        io.envoyproxy.envoy.config.core.v3.EventServiceConfig.Builder builderForValue) {
      if (eventServiceBuilder_ == null) {
        eventService_ = builderForValue.build();
      } else {
        eventServiceBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00080000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * The gRPC service for the health check event service.
     * If empty, health check events won't be sent to a remote endpoint.
     * </pre>
     *
     * <code>.envoy.config.core.v3.EventServiceConfig event_service = 22;</code>
     */
    public Builder mergeEventService(io.envoyproxy.envoy.config.core.v3.EventServiceConfig value) {
      if (eventServiceBuilder_ == null) {
        if (((bitField0_ & 0x00080000) != 0) &&
          eventService_ != null &&
          eventService_ != io.envoyproxy.envoy.config.core.v3.EventServiceConfig.getDefaultInstance()) {
          getEventServiceBuilder().mergeFrom(value);
        } else {
          eventService_ = value;
        }
      } else {
        eventServiceBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00080000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * The gRPC service for the health check event service.
     * If empty, health check events won't be sent to a remote endpoint.
     * </pre>
     *
     * <code>.envoy.config.core.v3.EventServiceConfig event_service = 22;</code>
     */
    public Builder clearEventService() {
      bitField0_ = (bitField0_ & ~0x00080000);
      eventService_ = null;
      if (eventServiceBuilder_ != null) {
        eventServiceBuilder_.dispose();
        eventServiceBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * The gRPC service for the health check event service.
     * If empty, health check events won't be sent to a remote endpoint.
     * </pre>
     *
     * <code>.envoy.config.core.v3.EventServiceConfig event_service = 22;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.EventServiceConfig.Builder getEventServiceBuilder() {
      bitField0_ |= 0x00080000;
      onChanged();
      return getEventServiceFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * The gRPC service for the health check event service.
     * If empty, health check events won't be sent to a remote endpoint.
     * </pre>
     *
     * <code>.envoy.config.core.v3.EventServiceConfig event_service = 22;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.EventServiceConfigOrBuilder getEventServiceOrBuilder() {
      if (eventServiceBuilder_ != null) {
        return eventServiceBuilder_.getMessageOrBuilder();
      } else {
        return eventService_ == null ?
            io.envoyproxy.envoy.config.core.v3.EventServiceConfig.getDefaultInstance() : eventService_;
      }
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * The gRPC service for the health check event service.
     * If empty, health check events won't be sent to a remote endpoint.
     * </pre>
     *
     * <code>.envoy.config.core.v3.EventServiceConfig event_service = 22;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.EventServiceConfig, io.envoyproxy.envoy.config.core.v3.EventServiceConfig.Builder, io.envoyproxy.envoy.config.core.v3.EventServiceConfigOrBuilder> 
        getEventServiceFieldBuilder() {
      if (eventServiceBuilder_ == null) {
        eventServiceBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.EventServiceConfig, io.envoyproxy.envoy.config.core.v3.EventServiceConfig.Builder, io.envoyproxy.envoy.config.core.v3.EventServiceConfigOrBuilder>(
                getEventService(),
                getParentForChildren(),
                isClean());
        eventService_ = null;
      }
      return eventServiceBuilder_;
    }

    private boolean alwaysLogHealthCheckFailures_ ;
    /**
     * <pre>
     * If set to true, health check failure events will always be logged. If set to false, only the
     * initial health check failure event will be logged.
     * The default value is false.
     * </pre>
     *
     * <code>bool always_log_health_check_failures = 19;</code>
     * @return The alwaysLogHealthCheckFailures.
     */
    @java.lang.Override
    public boolean getAlwaysLogHealthCheckFailures() {
      return alwaysLogHealthCheckFailures_;
    }
    /**
     * <pre>
     * If set to true, health check failure events will always be logged. If set to false, only the
     * initial health check failure event will be logged.
     * The default value is false.
     * </pre>
     *
     * <code>bool always_log_health_check_failures = 19;</code>
     * @param value The alwaysLogHealthCheckFailures to set.
     * @return This builder for chaining.
     */
    public Builder setAlwaysLogHealthCheckFailures(boolean value) {
      
      alwaysLogHealthCheckFailures_ = value;
      bitField0_ |= 0x00100000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If set to true, health check failure events will always be logged. If set to false, only the
     * initial health check failure event will be logged.
     * The default value is false.
     * </pre>
     *
     * <code>bool always_log_health_check_failures = 19;</code>
     * @return This builder for chaining.
     */
    public Builder clearAlwaysLogHealthCheckFailures() {
      bitField0_ = (bitField0_ & ~0x00100000);
      alwaysLogHealthCheckFailures_ = false;
      onChanged();
      return this;
    }

    private io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions tlsOptions_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions, io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptionsOrBuilder> tlsOptionsBuilder_;
    /**
     * <pre>
     * This allows overriding the cluster TLS settings, just for health check connections.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.TlsOptions tls_options = 21;</code>
     * @return Whether the tlsOptions field is set.
     */
    public boolean hasTlsOptions() {
      return ((bitField0_ & 0x00200000) != 0);
    }
    /**
     * <pre>
     * This allows overriding the cluster TLS settings, just for health check connections.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.TlsOptions tls_options = 21;</code>
     * @return The tlsOptions.
     */
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions getTlsOptions() {
      if (tlsOptionsBuilder_ == null) {
        return tlsOptions_ == null ? io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions.getDefaultInstance() : tlsOptions_;
      } else {
        return tlsOptionsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * This allows overriding the cluster TLS settings, just for health check connections.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.TlsOptions tls_options = 21;</code>
     */
    public Builder setTlsOptions(io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions value) {
      if (tlsOptionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        tlsOptions_ = value;
      } else {
        tlsOptionsBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00200000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * This allows overriding the cluster TLS settings, just for health check connections.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.TlsOptions tls_options = 21;</code>
     */
    public Builder setTlsOptions(
        io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions.Builder builderForValue) {
      if (tlsOptionsBuilder_ == null) {
        tlsOptions_ = builderForValue.build();
      } else {
        tlsOptionsBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00200000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * This allows overriding the cluster TLS settings, just for health check connections.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.TlsOptions tls_options = 21;</code>
     */
    public Builder mergeTlsOptions(io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions value) {
      if (tlsOptionsBuilder_ == null) {
        if (((bitField0_ & 0x00200000) != 0) &&
          tlsOptions_ != null &&
          tlsOptions_ != io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions.getDefaultInstance()) {
          getTlsOptionsBuilder().mergeFrom(value);
        } else {
          tlsOptions_ = value;
        }
      } else {
        tlsOptionsBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00200000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * This allows overriding the cluster TLS settings, just for health check connections.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.TlsOptions tls_options = 21;</code>
     */
    public Builder clearTlsOptions() {
      bitField0_ = (bitField0_ & ~0x00200000);
      tlsOptions_ = null;
      if (tlsOptionsBuilder_ != null) {
        tlsOptionsBuilder_.dispose();
        tlsOptionsBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * This allows overriding the cluster TLS settings, just for health check connections.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.TlsOptions tls_options = 21;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions.Builder getTlsOptionsBuilder() {
      bitField0_ |= 0x00200000;
      onChanged();
      return getTlsOptionsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * This allows overriding the cluster TLS settings, just for health check connections.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.TlsOptions tls_options = 21;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptionsOrBuilder getTlsOptionsOrBuilder() {
      if (tlsOptionsBuilder_ != null) {
        return tlsOptionsBuilder_.getMessageOrBuilder();
      } else {
        return tlsOptions_ == null ?
            io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions.getDefaultInstance() : tlsOptions_;
      }
    }
    /**
     * <pre>
     * This allows overriding the cluster TLS settings, just for health check connections.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HealthCheck.TlsOptions tls_options = 21;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions, io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptionsOrBuilder> 
        getTlsOptionsFieldBuilder() {
      if (tlsOptionsBuilder_ == null) {
        tlsOptionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions, io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptions.Builder, io.envoyproxy.envoy.config.core.v3.HealthCheck.TlsOptionsOrBuilder>(
                getTlsOptions(),
                getParentForChildren(),
                isClean());
        tlsOptions_ = null;
      }
      return tlsOptionsBuilder_;
    }

    private com.google.protobuf.Struct transportSocketMatchCriteria_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Struct, com.google.protobuf.Struct.Builder, com.google.protobuf.StructOrBuilder> transportSocketMatchCriteriaBuilder_;
    /**
     * <pre>
     * Optional key/value pairs that will be used to match a transport socket from those specified in the cluster's
     * :ref:`tranport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`.
     * For example, the following match criteria
     * .. code-block:: yaml
     *  transport_socket_match_criteria:
     *    useMTLS: true
     * Will match the following :ref:`cluster socket match &lt;envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;`
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "useMTLS"
     *    match:
     *      useMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     * If this field is set, then for health checks it will supersede an entry of ``envoy.transport_socket`` in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`.
     * This allows using different transport socket capabilities for health checking versus proxying to the
     * endpoint.
     * If the key/values pairs specified do not match any
     * :ref:`transport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`,
     * the cluster's :ref:`transport socket &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket&gt;`
     * will be used for health check socket configuration.
     * </pre>
     *
     * <code>.google.protobuf.Struct transport_socket_match_criteria = 23;</code>
     * @return Whether the transportSocketMatchCriteria field is set.
     */
    public boolean hasTransportSocketMatchCriteria() {
      return ((bitField0_ & 0x00400000) != 0);
    }
    /**
     * <pre>
     * Optional key/value pairs that will be used to match a transport socket from those specified in the cluster's
     * :ref:`tranport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`.
     * For example, the following match criteria
     * .. code-block:: yaml
     *  transport_socket_match_criteria:
     *    useMTLS: true
     * Will match the following :ref:`cluster socket match &lt;envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;`
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "useMTLS"
     *    match:
     *      useMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     * If this field is set, then for health checks it will supersede an entry of ``envoy.transport_socket`` in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`.
     * This allows using different transport socket capabilities for health checking versus proxying to the
     * endpoint.
     * If the key/values pairs specified do not match any
     * :ref:`transport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`,
     * the cluster's :ref:`transport socket &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket&gt;`
     * will be used for health check socket configuration.
     * </pre>
     *
     * <code>.google.protobuf.Struct transport_socket_match_criteria = 23;</code>
     * @return The transportSocketMatchCriteria.
     */
    public com.google.protobuf.Struct getTransportSocketMatchCriteria() {
      if (transportSocketMatchCriteriaBuilder_ == null) {
        return transportSocketMatchCriteria_ == null ? com.google.protobuf.Struct.getDefaultInstance() : transportSocketMatchCriteria_;
      } else {
        return transportSocketMatchCriteriaBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Optional key/value pairs that will be used to match a transport socket from those specified in the cluster's
     * :ref:`tranport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`.
     * For example, the following match criteria
     * .. code-block:: yaml
     *  transport_socket_match_criteria:
     *    useMTLS: true
     * Will match the following :ref:`cluster socket match &lt;envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;`
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "useMTLS"
     *    match:
     *      useMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     * If this field is set, then for health checks it will supersede an entry of ``envoy.transport_socket`` in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`.
     * This allows using different transport socket capabilities for health checking versus proxying to the
     * endpoint.
     * If the key/values pairs specified do not match any
     * :ref:`transport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`,
     * the cluster's :ref:`transport socket &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket&gt;`
     * will be used for health check socket configuration.
     * </pre>
     *
     * <code>.google.protobuf.Struct transport_socket_match_criteria = 23;</code>
     */
    public Builder setTransportSocketMatchCriteria(com.google.protobuf.Struct value) {
      if (transportSocketMatchCriteriaBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        transportSocketMatchCriteria_ = value;
      } else {
        transportSocketMatchCriteriaBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00400000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Optional key/value pairs that will be used to match a transport socket from those specified in the cluster's
     * :ref:`tranport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`.
     * For example, the following match criteria
     * .. code-block:: yaml
     *  transport_socket_match_criteria:
     *    useMTLS: true
     * Will match the following :ref:`cluster socket match &lt;envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;`
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "useMTLS"
     *    match:
     *      useMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     * If this field is set, then for health checks it will supersede an entry of ``envoy.transport_socket`` in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`.
     * This allows using different transport socket capabilities for health checking versus proxying to the
     * endpoint.
     * If the key/values pairs specified do not match any
     * :ref:`transport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`,
     * the cluster's :ref:`transport socket &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket&gt;`
     * will be used for health check socket configuration.
     * </pre>
     *
     * <code>.google.protobuf.Struct transport_socket_match_criteria = 23;</code>
     */
    public Builder setTransportSocketMatchCriteria(
        com.google.protobuf.Struct.Builder builderForValue) {
      if (transportSocketMatchCriteriaBuilder_ == null) {
        transportSocketMatchCriteria_ = builderForValue.build();
      } else {
        transportSocketMatchCriteriaBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00400000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Optional key/value pairs that will be used to match a transport socket from those specified in the cluster's
     * :ref:`tranport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`.
     * For example, the following match criteria
     * .. code-block:: yaml
     *  transport_socket_match_criteria:
     *    useMTLS: true
     * Will match the following :ref:`cluster socket match &lt;envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;`
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "useMTLS"
     *    match:
     *      useMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     * If this field is set, then for health checks it will supersede an entry of ``envoy.transport_socket`` in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`.
     * This allows using different transport socket capabilities for health checking versus proxying to the
     * endpoint.
     * If the key/values pairs specified do not match any
     * :ref:`transport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`,
     * the cluster's :ref:`transport socket &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket&gt;`
     * will be used for health check socket configuration.
     * </pre>
     *
     * <code>.google.protobuf.Struct transport_socket_match_criteria = 23;</code>
     */
    public Builder mergeTransportSocketMatchCriteria(com.google.protobuf.Struct value) {
      if (transportSocketMatchCriteriaBuilder_ == null) {
        if (((bitField0_ & 0x00400000) != 0) &&
          transportSocketMatchCriteria_ != null &&
          transportSocketMatchCriteria_ != com.google.protobuf.Struct.getDefaultInstance()) {
          getTransportSocketMatchCriteriaBuilder().mergeFrom(value);
        } else {
          transportSocketMatchCriteria_ = value;
        }
      } else {
        transportSocketMatchCriteriaBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00400000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Optional key/value pairs that will be used to match a transport socket from those specified in the cluster's
     * :ref:`tranport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`.
     * For example, the following match criteria
     * .. code-block:: yaml
     *  transport_socket_match_criteria:
     *    useMTLS: true
     * Will match the following :ref:`cluster socket match &lt;envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;`
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "useMTLS"
     *    match:
     *      useMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     * If this field is set, then for health checks it will supersede an entry of ``envoy.transport_socket`` in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`.
     * This allows using different transport socket capabilities for health checking versus proxying to the
     * endpoint.
     * If the key/values pairs specified do not match any
     * :ref:`transport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`,
     * the cluster's :ref:`transport socket &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket&gt;`
     * will be used for health check socket configuration.
     * </pre>
     *
     * <code>.google.protobuf.Struct transport_socket_match_criteria = 23;</code>
     */
    public Builder clearTransportSocketMatchCriteria() {
      bitField0_ = (bitField0_ & ~0x00400000);
      transportSocketMatchCriteria_ = null;
      if (transportSocketMatchCriteriaBuilder_ != null) {
        transportSocketMatchCriteriaBuilder_.dispose();
        transportSocketMatchCriteriaBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Optional key/value pairs that will be used to match a transport socket from those specified in the cluster's
     * :ref:`tranport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`.
     * For example, the following match criteria
     * .. code-block:: yaml
     *  transport_socket_match_criteria:
     *    useMTLS: true
     * Will match the following :ref:`cluster socket match &lt;envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;`
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "useMTLS"
     *    match:
     *      useMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     * If this field is set, then for health checks it will supersede an entry of ``envoy.transport_socket`` in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`.
     * This allows using different transport socket capabilities for health checking versus proxying to the
     * endpoint.
     * If the key/values pairs specified do not match any
     * :ref:`transport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`,
     * the cluster's :ref:`transport socket &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket&gt;`
     * will be used for health check socket configuration.
     * </pre>
     *
     * <code>.google.protobuf.Struct transport_socket_match_criteria = 23;</code>
     */
    public com.google.protobuf.Struct.Builder getTransportSocketMatchCriteriaBuilder() {
      bitField0_ |= 0x00400000;
      onChanged();
      return getTransportSocketMatchCriteriaFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Optional key/value pairs that will be used to match a transport socket from those specified in the cluster's
     * :ref:`tranport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`.
     * For example, the following match criteria
     * .. code-block:: yaml
     *  transport_socket_match_criteria:
     *    useMTLS: true
     * Will match the following :ref:`cluster socket match &lt;envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;`
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "useMTLS"
     *    match:
     *      useMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     * If this field is set, then for health checks it will supersede an entry of ``envoy.transport_socket`` in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`.
     * This allows using different transport socket capabilities for health checking versus proxying to the
     * endpoint.
     * If the key/values pairs specified do not match any
     * :ref:`transport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`,
     * the cluster's :ref:`transport socket &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket&gt;`
     * will be used for health check socket configuration.
     * </pre>
     *
     * <code>.google.protobuf.Struct transport_socket_match_criteria = 23;</code>
     */
    public com.google.protobuf.StructOrBuilder getTransportSocketMatchCriteriaOrBuilder() {
      if (transportSocketMatchCriteriaBuilder_ != null) {
        return transportSocketMatchCriteriaBuilder_.getMessageOrBuilder();
      } else {
        return transportSocketMatchCriteria_ == null ?
            com.google.protobuf.Struct.getDefaultInstance() : transportSocketMatchCriteria_;
      }
    }
    /**
     * <pre>
     * Optional key/value pairs that will be used to match a transport socket from those specified in the cluster's
     * :ref:`tranport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`.
     * For example, the following match criteria
     * .. code-block:: yaml
     *  transport_socket_match_criteria:
     *    useMTLS: true
     * Will match the following :ref:`cluster socket match &lt;envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch&gt;`
     * .. code-block:: yaml
     *  transport_socket_matches:
     *  - name: "useMTLS"
     *    match:
     *      useMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     * If this field is set, then for health checks it will supersede an entry of ``envoy.transport_socket`` in the
     * :ref:`LbEndpoint.Metadata &lt;envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata&gt;`.
     * This allows using different transport socket capabilities for health checking versus proxying to the
     * endpoint.
     * If the key/values pairs specified do not match any
     * :ref:`transport socket matches &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches&gt;`,
     * the cluster's :ref:`transport socket &lt;envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket&gt;`
     * will be used for health check socket configuration.
     * </pre>
     *
     * <code>.google.protobuf.Struct transport_socket_match_criteria = 23;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Struct, com.google.protobuf.Struct.Builder, com.google.protobuf.StructOrBuilder> 
        getTransportSocketMatchCriteriaFieldBuilder() {
      if (transportSocketMatchCriteriaBuilder_ == null) {
        transportSocketMatchCriteriaBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Struct, com.google.protobuf.Struct.Builder, com.google.protobuf.StructOrBuilder>(
                getTransportSocketMatchCriteria(),
                getParentForChildren(),
                isClean());
        transportSocketMatchCriteria_ = null;
      }
      return transportSocketMatchCriteriaBuilder_;
    }
    @java.lang.Override
    public final Builder setUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }


    // @@protoc_insertion_point(builder_scope:envoy.config.core.v3.HealthCheck)
  }

  // @@protoc_insertion_point(class_scope:envoy.config.core.v3.HealthCheck)
  private static final io.envoyproxy.envoy.config.core.v3.HealthCheck DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.core.v3.HealthCheck();
  }

  public static io.envoyproxy.envoy.config.core.v3.HealthCheck getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<HealthCheck>
      PARSER = new com.google.protobuf.AbstractParser<HealthCheck>() {
    @java.lang.Override
    public HealthCheck parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      Builder builder = newBuilder();
      try {
        builder.mergeFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(builder.buildPartial());
      } catch (com.google.protobuf.UninitializedMessageException e) {
        throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e)
            .setUnfinishedMessage(builder.buildPartial());
      }
      return builder.buildPartial();
    }
  };

  public static com.google.protobuf.Parser<HealthCheck> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<HealthCheck> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.HealthCheck getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}

