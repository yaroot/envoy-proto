// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/config/core/v3/protocol.proto

package io.envoyproxy.envoy.config.core.v3;

/**
 * <pre>
 * Config for keepalive probes in a QUIC connection.
 * Note that QUIC keep-alive probing packets work differently from HTTP/2 keep-alive PINGs in a sense that the probing packet
 * itself doesn't timeout waiting for a probing response. Quic has a shorter idle timeout than TCP, so it doesn't rely on such probing to discover dead connections. If the peer fails to respond, the connection will idle timeout eventually. Thus, they are configured differently from :ref:`connection_keepalive &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.connection_keepalive&gt;`.
 * </pre>
 *
 * Protobuf type {@code envoy.config.core.v3.QuicKeepAliveSettings}
 */
public final class QuicKeepAliveSettings extends
    com.google.protobuf.GeneratedMessageV3 implements
    // @@protoc_insertion_point(message_implements:envoy.config.core.v3.QuicKeepAliveSettings)
    QuicKeepAliveSettingsOrBuilder {
private static final long serialVersionUID = 0L;
  // Use QuicKeepAliveSettings.newBuilder() to construct.
  private QuicKeepAliveSettings(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }
  private QuicKeepAliveSettings() {
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(
      UnusedPrivateParameter unused) {
    return new QuicKeepAliveSettings();
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet
  getUnknownFields() {
    return this.unknownFields;
  }
  private QuicKeepAliveSettings(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 10: {
            com.google.protobuf.Duration.Builder subBuilder = null;
            if (maxInterval_ != null) {
              subBuilder = maxInterval_.toBuilder();
            }
            maxInterval_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(maxInterval_);
              maxInterval_ = subBuilder.buildPartial();
            }

            break;
          }
          case 18: {
            com.google.protobuf.Duration.Builder subBuilder = null;
            if (initialInterval_ != null) {
              subBuilder = initialInterval_.toBuilder();
            }
            initialInterval_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(initialInterval_);
              initialInterval_ = subBuilder.buildPartial();
            }

            break;
          }
          default: {
            if (!parseUnknownField(
                input, unknownFields, extensionRegistry, tag)) {
              done = true;
            }
            break;
          }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (com.google.protobuf.UninitializedMessageException e) {
      throw e.asInvalidProtocolBufferException().setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(
          e).setUnfinishedMessage(this);
    } finally {
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }
  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return io.envoyproxy.envoy.config.core.v3.ProtocolProto.internal_static_envoy_config_core_v3_QuicKeepAliveSettings_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return io.envoyproxy.envoy.config.core.v3.ProtocolProto.internal_static_envoy_config_core_v3_QuicKeepAliveSettings_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings.class, io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings.Builder.class);
  }

  public static final int MAX_INTERVAL_FIELD_NUMBER = 1;
  private com.google.protobuf.Duration maxInterval_;
  /**
   * <pre>
   * The max interval for a connection to send keep-alive probing packets (with PING or PATH_RESPONSE). The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout while not less than 1s to avoid throttling the connection or flooding the peer with probes.
   * If :ref:`initial_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.initial_interval&gt;` is absent or zero, a client connection will use this value to start probing.
   * If zero, disable keepalive probing.
   * If absent, use the QUICHE default interval to probe.
   * </pre>
   *
   * <code>.google.protobuf.Duration max_interval = 1 [(.validate.rules) = { ... }</code>
   * @return Whether the maxInterval field is set.
   */
  @java.lang.Override
  public boolean hasMaxInterval() {
    return maxInterval_ != null;
  }
  /**
   * <pre>
   * The max interval for a connection to send keep-alive probing packets (with PING or PATH_RESPONSE). The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout while not less than 1s to avoid throttling the connection or flooding the peer with probes.
   * If :ref:`initial_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.initial_interval&gt;` is absent or zero, a client connection will use this value to start probing.
   * If zero, disable keepalive probing.
   * If absent, use the QUICHE default interval to probe.
   * </pre>
   *
   * <code>.google.protobuf.Duration max_interval = 1 [(.validate.rules) = { ... }</code>
   * @return The maxInterval.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getMaxInterval() {
    return maxInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : maxInterval_;
  }
  /**
   * <pre>
   * The max interval for a connection to send keep-alive probing packets (with PING or PATH_RESPONSE). The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout while not less than 1s to avoid throttling the connection or flooding the peer with probes.
   * If :ref:`initial_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.initial_interval&gt;` is absent or zero, a client connection will use this value to start probing.
   * If zero, disable keepalive probing.
   * If absent, use the QUICHE default interval to probe.
   * </pre>
   *
   * <code>.google.protobuf.Duration max_interval = 1 [(.validate.rules) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getMaxIntervalOrBuilder() {
    return getMaxInterval();
  }

  public static final int INITIAL_INTERVAL_FIELD_NUMBER = 2;
  private com.google.protobuf.Duration initialInterval_;
  /**
   * <pre>
   * The interval to send the first few keep-alive probing packets to prevent connection from hitting the idle timeout. Subsequent probes will be sent, each one with an interval exponentially longer than previous one, till it reaches :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`. And the probes afterwards will always use :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`.
   * The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout and smaller than max_interval to take effect.
   * If absent or zero, disable keepalive probing for a server connection. For a client connection, if :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`  is also zero, do not keepalive, otherwise use max_interval or QUICHE default to probe all the time.
   * </pre>
   *
   * <code>.google.protobuf.Duration initial_interval = 2 [(.validate.rules) = { ... }</code>
   * @return Whether the initialInterval field is set.
   */
  @java.lang.Override
  public boolean hasInitialInterval() {
    return initialInterval_ != null;
  }
  /**
   * <pre>
   * The interval to send the first few keep-alive probing packets to prevent connection from hitting the idle timeout. Subsequent probes will be sent, each one with an interval exponentially longer than previous one, till it reaches :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`. And the probes afterwards will always use :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`.
   * The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout and smaller than max_interval to take effect.
   * If absent or zero, disable keepalive probing for a server connection. For a client connection, if :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`  is also zero, do not keepalive, otherwise use max_interval or QUICHE default to probe all the time.
   * </pre>
   *
   * <code>.google.protobuf.Duration initial_interval = 2 [(.validate.rules) = { ... }</code>
   * @return The initialInterval.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getInitialInterval() {
    return initialInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : initialInterval_;
  }
  /**
   * <pre>
   * The interval to send the first few keep-alive probing packets to prevent connection from hitting the idle timeout. Subsequent probes will be sent, each one with an interval exponentially longer than previous one, till it reaches :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`. And the probes afterwards will always use :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`.
   * The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout and smaller than max_interval to take effect.
   * If absent or zero, disable keepalive probing for a server connection. For a client connection, if :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`  is also zero, do not keepalive, otherwise use max_interval or QUICHE default to probe all the time.
   * </pre>
   *
   * <code>.google.protobuf.Duration initial_interval = 2 [(.validate.rules) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getInitialIntervalOrBuilder() {
    return getInitialInterval();
  }

  private byte memoizedIsInitialized = -1;
  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (maxInterval_ != null) {
      output.writeMessage(1, getMaxInterval());
    }
    if (initialInterval_ != null) {
      output.writeMessage(2, getInitialInterval());
    }
    unknownFields.writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (maxInterval_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(1, getMaxInterval());
    }
    if (initialInterval_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(2, getInitialInterval());
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
     return true;
    }
    if (!(obj instanceof io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings)) {
      return super.equals(obj);
    }
    io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings other = (io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings) obj;

    if (hasMaxInterval() != other.hasMaxInterval()) return false;
    if (hasMaxInterval()) {
      if (!getMaxInterval()
          .equals(other.getMaxInterval())) return false;
    }
    if (hasInitialInterval() != other.hasInitialInterval()) return false;
    if (hasInitialInterval()) {
      if (!getInitialInterval()
          .equals(other.getInitialInterval())) return false;
    }
    if (!unknownFields.equals(other.unknownFields)) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    if (hasMaxInterval()) {
      hash = (37 * hash) + MAX_INTERVAL_FIELD_NUMBER;
      hash = (53 * hash) + getMaxInterval().hashCode();
    }
    if (hasInitialInterval()) {
      hash = (37 * hash) + INITIAL_INTERVAL_FIELD_NUMBER;
      hash = (53 * hash) + getInitialInterval().hashCode();
    }
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input);
  }
  public static io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * <pre>
   * Config for keepalive probes in a QUIC connection.
   * Note that QUIC keep-alive probing packets work differently from HTTP/2 keep-alive PINGs in a sense that the probing packet
   * itself doesn't timeout waiting for a probing response. Quic has a shorter idle timeout than TCP, so it doesn't rely on such probing to discover dead connections. If the peer fails to respond, the connection will idle timeout eventually. Thus, they are configured differently from :ref:`connection_keepalive &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.connection_keepalive&gt;`.
   * </pre>
   *
   * Protobuf type {@code envoy.config.core.v3.QuicKeepAliveSettings}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:envoy.config.core.v3.QuicKeepAliveSettings)
      io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettingsOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.config.core.v3.ProtocolProto.internal_static_envoy_config_core_v3_QuicKeepAliveSettings_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.config.core.v3.ProtocolProto.internal_static_envoy_config_core_v3_QuicKeepAliveSettings_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings.class, io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings.Builder.class);
    }

    // Construct using io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }
    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3
              .alwaysUseFieldBuilders) {
      }
    }
    @java.lang.Override
    public Builder clear() {
      super.clear();
      if (maxIntervalBuilder_ == null) {
        maxInterval_ = null;
      } else {
        maxInterval_ = null;
        maxIntervalBuilder_ = null;
      }
      if (initialIntervalBuilder_ == null) {
        initialInterval_ = null;
      } else {
        initialInterval_ = null;
        initialIntervalBuilder_ = null;
      }
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return io.envoyproxy.envoy.config.core.v3.ProtocolProto.internal_static_envoy_config_core_v3_QuicKeepAliveSettings_descriptor;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings getDefaultInstanceForType() {
      return io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings.getDefaultInstance();
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings build() {
      io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings buildPartial() {
      io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings result = new io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings(this);
      if (maxIntervalBuilder_ == null) {
        result.maxInterval_ = maxInterval_;
      } else {
        result.maxInterval_ = maxIntervalBuilder_.build();
      }
      if (initialIntervalBuilder_ == null) {
        result.initialInterval_ = initialInterval_;
      } else {
        result.initialInterval_ = initialIntervalBuilder_.build();
      }
      onBuilt();
      return result;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }
    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.setField(field, value);
    }
    @java.lang.Override
    public Builder clearField(
        com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }
    @java.lang.Override
    public Builder clearOneof(
        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }
    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }
    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }
    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings) {
        return mergeFrom((io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings)other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings other) {
      if (other == io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings.getDefaultInstance()) return this;
      if (other.hasMaxInterval()) {
        mergeMaxInterval(other.getMaxInterval());
      }
      if (other.hasInitialInterval()) {
        mergeInitialInterval(other.getInitialInterval());
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }

    private com.google.protobuf.Duration maxInterval_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> maxIntervalBuilder_;
    /**
     * <pre>
     * The max interval for a connection to send keep-alive probing packets (with PING or PATH_RESPONSE). The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout while not less than 1s to avoid throttling the connection or flooding the peer with probes.
     * If :ref:`initial_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.initial_interval&gt;` is absent or zero, a client connection will use this value to start probing.
     * If zero, disable keepalive probing.
     * If absent, use the QUICHE default interval to probe.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_interval = 1 [(.validate.rules) = { ... }</code>
     * @return Whether the maxInterval field is set.
     */
    public boolean hasMaxInterval() {
      return maxIntervalBuilder_ != null || maxInterval_ != null;
    }
    /**
     * <pre>
     * The max interval for a connection to send keep-alive probing packets (with PING or PATH_RESPONSE). The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout while not less than 1s to avoid throttling the connection or flooding the peer with probes.
     * If :ref:`initial_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.initial_interval&gt;` is absent or zero, a client connection will use this value to start probing.
     * If zero, disable keepalive probing.
     * If absent, use the QUICHE default interval to probe.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_interval = 1 [(.validate.rules) = { ... }</code>
     * @return The maxInterval.
     */
    public com.google.protobuf.Duration getMaxInterval() {
      if (maxIntervalBuilder_ == null) {
        return maxInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : maxInterval_;
      } else {
        return maxIntervalBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The max interval for a connection to send keep-alive probing packets (with PING or PATH_RESPONSE). The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout while not less than 1s to avoid throttling the connection or flooding the peer with probes.
     * If :ref:`initial_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.initial_interval&gt;` is absent or zero, a client connection will use this value to start probing.
     * If zero, disable keepalive probing.
     * If absent, use the QUICHE default interval to probe.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_interval = 1 [(.validate.rules) = { ... }</code>
     */
    public Builder setMaxInterval(com.google.protobuf.Duration value) {
      if (maxIntervalBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        maxInterval_ = value;
        onChanged();
      } else {
        maxIntervalBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * The max interval for a connection to send keep-alive probing packets (with PING or PATH_RESPONSE). The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout while not less than 1s to avoid throttling the connection or flooding the peer with probes.
     * If :ref:`initial_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.initial_interval&gt;` is absent or zero, a client connection will use this value to start probing.
     * If zero, disable keepalive probing.
     * If absent, use the QUICHE default interval to probe.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_interval = 1 [(.validate.rules) = { ... }</code>
     */
    public Builder setMaxInterval(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (maxIntervalBuilder_ == null) {
        maxInterval_ = builderForValue.build();
        onChanged();
      } else {
        maxIntervalBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * The max interval for a connection to send keep-alive probing packets (with PING or PATH_RESPONSE). The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout while not less than 1s to avoid throttling the connection or flooding the peer with probes.
     * If :ref:`initial_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.initial_interval&gt;` is absent or zero, a client connection will use this value to start probing.
     * If zero, disable keepalive probing.
     * If absent, use the QUICHE default interval to probe.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_interval = 1 [(.validate.rules) = { ... }</code>
     */
    public Builder mergeMaxInterval(com.google.protobuf.Duration value) {
      if (maxIntervalBuilder_ == null) {
        if (maxInterval_ != null) {
          maxInterval_ =
            com.google.protobuf.Duration.newBuilder(maxInterval_).mergeFrom(value).buildPartial();
        } else {
          maxInterval_ = value;
        }
        onChanged();
      } else {
        maxIntervalBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * The max interval for a connection to send keep-alive probing packets (with PING or PATH_RESPONSE). The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout while not less than 1s to avoid throttling the connection or flooding the peer with probes.
     * If :ref:`initial_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.initial_interval&gt;` is absent or zero, a client connection will use this value to start probing.
     * If zero, disable keepalive probing.
     * If absent, use the QUICHE default interval to probe.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_interval = 1 [(.validate.rules) = { ... }</code>
     */
    public Builder clearMaxInterval() {
      if (maxIntervalBuilder_ == null) {
        maxInterval_ = null;
        onChanged();
      } else {
        maxInterval_ = null;
        maxIntervalBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * The max interval for a connection to send keep-alive probing packets (with PING or PATH_RESPONSE). The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout while not less than 1s to avoid throttling the connection or flooding the peer with probes.
     * If :ref:`initial_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.initial_interval&gt;` is absent or zero, a client connection will use this value to start probing.
     * If zero, disable keepalive probing.
     * If absent, use the QUICHE default interval to probe.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_interval = 1 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.Duration.Builder getMaxIntervalBuilder() {
      
      onChanged();
      return getMaxIntervalFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The max interval for a connection to send keep-alive probing packets (with PING or PATH_RESPONSE). The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout while not less than 1s to avoid throttling the connection or flooding the peer with probes.
     * If :ref:`initial_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.initial_interval&gt;` is absent or zero, a client connection will use this value to start probing.
     * If zero, disable keepalive probing.
     * If absent, use the QUICHE default interval to probe.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_interval = 1 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.DurationOrBuilder getMaxIntervalOrBuilder() {
      if (maxIntervalBuilder_ != null) {
        return maxIntervalBuilder_.getMessageOrBuilder();
      } else {
        return maxInterval_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : maxInterval_;
      }
    }
    /**
     * <pre>
     * The max interval for a connection to send keep-alive probing packets (with PING or PATH_RESPONSE). The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout while not less than 1s to avoid throttling the connection or flooding the peer with probes.
     * If :ref:`initial_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.initial_interval&gt;` is absent or zero, a client connection will use this value to start probing.
     * If zero, disable keepalive probing.
     * If absent, use the QUICHE default interval to probe.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_interval = 1 [(.validate.rules) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getMaxIntervalFieldBuilder() {
      if (maxIntervalBuilder_ == null) {
        maxIntervalBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getMaxInterval(),
                getParentForChildren(),
                isClean());
        maxInterval_ = null;
      }
      return maxIntervalBuilder_;
    }

    private com.google.protobuf.Duration initialInterval_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> initialIntervalBuilder_;
    /**
     * <pre>
     * The interval to send the first few keep-alive probing packets to prevent connection from hitting the idle timeout. Subsequent probes will be sent, each one with an interval exponentially longer than previous one, till it reaches :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`. And the probes afterwards will always use :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`.
     * The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout and smaller than max_interval to take effect.
     * If absent or zero, disable keepalive probing for a server connection. For a client connection, if :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`  is also zero, do not keepalive, otherwise use max_interval or QUICHE default to probe all the time.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_interval = 2 [(.validate.rules) = { ... }</code>
     * @return Whether the initialInterval field is set.
     */
    public boolean hasInitialInterval() {
      return initialIntervalBuilder_ != null || initialInterval_ != null;
    }
    /**
     * <pre>
     * The interval to send the first few keep-alive probing packets to prevent connection from hitting the idle timeout. Subsequent probes will be sent, each one with an interval exponentially longer than previous one, till it reaches :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`. And the probes afterwards will always use :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`.
     * The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout and smaller than max_interval to take effect.
     * If absent or zero, disable keepalive probing for a server connection. For a client connection, if :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`  is also zero, do not keepalive, otherwise use max_interval or QUICHE default to probe all the time.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_interval = 2 [(.validate.rules) = { ... }</code>
     * @return The initialInterval.
     */
    public com.google.protobuf.Duration getInitialInterval() {
      if (initialIntervalBuilder_ == null) {
        return initialInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : initialInterval_;
      } else {
        return initialIntervalBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The interval to send the first few keep-alive probing packets to prevent connection from hitting the idle timeout. Subsequent probes will be sent, each one with an interval exponentially longer than previous one, till it reaches :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`. And the probes afterwards will always use :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`.
     * The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout and smaller than max_interval to take effect.
     * If absent or zero, disable keepalive probing for a server connection. For a client connection, if :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`  is also zero, do not keepalive, otherwise use max_interval or QUICHE default to probe all the time.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_interval = 2 [(.validate.rules) = { ... }</code>
     */
    public Builder setInitialInterval(com.google.protobuf.Duration value) {
      if (initialIntervalBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        initialInterval_ = value;
        onChanged();
      } else {
        initialIntervalBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * The interval to send the first few keep-alive probing packets to prevent connection from hitting the idle timeout. Subsequent probes will be sent, each one with an interval exponentially longer than previous one, till it reaches :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`. And the probes afterwards will always use :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`.
     * The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout and smaller than max_interval to take effect.
     * If absent or zero, disable keepalive probing for a server connection. For a client connection, if :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`  is also zero, do not keepalive, otherwise use max_interval or QUICHE default to probe all the time.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_interval = 2 [(.validate.rules) = { ... }</code>
     */
    public Builder setInitialInterval(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (initialIntervalBuilder_ == null) {
        initialInterval_ = builderForValue.build();
        onChanged();
      } else {
        initialIntervalBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * The interval to send the first few keep-alive probing packets to prevent connection from hitting the idle timeout. Subsequent probes will be sent, each one with an interval exponentially longer than previous one, till it reaches :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`. And the probes afterwards will always use :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`.
     * The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout and smaller than max_interval to take effect.
     * If absent or zero, disable keepalive probing for a server connection. For a client connection, if :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`  is also zero, do not keepalive, otherwise use max_interval or QUICHE default to probe all the time.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_interval = 2 [(.validate.rules) = { ... }</code>
     */
    public Builder mergeInitialInterval(com.google.protobuf.Duration value) {
      if (initialIntervalBuilder_ == null) {
        if (initialInterval_ != null) {
          initialInterval_ =
            com.google.protobuf.Duration.newBuilder(initialInterval_).mergeFrom(value).buildPartial();
        } else {
          initialInterval_ = value;
        }
        onChanged();
      } else {
        initialIntervalBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * The interval to send the first few keep-alive probing packets to prevent connection from hitting the idle timeout. Subsequent probes will be sent, each one with an interval exponentially longer than previous one, till it reaches :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`. And the probes afterwards will always use :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`.
     * The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout and smaller than max_interval to take effect.
     * If absent or zero, disable keepalive probing for a server connection. For a client connection, if :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`  is also zero, do not keepalive, otherwise use max_interval or QUICHE default to probe all the time.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_interval = 2 [(.validate.rules) = { ... }</code>
     */
    public Builder clearInitialInterval() {
      if (initialIntervalBuilder_ == null) {
        initialInterval_ = null;
        onChanged();
      } else {
        initialInterval_ = null;
        initialIntervalBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * The interval to send the first few keep-alive probing packets to prevent connection from hitting the idle timeout. Subsequent probes will be sent, each one with an interval exponentially longer than previous one, till it reaches :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`. And the probes afterwards will always use :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`.
     * The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout and smaller than max_interval to take effect.
     * If absent or zero, disable keepalive probing for a server connection. For a client connection, if :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`  is also zero, do not keepalive, otherwise use max_interval or QUICHE default to probe all the time.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_interval = 2 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.Duration.Builder getInitialIntervalBuilder() {
      
      onChanged();
      return getInitialIntervalFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The interval to send the first few keep-alive probing packets to prevent connection from hitting the idle timeout. Subsequent probes will be sent, each one with an interval exponentially longer than previous one, till it reaches :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`. And the probes afterwards will always use :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`.
     * The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout and smaller than max_interval to take effect.
     * If absent or zero, disable keepalive probing for a server connection. For a client connection, if :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`  is also zero, do not keepalive, otherwise use max_interval or QUICHE default to probe all the time.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_interval = 2 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.DurationOrBuilder getInitialIntervalOrBuilder() {
      if (initialIntervalBuilder_ != null) {
        return initialIntervalBuilder_.getMessageOrBuilder();
      } else {
        return initialInterval_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : initialInterval_;
      }
    }
    /**
     * <pre>
     * The interval to send the first few keep-alive probing packets to prevent connection from hitting the idle timeout. Subsequent probes will be sent, each one with an interval exponentially longer than previous one, till it reaches :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`. And the probes afterwards will always use :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`.
     * The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout&gt;` to prevent idle timeout and smaller than max_interval to take effect.
     * If absent or zero, disable keepalive probing for a server connection. For a client connection, if :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval&gt;`  is also zero, do not keepalive, otherwise use max_interval or QUICHE default to probe all the time.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_interval = 2 [(.validate.rules) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getInitialIntervalFieldBuilder() {
      if (initialIntervalBuilder_ == null) {
        initialIntervalBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getInitialInterval(),
                getParentForChildren(),
                isClean());
        initialInterval_ = null;
      }
      return initialIntervalBuilder_;
    }
    @java.lang.Override
    public final Builder setUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }


    // @@protoc_insertion_point(builder_scope:envoy.config.core.v3.QuicKeepAliveSettings)
  }

  // @@protoc_insertion_point(class_scope:envoy.config.core.v3.QuicKeepAliveSettings)
  private static final io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings();
  }

  public static io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<QuicKeepAliveSettings>
      PARSER = new com.google.protobuf.AbstractParser<QuicKeepAliveSettings>() {
    @java.lang.Override
    public QuicKeepAliveSettings parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return new QuicKeepAliveSettings(input, extensionRegistry);
    }
  };

  public static com.google.protobuf.Parser<QuicKeepAliveSettings> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<QuicKeepAliveSettings> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}

