// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/config/core/v3/protocol.proto

package io.envoyproxy.envoy.config.core.v3;

public interface QuicProtocolOptionsOrBuilder extends
    // @@protoc_insertion_point(interface_extends:envoy.config.core.v3.QuicProtocolOptions)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * Maximum number of streams that the client can negotiate per connection. 100
   * if not specified.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_concurrent_streams = 1 [(.validate.rules) = { ... }</code>
   * @return Whether the maxConcurrentStreams field is set.
   */
  boolean hasMaxConcurrentStreams();
  /**
   * <pre>
   * Maximum number of streams that the client can negotiate per connection. 100
   * if not specified.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_concurrent_streams = 1 [(.validate.rules) = { ... }</code>
   * @return The maxConcurrentStreams.
   */
  com.google.protobuf.UInt32Value getMaxConcurrentStreams();
  /**
   * <pre>
   * Maximum number of streams that the client can negotiate per connection. 100
   * if not specified.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_concurrent_streams = 1 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getMaxConcurrentStreamsOrBuilder();

  /**
   * <pre>
   * `Initial stream-level flow-control receive window
   * &lt;https://tools.ietf.org/html/draft-ietf-quic-transport-34#section-4.1&gt;`_ size. Valid values range from
   * 1 to 16777216 (2^24, maximum supported by QUICHE) and defaults to 65536 (2^16).
   * NOTE: 16384 (2^14) is the minimum window size supported in Google QUIC. If configured smaller than it, we will use 16384 instead.
   * QUICHE IETF Quic implementation supports 1 bytes window. We only support increasing the default window size now, so it's also the minimum.
   * This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the
   * QUIC stream send and receive buffers. Once the buffer reaches this pointer, watermark callbacks will fire to
   * stop the flow of data to the stream buffers.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value initial_stream_window_size = 2 [(.validate.rules) = { ... }</code>
   * @return Whether the initialStreamWindowSize field is set.
   */
  boolean hasInitialStreamWindowSize();
  /**
   * <pre>
   * `Initial stream-level flow-control receive window
   * &lt;https://tools.ietf.org/html/draft-ietf-quic-transport-34#section-4.1&gt;`_ size. Valid values range from
   * 1 to 16777216 (2^24, maximum supported by QUICHE) and defaults to 65536 (2^16).
   * NOTE: 16384 (2^14) is the minimum window size supported in Google QUIC. If configured smaller than it, we will use 16384 instead.
   * QUICHE IETF Quic implementation supports 1 bytes window. We only support increasing the default window size now, so it's also the minimum.
   * This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the
   * QUIC stream send and receive buffers. Once the buffer reaches this pointer, watermark callbacks will fire to
   * stop the flow of data to the stream buffers.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value initial_stream_window_size = 2 [(.validate.rules) = { ... }</code>
   * @return The initialStreamWindowSize.
   */
  com.google.protobuf.UInt32Value getInitialStreamWindowSize();
  /**
   * <pre>
   * `Initial stream-level flow-control receive window
   * &lt;https://tools.ietf.org/html/draft-ietf-quic-transport-34#section-4.1&gt;`_ size. Valid values range from
   * 1 to 16777216 (2^24, maximum supported by QUICHE) and defaults to 65536 (2^16).
   * NOTE: 16384 (2^14) is the minimum window size supported in Google QUIC. If configured smaller than it, we will use 16384 instead.
   * QUICHE IETF Quic implementation supports 1 bytes window. We only support increasing the default window size now, so it's also the minimum.
   * This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the
   * QUIC stream send and receive buffers. Once the buffer reaches this pointer, watermark callbacks will fire to
   * stop the flow of data to the stream buffers.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value initial_stream_window_size = 2 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getInitialStreamWindowSizeOrBuilder();

  /**
   * <pre>
   * Similar to ``initial_stream_window_size``, but for connection-level
   * flow-control. Valid values rage from 1 to 25165824 (24MB, maximum supported by QUICHE) and defaults to 65536 (2^16).
   * window. Currently, this has the same minimum/default as ``initial_stream_window_size``.
   * NOTE: 16384 (2^14) is the minimum window size supported in Google QUIC. We only support increasing the default
   * window size now, so it's also the minimum.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value initial_connection_window_size = 3 [(.validate.rules) = { ... }</code>
   * @return Whether the initialConnectionWindowSize field is set.
   */
  boolean hasInitialConnectionWindowSize();
  /**
   * <pre>
   * Similar to ``initial_stream_window_size``, but for connection-level
   * flow-control. Valid values rage from 1 to 25165824 (24MB, maximum supported by QUICHE) and defaults to 65536 (2^16).
   * window. Currently, this has the same minimum/default as ``initial_stream_window_size``.
   * NOTE: 16384 (2^14) is the minimum window size supported in Google QUIC. We only support increasing the default
   * window size now, so it's also the minimum.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value initial_connection_window_size = 3 [(.validate.rules) = { ... }</code>
   * @return The initialConnectionWindowSize.
   */
  com.google.protobuf.UInt32Value getInitialConnectionWindowSize();
  /**
   * <pre>
   * Similar to ``initial_stream_window_size``, but for connection-level
   * flow-control. Valid values rage from 1 to 25165824 (24MB, maximum supported by QUICHE) and defaults to 65536 (2^16).
   * window. Currently, this has the same minimum/default as ``initial_stream_window_size``.
   * NOTE: 16384 (2^14) is the minimum window size supported in Google QUIC. We only support increasing the default
   * window size now, so it's also the minimum.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value initial_connection_window_size = 3 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getInitialConnectionWindowSizeOrBuilder();

  /**
   * <pre>
   * The number of timeouts that can occur before port migration is triggered for QUIC clients.
   * This defaults to 1. If set to 0, port migration will not occur on path degrading.
   * Timeout here refers to QUIC internal path degrading timeout mechanism, such as PTO.
   * This has no effect on server sessions.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value num_timeouts_to_trigger_port_migration = 4 [(.validate.rules) = { ... }</code>
   * @return Whether the numTimeoutsToTriggerPortMigration field is set.
   */
  boolean hasNumTimeoutsToTriggerPortMigration();
  /**
   * <pre>
   * The number of timeouts that can occur before port migration is triggered for QUIC clients.
   * This defaults to 1. If set to 0, port migration will not occur on path degrading.
   * Timeout here refers to QUIC internal path degrading timeout mechanism, such as PTO.
   * This has no effect on server sessions.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value num_timeouts_to_trigger_port_migration = 4 [(.validate.rules) = { ... }</code>
   * @return The numTimeoutsToTriggerPortMigration.
   */
  com.google.protobuf.UInt32Value getNumTimeoutsToTriggerPortMigration();
  /**
   * <pre>
   * The number of timeouts that can occur before port migration is triggered for QUIC clients.
   * This defaults to 1. If set to 0, port migration will not occur on path degrading.
   * Timeout here refers to QUIC internal path degrading timeout mechanism, such as PTO.
   * This has no effect on server sessions.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value num_timeouts_to_trigger_port_migration = 4 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getNumTimeoutsToTriggerPortMigrationOrBuilder();

  /**
   * <pre>
   * Probes the peer at the configured interval to solicit traffic, i.e. ACK or PATH_RESPONSE, from the peer to push back connection idle timeout.
   * If absent, use the default keepalive behavior of which a client connection sends PINGs every 15s, and a server connection doesn't do anything.
   * </pre>
   *
   * <code>.envoy.config.core.v3.QuicKeepAliveSettings connection_keepalive = 5;</code>
   * @return Whether the connectionKeepalive field is set.
   */
  boolean hasConnectionKeepalive();
  /**
   * <pre>
   * Probes the peer at the configured interval to solicit traffic, i.e. ACK or PATH_RESPONSE, from the peer to push back connection idle timeout.
   * If absent, use the default keepalive behavior of which a client connection sends PINGs every 15s, and a server connection doesn't do anything.
   * </pre>
   *
   * <code>.envoy.config.core.v3.QuicKeepAliveSettings connection_keepalive = 5;</code>
   * @return The connectionKeepalive.
   */
  io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettings getConnectionKeepalive();
  /**
   * <pre>
   * Probes the peer at the configured interval to solicit traffic, i.e. ACK or PATH_RESPONSE, from the peer to push back connection idle timeout.
   * If absent, use the default keepalive behavior of which a client connection sends PINGs every 15s, and a server connection doesn't do anything.
   * </pre>
   *
   * <code>.envoy.config.core.v3.QuicKeepAliveSettings connection_keepalive = 5;</code>
   */
  io.envoyproxy.envoy.config.core.v3.QuicKeepAliveSettingsOrBuilder getConnectionKeepaliveOrBuilder();
}
