// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/api/v2/route/route_components.proto

package io.envoyproxy.envoy.api.v2.route;

public interface RouteMatchOrBuilder extends
    // @@protoc_insertion_point(interface_extends:envoy.api.v2.route.RouteMatch)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * If specified, the route is a prefix rule meaning that the prefix must
   * match the beginning of the *:path* header.
   * </pre>
   *
   * <code>string prefix = 1;</code>
   * @return Whether the prefix field is set.
   */
  boolean hasPrefix();
  /**
   * <pre>
   * If specified, the route is a prefix rule meaning that the prefix must
   * match the beginning of the *:path* header.
   * </pre>
   *
   * <code>string prefix = 1;</code>
   * @return The prefix.
   */
  java.lang.String getPrefix();
  /**
   * <pre>
   * If specified, the route is a prefix rule meaning that the prefix must
   * match the beginning of the *:path* header.
   * </pre>
   *
   * <code>string prefix = 1;</code>
   * @return The bytes for prefix.
   */
  com.google.protobuf.ByteString
      getPrefixBytes();

  /**
   * <pre>
   * If specified, the route is an exact path rule meaning that the path must
   * exactly match the *:path* header once the query string is removed.
   * </pre>
   *
   * <code>string path = 2;</code>
   * @return Whether the path field is set.
   */
  boolean hasPath();
  /**
   * <pre>
   * If specified, the route is an exact path rule meaning that the path must
   * exactly match the *:path* header once the query string is removed.
   * </pre>
   *
   * <code>string path = 2;</code>
   * @return The path.
   */
  java.lang.String getPath();
  /**
   * <pre>
   * If specified, the route is an exact path rule meaning that the path must
   * exactly match the *:path* header once the query string is removed.
   * </pre>
   *
   * <code>string path = 2;</code>
   * @return The bytes for path.
   */
  com.google.protobuf.ByteString
      getPathBytes();

  /**
   * <pre>
   * If specified, the route is a regular expression rule meaning that the
   * regex must match the *:path* header once the query string is removed. The entire path
   * (without the query string) must match the regex. The rule will not match if only a
   * subsequence of the *:path* header matches the regex. The regex grammar is defined `here
   * &lt;https://en.cppreference.com/w/cpp/regex/ecmascript&gt;`_.
   * Examples:
   * * The regex ``/b[io]t`` matches the path *&#47;bit*
   * * The regex ``/b[io]t`` matches the path *&#47;bot*
   * * The regex ``/b[io]t`` does not match the path *&#47;bite*
   * * The regex ``/b[io]t`` does not match the path *&#47;bit/bot*
   * .. attention::
   *   This field has been deprecated in favor of `safe_regex` as it is not safe for use with
   *   untrusted input in all cases.
   * </pre>
   *
   * <code>string regex = 3 [deprecated = true, (.validate.rules) = { ... }</code>
   * @deprecated envoy.api.v2.route.RouteMatch.regex is deprecated.
   *     See envoy/api/v2/route/route_components.proto;l=418
   * @return Whether the regex field is set.
   */
  @java.lang.Deprecated boolean hasRegex();
  /**
   * <pre>
   * If specified, the route is a regular expression rule meaning that the
   * regex must match the *:path* header once the query string is removed. The entire path
   * (without the query string) must match the regex. The rule will not match if only a
   * subsequence of the *:path* header matches the regex. The regex grammar is defined `here
   * &lt;https://en.cppreference.com/w/cpp/regex/ecmascript&gt;`_.
   * Examples:
   * * The regex ``/b[io]t`` matches the path *&#47;bit*
   * * The regex ``/b[io]t`` matches the path *&#47;bot*
   * * The regex ``/b[io]t`` does not match the path *&#47;bite*
   * * The regex ``/b[io]t`` does not match the path *&#47;bit/bot*
   * .. attention::
   *   This field has been deprecated in favor of `safe_regex` as it is not safe for use with
   *   untrusted input in all cases.
   * </pre>
   *
   * <code>string regex = 3 [deprecated = true, (.validate.rules) = { ... }</code>
   * @deprecated envoy.api.v2.route.RouteMatch.regex is deprecated.
   *     See envoy/api/v2/route/route_components.proto;l=418
   * @return The regex.
   */
  @java.lang.Deprecated java.lang.String getRegex();
  /**
   * <pre>
   * If specified, the route is a regular expression rule meaning that the
   * regex must match the *:path* header once the query string is removed. The entire path
   * (without the query string) must match the regex. The rule will not match if only a
   * subsequence of the *:path* header matches the regex. The regex grammar is defined `here
   * &lt;https://en.cppreference.com/w/cpp/regex/ecmascript&gt;`_.
   * Examples:
   * * The regex ``/b[io]t`` matches the path *&#47;bit*
   * * The regex ``/b[io]t`` matches the path *&#47;bot*
   * * The regex ``/b[io]t`` does not match the path *&#47;bite*
   * * The regex ``/b[io]t`` does not match the path *&#47;bit/bot*
   * .. attention::
   *   This field has been deprecated in favor of `safe_regex` as it is not safe for use with
   *   untrusted input in all cases.
   * </pre>
   *
   * <code>string regex = 3 [deprecated = true, (.validate.rules) = { ... }</code>
   * @deprecated envoy.api.v2.route.RouteMatch.regex is deprecated.
   *     See envoy/api/v2/route/route_components.proto;l=418
   * @return The bytes for regex.
   */
  @java.lang.Deprecated com.google.protobuf.ByteString
      getRegexBytes();

  /**
   * <pre>
   * If specified, the route is a regular expression rule meaning that the
   * regex must match the *:path* header once the query string is removed. The entire path
   * (without the query string) must match the regex. The rule will not match if only a
   * subsequence of the *:path* header matches the regex.
   * [#next-major-version: In the v3 API we should redo how path specification works such
   * that we utilize StringMatcher, and additionally have consistent options around whether we
   * strip query strings, do a case sensitive match, etc. In the interim it will be too disruptive
   * to deprecate the existing options. We should even consider whether we want to do away with
   * path_specifier entirely and just rely on a set of header matchers which can already match
   * on :path, etc. The issue with that is it is unclear how to generically deal with query string
   * stripping. This needs more thought.]
   * </pre>
   *
   * <code>.envoy.type.matcher.RegexMatcher safe_regex = 10 [(.validate.rules) = { ... }</code>
   * @return Whether the safeRegex field is set.
   */
  boolean hasSafeRegex();
  /**
   * <pre>
   * If specified, the route is a regular expression rule meaning that the
   * regex must match the *:path* header once the query string is removed. The entire path
   * (without the query string) must match the regex. The rule will not match if only a
   * subsequence of the *:path* header matches the regex.
   * [#next-major-version: In the v3 API we should redo how path specification works such
   * that we utilize StringMatcher, and additionally have consistent options around whether we
   * strip query strings, do a case sensitive match, etc. In the interim it will be too disruptive
   * to deprecate the existing options. We should even consider whether we want to do away with
   * path_specifier entirely and just rely on a set of header matchers which can already match
   * on :path, etc. The issue with that is it is unclear how to generically deal with query string
   * stripping. This needs more thought.]
   * </pre>
   *
   * <code>.envoy.type.matcher.RegexMatcher safe_regex = 10 [(.validate.rules) = { ... }</code>
   * @return The safeRegex.
   */
  io.envoyproxy.envoy.type.matcher.RegexMatcher getSafeRegex();
  /**
   * <pre>
   * If specified, the route is a regular expression rule meaning that the
   * regex must match the *:path* header once the query string is removed. The entire path
   * (without the query string) must match the regex. The rule will not match if only a
   * subsequence of the *:path* header matches the regex.
   * [#next-major-version: In the v3 API we should redo how path specification works such
   * that we utilize StringMatcher, and additionally have consistent options around whether we
   * strip query strings, do a case sensitive match, etc. In the interim it will be too disruptive
   * to deprecate the existing options. We should even consider whether we want to do away with
   * path_specifier entirely and just rely on a set of header matchers which can already match
   * on :path, etc. The issue with that is it is unclear how to generically deal with query string
   * stripping. This needs more thought.]
   * </pre>
   *
   * <code>.envoy.type.matcher.RegexMatcher safe_regex = 10 [(.validate.rules) = { ... }</code>
   */
  io.envoyproxy.envoy.type.matcher.RegexMatcherOrBuilder getSafeRegexOrBuilder();

  /**
   * <pre>
   * Indicates that prefix/path matching should be case sensitive. The default
   * is true.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue case_sensitive = 4;</code>
   * @return Whether the caseSensitive field is set.
   */
  boolean hasCaseSensitive();
  /**
   * <pre>
   * Indicates that prefix/path matching should be case sensitive. The default
   * is true.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue case_sensitive = 4;</code>
   * @return The caseSensitive.
   */
  com.google.protobuf.BoolValue getCaseSensitive();
  /**
   * <pre>
   * Indicates that prefix/path matching should be case sensitive. The default
   * is true.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue case_sensitive = 4;</code>
   */
  com.google.protobuf.BoolValueOrBuilder getCaseSensitiveOrBuilder();

  /**
   * <pre>
   * Indicates that the route should additionally match on a runtime key. Every time the route
   * is considered for a match, it must also fall under the percentage of matches indicated by
   * this field. For some fraction N/D, a random number in the range [0,D) is selected. If the
   * number is &lt;= the value of the numerator N, or if the key is not present, the default
   * value, the router continues to evaluate the remaining match criteria. A runtime_fraction
   * route configuration can be used to roll out route changes in a gradual manner without full
   * code/config deploys. Refer to the :ref:`traffic shifting
   * &lt;config_http_conn_man_route_table_traffic_splitting_shift&gt;` docs for additional documentation.
   * .. note::
   *    Parsing this field is implemented such that the runtime key's data may be represented
   *    as a FractionalPercent proto represented as JSON/YAML and may also be represented as an
   *    integer with the assumption that the value is an integral percentage out of 100. For
   *    instance, a runtime key lookup returning the value "42" would parse as a FractionalPercent
   *    whose numerator is 42 and denominator is HUNDRED. This preserves legacy semantics.
   * </pre>
   *
   * <code>.envoy.api.v2.core.RuntimeFractionalPercent runtime_fraction = 9;</code>
   * @return Whether the runtimeFraction field is set.
   */
  boolean hasRuntimeFraction();
  /**
   * <pre>
   * Indicates that the route should additionally match on a runtime key. Every time the route
   * is considered for a match, it must also fall under the percentage of matches indicated by
   * this field. For some fraction N/D, a random number in the range [0,D) is selected. If the
   * number is &lt;= the value of the numerator N, or if the key is not present, the default
   * value, the router continues to evaluate the remaining match criteria. A runtime_fraction
   * route configuration can be used to roll out route changes in a gradual manner without full
   * code/config deploys. Refer to the :ref:`traffic shifting
   * &lt;config_http_conn_man_route_table_traffic_splitting_shift&gt;` docs for additional documentation.
   * .. note::
   *    Parsing this field is implemented such that the runtime key's data may be represented
   *    as a FractionalPercent proto represented as JSON/YAML and may also be represented as an
   *    integer with the assumption that the value is an integral percentage out of 100. For
   *    instance, a runtime key lookup returning the value "42" would parse as a FractionalPercent
   *    whose numerator is 42 and denominator is HUNDRED. This preserves legacy semantics.
   * </pre>
   *
   * <code>.envoy.api.v2.core.RuntimeFractionalPercent runtime_fraction = 9;</code>
   * @return The runtimeFraction.
   */
  io.envoyproxy.envoy.api.v2.core.RuntimeFractionalPercent getRuntimeFraction();
  /**
   * <pre>
   * Indicates that the route should additionally match on a runtime key. Every time the route
   * is considered for a match, it must also fall under the percentage of matches indicated by
   * this field. For some fraction N/D, a random number in the range [0,D) is selected. If the
   * number is &lt;= the value of the numerator N, or if the key is not present, the default
   * value, the router continues to evaluate the remaining match criteria. A runtime_fraction
   * route configuration can be used to roll out route changes in a gradual manner without full
   * code/config deploys. Refer to the :ref:`traffic shifting
   * &lt;config_http_conn_man_route_table_traffic_splitting_shift&gt;` docs for additional documentation.
   * .. note::
   *    Parsing this field is implemented such that the runtime key's data may be represented
   *    as a FractionalPercent proto represented as JSON/YAML and may also be represented as an
   *    integer with the assumption that the value is an integral percentage out of 100. For
   *    instance, a runtime key lookup returning the value "42" would parse as a FractionalPercent
   *    whose numerator is 42 and denominator is HUNDRED. This preserves legacy semantics.
   * </pre>
   *
   * <code>.envoy.api.v2.core.RuntimeFractionalPercent runtime_fraction = 9;</code>
   */
  io.envoyproxy.envoy.api.v2.core.RuntimeFractionalPercentOrBuilder getRuntimeFractionOrBuilder();

  /**
   * <pre>
   * Specifies a set of headers that the route should match on. The router will
   * check the request’s headers against all the specified headers in the route
   * config. A match will happen if all the headers in the route are present in
   * the request with the same values (or based on presence if the value field
   * is not in the config).
   * </pre>
   *
   * <code>repeated .envoy.api.v2.route.HeaderMatcher headers = 6;</code>
   */
  java.util.List<io.envoyproxy.envoy.api.v2.route.HeaderMatcher> 
      getHeadersList();
  /**
   * <pre>
   * Specifies a set of headers that the route should match on. The router will
   * check the request’s headers against all the specified headers in the route
   * config. A match will happen if all the headers in the route are present in
   * the request with the same values (or based on presence if the value field
   * is not in the config).
   * </pre>
   *
   * <code>repeated .envoy.api.v2.route.HeaderMatcher headers = 6;</code>
   */
  io.envoyproxy.envoy.api.v2.route.HeaderMatcher getHeaders(int index);
  /**
   * <pre>
   * Specifies a set of headers that the route should match on. The router will
   * check the request’s headers against all the specified headers in the route
   * config. A match will happen if all the headers in the route are present in
   * the request with the same values (or based on presence if the value field
   * is not in the config).
   * </pre>
   *
   * <code>repeated .envoy.api.v2.route.HeaderMatcher headers = 6;</code>
   */
  int getHeadersCount();
  /**
   * <pre>
   * Specifies a set of headers that the route should match on. The router will
   * check the request’s headers against all the specified headers in the route
   * config. A match will happen if all the headers in the route are present in
   * the request with the same values (or based on presence if the value field
   * is not in the config).
   * </pre>
   *
   * <code>repeated .envoy.api.v2.route.HeaderMatcher headers = 6;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.api.v2.route.HeaderMatcherOrBuilder> 
      getHeadersOrBuilderList();
  /**
   * <pre>
   * Specifies a set of headers that the route should match on. The router will
   * check the request’s headers against all the specified headers in the route
   * config. A match will happen if all the headers in the route are present in
   * the request with the same values (or based on presence if the value field
   * is not in the config).
   * </pre>
   *
   * <code>repeated .envoy.api.v2.route.HeaderMatcher headers = 6;</code>
   */
  io.envoyproxy.envoy.api.v2.route.HeaderMatcherOrBuilder getHeadersOrBuilder(
      int index);

  /**
   * <pre>
   * Specifies a set of URL query parameters on which the route should
   * match. The router will check the query string from the *path* header
   * against all the specified query parameters. If the number of specified
   * query parameters is nonzero, they all must match the *path* header's
   * query string for a match to occur.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.route.QueryParameterMatcher query_parameters = 7;</code>
   */
  java.util.List<io.envoyproxy.envoy.api.v2.route.QueryParameterMatcher> 
      getQueryParametersList();
  /**
   * <pre>
   * Specifies a set of URL query parameters on which the route should
   * match. The router will check the query string from the *path* header
   * against all the specified query parameters. If the number of specified
   * query parameters is nonzero, they all must match the *path* header's
   * query string for a match to occur.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.route.QueryParameterMatcher query_parameters = 7;</code>
   */
  io.envoyproxy.envoy.api.v2.route.QueryParameterMatcher getQueryParameters(int index);
  /**
   * <pre>
   * Specifies a set of URL query parameters on which the route should
   * match. The router will check the query string from the *path* header
   * against all the specified query parameters. If the number of specified
   * query parameters is nonzero, they all must match the *path* header's
   * query string for a match to occur.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.route.QueryParameterMatcher query_parameters = 7;</code>
   */
  int getQueryParametersCount();
  /**
   * <pre>
   * Specifies a set of URL query parameters on which the route should
   * match. The router will check the query string from the *path* header
   * against all the specified query parameters. If the number of specified
   * query parameters is nonzero, they all must match the *path* header's
   * query string for a match to occur.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.route.QueryParameterMatcher query_parameters = 7;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.api.v2.route.QueryParameterMatcherOrBuilder> 
      getQueryParametersOrBuilderList();
  /**
   * <pre>
   * Specifies a set of URL query parameters on which the route should
   * match. The router will check the query string from the *path* header
   * against all the specified query parameters. If the number of specified
   * query parameters is nonzero, they all must match the *path* header's
   * query string for a match to occur.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.route.QueryParameterMatcher query_parameters = 7;</code>
   */
  io.envoyproxy.envoy.api.v2.route.QueryParameterMatcherOrBuilder getQueryParametersOrBuilder(
      int index);

  /**
   * <pre>
   * If specified, only gRPC requests will be matched. The router will check
   * that the content-type header has a application/grpc or one of the various
   * application/grpc+ values.
   * </pre>
   *
   * <code>.envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions grpc = 8;</code>
   * @return Whether the grpc field is set.
   */
  boolean hasGrpc();
  /**
   * <pre>
   * If specified, only gRPC requests will be matched. The router will check
   * that the content-type header has a application/grpc or one of the various
   * application/grpc+ values.
   * </pre>
   *
   * <code>.envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions grpc = 8;</code>
   * @return The grpc.
   */
  io.envoyproxy.envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions getGrpc();
  /**
   * <pre>
   * If specified, only gRPC requests will be matched. The router will check
   * that the content-type header has a application/grpc or one of the various
   * application/grpc+ values.
   * </pre>
   *
   * <code>.envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions grpc = 8;</code>
   */
  io.envoyproxy.envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptionsOrBuilder getGrpcOrBuilder();

  /**
   * <pre>
   * If specified, the client tls context will be matched against the defined
   * match options.
   * [#next-major-version: unify with RBAC]
   * </pre>
   *
   * <code>.envoy.api.v2.route.RouteMatch.TlsContextMatchOptions tls_context = 11;</code>
   * @return Whether the tlsContext field is set.
   */
  boolean hasTlsContext();
  /**
   * <pre>
   * If specified, the client tls context will be matched against the defined
   * match options.
   * [#next-major-version: unify with RBAC]
   * </pre>
   *
   * <code>.envoy.api.v2.route.RouteMatch.TlsContextMatchOptions tls_context = 11;</code>
   * @return The tlsContext.
   */
  io.envoyproxy.envoy.api.v2.route.RouteMatch.TlsContextMatchOptions getTlsContext();
  /**
   * <pre>
   * If specified, the client tls context will be matched against the defined
   * match options.
   * [#next-major-version: unify with RBAC]
   * </pre>
   *
   * <code>.envoy.api.v2.route.RouteMatch.TlsContextMatchOptions tls_context = 11;</code>
   */
  io.envoyproxy.envoy.api.v2.route.RouteMatch.TlsContextMatchOptionsOrBuilder getTlsContextOrBuilder();

  public io.envoyproxy.envoy.api.v2.route.RouteMatch.PathSpecifierCase getPathSpecifierCase();
}
