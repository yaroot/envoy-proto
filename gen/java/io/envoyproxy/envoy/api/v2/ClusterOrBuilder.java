// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/api/v2/cluster.proto

package io.envoyproxy.envoy.api.v2;

public interface ClusterOrBuilder extends
    // @@protoc_insertion_point(interface_extends:envoy.api.v2.Cluster)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * Configuration to use different transport sockets for different endpoints.
   * The entry of *envoy.transport_socket_match* in the
   * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_endpoint.LbEndpoint.metadata&gt;`
   * is used to match against the transport sockets as they appear in the list. The first
   * :ref:`match &lt;envoy_api_msg_Cluster.TransportSocketMatch&gt;` is used.
   * For example, with the following match
   * .. code-block:: yaml
   *  transport_socket_matches:
   *  - name: "enableMTLS"
   *    match:
   *      acceptMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   *  - name: "defaultToPlaintext"
   *    match: {}
   *    transport_socket:
   *      name: envoy.transport_sockets.raw_buffer
   * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
   * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
   * If a :ref:`socket match &lt;envoy_api_msg_Cluster.TransportSocketMatch&gt;` with empty match
   * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
   * socket match in case above.
   * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
   * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
   * *transport_socket* specified in this cluster.
   * This field allows gradual and flexible transport socket configuration changes.
   * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
   * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
   * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
   * has "acceptPlaintext": "true" metadata information.
   * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
   * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
   * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
   * *transport_socket_match* set, and still send plain text traffic to the same cluster.
   * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
   * </pre>
   *
   * <code>repeated .envoy.api.v2.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
   */
  java.util.List<io.envoyproxy.envoy.api.v2.Cluster.TransportSocketMatch> 
      getTransportSocketMatchesList();
  /**
   * <pre>
   * Configuration to use different transport sockets for different endpoints.
   * The entry of *envoy.transport_socket_match* in the
   * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_endpoint.LbEndpoint.metadata&gt;`
   * is used to match against the transport sockets as they appear in the list. The first
   * :ref:`match &lt;envoy_api_msg_Cluster.TransportSocketMatch&gt;` is used.
   * For example, with the following match
   * .. code-block:: yaml
   *  transport_socket_matches:
   *  - name: "enableMTLS"
   *    match:
   *      acceptMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   *  - name: "defaultToPlaintext"
   *    match: {}
   *    transport_socket:
   *      name: envoy.transport_sockets.raw_buffer
   * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
   * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
   * If a :ref:`socket match &lt;envoy_api_msg_Cluster.TransportSocketMatch&gt;` with empty match
   * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
   * socket match in case above.
   * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
   * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
   * *transport_socket* specified in this cluster.
   * This field allows gradual and flexible transport socket configuration changes.
   * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
   * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
   * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
   * has "acceptPlaintext": "true" metadata information.
   * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
   * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
   * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
   * *transport_socket_match* set, and still send plain text traffic to the same cluster.
   * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
   * </pre>
   *
   * <code>repeated .envoy.api.v2.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
   */
  io.envoyproxy.envoy.api.v2.Cluster.TransportSocketMatch getTransportSocketMatches(int index);
  /**
   * <pre>
   * Configuration to use different transport sockets for different endpoints.
   * The entry of *envoy.transport_socket_match* in the
   * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_endpoint.LbEndpoint.metadata&gt;`
   * is used to match against the transport sockets as they appear in the list. The first
   * :ref:`match &lt;envoy_api_msg_Cluster.TransportSocketMatch&gt;` is used.
   * For example, with the following match
   * .. code-block:: yaml
   *  transport_socket_matches:
   *  - name: "enableMTLS"
   *    match:
   *      acceptMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   *  - name: "defaultToPlaintext"
   *    match: {}
   *    transport_socket:
   *      name: envoy.transport_sockets.raw_buffer
   * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
   * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
   * If a :ref:`socket match &lt;envoy_api_msg_Cluster.TransportSocketMatch&gt;` with empty match
   * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
   * socket match in case above.
   * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
   * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
   * *transport_socket* specified in this cluster.
   * This field allows gradual and flexible transport socket configuration changes.
   * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
   * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
   * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
   * has "acceptPlaintext": "true" metadata information.
   * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
   * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
   * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
   * *transport_socket_match* set, and still send plain text traffic to the same cluster.
   * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
   * </pre>
   *
   * <code>repeated .envoy.api.v2.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
   */
  int getTransportSocketMatchesCount();
  /**
   * <pre>
   * Configuration to use different transport sockets for different endpoints.
   * The entry of *envoy.transport_socket_match* in the
   * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_endpoint.LbEndpoint.metadata&gt;`
   * is used to match against the transport sockets as they appear in the list. The first
   * :ref:`match &lt;envoy_api_msg_Cluster.TransportSocketMatch&gt;` is used.
   * For example, with the following match
   * .. code-block:: yaml
   *  transport_socket_matches:
   *  - name: "enableMTLS"
   *    match:
   *      acceptMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   *  - name: "defaultToPlaintext"
   *    match: {}
   *    transport_socket:
   *      name: envoy.transport_sockets.raw_buffer
   * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
   * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
   * If a :ref:`socket match &lt;envoy_api_msg_Cluster.TransportSocketMatch&gt;` with empty match
   * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
   * socket match in case above.
   * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
   * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
   * *transport_socket* specified in this cluster.
   * This field allows gradual and flexible transport socket configuration changes.
   * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
   * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
   * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
   * has "acceptPlaintext": "true" metadata information.
   * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
   * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
   * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
   * *transport_socket_match* set, and still send plain text traffic to the same cluster.
   * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
   * </pre>
   *
   * <code>repeated .envoy.api.v2.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.api.v2.Cluster.TransportSocketMatchOrBuilder> 
      getTransportSocketMatchesOrBuilderList();
  /**
   * <pre>
   * Configuration to use different transport sockets for different endpoints.
   * The entry of *envoy.transport_socket_match* in the
   * :ref:`LbEndpoint.Metadata &lt;envoy_api_field_endpoint.LbEndpoint.metadata&gt;`
   * is used to match against the transport sockets as they appear in the list. The first
   * :ref:`match &lt;envoy_api_msg_Cluster.TransportSocketMatch&gt;` is used.
   * For example, with the following match
   * .. code-block:: yaml
   *  transport_socket_matches:
   *  - name: "enableMTLS"
   *    match:
   *      acceptMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   *  - name: "defaultToPlaintext"
   *    match: {}
   *    transport_socket:
   *      name: envoy.transport_sockets.raw_buffer
   * Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
   * having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
   * If a :ref:`socket match &lt;envoy_api_msg_Cluster.TransportSocketMatch&gt;` with empty match
   * criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
   * socket match in case above.
   * If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
   * *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
   * *transport_socket* specified in this cluster.
   * This field allows gradual and flexible transport socket configuration changes.
   * The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
   * an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
   * "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
   * has "acceptPlaintext": "true" metadata information.
   * Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
   * traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
   * *TransportSocketMatch* in this field. Other client Envoys receive CDS without
   * *transport_socket_match* set, and still send plain text traffic to the same cluster.
   * [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
   * </pre>
   *
   * <code>repeated .envoy.api.v2.Cluster.TransportSocketMatch transport_socket_matches = 43;</code>
   */
  io.envoyproxy.envoy.api.v2.Cluster.TransportSocketMatchOrBuilder getTransportSocketMatchesOrBuilder(
      int index);

  /**
   * <pre>
   * Supplies the name of the cluster which must be unique across all clusters.
   * The cluster name is used when emitting
   * :ref:`statistics &lt;config_cluster_manager_cluster_stats&gt;` if :ref:`alt_stat_name
   * &lt;envoy_api_field_Cluster.alt_stat_name&gt;` is not provided.
   * Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
   * </pre>
   *
   * <code>string name = 1 [(.validate.rules) = { ... }</code>
   * @return The name.
   */
  java.lang.String getName();
  /**
   * <pre>
   * Supplies the name of the cluster which must be unique across all clusters.
   * The cluster name is used when emitting
   * :ref:`statistics &lt;config_cluster_manager_cluster_stats&gt;` if :ref:`alt_stat_name
   * &lt;envoy_api_field_Cluster.alt_stat_name&gt;` is not provided.
   * Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
   * </pre>
   *
   * <code>string name = 1 [(.validate.rules) = { ... }</code>
   * @return The bytes for name.
   */
  com.google.protobuf.ByteString
      getNameBytes();

  /**
   * <pre>
   * An optional alternative to the cluster name to be used while emitting stats.
   * Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
   * confused with :ref:`Router Filter Header
   * &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name&gt;`.
   * </pre>
   *
   * <code>string alt_stat_name = 28;</code>
   * @return The altStatName.
   */
  java.lang.String getAltStatName();
  /**
   * <pre>
   * An optional alternative to the cluster name to be used while emitting stats.
   * Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
   * confused with :ref:`Router Filter Header
   * &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name&gt;`.
   * </pre>
   *
   * <code>string alt_stat_name = 28;</code>
   * @return The bytes for altStatName.
   */
  com.google.protobuf.ByteString
      getAltStatNameBytes();

  /**
   * <pre>
   * The :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
   * to use for resolving the cluster.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.DiscoveryType type = 2 [(.validate.rules) = { ... }</code>
   * @return Whether the type field is set.
   */
  boolean hasType();
  /**
   * <pre>
   * The :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
   * to use for resolving the cluster.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.DiscoveryType type = 2 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for type.
   */
  int getTypeValue();
  /**
   * <pre>
   * The :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
   * to use for resolving the cluster.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.DiscoveryType type = 2 [(.validate.rules) = { ... }</code>
   * @return The type.
   */
  io.envoyproxy.envoy.api.v2.Cluster.DiscoveryType getType();

  /**
   * <pre>
   * The custom cluster type.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.CustomClusterType cluster_type = 38;</code>
   * @return Whether the clusterType field is set.
   */
  boolean hasClusterType();
  /**
   * <pre>
   * The custom cluster type.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.CustomClusterType cluster_type = 38;</code>
   * @return The clusterType.
   */
  io.envoyproxy.envoy.api.v2.Cluster.CustomClusterType getClusterType();
  /**
   * <pre>
   * The custom cluster type.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.CustomClusterType cluster_type = 38;</code>
   */
  io.envoyproxy.envoy.api.v2.Cluster.CustomClusterTypeOrBuilder getClusterTypeOrBuilder();

  /**
   * <pre>
   * Configuration to use for EDS updates for the Cluster.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
   * @return Whether the edsClusterConfig field is set.
   */
  boolean hasEdsClusterConfig();
  /**
   * <pre>
   * Configuration to use for EDS updates for the Cluster.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
   * @return The edsClusterConfig.
   */
  io.envoyproxy.envoy.api.v2.Cluster.EdsClusterConfig getEdsClusterConfig();
  /**
   * <pre>
   * Configuration to use for EDS updates for the Cluster.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
   */
  io.envoyproxy.envoy.api.v2.Cluster.EdsClusterConfigOrBuilder getEdsClusterConfigOrBuilder();

  /**
   * <pre>
   * The timeout for new network connections to hosts in the cluster.
   * </pre>
   *
   * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
   * @return Whether the connectTimeout field is set.
   */
  boolean hasConnectTimeout();
  /**
   * <pre>
   * The timeout for new network connections to hosts in the cluster.
   * </pre>
   *
   * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
   * @return The connectTimeout.
   */
  com.google.protobuf.Duration getConnectTimeout();
  /**
   * <pre>
   * The timeout for new network connections to hosts in the cluster.
   * </pre>
   *
   * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.DurationOrBuilder getConnectTimeoutOrBuilder();

  /**
   * <pre>
   * Soft limit on size of the cluster’s connections read and write buffers. If
   * unspecified, an implementation defined default is applied (1MiB).
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5;</code>
   * @return Whether the perConnectionBufferLimitBytes field is set.
   */
  boolean hasPerConnectionBufferLimitBytes();
  /**
   * <pre>
   * Soft limit on size of the cluster’s connections read and write buffers. If
   * unspecified, an implementation defined default is applied (1MiB).
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5;</code>
   * @return The perConnectionBufferLimitBytes.
   */
  com.google.protobuf.UInt32Value getPerConnectionBufferLimitBytes();
  /**
   * <pre>
   * Soft limit on size of the cluster’s connections read and write buffers. If
   * unspecified, an implementation defined default is applied (1MiB).
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5;</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getPerConnectionBufferLimitBytesOrBuilder();

  /**
   * <pre>
   * The :ref:`load balancer type &lt;arch_overview_load_balancing_types&gt;` to use
   * when picking a host in the cluster.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.LbPolicy lb_policy = 6 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for lbPolicy.
   */
  int getLbPolicyValue();
  /**
   * <pre>
   * The :ref:`load balancer type &lt;arch_overview_load_balancing_types&gt;` to use
   * when picking a host in the cluster.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.LbPolicy lb_policy = 6 [(.validate.rules) = { ... }</code>
   * @return The lbPolicy.
   */
  io.envoyproxy.envoy.api.v2.Cluster.LbPolicy getLbPolicy();

  /**
   * <pre>
   * If the service discovery type is
   * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * then hosts is required.
   * .. attention::
   *   **This field is deprecated**. Set the
   *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
   */
  @java.lang.Deprecated java.util.List<io.envoyproxy.envoy.api.v2.core.Address> 
      getHostsList();
  /**
   * <pre>
   * If the service discovery type is
   * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * then hosts is required.
   * .. attention::
   *   **This field is deprecated**. Set the
   *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
   */
  @java.lang.Deprecated io.envoyproxy.envoy.api.v2.core.Address getHosts(int index);
  /**
   * <pre>
   * If the service discovery type is
   * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * then hosts is required.
   * .. attention::
   *   **This field is deprecated**. Set the
   *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
   */
  @java.lang.Deprecated int getHostsCount();
  /**
   * <pre>
   * If the service discovery type is
   * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * then hosts is required.
   * .. attention::
   *   **This field is deprecated**. Set the
   *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
   */
  @java.lang.Deprecated java.util.List<? extends io.envoyproxy.envoy.api.v2.core.AddressOrBuilder> 
      getHostsOrBuilderList();
  /**
   * <pre>
   * If the service discovery type is
   * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * then hosts is required.
   * .. attention::
   *   **This field is deprecated**. Set the
   *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
   */
  @java.lang.Deprecated io.envoyproxy.envoy.api.v2.core.AddressOrBuilder getHostsOrBuilder(
      int index);

  /**
   * <pre>
   * Setting this is required for specifying members of
   * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
   * This field supersedes the *hosts* field in the v2 API.
   * .. attention::
   *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
   *   :ref:`endpoint assignments&lt;envoy_api_msg_ClusterLoadAssignment&gt;`.
   * </pre>
   *
   * <code>.envoy.api.v2.ClusterLoadAssignment load_assignment = 33;</code>
   * @return Whether the loadAssignment field is set.
   */
  boolean hasLoadAssignment();
  /**
   * <pre>
   * Setting this is required for specifying members of
   * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
   * This field supersedes the *hosts* field in the v2 API.
   * .. attention::
   *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
   *   :ref:`endpoint assignments&lt;envoy_api_msg_ClusterLoadAssignment&gt;`.
   * </pre>
   *
   * <code>.envoy.api.v2.ClusterLoadAssignment load_assignment = 33;</code>
   * @return The loadAssignment.
   */
  io.envoyproxy.envoy.api.v2.ClusterLoadAssignment getLoadAssignment();
  /**
   * <pre>
   * Setting this is required for specifying members of
   * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
   * This field supersedes the *hosts* field in the v2 API.
   * .. attention::
   *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
   *   :ref:`endpoint assignments&lt;envoy_api_msg_ClusterLoadAssignment&gt;`.
   * </pre>
   *
   * <code>.envoy.api.v2.ClusterLoadAssignment load_assignment = 33;</code>
   */
  io.envoyproxy.envoy.api.v2.ClusterLoadAssignmentOrBuilder getLoadAssignmentOrBuilder();

  /**
   * <pre>
   * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
   */
  java.util.List<io.envoyproxy.envoy.api.v2.core.HealthCheck> 
      getHealthChecksList();
  /**
   * <pre>
   * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
   */
  io.envoyproxy.envoy.api.v2.core.HealthCheck getHealthChecks(int index);
  /**
   * <pre>
   * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
   */
  int getHealthChecksCount();
  /**
   * <pre>
   * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.api.v2.core.HealthCheckOrBuilder> 
      getHealthChecksOrBuilderList();
  /**
   * <pre>
   * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
   */
  io.envoyproxy.envoy.api.v2.core.HealthCheckOrBuilder getHealthChecksOrBuilder(
      int index);

  /**
   * <pre>
   * Optional maximum requests for a single upstream connection. This parameter
   * is respected by both the HTTP/1.1 and HTTP/2 connection pool
   * implementations. If not specified, there is no limit. Setting this
   * parameter to 1 will effectively disable keep alive.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
   * @return Whether the maxRequestsPerConnection field is set.
   */
  boolean hasMaxRequestsPerConnection();
  /**
   * <pre>
   * Optional maximum requests for a single upstream connection. This parameter
   * is respected by both the HTTP/1.1 and HTTP/2 connection pool
   * implementations. If not specified, there is no limit. Setting this
   * parameter to 1 will effectively disable keep alive.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
   * @return The maxRequestsPerConnection.
   */
  com.google.protobuf.UInt32Value getMaxRequestsPerConnection();
  /**
   * <pre>
   * Optional maximum requests for a single upstream connection. This parameter
   * is respected by both the HTTP/1.1 and HTTP/2 connection pool
   * implementations. If not specified, there is no limit. Setting this
   * parameter to 1 will effectively disable keep alive.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getMaxRequestsPerConnectionOrBuilder();

  /**
   * <pre>
   * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
   * </pre>
   *
   * <code>.envoy.api.v2.cluster.CircuitBreakers circuit_breakers = 10;</code>
   * @return Whether the circuitBreakers field is set.
   */
  boolean hasCircuitBreakers();
  /**
   * <pre>
   * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
   * </pre>
   *
   * <code>.envoy.api.v2.cluster.CircuitBreakers circuit_breakers = 10;</code>
   * @return The circuitBreakers.
   */
  io.envoyproxy.envoy.api.v2.cluster.CircuitBreakers getCircuitBreakers();
  /**
   * <pre>
   * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
   * </pre>
   *
   * <code>.envoy.api.v2.cluster.CircuitBreakers circuit_breakers = 10;</code>
   */
  io.envoyproxy.envoy.api.v2.cluster.CircuitBreakersOrBuilder getCircuitBreakersOrBuilder();

  /**
   * <pre>
   * The TLS configuration for connections to the upstream cluster.
   * .. attention::
   *   **This field is deprecated**. Use `transport_socket` with name `tls` instead. If both are
   *   set, `transport_socket` takes priority.
   * </pre>
   *
   * <code>.envoy.api.v2.auth.UpstreamTlsContext tls_context = 11 [deprecated = true, (.envoy.annotations.disallowed_by_default) = true];</code>
   * @deprecated envoy.api.v2.Cluster.tls_context is deprecated.
   *     See envoy/api/v2/cluster.proto;l=607
   * @return Whether the tlsContext field is set.
   */
  @java.lang.Deprecated boolean hasTlsContext();
  /**
   * <pre>
   * The TLS configuration for connections to the upstream cluster.
   * .. attention::
   *   **This field is deprecated**. Use `transport_socket` with name `tls` instead. If both are
   *   set, `transport_socket` takes priority.
   * </pre>
   *
   * <code>.envoy.api.v2.auth.UpstreamTlsContext tls_context = 11 [deprecated = true, (.envoy.annotations.disallowed_by_default) = true];</code>
   * @deprecated envoy.api.v2.Cluster.tls_context is deprecated.
   *     See envoy/api/v2/cluster.proto;l=607
   * @return The tlsContext.
   */
  @java.lang.Deprecated io.envoyproxy.envoy.api.v2.auth.UpstreamTlsContext getTlsContext();
  /**
   * <pre>
   * The TLS configuration for connections to the upstream cluster.
   * .. attention::
   *   **This field is deprecated**. Use `transport_socket` with name `tls` instead. If both are
   *   set, `transport_socket` takes priority.
   * </pre>
   *
   * <code>.envoy.api.v2.auth.UpstreamTlsContext tls_context = 11 [deprecated = true, (.envoy.annotations.disallowed_by_default) = true];</code>
   */
  @java.lang.Deprecated io.envoyproxy.envoy.api.v2.auth.UpstreamTlsContextOrBuilder getTlsContextOrBuilder();

  /**
   * <pre>
   * HTTP protocol options that are applied only to upstream HTTP connections.
   * These options apply to all HTTP versions.
   * </pre>
   *
   * <code>.envoy.api.v2.core.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46;</code>
   * @return Whether the upstreamHttpProtocolOptions field is set.
   */
  boolean hasUpstreamHttpProtocolOptions();
  /**
   * <pre>
   * HTTP protocol options that are applied only to upstream HTTP connections.
   * These options apply to all HTTP versions.
   * </pre>
   *
   * <code>.envoy.api.v2.core.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46;</code>
   * @return The upstreamHttpProtocolOptions.
   */
  io.envoyproxy.envoy.api.v2.core.UpstreamHttpProtocolOptions getUpstreamHttpProtocolOptions();
  /**
   * <pre>
   * HTTP protocol options that are applied only to upstream HTTP connections.
   * These options apply to all HTTP versions.
   * </pre>
   *
   * <code>.envoy.api.v2.core.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46;</code>
   */
  io.envoyproxy.envoy.api.v2.core.UpstreamHttpProtocolOptionsOrBuilder getUpstreamHttpProtocolOptionsOrBuilder();

  /**
   * <pre>
   * Additional options when handling HTTP requests upstream. These options will be applicable to
   * both HTTP1 and HTTP2 requests.
   * </pre>
   *
   * <code>.envoy.api.v2.core.HttpProtocolOptions common_http_protocol_options = 29;</code>
   * @return Whether the commonHttpProtocolOptions field is set.
   */
  boolean hasCommonHttpProtocolOptions();
  /**
   * <pre>
   * Additional options when handling HTTP requests upstream. These options will be applicable to
   * both HTTP1 and HTTP2 requests.
   * </pre>
   *
   * <code>.envoy.api.v2.core.HttpProtocolOptions common_http_protocol_options = 29;</code>
   * @return The commonHttpProtocolOptions.
   */
  io.envoyproxy.envoy.api.v2.core.HttpProtocolOptions getCommonHttpProtocolOptions();
  /**
   * <pre>
   * Additional options when handling HTTP requests upstream. These options will be applicable to
   * both HTTP1 and HTTP2 requests.
   * </pre>
   *
   * <code>.envoy.api.v2.core.HttpProtocolOptions common_http_protocol_options = 29;</code>
   */
  io.envoyproxy.envoy.api.v2.core.HttpProtocolOptionsOrBuilder getCommonHttpProtocolOptionsOrBuilder();

  /**
   * <pre>
   * Additional options when handling HTTP1 requests.
   * </pre>
   *
   * <code>.envoy.api.v2.core.Http1ProtocolOptions http_protocol_options = 13;</code>
   * @return Whether the httpProtocolOptions field is set.
   */
  boolean hasHttpProtocolOptions();
  /**
   * <pre>
   * Additional options when handling HTTP1 requests.
   * </pre>
   *
   * <code>.envoy.api.v2.core.Http1ProtocolOptions http_protocol_options = 13;</code>
   * @return The httpProtocolOptions.
   */
  io.envoyproxy.envoy.api.v2.core.Http1ProtocolOptions getHttpProtocolOptions();
  /**
   * <pre>
   * Additional options when handling HTTP1 requests.
   * </pre>
   *
   * <code>.envoy.api.v2.core.Http1ProtocolOptions http_protocol_options = 13;</code>
   */
  io.envoyproxy.envoy.api.v2.core.Http1ProtocolOptionsOrBuilder getHttpProtocolOptionsOrBuilder();

  /**
   * <pre>
   * Even if default HTTP2 protocol options are desired, this field must be
   * set so that Envoy will assume that the upstream supports HTTP/2 when
   * making new HTTP connection pool connections. Currently, Envoy only
   * supports prior knowledge for upstream connections. Even if TLS is used
   * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
   * connections to happen over plain text.
   * </pre>
   *
   * <code>.envoy.api.v2.core.Http2ProtocolOptions http2_protocol_options = 14;</code>
   * @return Whether the http2ProtocolOptions field is set.
   */
  boolean hasHttp2ProtocolOptions();
  /**
   * <pre>
   * Even if default HTTP2 protocol options are desired, this field must be
   * set so that Envoy will assume that the upstream supports HTTP/2 when
   * making new HTTP connection pool connections. Currently, Envoy only
   * supports prior knowledge for upstream connections. Even if TLS is used
   * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
   * connections to happen over plain text.
   * </pre>
   *
   * <code>.envoy.api.v2.core.Http2ProtocolOptions http2_protocol_options = 14;</code>
   * @return The http2ProtocolOptions.
   */
  io.envoyproxy.envoy.api.v2.core.Http2ProtocolOptions getHttp2ProtocolOptions();
  /**
   * <pre>
   * Even if default HTTP2 protocol options are desired, this field must be
   * set so that Envoy will assume that the upstream supports HTTP/2 when
   * making new HTTP connection pool connections. Currently, Envoy only
   * supports prior knowledge for upstream connections. Even if TLS is used
   * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
   * connections to happen over plain text.
   * </pre>
   *
   * <code>.envoy.api.v2.core.Http2ProtocolOptions http2_protocol_options = 14;</code>
   */
  io.envoyproxy.envoy.api.v2.core.Http2ProtocolOptionsOrBuilder getHttp2ProtocolOptionsOrBuilder();

  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Struct&gt; extension_protocol_options = 35 [deprecated = true, (.envoy.annotations.disallowed_by_default) = true];</code>
   */
  @java.lang.Deprecated int getExtensionProtocolOptionsCount();
  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Struct&gt; extension_protocol_options = 35 [deprecated = true, (.envoy.annotations.disallowed_by_default) = true];</code>
   */
  @java.lang.Deprecated boolean containsExtensionProtocolOptions(
      java.lang.String key);
  /**
   * Use {@link #getExtensionProtocolOptionsMap()} instead.
   */
  @java.lang.Deprecated
  java.util.Map<java.lang.String, com.google.protobuf.Struct>
  getExtensionProtocolOptions();
  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Struct&gt; extension_protocol_options = 35 [deprecated = true, (.envoy.annotations.disallowed_by_default) = true];</code>
   */
  @java.lang.Deprecated java.util.Map<java.lang.String, com.google.protobuf.Struct>
  getExtensionProtocolOptionsMap();
  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Struct&gt; extension_protocol_options = 35 [deprecated = true, (.envoy.annotations.disallowed_by_default) = true];</code>
   */
  @java.lang.Deprecated /* nullable */
com.google.protobuf.Struct getExtensionProtocolOptionsOrDefault(
      java.lang.String key,
      /* nullable */
com.google.protobuf.Struct defaultValue);
  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Struct&gt; extension_protocol_options = 35 [deprecated = true, (.envoy.annotations.disallowed_by_default) = true];</code>
   */
  @java.lang.Deprecated com.google.protobuf.Struct getExtensionProtocolOptionsOrThrow(
      java.lang.String key);

  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
   */
  int getTypedExtensionProtocolOptionsCount();
  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
   */
  boolean containsTypedExtensionProtocolOptions(
      java.lang.String key);
  /**
   * Use {@link #getTypedExtensionProtocolOptionsMap()} instead.
   */
  @java.lang.Deprecated
  java.util.Map<java.lang.String, com.google.protobuf.Any>
  getTypedExtensionProtocolOptions();
  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
   */
  java.util.Map<java.lang.String, com.google.protobuf.Any>
  getTypedExtensionProtocolOptionsMap();
  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
   */
  /* nullable */
com.google.protobuf.Any getTypedExtensionProtocolOptionsOrDefault(
      java.lang.String key,
      /* nullable */
com.google.protobuf.Any defaultValue);
  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
   */
  com.google.protobuf.Any getTypedExtensionProtocolOptionsOrThrow(
      java.lang.String key);

  /**
   * <pre>
   * If the DNS refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used as the cluster’s DNS refresh
   * rate. The value configured must be at least 1ms. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
   * @return Whether the dnsRefreshRate field is set.
   */
  boolean hasDnsRefreshRate();
  /**
   * <pre>
   * If the DNS refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used as the cluster’s DNS refresh
   * rate. The value configured must be at least 1ms. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
   * @return The dnsRefreshRate.
   */
  com.google.protobuf.Duration getDnsRefreshRate();
  /**
   * <pre>
   * If the DNS refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used as the cluster’s DNS refresh
   * rate. The value configured must be at least 1ms. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.DurationOrBuilder getDnsRefreshRateOrBuilder();

  /**
   * <pre>
   * If the DNS failure refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
   * not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
   * other than :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;` and
   * :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;` this setting is
   * ignored.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.RefreshRate dns_failure_refresh_rate = 44;</code>
   * @return Whether the dnsFailureRefreshRate field is set.
   */
  boolean hasDnsFailureRefreshRate();
  /**
   * <pre>
   * If the DNS failure refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
   * not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
   * other than :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;` and
   * :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;` this setting is
   * ignored.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.RefreshRate dns_failure_refresh_rate = 44;</code>
   * @return The dnsFailureRefreshRate.
   */
  io.envoyproxy.envoy.api.v2.Cluster.RefreshRate getDnsFailureRefreshRate();
  /**
   * <pre>
   * If the DNS failure refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
   * not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
   * other than :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;` and
   * :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;` this setting is
   * ignored.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.RefreshRate dns_failure_refresh_rate = 44;</code>
   */
  io.envoyproxy.envoy.api.v2.Cluster.RefreshRateOrBuilder getDnsFailureRefreshRateOrBuilder();

  /**
   * <pre>
   * Optional configuration for setting cluster's DNS refresh rate. If the value is set to true,
   * cluster's DNS refresh rate will be set to resource record's TTL which comes from DNS
   * resolution.
   * </pre>
   *
   * <code>bool respect_dns_ttl = 39;</code>
   * @return The respectDnsTtl.
   */
  boolean getRespectDnsTtl();

  /**
   * <pre>
   * The DNS IP address resolution policy. If this setting is not specified, the
   * value defaults to
   * :ref:`AUTO&lt;envoy_api_enum_value_Cluster.DnsLookupFamily.AUTO&gt;`.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.DnsLookupFamily dns_lookup_family = 17 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for dnsLookupFamily.
   */
  int getDnsLookupFamilyValue();
  /**
   * <pre>
   * The DNS IP address resolution policy. If this setting is not specified, the
   * value defaults to
   * :ref:`AUTO&lt;envoy_api_enum_value_Cluster.DnsLookupFamily.AUTO&gt;`.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.DnsLookupFamily dns_lookup_family = 17 [(.validate.rules) = { ... }</code>
   * @return The dnsLookupFamily.
   */
  io.envoyproxy.envoy.api.v2.Cluster.DnsLookupFamily getDnsLookupFamily();

  /**
   * <pre>
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used to specify the cluster’s dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * Setting this value causes failure if the
   * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
   * server startup. Apple's API only allows overriding DNS resolvers via system settings.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
   */
  java.util.List<io.envoyproxy.envoy.api.v2.core.Address> 
      getDnsResolversList();
  /**
   * <pre>
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used to specify the cluster’s dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * Setting this value causes failure if the
   * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
   * server startup. Apple's API only allows overriding DNS resolvers via system settings.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
   */
  io.envoyproxy.envoy.api.v2.core.Address getDnsResolvers(int index);
  /**
   * <pre>
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used to specify the cluster’s dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * Setting this value causes failure if the
   * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
   * server startup. Apple's API only allows overriding DNS resolvers via system settings.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
   */
  int getDnsResolversCount();
  /**
   * <pre>
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used to specify the cluster’s dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * Setting this value causes failure if the
   * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
   * server startup. Apple's API only allows overriding DNS resolvers via system settings.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.api.v2.core.AddressOrBuilder> 
      getDnsResolversOrBuilderList();
  /**
   * <pre>
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used to specify the cluster’s dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * Setting this value causes failure if the
   * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
   * server startup. Apple's API only allows overriding DNS resolvers via system settings.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
   */
  io.envoyproxy.envoy.api.v2.core.AddressOrBuilder getDnsResolversOrBuilder(
      int index);

  /**
   * <pre>
   * [#next-major-version: Reconcile DNS options in a single message.]
   * Always use TCP queries instead of UDP queries for DNS lookups.
   * Setting this value causes failure if the
   * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
   * server startup. Apple' API only uses UDP for DNS resolution.
   * </pre>
   *
   * <code>bool use_tcp_for_dns_lookups = 45;</code>
   * @return The useTcpForDnsLookups.
   */
  boolean getUseTcpForDnsLookups();

  /**
   * <pre>
   * If specified, outlier detection will be enabled for this upstream cluster.
   * Each of the configuration values can be overridden via
   * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
   * </pre>
   *
   * <code>.envoy.api.v2.cluster.OutlierDetection outlier_detection = 19;</code>
   * @return Whether the outlierDetection field is set.
   */
  boolean hasOutlierDetection();
  /**
   * <pre>
   * If specified, outlier detection will be enabled for this upstream cluster.
   * Each of the configuration values can be overridden via
   * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
   * </pre>
   *
   * <code>.envoy.api.v2.cluster.OutlierDetection outlier_detection = 19;</code>
   * @return The outlierDetection.
   */
  io.envoyproxy.envoy.api.v2.cluster.OutlierDetection getOutlierDetection();
  /**
   * <pre>
   * If specified, outlier detection will be enabled for this upstream cluster.
   * Each of the configuration values can be overridden via
   * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
   * </pre>
   *
   * <code>.envoy.api.v2.cluster.OutlierDetection outlier_detection = 19;</code>
   */
  io.envoyproxy.envoy.api.v2.cluster.OutlierDetectionOrBuilder getOutlierDetectionOrBuilder();

  /**
   * <pre>
   * The interval for removing stale hosts from a cluster type
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
   * Hosts are considered stale if they have not been used
   * as upstream destinations during this interval. New hosts are added
   * to original destination clusters on demand as new connections are
   * redirected to Envoy, causing the number of hosts in the cluster to
   * grow over time. Hosts that are not stale (they are actively used as
   * destinations) are kept in the cluster, which allows connections to
   * them remain open, saving the latency that would otherwise be spent
   * on opening new connections. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
   * @return Whether the cleanupInterval field is set.
   */
  boolean hasCleanupInterval();
  /**
   * <pre>
   * The interval for removing stale hosts from a cluster type
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
   * Hosts are considered stale if they have not been used
   * as upstream destinations during this interval. New hosts are added
   * to original destination clusters on demand as new connections are
   * redirected to Envoy, causing the number of hosts in the cluster to
   * grow over time. Hosts that are not stale (they are actively used as
   * destinations) are kept in the cluster, which allows connections to
   * them remain open, saving the latency that would otherwise be spent
   * on opening new connections. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
   * @return The cleanupInterval.
   */
  com.google.protobuf.Duration getCleanupInterval();
  /**
   * <pre>
   * The interval for removing stale hosts from a cluster type
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
   * Hosts are considered stale if they have not been used
   * as upstream destinations during this interval. New hosts are added
   * to original destination clusters on demand as new connections are
   * redirected to Envoy, causing the number of hosts in the cluster to
   * grow over time. Hosts that are not stale (they are actively used as
   * destinations) are kept in the cluster, which allows connections to
   * them remain open, saving the latency that would otherwise be spent
   * on opening new connections. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.DurationOrBuilder getCleanupIntervalOrBuilder();

  /**
   * <pre>
   * Optional configuration used to bind newly established upstream connections.
   * This overrides any bind_config specified in the bootstrap proto.
   * If the address and port are empty, no bind will be performed.
   * </pre>
   *
   * <code>.envoy.api.v2.core.BindConfig upstream_bind_config = 21;</code>
   * @return Whether the upstreamBindConfig field is set.
   */
  boolean hasUpstreamBindConfig();
  /**
   * <pre>
   * Optional configuration used to bind newly established upstream connections.
   * This overrides any bind_config specified in the bootstrap proto.
   * If the address and port are empty, no bind will be performed.
   * </pre>
   *
   * <code>.envoy.api.v2.core.BindConfig upstream_bind_config = 21;</code>
   * @return The upstreamBindConfig.
   */
  io.envoyproxy.envoy.api.v2.core.BindConfig getUpstreamBindConfig();
  /**
   * <pre>
   * Optional configuration used to bind newly established upstream connections.
   * This overrides any bind_config specified in the bootstrap proto.
   * If the address and port are empty, no bind will be performed.
   * </pre>
   *
   * <code>.envoy.api.v2.core.BindConfig upstream_bind_config = 21;</code>
   */
  io.envoyproxy.envoy.api.v2.core.BindConfigOrBuilder getUpstreamBindConfigOrBuilder();

  /**
   * <pre>
   * Configuration for load balancing subsetting.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
   * @return Whether the lbSubsetConfig field is set.
   */
  boolean hasLbSubsetConfig();
  /**
   * <pre>
   * Configuration for load balancing subsetting.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
   * @return The lbSubsetConfig.
   */
  io.envoyproxy.envoy.api.v2.Cluster.LbSubsetConfig getLbSubsetConfig();
  /**
   * <pre>
   * Configuration for load balancing subsetting.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
   */
  io.envoyproxy.envoy.api.v2.Cluster.LbSubsetConfigOrBuilder getLbSubsetConfigOrBuilder();

  /**
   * <pre>
   * Optional configuration for the Ring Hash load balancing policy.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
   * @return Whether the ringHashLbConfig field is set.
   */
  boolean hasRingHashLbConfig();
  /**
   * <pre>
   * Optional configuration for the Ring Hash load balancing policy.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
   * @return The ringHashLbConfig.
   */
  io.envoyproxy.envoy.api.v2.Cluster.RingHashLbConfig getRingHashLbConfig();
  /**
   * <pre>
   * Optional configuration for the Ring Hash load balancing policy.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
   */
  io.envoyproxy.envoy.api.v2.Cluster.RingHashLbConfigOrBuilder getRingHashLbConfigOrBuilder();

  /**
   * <pre>
   * Optional configuration for the Original Destination load balancing policy.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
   * @return Whether the originalDstLbConfig field is set.
   */
  boolean hasOriginalDstLbConfig();
  /**
   * <pre>
   * Optional configuration for the Original Destination load balancing policy.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
   * @return The originalDstLbConfig.
   */
  io.envoyproxy.envoy.api.v2.Cluster.OriginalDstLbConfig getOriginalDstLbConfig();
  /**
   * <pre>
   * Optional configuration for the Original Destination load balancing policy.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
   */
  io.envoyproxy.envoy.api.v2.Cluster.OriginalDstLbConfigOrBuilder getOriginalDstLbConfigOrBuilder();

  /**
   * <pre>
   * Optional configuration for the LeastRequest load balancing policy.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
   * @return Whether the leastRequestLbConfig field is set.
   */
  boolean hasLeastRequestLbConfig();
  /**
   * <pre>
   * Optional configuration for the LeastRequest load balancing policy.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
   * @return The leastRequestLbConfig.
   */
  io.envoyproxy.envoy.api.v2.Cluster.LeastRequestLbConfig getLeastRequestLbConfig();
  /**
   * <pre>
   * Optional configuration for the LeastRequest load balancing policy.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
   */
  io.envoyproxy.envoy.api.v2.Cluster.LeastRequestLbConfigOrBuilder getLeastRequestLbConfigOrBuilder();

  /**
   * <pre>
   * Common configuration for all load balancer implementations.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.CommonLbConfig common_lb_config = 27;</code>
   * @return Whether the commonLbConfig field is set.
   */
  boolean hasCommonLbConfig();
  /**
   * <pre>
   * Common configuration for all load balancer implementations.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.CommonLbConfig common_lb_config = 27;</code>
   * @return The commonLbConfig.
   */
  io.envoyproxy.envoy.api.v2.Cluster.CommonLbConfig getCommonLbConfig();
  /**
   * <pre>
   * Common configuration for all load balancer implementations.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.CommonLbConfig common_lb_config = 27;</code>
   */
  io.envoyproxy.envoy.api.v2.Cluster.CommonLbConfigOrBuilder getCommonLbConfigOrBuilder();

  /**
   * <pre>
   * Optional custom transport socket implementation to use for upstream connections.
   * To setup TLS, set a transport socket with name `tls` and
   * :ref:`UpstreamTlsContexts &lt;envoy_api_msg_auth.UpstreamTlsContext&gt;` in the `typed_config`.
   * If no transport socket configuration is specified, new connections
   * will be set up with plaintext.
   * </pre>
   *
   * <code>.envoy.api.v2.core.TransportSocket transport_socket = 24;</code>
   * @return Whether the transportSocket field is set.
   */
  boolean hasTransportSocket();
  /**
   * <pre>
   * Optional custom transport socket implementation to use for upstream connections.
   * To setup TLS, set a transport socket with name `tls` and
   * :ref:`UpstreamTlsContexts &lt;envoy_api_msg_auth.UpstreamTlsContext&gt;` in the `typed_config`.
   * If no transport socket configuration is specified, new connections
   * will be set up with plaintext.
   * </pre>
   *
   * <code>.envoy.api.v2.core.TransportSocket transport_socket = 24;</code>
   * @return The transportSocket.
   */
  io.envoyproxy.envoy.api.v2.core.TransportSocket getTransportSocket();
  /**
   * <pre>
   * Optional custom transport socket implementation to use for upstream connections.
   * To setup TLS, set a transport socket with name `tls` and
   * :ref:`UpstreamTlsContexts &lt;envoy_api_msg_auth.UpstreamTlsContext&gt;` in the `typed_config`.
   * If no transport socket configuration is specified, new connections
   * will be set up with plaintext.
   * </pre>
   *
   * <code>.envoy.api.v2.core.TransportSocket transport_socket = 24;</code>
   */
  io.envoyproxy.envoy.api.v2.core.TransportSocketOrBuilder getTransportSocketOrBuilder();

  /**
   * <pre>
   * The Metadata field can be used to provide additional information about the
   * cluster. It can be used for stats, logging, and varying filter behavior.
   * Fields should use reverse DNS notation to denote which entity within Envoy
   * will need the information. For instance, if the metadata is intended for
   * the Router filter, the filter name should be specified as *envoy.filters.http.router*.
   * </pre>
   *
   * <code>.envoy.api.v2.core.Metadata metadata = 25;</code>
   * @return Whether the metadata field is set.
   */
  boolean hasMetadata();
  /**
   * <pre>
   * The Metadata field can be used to provide additional information about the
   * cluster. It can be used for stats, logging, and varying filter behavior.
   * Fields should use reverse DNS notation to denote which entity within Envoy
   * will need the information. For instance, if the metadata is intended for
   * the Router filter, the filter name should be specified as *envoy.filters.http.router*.
   * </pre>
   *
   * <code>.envoy.api.v2.core.Metadata metadata = 25;</code>
   * @return The metadata.
   */
  io.envoyproxy.envoy.api.v2.core.Metadata getMetadata();
  /**
   * <pre>
   * The Metadata field can be used to provide additional information about the
   * cluster. It can be used for stats, logging, and varying filter behavior.
   * Fields should use reverse DNS notation to denote which entity within Envoy
   * will need the information. For instance, if the metadata is intended for
   * the Router filter, the filter name should be specified as *envoy.filters.http.router*.
   * </pre>
   *
   * <code>.envoy.api.v2.core.Metadata metadata = 25;</code>
   */
  io.envoyproxy.envoy.api.v2.core.MetadataOrBuilder getMetadataOrBuilder();

  /**
   * <pre>
   * Determines how Envoy selects the protocol used to speak to upstream hosts.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.ClusterProtocolSelection protocol_selection = 26;</code>
   * @return The enum numeric value on the wire for protocolSelection.
   */
  int getProtocolSelectionValue();
  /**
   * <pre>
   * Determines how Envoy selects the protocol used to speak to upstream hosts.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.ClusterProtocolSelection protocol_selection = 26;</code>
   * @return The protocolSelection.
   */
  io.envoyproxy.envoy.api.v2.Cluster.ClusterProtocolSelection getProtocolSelection();

  /**
   * <pre>
   * Optional options for upstream connections.
   * </pre>
   *
   * <code>.envoy.api.v2.UpstreamConnectionOptions upstream_connection_options = 30;</code>
   * @return Whether the upstreamConnectionOptions field is set.
   */
  boolean hasUpstreamConnectionOptions();
  /**
   * <pre>
   * Optional options for upstream connections.
   * </pre>
   *
   * <code>.envoy.api.v2.UpstreamConnectionOptions upstream_connection_options = 30;</code>
   * @return The upstreamConnectionOptions.
   */
  io.envoyproxy.envoy.api.v2.UpstreamConnectionOptions getUpstreamConnectionOptions();
  /**
   * <pre>
   * Optional options for upstream connections.
   * </pre>
   *
   * <code>.envoy.api.v2.UpstreamConnectionOptions upstream_connection_options = 30;</code>
   */
  io.envoyproxy.envoy.api.v2.UpstreamConnectionOptionsOrBuilder getUpstreamConnectionOptionsOrBuilder();

  /**
   * <pre>
   * If an upstream host becomes unhealthy (as determined by the configured health checks
   * or outlier detection), immediately close all connections to the failed host.
   * .. note::
   *   This is currently only supported for connections created by tcp_proxy.
   * .. note::
   *   The current implementation of this feature closes all connections immediately when
   *   the unhealthy status is detected. If there are a large number of connections open
   *   to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
   *   time exclusively closing these connections, and not processing any other traffic.
   * </pre>
   *
   * <code>bool close_connections_on_host_health_failure = 31;</code>
   * @return The closeConnectionsOnHostHealthFailure.
   */
  boolean getCloseConnectionsOnHostHealthFailure();

  /**
   * <pre>
   * If set to true, Envoy will ignore the health value of a host when processing its removal
   * from service discovery. This means that if active health checking is used, Envoy will *not*
   * wait for the endpoint to go unhealthy before removing it.
   * </pre>
   *
   * <code>bool drain_connections_on_host_removal = 32 [(.udpa.annotations.field_migrate) = { ... }</code>
   * @return The drainConnectionsOnHostRemoval.
   */
  boolean getDrainConnectionsOnHostRemoval();

  /**
   * <pre>
   * An (optional) network filter chain, listed in the order the filters should be applied.
   * The chain will be applied to all outgoing connections that Envoy makes to the upstream
   * servers of this cluster.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.cluster.Filter filters = 40;</code>
   */
  java.util.List<io.envoyproxy.envoy.api.v2.cluster.Filter> 
      getFiltersList();
  /**
   * <pre>
   * An (optional) network filter chain, listed in the order the filters should be applied.
   * The chain will be applied to all outgoing connections that Envoy makes to the upstream
   * servers of this cluster.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.cluster.Filter filters = 40;</code>
   */
  io.envoyproxy.envoy.api.v2.cluster.Filter getFilters(int index);
  /**
   * <pre>
   * An (optional) network filter chain, listed in the order the filters should be applied.
   * The chain will be applied to all outgoing connections that Envoy makes to the upstream
   * servers of this cluster.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.cluster.Filter filters = 40;</code>
   */
  int getFiltersCount();
  /**
   * <pre>
   * An (optional) network filter chain, listed in the order the filters should be applied.
   * The chain will be applied to all outgoing connections that Envoy makes to the upstream
   * servers of this cluster.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.cluster.Filter filters = 40;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.api.v2.cluster.FilterOrBuilder> 
      getFiltersOrBuilderList();
  /**
   * <pre>
   * An (optional) network filter chain, listed in the order the filters should be applied.
   * The chain will be applied to all outgoing connections that Envoy makes to the upstream
   * servers of this cluster.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.cluster.Filter filters = 40;</code>
   */
  io.envoyproxy.envoy.api.v2.cluster.FilterOrBuilder getFiltersOrBuilder(
      int index);

  /**
   * <pre>
   * [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
   * :ref:`lb_policy&lt;envoy_api_field_Cluster.lb_policy&gt;` field has the value
   * :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;`.
   * </pre>
   *
   * <code>.envoy.api.v2.LoadBalancingPolicy load_balancing_policy = 41;</code>
   * @return Whether the loadBalancingPolicy field is set.
   */
  boolean hasLoadBalancingPolicy();
  /**
   * <pre>
   * [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
   * :ref:`lb_policy&lt;envoy_api_field_Cluster.lb_policy&gt;` field has the value
   * :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;`.
   * </pre>
   *
   * <code>.envoy.api.v2.LoadBalancingPolicy load_balancing_policy = 41;</code>
   * @return The loadBalancingPolicy.
   */
  io.envoyproxy.envoy.api.v2.LoadBalancingPolicy getLoadBalancingPolicy();
  /**
   * <pre>
   * [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
   * :ref:`lb_policy&lt;envoy_api_field_Cluster.lb_policy&gt;` field has the value
   * :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG&gt;`.
   * </pre>
   *
   * <code>.envoy.api.v2.LoadBalancingPolicy load_balancing_policy = 41;</code>
   */
  io.envoyproxy.envoy.api.v2.LoadBalancingPolicyOrBuilder getLoadBalancingPolicyOrBuilder();

  /**
   * <pre>
   * [#not-implemented-hide:]
   * If present, tells the client where to send load reports via LRS. If not present, the
   * client will fall back to a client-side default, which may be either (a) don't send any
   * load reports or (b) send load reports for all clusters to a single default server
   * (which may be configured in the bootstrap file).
   * Note that if multiple clusters point to the same LRS server, the client may choose to
   * create a separate stream for each cluster or it may choose to coalesce the data for
   * multiple clusters onto a single stream. Either way, the client must make sure to send
   * the data for any given cluster on no more than one stream.
   * [#next-major-version: In the v3 API, we should consider restructuring this somehow,
   * maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
   * from the LRS stream here.]
   * </pre>
   *
   * <code>.envoy.api.v2.core.ConfigSource lrs_server = 42;</code>
   * @return Whether the lrsServer field is set.
   */
  boolean hasLrsServer();
  /**
   * <pre>
   * [#not-implemented-hide:]
   * If present, tells the client where to send load reports via LRS. If not present, the
   * client will fall back to a client-side default, which may be either (a) don't send any
   * load reports or (b) send load reports for all clusters to a single default server
   * (which may be configured in the bootstrap file).
   * Note that if multiple clusters point to the same LRS server, the client may choose to
   * create a separate stream for each cluster or it may choose to coalesce the data for
   * multiple clusters onto a single stream. Either way, the client must make sure to send
   * the data for any given cluster on no more than one stream.
   * [#next-major-version: In the v3 API, we should consider restructuring this somehow,
   * maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
   * from the LRS stream here.]
   * </pre>
   *
   * <code>.envoy.api.v2.core.ConfigSource lrs_server = 42;</code>
   * @return The lrsServer.
   */
  io.envoyproxy.envoy.api.v2.core.ConfigSource getLrsServer();
  /**
   * <pre>
   * [#not-implemented-hide:]
   * If present, tells the client where to send load reports via LRS. If not present, the
   * client will fall back to a client-side default, which may be either (a) don't send any
   * load reports or (b) send load reports for all clusters to a single default server
   * (which may be configured in the bootstrap file).
   * Note that if multiple clusters point to the same LRS server, the client may choose to
   * create a separate stream for each cluster or it may choose to coalesce the data for
   * multiple clusters onto a single stream. Either way, the client must make sure to send
   * the data for any given cluster on no more than one stream.
   * [#next-major-version: In the v3 API, we should consider restructuring this somehow,
   * maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
   * from the LRS stream here.]
   * </pre>
   *
   * <code>.envoy.api.v2.core.ConfigSource lrs_server = 42;</code>
   */
  io.envoyproxy.envoy.api.v2.core.ConfigSourceOrBuilder getLrsServerOrBuilder();

  /**
   * <pre>
   * If track_timeout_budgets is true, the :ref:`timeout budget histograms
   * &lt;config_cluster_manager_cluster_stats_timeout_budgets&gt;` will be published for each
   * request. These show what percentage of a request's per try and global timeout was used. A value
   * of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
   * of 100 would indicate that the request took the entirety of the timeout given to it.
   * </pre>
   *
   * <code>bool track_timeout_budgets = 47;</code>
   * @return The trackTimeoutBudgets.
   */
  boolean getTrackTimeoutBudgets();

  public io.envoyproxy.envoy.api.v2.Cluster.ClusterDiscoveryTypeCase getClusterDiscoveryTypeCase();

  public io.envoyproxy.envoy.api.v2.Cluster.LbConfigCase getLbConfigCase();
}
