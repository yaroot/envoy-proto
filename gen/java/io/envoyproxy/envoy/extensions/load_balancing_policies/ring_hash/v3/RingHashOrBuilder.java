// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/extensions/load_balancing_policies/ring_hash/v3/ring_hash.proto

package io.envoyproxy.envoy.extensions.load_balancing_policies.ring_hash.v3;

public interface RingHashOrBuilder extends
    // @@protoc_insertion_point(interface_extends:envoy.extensions.load_balancing_policies.ring_hash.v3.RingHash)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * The hash function used to hash hosts onto the ketama ring. The value defaults to
   * :ref:`XX_HASH&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH&gt;`.
   * </pre>
   *
   * <code>.envoy.extensions.load_balancing_policies.ring_hash.v3.RingHash.HashFunction hash_function = 1 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for hashFunction.
   */
  int getHashFunctionValue();
  /**
   * <pre>
   * The hash function used to hash hosts onto the ketama ring. The value defaults to
   * :ref:`XX_HASH&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH&gt;`.
   * </pre>
   *
   * <code>.envoy.extensions.load_balancing_policies.ring_hash.v3.RingHash.HashFunction hash_function = 1 [(.validate.rules) = { ... }</code>
   * @return The hashFunction.
   */
  io.envoyproxy.envoy.extensions.load_balancing_policies.ring_hash.v3.RingHash.HashFunction getHashFunction();

  /**
   * <pre>
   * Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
   * provided host) the better the request distribution will reflect the desired weights. Defaults
   * to 1024 entries, and limited to 8M entries. See also
   * :ref:`maximum_ring_size&lt;envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size&gt;`.
   * </pre>
   *
   * <code>.google.protobuf.UInt64Value minimum_ring_size = 2 [(.validate.rules) = { ... }</code>
   * @return Whether the minimumRingSize field is set.
   */
  boolean hasMinimumRingSize();
  /**
   * <pre>
   * Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
   * provided host) the better the request distribution will reflect the desired weights. Defaults
   * to 1024 entries, and limited to 8M entries. See also
   * :ref:`maximum_ring_size&lt;envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size&gt;`.
   * </pre>
   *
   * <code>.google.protobuf.UInt64Value minimum_ring_size = 2 [(.validate.rules) = { ... }</code>
   * @return The minimumRingSize.
   */
  com.google.protobuf.UInt64Value getMinimumRingSize();
  /**
   * <pre>
   * Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
   * provided host) the better the request distribution will reflect the desired weights. Defaults
   * to 1024 entries, and limited to 8M entries. See also
   * :ref:`maximum_ring_size&lt;envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size&gt;`.
   * </pre>
   *
   * <code>.google.protobuf.UInt64Value minimum_ring_size = 2 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.UInt64ValueOrBuilder getMinimumRingSizeOrBuilder();

  /**
   * <pre>
   * Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
   * to further constrain resource use. See also
   * :ref:`minimum_ring_size&lt;envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size&gt;`.
   * </pre>
   *
   * <code>.google.protobuf.UInt64Value maximum_ring_size = 3 [(.validate.rules) = { ... }</code>
   * @return Whether the maximumRingSize field is set.
   */
  boolean hasMaximumRingSize();
  /**
   * <pre>
   * Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
   * to further constrain resource use. See also
   * :ref:`minimum_ring_size&lt;envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size&gt;`.
   * </pre>
   *
   * <code>.google.protobuf.UInt64Value maximum_ring_size = 3 [(.validate.rules) = { ... }</code>
   * @return The maximumRingSize.
   */
  com.google.protobuf.UInt64Value getMaximumRingSize();
  /**
   * <pre>
   * Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
   * to further constrain resource use. See also
   * :ref:`minimum_ring_size&lt;envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size&gt;`.
   * </pre>
   *
   * <code>.google.protobuf.UInt64Value maximum_ring_size = 3 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.UInt64ValueOrBuilder getMaximumRingSizeOrBuilder();

  /**
   * <pre>
   * If set to `true`, the cluster will use hostname instead of the resolved
   * address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
   * </pre>
   *
   * <code>bool use_hostname_for_hashing = 4;</code>
   * @return The useHostnameForHashing.
   */
  boolean getUseHostnameForHashing();

  /**
   * <pre>
   * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
   * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
   * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
   * Minimum is 100.
   * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
   * `hash_balance_factor`, requests to any upstream host are capped at `hash_balance_factor/100` times the average number of requests
   * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
   * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
   * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
   * cascading overflow effect when choosing the next host in the ring/table).
   * If weights are specified on the hosts, they are respected.
   * This is an O(N) algorithm, unlike other load balancers. Using a lower `hash_balance_factor` results in more hosts
   * being probed, so use a higher value if you require better performance.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value hash_balance_factor = 5 [(.validate.rules) = { ... }</code>
   * @return Whether the hashBalanceFactor field is set.
   */
  boolean hasHashBalanceFactor();
  /**
   * <pre>
   * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
   * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
   * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
   * Minimum is 100.
   * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
   * `hash_balance_factor`, requests to any upstream host are capped at `hash_balance_factor/100` times the average number of requests
   * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
   * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
   * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
   * cascading overflow effect when choosing the next host in the ring/table).
   * If weights are specified on the hosts, they are respected.
   * This is an O(N) algorithm, unlike other load balancers. Using a lower `hash_balance_factor` results in more hosts
   * being probed, so use a higher value if you require better performance.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value hash_balance_factor = 5 [(.validate.rules) = { ... }</code>
   * @return The hashBalanceFactor.
   */
  com.google.protobuf.UInt32Value getHashBalanceFactor();
  /**
   * <pre>
   * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
   * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
   * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
   * Minimum is 100.
   * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
   * `hash_balance_factor`, requests to any upstream host are capped at `hash_balance_factor/100` times the average number of requests
   * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
   * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
   * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
   * cascading overflow effect when choosing the next host in the ring/table).
   * If weights are specified on the hosts, they are respected.
   * This is an O(N) algorithm, unlike other load balancers. Using a lower `hash_balance_factor` results in more hosts
   * being probed, so use a higher value if you require better performance.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value hash_balance_factor = 5 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getHashBalanceFactorOrBuilder();
}
