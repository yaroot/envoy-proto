// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/extensions/common/dynamic_forward_proxy/v3/dns_cache.proto

package io.envoyproxy.envoy.extensions.common.dynamic_forward_proxy.v3;

public interface DnsCacheConfigOrBuilder extends
    // @@protoc_insertion_point(interface_extends:envoy.extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * The name of the cache. Multiple named caches allow independent dynamic forward proxy
   * configurations to operate within a single Envoy process using different configurations. All
   * configurations with the same name *must* otherwise have the same settings when referenced
   * from different configuration components. Configuration will fail to load if this is not
   * the case.
   * </pre>
   *
   * <code>string name = 1 [(.validate.rules) = { ... }</code>
   * @return The name.
   */
  java.lang.String getName();
  /**
   * <pre>
   * The name of the cache. Multiple named caches allow independent dynamic forward proxy
   * configurations to operate within a single Envoy process using different configurations. All
   * configurations with the same name *must* otherwise have the same settings when referenced
   * from different configuration components. Configuration will fail to load if this is not
   * the case.
   * </pre>
   *
   * <code>string name = 1 [(.validate.rules) = { ... }</code>
   * @return The bytes for name.
   */
  com.google.protobuf.ByteString
      getNameBytes();

  /**
   * <pre>
   * The DNS lookup family to use during resolution.
   * [#comment:TODO(mattklein123): Figure out how to support IPv4/IPv6 "happy eyeballs" mode. The
   * way this might work is a new lookup family which returns both IPv4 and IPv6 addresses, and
   * then configures a host to have a primary and fall back address. With this, we could very
   * likely build a "happy eyeballs" connection pool which would race the primary / fall back
   * address and return the one that wins. This same method could potentially also be used for
   * QUIC to TCP fall back.]
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.DnsLookupFamily dns_lookup_family = 2 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for dnsLookupFamily.
   */
  int getDnsLookupFamilyValue();
  /**
   * <pre>
   * The DNS lookup family to use during resolution.
   * [#comment:TODO(mattklein123): Figure out how to support IPv4/IPv6 "happy eyeballs" mode. The
   * way this might work is a new lookup family which returns both IPv4 and IPv6 addresses, and
   * then configures a host to have a primary and fall back address. With this, we could very
   * likely build a "happy eyeballs" connection pool which would race the primary / fall back
   * address and return the one that wins. This same method could potentially also be used for
   * QUIC to TCP fall back.]
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.DnsLookupFamily dns_lookup_family = 2 [(.validate.rules) = { ... }</code>
   * @return The dnsLookupFamily.
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.DnsLookupFamily getDnsLookupFamily();

  /**
   * <pre>
   * The DNS refresh rate for unresolved DNS hosts. If not specified defaults to 60s.
   * The refresh rate is rounded to the closest millisecond, and must be at least 1ms.
   * Once a host has been resolved, the refresh rate will be the DNS TTL, capped
   * at a minimum of ``dns_min_refresh_rate``.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_refresh_rate = 3 [(.validate.rules) = { ... }</code>
   * @return Whether the dnsRefreshRate field is set.
   */
  boolean hasDnsRefreshRate();
  /**
   * <pre>
   * The DNS refresh rate for unresolved DNS hosts. If not specified defaults to 60s.
   * The refresh rate is rounded to the closest millisecond, and must be at least 1ms.
   * Once a host has been resolved, the refresh rate will be the DNS TTL, capped
   * at a minimum of ``dns_min_refresh_rate``.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_refresh_rate = 3 [(.validate.rules) = { ... }</code>
   * @return The dnsRefreshRate.
   */
  com.google.protobuf.Duration getDnsRefreshRate();
  /**
   * <pre>
   * The DNS refresh rate for unresolved DNS hosts. If not specified defaults to 60s.
   * The refresh rate is rounded to the closest millisecond, and must be at least 1ms.
   * Once a host has been resolved, the refresh rate will be the DNS TTL, capped
   * at a minimum of ``dns_min_refresh_rate``.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_refresh_rate = 3 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.DurationOrBuilder getDnsRefreshRateOrBuilder();

  /**
   * <pre>
   * The minimum rate that DNS resolution will occur. Per ``dns_refresh_rate``, once a host is
   * resolved, the DNS TTL will be used, with a minimum set by ``dns_min_refresh_rate``.
   * ``dns_min_refresh_rate`` defaults to 5s and must also be &gt;= 5s.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_min_refresh_rate = 14 [(.validate.rules) = { ... }</code>
   * @return Whether the dnsMinRefreshRate field is set.
   */
  boolean hasDnsMinRefreshRate();
  /**
   * <pre>
   * The minimum rate that DNS resolution will occur. Per ``dns_refresh_rate``, once a host is
   * resolved, the DNS TTL will be used, with a minimum set by ``dns_min_refresh_rate``.
   * ``dns_min_refresh_rate`` defaults to 5s and must also be &gt;= 5s.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_min_refresh_rate = 14 [(.validate.rules) = { ... }</code>
   * @return The dnsMinRefreshRate.
   */
  com.google.protobuf.Duration getDnsMinRefreshRate();
  /**
   * <pre>
   * The minimum rate that DNS resolution will occur. Per ``dns_refresh_rate``, once a host is
   * resolved, the DNS TTL will be used, with a minimum set by ``dns_min_refresh_rate``.
   * ``dns_min_refresh_rate`` defaults to 5s and must also be &gt;= 5s.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_min_refresh_rate = 14 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.DurationOrBuilder getDnsMinRefreshRateOrBuilder();

  /**
   * <pre>
   * The TTL for hosts that are unused. Hosts that have not been used in the configured time
   * interval will be purged. If not specified defaults to 5m.
   * .. note:
   *   The TTL is only checked at the time of DNS refresh, as specified by ``dns_refresh_rate``. This
   *   means that if the configured TTL is shorter than the refresh rate the host may not be removed
   *   immediately.
   *  .. note:
   *   The TTL has no relation to DNS TTL and is only used to control Envoy's resource usage.
   * </pre>
   *
   * <code>.google.protobuf.Duration host_ttl = 4 [(.validate.rules) = { ... }</code>
   * @return Whether the hostTtl field is set.
   */
  boolean hasHostTtl();
  /**
   * <pre>
   * The TTL for hosts that are unused. Hosts that have not been used in the configured time
   * interval will be purged. If not specified defaults to 5m.
   * .. note:
   *   The TTL is only checked at the time of DNS refresh, as specified by ``dns_refresh_rate``. This
   *   means that if the configured TTL is shorter than the refresh rate the host may not be removed
   *   immediately.
   *  .. note:
   *   The TTL has no relation to DNS TTL and is only used to control Envoy's resource usage.
   * </pre>
   *
   * <code>.google.protobuf.Duration host_ttl = 4 [(.validate.rules) = { ... }</code>
   * @return The hostTtl.
   */
  com.google.protobuf.Duration getHostTtl();
  /**
   * <pre>
   * The TTL for hosts that are unused. Hosts that have not been used in the configured time
   * interval will be purged. If not specified defaults to 5m.
   * .. note:
   *   The TTL is only checked at the time of DNS refresh, as specified by ``dns_refresh_rate``. This
   *   means that if the configured TTL is shorter than the refresh rate the host may not be removed
   *   immediately.
   *  .. note:
   *   The TTL has no relation to DNS TTL and is only used to control Envoy's resource usage.
   * </pre>
   *
   * <code>.google.protobuf.Duration host_ttl = 4 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.DurationOrBuilder getHostTtlOrBuilder();

  /**
   * <pre>
   * The maximum number of hosts that the cache will hold. If not specified defaults to 1024.
   * .. note:
   *   The implementation is approximate and enforced independently on each worker thread, thus
   *   it is possible for the maximum hosts in the cache to go slightly above the configured
   *   value depending on timing. This is similar to how other circuit breakers work.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_hosts = 5 [(.validate.rules) = { ... }</code>
   * @return Whether the maxHosts field is set.
   */
  boolean hasMaxHosts();
  /**
   * <pre>
   * The maximum number of hosts that the cache will hold. If not specified defaults to 1024.
   * .. note:
   *   The implementation is approximate and enforced independently on each worker thread, thus
   *   it is possible for the maximum hosts in the cache to go slightly above the configured
   *   value depending on timing. This is similar to how other circuit breakers work.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_hosts = 5 [(.validate.rules) = { ... }</code>
   * @return The maxHosts.
   */
  com.google.protobuf.UInt32Value getMaxHosts();
  /**
   * <pre>
   * The maximum number of hosts that the cache will hold. If not specified defaults to 1024.
   * .. note:
   *   The implementation is approximate and enforced independently on each worker thread, thus
   *   it is possible for the maximum hosts in the cache to go slightly above the configured
   *   value depending on timing. This is similar to how other circuit breakers work.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_hosts = 5 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getMaxHostsOrBuilder();

  /**
   * <pre>
   * If the DNS failure refresh rate is specified,
   * this is used as the cache's DNS refresh rate when DNS requests are failing. If this setting is
   * not specified, the failure refresh rate defaults to the dns_refresh_rate.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 6;</code>
   * @return Whether the dnsFailureRefreshRate field is set.
   */
  boolean hasDnsFailureRefreshRate();
  /**
   * <pre>
   * If the DNS failure refresh rate is specified,
   * this is used as the cache's DNS refresh rate when DNS requests are failing. If this setting is
   * not specified, the failure refresh rate defaults to the dns_refresh_rate.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 6;</code>
   * @return The dnsFailureRefreshRate.
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRate getDnsFailureRefreshRate();
  /**
   * <pre>
   * If the DNS failure refresh rate is specified,
   * this is used as the cache's DNS refresh rate when DNS requests are failing. If this setting is
   * not specified, the failure refresh rate defaults to the dns_refresh_rate.
   * </pre>
   *
   * <code>.envoy.config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 6;</code>
   */
  io.envoyproxy.envoy.config.cluster.v3.Cluster.RefreshRateOrBuilder getDnsFailureRefreshRateOrBuilder();

  /**
   * <pre>
   * The config of circuit breakers for resolver. It provides a configurable threshold.
   * Envoy will use dns cache circuit breakers with default settings even if this value is not set.
   * </pre>
   *
   * <code>.envoy.extensions.common.dynamic_forward_proxy.v3.DnsCacheCircuitBreakers dns_cache_circuit_breaker = 7;</code>
   * @return Whether the dnsCacheCircuitBreaker field is set.
   */
  boolean hasDnsCacheCircuitBreaker();
  /**
   * <pre>
   * The config of circuit breakers for resolver. It provides a configurable threshold.
   * Envoy will use dns cache circuit breakers with default settings even if this value is not set.
   * </pre>
   *
   * <code>.envoy.extensions.common.dynamic_forward_proxy.v3.DnsCacheCircuitBreakers dns_cache_circuit_breaker = 7;</code>
   * @return The dnsCacheCircuitBreaker.
   */
  io.envoyproxy.envoy.extensions.common.dynamic_forward_proxy.v3.DnsCacheCircuitBreakers getDnsCacheCircuitBreaker();
  /**
   * <pre>
   * The config of circuit breakers for resolver. It provides a configurable threshold.
   * Envoy will use dns cache circuit breakers with default settings even if this value is not set.
   * </pre>
   *
   * <code>.envoy.extensions.common.dynamic_forward_proxy.v3.DnsCacheCircuitBreakers dns_cache_circuit_breaker = 7;</code>
   */
  io.envoyproxy.envoy.extensions.common.dynamic_forward_proxy.v3.DnsCacheCircuitBreakersOrBuilder getDnsCacheCircuitBreakerOrBuilder();

  /**
   * <pre>
   * Always use TCP queries instead of UDP queries for DNS lookups.
   * This field is deprecated in favor of ``dns_resolution_config``
   * which aggregates all of the DNS resolver configuration in a single message.
   * </pre>
   *
   * <code>bool use_tcp_for_dns_lookups = 8 [deprecated = true, (.envoy.annotations.deprecated_at_minor_version) = "3.0"];</code>
   * @deprecated envoy.extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.use_tcp_for_dns_lookups is deprecated.
   *     See envoy/extensions/common/dynamic_forward_proxy/v3/dns_cache.proto;l=108
   * @return The useTcpForDnsLookups.
   */
  @java.lang.Deprecated boolean getUseTcpForDnsLookups();

  /**
   * <pre>
   * DNS resolution configuration which includes the underlying dns resolver addresses and options.
   * This field is deprecated in favor of
   * :ref:`typed_dns_resolver_config &lt;envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.typed_dns_resolver_config&gt;`.
   * </pre>
   *
   * <code>.envoy.config.core.v3.DnsResolutionConfig dns_resolution_config = 9 [deprecated = true, (.envoy.annotations.deprecated_at_minor_version) = "3.0"];</code>
   * @deprecated envoy.extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.dns_resolution_config is deprecated.
   *     See envoy/extensions/common/dynamic_forward_proxy/v3/dns_cache.proto;l=114
   * @return Whether the dnsResolutionConfig field is set.
   */
  @java.lang.Deprecated boolean hasDnsResolutionConfig();
  /**
   * <pre>
   * DNS resolution configuration which includes the underlying dns resolver addresses and options.
   * This field is deprecated in favor of
   * :ref:`typed_dns_resolver_config &lt;envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.typed_dns_resolver_config&gt;`.
   * </pre>
   *
   * <code>.envoy.config.core.v3.DnsResolutionConfig dns_resolution_config = 9 [deprecated = true, (.envoy.annotations.deprecated_at_minor_version) = "3.0"];</code>
   * @deprecated envoy.extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.dns_resolution_config is deprecated.
   *     See envoy/extensions/common/dynamic_forward_proxy/v3/dns_cache.proto;l=114
   * @return The dnsResolutionConfig.
   */
  @java.lang.Deprecated io.envoyproxy.envoy.config.core.v3.DnsResolutionConfig getDnsResolutionConfig();
  /**
   * <pre>
   * DNS resolution configuration which includes the underlying dns resolver addresses and options.
   * This field is deprecated in favor of
   * :ref:`typed_dns_resolver_config &lt;envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.typed_dns_resolver_config&gt;`.
   * </pre>
   *
   * <code>.envoy.config.core.v3.DnsResolutionConfig dns_resolution_config = 9 [deprecated = true, (.envoy.annotations.deprecated_at_minor_version) = "3.0"];</code>
   */
  @java.lang.Deprecated io.envoyproxy.envoy.config.core.v3.DnsResolutionConfigOrBuilder getDnsResolutionConfigOrBuilder();

  /**
   * <pre>
   * DNS resolver type configuration extension. This extension can be used to configure c-ares, apple,
   * or any other DNS resolver types and the related parameters.
   * For example, an object of
   * :ref:`CaresDnsResolverConfig &lt;envoy_v3_api_msg_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig&gt;`
   * can be packed into this ``typed_dns_resolver_config``. This configuration replaces the
   * :ref:`dns_resolution_config &lt;envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.dns_resolution_config&gt;`
   * configuration.
   * During the transition period when both ``dns_resolution_config`` and ``typed_dns_resolver_config`` exists,
   * when ``typed_dns_resolver_config`` is in place, Envoy will use it and ignore ``dns_resolution_config``.
   * When ``typed_dns_resolver_config`` is missing, the default behavior is in place.
   * [#extension-category: envoy.network.dns_resolver]
   * </pre>
   *
   * <code>.envoy.config.core.v3.TypedExtensionConfig typed_dns_resolver_config = 12;</code>
   * @return Whether the typedDnsResolverConfig field is set.
   */
  boolean hasTypedDnsResolverConfig();
  /**
   * <pre>
   * DNS resolver type configuration extension. This extension can be used to configure c-ares, apple,
   * or any other DNS resolver types and the related parameters.
   * For example, an object of
   * :ref:`CaresDnsResolverConfig &lt;envoy_v3_api_msg_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig&gt;`
   * can be packed into this ``typed_dns_resolver_config``. This configuration replaces the
   * :ref:`dns_resolution_config &lt;envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.dns_resolution_config&gt;`
   * configuration.
   * During the transition period when both ``dns_resolution_config`` and ``typed_dns_resolver_config`` exists,
   * when ``typed_dns_resolver_config`` is in place, Envoy will use it and ignore ``dns_resolution_config``.
   * When ``typed_dns_resolver_config`` is missing, the default behavior is in place.
   * [#extension-category: envoy.network.dns_resolver]
   * </pre>
   *
   * <code>.envoy.config.core.v3.TypedExtensionConfig typed_dns_resolver_config = 12;</code>
   * @return The typedDnsResolverConfig.
   */
  io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig getTypedDnsResolverConfig();
  /**
   * <pre>
   * DNS resolver type configuration extension. This extension can be used to configure c-ares, apple,
   * or any other DNS resolver types and the related parameters.
   * For example, an object of
   * :ref:`CaresDnsResolverConfig &lt;envoy_v3_api_msg_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig&gt;`
   * can be packed into this ``typed_dns_resolver_config``. This configuration replaces the
   * :ref:`dns_resolution_config &lt;envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.dns_resolution_config&gt;`
   * configuration.
   * During the transition period when both ``dns_resolution_config`` and ``typed_dns_resolver_config`` exists,
   * when ``typed_dns_resolver_config`` is in place, Envoy will use it and ignore ``dns_resolution_config``.
   * When ``typed_dns_resolver_config`` is missing, the default behavior is in place.
   * [#extension-category: envoy.network.dns_resolver]
   * </pre>
   *
   * <code>.envoy.config.core.v3.TypedExtensionConfig typed_dns_resolver_config = 12;</code>
   */
  io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder getTypedDnsResolverConfigOrBuilder();

  /**
   * <pre>
   * Hostnames that should be preresolved into the cache upon creation. This might provide a
   * performance improvement, in the form of cache hits, for hostnames that are going to be
   * resolved during steady state and are known at config load time.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.SocketAddress preresolve_hostnames = 10;</code>
   */
  java.util.List<io.envoyproxy.envoy.config.core.v3.SocketAddress> 
      getPreresolveHostnamesList();
  /**
   * <pre>
   * Hostnames that should be preresolved into the cache upon creation. This might provide a
   * performance improvement, in the form of cache hits, for hostnames that are going to be
   * resolved during steady state and are known at config load time.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.SocketAddress preresolve_hostnames = 10;</code>
   */
  io.envoyproxy.envoy.config.core.v3.SocketAddress getPreresolveHostnames(int index);
  /**
   * <pre>
   * Hostnames that should be preresolved into the cache upon creation. This might provide a
   * performance improvement, in the form of cache hits, for hostnames that are going to be
   * resolved during steady state and are known at config load time.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.SocketAddress preresolve_hostnames = 10;</code>
   */
  int getPreresolveHostnamesCount();
  /**
   * <pre>
   * Hostnames that should be preresolved into the cache upon creation. This might provide a
   * performance improvement, in the form of cache hits, for hostnames that are going to be
   * resolved during steady state and are known at config load time.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.SocketAddress preresolve_hostnames = 10;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.config.core.v3.SocketAddressOrBuilder> 
      getPreresolveHostnamesOrBuilderList();
  /**
   * <pre>
   * Hostnames that should be preresolved into the cache upon creation. This might provide a
   * performance improvement, in the form of cache hits, for hostnames that are going to be
   * resolved during steady state and are known at config load time.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.SocketAddress preresolve_hostnames = 10;</code>
   */
  io.envoyproxy.envoy.config.core.v3.SocketAddressOrBuilder getPreresolveHostnamesOrBuilder(
      int index);

  /**
   * <pre>
   * The timeout used for DNS queries. This timeout is independent of any timeout and retry policy
   * used by the underlying DNS implementation (e.g., c-areas and Apple DNS) which are opaque.
   * Setting this timeout will ensure that queries succeed or fail within the specified time frame
   * and are then retried using the standard refresh rates. Defaults to 5s if not set.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_query_timeout = 11 [(.validate.rules) = { ... }</code>
   * @return Whether the dnsQueryTimeout field is set.
   */
  boolean hasDnsQueryTimeout();
  /**
   * <pre>
   * The timeout used for DNS queries. This timeout is independent of any timeout and retry policy
   * used by the underlying DNS implementation (e.g., c-areas and Apple DNS) which are opaque.
   * Setting this timeout will ensure that queries succeed or fail within the specified time frame
   * and are then retried using the standard refresh rates. Defaults to 5s if not set.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_query_timeout = 11 [(.validate.rules) = { ... }</code>
   * @return The dnsQueryTimeout.
   */
  com.google.protobuf.Duration getDnsQueryTimeout();
  /**
   * <pre>
   * The timeout used for DNS queries. This timeout is independent of any timeout and retry policy
   * used by the underlying DNS implementation (e.g., c-areas and Apple DNS) which are opaque.
   * Setting this timeout will ensure that queries succeed or fail within the specified time frame
   * and are then retried using the standard refresh rates. Defaults to 5s if not set.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_query_timeout = 11 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.DurationOrBuilder getDnsQueryTimeoutOrBuilder();

  /**
   * <pre>
   * [#not-implemented-hide:]
   * Configuration to flush the DNS cache to long term storage.
   * </pre>
   *
   * <code>.envoy.config.common.key_value.v3.KeyValueStoreConfig key_value_config = 13;</code>
   * @return Whether the keyValueConfig field is set.
   */
  boolean hasKeyValueConfig();
  /**
   * <pre>
   * [#not-implemented-hide:]
   * Configuration to flush the DNS cache to long term storage.
   * </pre>
   *
   * <code>.envoy.config.common.key_value.v3.KeyValueStoreConfig key_value_config = 13;</code>
   * @return The keyValueConfig.
   */
  io.envoyproxy.envoy.config.common.key_value.v3.KeyValueStoreConfig getKeyValueConfig();
  /**
   * <pre>
   * [#not-implemented-hide:]
   * Configuration to flush the DNS cache to long term storage.
   * </pre>
   *
   * <code>.envoy.config.common.key_value.v3.KeyValueStoreConfig key_value_config = 13;</code>
   */
  io.envoyproxy.envoy.config.common.key_value.v3.KeyValueStoreConfigOrBuilder getKeyValueConfigOrBuilder();
}
