// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto

package io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3;

/**
 * <pre>
 * [#next-free-field: 53]
 * </pre>
 *
 * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager}
 */
public final class HttpConnectionManager extends
    com.google.protobuf.GeneratedMessageV3 implements
    // @@protoc_insertion_point(message_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager)
    HttpConnectionManagerOrBuilder {
private static final long serialVersionUID = 0L;
  // Use HttpConnectionManager.newBuilder() to construct.
  private HttpConnectionManager(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }
  private HttpConnectionManager() {
    codecType_ = 0;
    statPrefix_ = "";
    httpFilters_ = java.util.Collections.emptyList();
    serverName_ = "";
    serverHeaderTransformation_ = 0;
    accessLog_ = java.util.Collections.emptyList();
    originalIpDetectionExtensions_ = java.util.Collections.emptyList();
    earlyHeaderMutationExtensions_ = java.util.Collections.emptyList();
    via_ = "";
    forwardClientCertDetails_ = 0;
    upgradeConfigs_ = java.util.Collections.emptyList();
    pathWithEscapedSlashesAction_ = 0;
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(
      UnusedPrivateParameter unused) {
    return new HttpConnectionManager();
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet
  getUnknownFields() {
    return this.unknownFields;
  }
  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Builder.class);
  }

  /**
   * Protobuf enum {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType}
   */
  public enum CodecType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * For every new connection, the connection manager will determine which
     * codec to use. This mode supports both ALPN for TLS listeners as well as
     * protocol inference for plaintext listeners. If ALPN data is available, it
     * is preferred, otherwise protocol inference is used. In almost all cases,
     * this is the right option to choose for this setting.
     * </pre>
     *
     * <code>AUTO = 0;</code>
     */
    AUTO(0),
    /**
     * <pre>
     * The connection manager will assume that the client is speaking HTTP/1.1.
     * </pre>
     *
     * <code>HTTP1 = 1;</code>
     */
    HTTP1(1),
    /**
     * <pre>
     * The connection manager will assume that the client is speaking HTTP/2
     * (Envoy does not require HTTP/2 to take place over TLS or to use ALPN.
     * Prior knowledge is allowed).
     * </pre>
     *
     * <code>HTTP2 = 2;</code>
     */
    HTTP2(2),
    /**
     * <pre>
     * [#not-implemented-hide:] QUIC implementation is not production ready yet. Use this enum with
     * caution to prevent accidental execution of QUIC code. I.e. `!= HTTP2` is no longer sufficient
     * to distinguish HTTP1 and HTTP2 traffic.
     * </pre>
     *
     * <code>HTTP3 = 3;</code>
     */
    HTTP3(3),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * For every new connection, the connection manager will determine which
     * codec to use. This mode supports both ALPN for TLS listeners as well as
     * protocol inference for plaintext listeners. If ALPN data is available, it
     * is preferred, otherwise protocol inference is used. In almost all cases,
     * this is the right option to choose for this setting.
     * </pre>
     *
     * <code>AUTO = 0;</code>
     */
    public static final int AUTO_VALUE = 0;
    /**
     * <pre>
     * The connection manager will assume that the client is speaking HTTP/1.1.
     * </pre>
     *
     * <code>HTTP1 = 1;</code>
     */
    public static final int HTTP1_VALUE = 1;
    /**
     * <pre>
     * The connection manager will assume that the client is speaking HTTP/2
     * (Envoy does not require HTTP/2 to take place over TLS or to use ALPN.
     * Prior knowledge is allowed).
     * </pre>
     *
     * <code>HTTP2 = 2;</code>
     */
    public static final int HTTP2_VALUE = 2;
    /**
     * <pre>
     * [#not-implemented-hide:] QUIC implementation is not production ready yet. Use this enum with
     * caution to prevent accidental execution of QUIC code. I.e. `!= HTTP2` is no longer sufficient
     * to distinguish HTTP1 and HTTP2 traffic.
     * </pre>
     *
     * <code>HTTP3 = 3;</code>
     */
    public static final int HTTP3_VALUE = 3;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static CodecType valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static CodecType forNumber(int value) {
      switch (value) {
        case 0: return AUTO;
        case 1: return HTTP1;
        case 2: return HTTP2;
        case 3: return HTTP3;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<CodecType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        CodecType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<CodecType>() {
            public CodecType findValueByNumber(int number) {
              return CodecType.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.getDescriptor().getEnumTypes().get(0);
    }

    private static final CodecType[] VALUES = values();

    public static CodecType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private CodecType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType)
  }

  /**
   * Protobuf enum {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation}
   */
  public enum ServerHeaderTransformation
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * Overwrite any Server header with the contents of server_name.
     * </pre>
     *
     * <code>OVERWRITE = 0;</code>
     */
    OVERWRITE(0),
    /**
     * <pre>
     * If no Server header is present, append Server server_name
     * If a Server header is present, pass it through.
     * </pre>
     *
     * <code>APPEND_IF_ABSENT = 1;</code>
     */
    APPEND_IF_ABSENT(1),
    /**
     * <pre>
     * Pass through the value of the server header, and do not append a header
     * if none is present.
     * </pre>
     *
     * <code>PASS_THROUGH = 2;</code>
     */
    PASS_THROUGH(2),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * Overwrite any Server header with the contents of server_name.
     * </pre>
     *
     * <code>OVERWRITE = 0;</code>
     */
    public static final int OVERWRITE_VALUE = 0;
    /**
     * <pre>
     * If no Server header is present, append Server server_name
     * If a Server header is present, pass it through.
     * </pre>
     *
     * <code>APPEND_IF_ABSENT = 1;</code>
     */
    public static final int APPEND_IF_ABSENT_VALUE = 1;
    /**
     * <pre>
     * Pass through the value of the server header, and do not append a header
     * if none is present.
     * </pre>
     *
     * <code>PASS_THROUGH = 2;</code>
     */
    public static final int PASS_THROUGH_VALUE = 2;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static ServerHeaderTransformation valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static ServerHeaderTransformation forNumber(int value) {
      switch (value) {
        case 0: return OVERWRITE;
        case 1: return APPEND_IF_ABSENT;
        case 2: return PASS_THROUGH;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ServerHeaderTransformation>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        ServerHeaderTransformation> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ServerHeaderTransformation>() {
            public ServerHeaderTransformation findValueByNumber(int number) {
              return ServerHeaderTransformation.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.getDescriptor().getEnumTypes().get(1);
    }

    private static final ServerHeaderTransformation[] VALUES = values();

    public static ServerHeaderTransformation valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private ServerHeaderTransformation(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation)
  }

  /**
   * <pre>
   * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
   * header.
   * </pre>
   *
   * Protobuf enum {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails}
   */
  public enum ForwardClientCertDetails
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * Do not send the XFCC header to the next hop. This is the default value.
     * </pre>
     *
     * <code>SANITIZE = 0;</code>
     */
    SANITIZE(0),
    /**
     * <pre>
     * When the client connection is mTLS (Mutual TLS), forward the XFCC header
     * in the request.
     * </pre>
     *
     * <code>FORWARD_ONLY = 1;</code>
     */
    FORWARD_ONLY(1),
    /**
     * <pre>
     * When the client connection is mTLS, append the client certificate
     * information to the request’s XFCC header and forward it.
     * </pre>
     *
     * <code>APPEND_FORWARD = 2;</code>
     */
    APPEND_FORWARD(2),
    /**
     * <pre>
     * When the client connection is mTLS, reset the XFCC header with the client
     * certificate information and send it to the next hop.
     * </pre>
     *
     * <code>SANITIZE_SET = 3;</code>
     */
    SANITIZE_SET(3),
    /**
     * <pre>
     * Always forward the XFCC header in the request, regardless of whether the
     * client connection is mTLS.
     * </pre>
     *
     * <code>ALWAYS_FORWARD_ONLY = 4;</code>
     */
    ALWAYS_FORWARD_ONLY(4),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * Do not send the XFCC header to the next hop. This is the default value.
     * </pre>
     *
     * <code>SANITIZE = 0;</code>
     */
    public static final int SANITIZE_VALUE = 0;
    /**
     * <pre>
     * When the client connection is mTLS (Mutual TLS), forward the XFCC header
     * in the request.
     * </pre>
     *
     * <code>FORWARD_ONLY = 1;</code>
     */
    public static final int FORWARD_ONLY_VALUE = 1;
    /**
     * <pre>
     * When the client connection is mTLS, append the client certificate
     * information to the request’s XFCC header and forward it.
     * </pre>
     *
     * <code>APPEND_FORWARD = 2;</code>
     */
    public static final int APPEND_FORWARD_VALUE = 2;
    /**
     * <pre>
     * When the client connection is mTLS, reset the XFCC header with the client
     * certificate information and send it to the next hop.
     * </pre>
     *
     * <code>SANITIZE_SET = 3;</code>
     */
    public static final int SANITIZE_SET_VALUE = 3;
    /**
     * <pre>
     * Always forward the XFCC header in the request, regardless of whether the
     * client connection is mTLS.
     * </pre>
     *
     * <code>ALWAYS_FORWARD_ONLY = 4;</code>
     */
    public static final int ALWAYS_FORWARD_ONLY_VALUE = 4;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static ForwardClientCertDetails valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static ForwardClientCertDetails forNumber(int value) {
      switch (value) {
        case 0: return SANITIZE;
        case 1: return FORWARD_ONLY;
        case 2: return APPEND_FORWARD;
        case 3: return SANITIZE_SET;
        case 4: return ALWAYS_FORWARD_ONLY;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ForwardClientCertDetails>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        ForwardClientCertDetails> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ForwardClientCertDetails>() {
            public ForwardClientCertDetails findValueByNumber(int number) {
              return ForwardClientCertDetails.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.getDescriptor().getEnumTypes().get(2);
    }

    private static final ForwardClientCertDetails[] VALUES = values();

    public static ForwardClientCertDetails valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private ForwardClientCertDetails(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails)
  }

  /**
   * <pre>
   * Determines the action for request that contain %2F, %2f, %5C or %5c sequences in the URI path.
   * This operation occurs before URL normalization and the merge slashes transformations if they were enabled.
   * </pre>
   *
   * Protobuf enum {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction}
   */
  public enum PathWithEscapedSlashesAction
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * Default behavior specific to implementation (i.e. Envoy) of this configuration option.
     * Envoy, by default, takes the KEEP_UNCHANGED action.
     * NOTE: the implementation may change the default behavior at-will.
     * </pre>
     *
     * <code>IMPLEMENTATION_SPECIFIC_DEFAULT = 0;</code>
     */
    IMPLEMENTATION_SPECIFIC_DEFAULT(0),
    /**
     * <pre>
     * Keep escaped slashes.
     * </pre>
     *
     * <code>KEEP_UNCHANGED = 1;</code>
     */
    KEEP_UNCHANGED(1),
    /**
     * <pre>
     * Reject client request with the 400 status. gRPC requests will be rejected with the INTERNAL (13) error code.
     * The "httpN.downstream_rq_failed_path_normalization" counter is incremented for each rejected request.
     * </pre>
     *
     * <code>REJECT_REQUEST = 2;</code>
     */
    REJECT_REQUEST(2),
    /**
     * <pre>
     * Unescape %2F and %5C sequences and redirect request to the new path if these sequences were present.
     * Redirect occurs after path normalization and merge slashes transformations if they were configured.
     * NOTE: gRPC requests will be rejected with the INTERNAL (13) error code.
     * This option minimizes possibility of path confusion exploits by forcing request with unescaped slashes to
     * traverse all parties: downstream client, intermediate proxies, Envoy and upstream server.
     * The "httpN.downstream_rq_redirected_with_normalized_path" counter is incremented for each
     * redirected request.
     * </pre>
     *
     * <code>UNESCAPE_AND_REDIRECT = 3;</code>
     */
    UNESCAPE_AND_REDIRECT(3),
    /**
     * <pre>
     * Unescape %2F and %5C sequences.
     * Note: this option should not be enabled if intermediaries perform path based access control as
     * it may lead to path confusion vulnerabilities.
     * </pre>
     *
     * <code>UNESCAPE_AND_FORWARD = 4;</code>
     */
    UNESCAPE_AND_FORWARD(4),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * Default behavior specific to implementation (i.e. Envoy) of this configuration option.
     * Envoy, by default, takes the KEEP_UNCHANGED action.
     * NOTE: the implementation may change the default behavior at-will.
     * </pre>
     *
     * <code>IMPLEMENTATION_SPECIFIC_DEFAULT = 0;</code>
     */
    public static final int IMPLEMENTATION_SPECIFIC_DEFAULT_VALUE = 0;
    /**
     * <pre>
     * Keep escaped slashes.
     * </pre>
     *
     * <code>KEEP_UNCHANGED = 1;</code>
     */
    public static final int KEEP_UNCHANGED_VALUE = 1;
    /**
     * <pre>
     * Reject client request with the 400 status. gRPC requests will be rejected with the INTERNAL (13) error code.
     * The "httpN.downstream_rq_failed_path_normalization" counter is incremented for each rejected request.
     * </pre>
     *
     * <code>REJECT_REQUEST = 2;</code>
     */
    public static final int REJECT_REQUEST_VALUE = 2;
    /**
     * <pre>
     * Unescape %2F and %5C sequences and redirect request to the new path if these sequences were present.
     * Redirect occurs after path normalization and merge slashes transformations if they were configured.
     * NOTE: gRPC requests will be rejected with the INTERNAL (13) error code.
     * This option minimizes possibility of path confusion exploits by forcing request with unescaped slashes to
     * traverse all parties: downstream client, intermediate proxies, Envoy and upstream server.
     * The "httpN.downstream_rq_redirected_with_normalized_path" counter is incremented for each
     * redirected request.
     * </pre>
     *
     * <code>UNESCAPE_AND_REDIRECT = 3;</code>
     */
    public static final int UNESCAPE_AND_REDIRECT_VALUE = 3;
    /**
     * <pre>
     * Unescape %2F and %5C sequences.
     * Note: this option should not be enabled if intermediaries perform path based access control as
     * it may lead to path confusion vulnerabilities.
     * </pre>
     *
     * <code>UNESCAPE_AND_FORWARD = 4;</code>
     */
    public static final int UNESCAPE_AND_FORWARD_VALUE = 4;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static PathWithEscapedSlashesAction valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static PathWithEscapedSlashesAction forNumber(int value) {
      switch (value) {
        case 0: return IMPLEMENTATION_SPECIFIC_DEFAULT;
        case 1: return KEEP_UNCHANGED;
        case 2: return REJECT_REQUEST;
        case 3: return UNESCAPE_AND_REDIRECT;
        case 4: return UNESCAPE_AND_FORWARD;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<PathWithEscapedSlashesAction>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        PathWithEscapedSlashesAction> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<PathWithEscapedSlashesAction>() {
            public PathWithEscapedSlashesAction findValueByNumber(int number) {
              return PathWithEscapedSlashesAction.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.getDescriptor().getEnumTypes().get(3);
    }

    private static final PathWithEscapedSlashesAction[] VALUES = values();

    public static PathWithEscapedSlashesAction valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private PathWithEscapedSlashesAction(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction)
  }

  public interface TracingOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be force
     * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
     * header is set. This field is a direct analog for the runtime variable
     * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
     * &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
     * @return Whether the clientSampling field is set.
     */
    boolean hasClientSampling();
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be force
     * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
     * header is set. This field is a direct analog for the runtime variable
     * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
     * &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
     * @return The clientSampling.
     */
    io.envoyproxy.envoy.type.v3.Percent getClientSampling();
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be force
     * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
     * header is set. This field is a direct analog for the runtime variable
     * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
     * &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
     */
    io.envoyproxy.envoy.type.v3.PercentOrBuilder getClientSamplingOrBuilder();

    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be randomly
     * selected for trace generation, if not requested by the client or not forced. This field is
     * a direct analog for the runtime variable 'tracing.random_sampling' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
     * @return Whether the randomSampling field is set.
     */
    boolean hasRandomSampling();
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be randomly
     * selected for trace generation, if not requested by the client or not forced. This field is
     * a direct analog for the runtime variable 'tracing.random_sampling' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
     * @return The randomSampling.
     */
    io.envoyproxy.envoy.type.v3.Percent getRandomSampling();
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be randomly
     * selected for trace generation, if not requested by the client or not forced. This field is
     * a direct analog for the runtime variable 'tracing.random_sampling' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
     */
    io.envoyproxy.envoy.type.v3.PercentOrBuilder getRandomSamplingOrBuilder();

    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be traced
     * after all other sampling checks have been applied (client-directed, force tracing, random
     * sampling). This field functions as an upper limit on the total configured sampling rate. For
     * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
     * of client requests with the appropriate headers to be force traced. This field is a direct
     * analog for the runtime variable 'tracing.global_enabled' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
     * @return Whether the overallSampling field is set.
     */
    boolean hasOverallSampling();
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be traced
     * after all other sampling checks have been applied (client-directed, force tracing, random
     * sampling). This field functions as an upper limit on the total configured sampling rate. For
     * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
     * of client requests with the appropriate headers to be force traced. This field is a direct
     * analog for the runtime variable 'tracing.global_enabled' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
     * @return The overallSampling.
     */
    io.envoyproxy.envoy.type.v3.Percent getOverallSampling();
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be traced
     * after all other sampling checks have been applied (client-directed, force tracing, random
     * sampling). This field functions as an upper limit on the total configured sampling rate. For
     * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
     * of client requests with the appropriate headers to be force traced. This field is a direct
     * analog for the runtime variable 'tracing.global_enabled' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
     */
    io.envoyproxy.envoy.type.v3.PercentOrBuilder getOverallSamplingOrBuilder();

    /**
     * <pre>
     * Whether to annotate spans with additional data. If true, spans will include logs for stream
     * events.
     * </pre>
     *
     * <code>bool verbose = 6;</code>
     * @return The verbose.
     */
    boolean getVerbose();

    /**
     * <pre>
     * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
     * truncate lengthy request paths to meet the needs of a tracing backend.
     * Default: 256
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
     * @return Whether the maxPathTagLength field is set.
     */
    boolean hasMaxPathTagLength();
    /**
     * <pre>
     * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
     * truncate lengthy request paths to meet the needs of a tracing backend.
     * Default: 256
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
     * @return The maxPathTagLength.
     */
    com.google.protobuf.UInt32Value getMaxPathTagLength();
    /**
     * <pre>
     * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
     * truncate lengthy request paths to meet the needs of a tracing backend.
     * Default: 256
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
     */
    com.google.protobuf.UInt32ValueOrBuilder getMaxPathTagLengthOrBuilder();

    /**
     * <pre>
     * A list of custom tags with unique tag name to create tags for the active span.
     * </pre>
     *
     * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
     */
    java.util.List<io.envoyproxy.envoy.type.tracing.v3.CustomTag> 
        getCustomTagsList();
    /**
     * <pre>
     * A list of custom tags with unique tag name to create tags for the active span.
     * </pre>
     *
     * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
     */
    io.envoyproxy.envoy.type.tracing.v3.CustomTag getCustomTags(int index);
    /**
     * <pre>
     * A list of custom tags with unique tag name to create tags for the active span.
     * </pre>
     *
     * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
     */
    int getCustomTagsCount();
    /**
     * <pre>
     * A list of custom tags with unique tag name to create tags for the active span.
     * </pre>
     *
     * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
     */
    java.util.List<? extends io.envoyproxy.envoy.type.tracing.v3.CustomTagOrBuilder> 
        getCustomTagsOrBuilderList();
    /**
     * <pre>
     * A list of custom tags with unique tag name to create tags for the active span.
     * </pre>
     *
     * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
     */
    io.envoyproxy.envoy.type.tracing.v3.CustomTagOrBuilder getCustomTagsOrBuilder(
        int index);

    /**
     * <pre>
     * Configuration for an external tracing provider.
     * If not specified, no tracing will be performed.
     * .. attention::
     *   Please be aware that ``envoy.tracers.opencensus`` provider can only be configured once
     *   in Envoy lifetime.
     *   Any attempts to reconfigure it or to use different configurations for different HCM filters
     *   will be rejected.
     *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
     *   on OpenCensus side.
     * </pre>
     *
     * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
     * @return Whether the provider field is set.
     */
    boolean hasProvider();
    /**
     * <pre>
     * Configuration for an external tracing provider.
     * If not specified, no tracing will be performed.
     * .. attention::
     *   Please be aware that ``envoy.tracers.opencensus`` provider can only be configured once
     *   in Envoy lifetime.
     *   Any attempts to reconfigure it or to use different configurations for different HCM filters
     *   will be rejected.
     *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
     *   on OpenCensus side.
     * </pre>
     *
     * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
     * @return The provider.
     */
    io.envoyproxy.envoy.config.trace.v3.Tracing.Http getProvider();
    /**
     * <pre>
     * Configuration for an external tracing provider.
     * If not specified, no tracing will be performed.
     * .. attention::
     *   Please be aware that ``envoy.tracers.opencensus`` provider can only be configured once
     *   in Envoy lifetime.
     *   Any attempts to reconfigure it or to use different configurations for different HCM filters
     *   will be rejected.
     *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
     *   on OpenCensus side.
     * </pre>
     *
     * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
     */
    io.envoyproxy.envoy.config.trace.v3.Tracing.HttpOrBuilder getProviderOrBuilder();
  }
  /**
   * <pre>
   * [#next-free-field: 10]
   * </pre>
   *
   * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing}
   */
  public static final class Tracing extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing)
      TracingOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Tracing.newBuilder() to construct.
    private Tracing(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Tracing() {
      customTags_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Tracing();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_Tracing_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_Tracing_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.Builder.class);
    }

    /**
     * Protobuf enum {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.OperationName}
     */
    public enum OperationName
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * The HTTP listener is used for ingress/incoming requests.
       * </pre>
       *
       * <code>INGRESS = 0;</code>
       */
      INGRESS(0),
      /**
       * <pre>
       * The HTTP listener is used for egress/outgoing requests.
       * </pre>
       *
       * <code>EGRESS = 1;</code>
       */
      EGRESS(1),
      UNRECOGNIZED(-1),
      ;

      /**
       * <pre>
       * The HTTP listener is used for ingress/incoming requests.
       * </pre>
       *
       * <code>INGRESS = 0;</code>
       */
      public static final int INGRESS_VALUE = 0;
      /**
       * <pre>
       * The HTTP listener is used for egress/outgoing requests.
       * </pre>
       *
       * <code>EGRESS = 1;</code>
       */
      public static final int EGRESS_VALUE = 1;


      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static OperationName valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static OperationName forNumber(int value) {
        switch (value) {
          case 0: return INGRESS;
          case 1: return EGRESS;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<OperationName>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          OperationName> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<OperationName>() {
              public OperationName findValueByNumber(int number) {
                return OperationName.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalStateException(
              "Can't get the descriptor of an unrecognized enum value.");
        }
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.getDescriptor().getEnumTypes().get(0);
      }

      private static final OperationName[] VALUES = values();

      public static OperationName valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private OperationName(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.OperationName)
    }

    public static final int CLIENT_SAMPLING_FIELD_NUMBER = 3;
    private io.envoyproxy.envoy.type.v3.Percent clientSampling_;
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be force
     * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
     * header is set. This field is a direct analog for the runtime variable
     * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
     * &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
     * @return Whether the clientSampling field is set.
     */
    @java.lang.Override
    public boolean hasClientSampling() {
      return clientSampling_ != null;
    }
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be force
     * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
     * header is set. This field is a direct analog for the runtime variable
     * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
     * &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
     * @return The clientSampling.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.v3.Percent getClientSampling() {
      return clientSampling_ == null ? io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : clientSampling_;
    }
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be force
     * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
     * header is set. This field is a direct analog for the runtime variable
     * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
     * &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.v3.PercentOrBuilder getClientSamplingOrBuilder() {
      return clientSampling_ == null ? io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : clientSampling_;
    }

    public static final int RANDOM_SAMPLING_FIELD_NUMBER = 4;
    private io.envoyproxy.envoy.type.v3.Percent randomSampling_;
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be randomly
     * selected for trace generation, if not requested by the client or not forced. This field is
     * a direct analog for the runtime variable 'tracing.random_sampling' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
     * @return Whether the randomSampling field is set.
     */
    @java.lang.Override
    public boolean hasRandomSampling() {
      return randomSampling_ != null;
    }
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be randomly
     * selected for trace generation, if not requested by the client or not forced. This field is
     * a direct analog for the runtime variable 'tracing.random_sampling' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
     * @return The randomSampling.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.v3.Percent getRandomSampling() {
      return randomSampling_ == null ? io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : randomSampling_;
    }
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be randomly
     * selected for trace generation, if not requested by the client or not forced. This field is
     * a direct analog for the runtime variable 'tracing.random_sampling' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.v3.PercentOrBuilder getRandomSamplingOrBuilder() {
      return randomSampling_ == null ? io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : randomSampling_;
    }

    public static final int OVERALL_SAMPLING_FIELD_NUMBER = 5;
    private io.envoyproxy.envoy.type.v3.Percent overallSampling_;
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be traced
     * after all other sampling checks have been applied (client-directed, force tracing, random
     * sampling). This field functions as an upper limit on the total configured sampling rate. For
     * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
     * of client requests with the appropriate headers to be force traced. This field is a direct
     * analog for the runtime variable 'tracing.global_enabled' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
     * @return Whether the overallSampling field is set.
     */
    @java.lang.Override
    public boolean hasOverallSampling() {
      return overallSampling_ != null;
    }
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be traced
     * after all other sampling checks have been applied (client-directed, force tracing, random
     * sampling). This field functions as an upper limit on the total configured sampling rate. For
     * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
     * of client requests with the appropriate headers to be force traced. This field is a direct
     * analog for the runtime variable 'tracing.global_enabled' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
     * @return The overallSampling.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.v3.Percent getOverallSampling() {
      return overallSampling_ == null ? io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : overallSampling_;
    }
    /**
     * <pre>
     * Target percentage of requests managed by this HTTP connection manager that will be traced
     * after all other sampling checks have been applied (client-directed, force tracing, random
     * sampling). This field functions as an upper limit on the total configured sampling rate. For
     * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
     * of client requests with the appropriate headers to be force traced. This field is a direct
     * analog for the runtime variable 'tracing.global_enabled' in the
     * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
     * Default: 100%
     * </pre>
     *
     * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.v3.PercentOrBuilder getOverallSamplingOrBuilder() {
      return overallSampling_ == null ? io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : overallSampling_;
    }

    public static final int VERBOSE_FIELD_NUMBER = 6;
    private boolean verbose_ = false;
    /**
     * <pre>
     * Whether to annotate spans with additional data. If true, spans will include logs for stream
     * events.
     * </pre>
     *
     * <code>bool verbose = 6;</code>
     * @return The verbose.
     */
    @java.lang.Override
    public boolean getVerbose() {
      return verbose_;
    }

    public static final int MAX_PATH_TAG_LENGTH_FIELD_NUMBER = 7;
    private com.google.protobuf.UInt32Value maxPathTagLength_;
    /**
     * <pre>
     * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
     * truncate lengthy request paths to meet the needs of a tracing backend.
     * Default: 256
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
     * @return Whether the maxPathTagLength field is set.
     */
    @java.lang.Override
    public boolean hasMaxPathTagLength() {
      return maxPathTagLength_ != null;
    }
    /**
     * <pre>
     * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
     * truncate lengthy request paths to meet the needs of a tracing backend.
     * Default: 256
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
     * @return The maxPathTagLength.
     */
    @java.lang.Override
    public com.google.protobuf.UInt32Value getMaxPathTagLength() {
      return maxPathTagLength_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : maxPathTagLength_;
    }
    /**
     * <pre>
     * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
     * truncate lengthy request paths to meet the needs of a tracing backend.
     * Default: 256
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
     */
    @java.lang.Override
    public com.google.protobuf.UInt32ValueOrBuilder getMaxPathTagLengthOrBuilder() {
      return maxPathTagLength_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : maxPathTagLength_;
    }

    public static final int CUSTOM_TAGS_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private java.util.List<io.envoyproxy.envoy.type.tracing.v3.CustomTag> customTags_;
    /**
     * <pre>
     * A list of custom tags with unique tag name to create tags for the active span.
     * </pre>
     *
     * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
     */
    @java.lang.Override
    public java.util.List<io.envoyproxy.envoy.type.tracing.v3.CustomTag> getCustomTagsList() {
      return customTags_;
    }
    /**
     * <pre>
     * A list of custom tags with unique tag name to create tags for the active span.
     * </pre>
     *
     * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.envoyproxy.envoy.type.tracing.v3.CustomTagOrBuilder> 
        getCustomTagsOrBuilderList() {
      return customTags_;
    }
    /**
     * <pre>
     * A list of custom tags with unique tag name to create tags for the active span.
     * </pre>
     *
     * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
     */
    @java.lang.Override
    public int getCustomTagsCount() {
      return customTags_.size();
    }
    /**
     * <pre>
     * A list of custom tags with unique tag name to create tags for the active span.
     * </pre>
     *
     * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.tracing.v3.CustomTag getCustomTags(int index) {
      return customTags_.get(index);
    }
    /**
     * <pre>
     * A list of custom tags with unique tag name to create tags for the active span.
     * </pre>
     *
     * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.tracing.v3.CustomTagOrBuilder getCustomTagsOrBuilder(
        int index) {
      return customTags_.get(index);
    }

    public static final int PROVIDER_FIELD_NUMBER = 9;
    private io.envoyproxy.envoy.config.trace.v3.Tracing.Http provider_;
    /**
     * <pre>
     * Configuration for an external tracing provider.
     * If not specified, no tracing will be performed.
     * .. attention::
     *   Please be aware that ``envoy.tracers.opencensus`` provider can only be configured once
     *   in Envoy lifetime.
     *   Any attempts to reconfigure it or to use different configurations for different HCM filters
     *   will be rejected.
     *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
     *   on OpenCensus side.
     * </pre>
     *
     * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
     * @return Whether the provider field is set.
     */
    @java.lang.Override
    public boolean hasProvider() {
      return provider_ != null;
    }
    /**
     * <pre>
     * Configuration for an external tracing provider.
     * If not specified, no tracing will be performed.
     * .. attention::
     *   Please be aware that ``envoy.tracers.opencensus`` provider can only be configured once
     *   in Envoy lifetime.
     *   Any attempts to reconfigure it or to use different configurations for different HCM filters
     *   will be rejected.
     *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
     *   on OpenCensus side.
     * </pre>
     *
     * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
     * @return The provider.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.trace.v3.Tracing.Http getProvider() {
      return provider_ == null ? io.envoyproxy.envoy.config.trace.v3.Tracing.Http.getDefaultInstance() : provider_;
    }
    /**
     * <pre>
     * Configuration for an external tracing provider.
     * If not specified, no tracing will be performed.
     * .. attention::
     *   Please be aware that ``envoy.tracers.opencensus`` provider can only be configured once
     *   in Envoy lifetime.
     *   Any attempts to reconfigure it or to use different configurations for different HCM filters
     *   will be rejected.
     *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
     *   on OpenCensus side.
     * </pre>
     *
     * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.trace.v3.Tracing.HttpOrBuilder getProviderOrBuilder() {
      return provider_ == null ? io.envoyproxy.envoy.config.trace.v3.Tracing.Http.getDefaultInstance() : provider_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (clientSampling_ != null) {
        output.writeMessage(3, getClientSampling());
      }
      if (randomSampling_ != null) {
        output.writeMessage(4, getRandomSampling());
      }
      if (overallSampling_ != null) {
        output.writeMessage(5, getOverallSampling());
      }
      if (verbose_ != false) {
        output.writeBool(6, verbose_);
      }
      if (maxPathTagLength_ != null) {
        output.writeMessage(7, getMaxPathTagLength());
      }
      for (int i = 0; i < customTags_.size(); i++) {
        output.writeMessage(8, customTags_.get(i));
      }
      if (provider_ != null) {
        output.writeMessage(9, getProvider());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (clientSampling_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getClientSampling());
      }
      if (randomSampling_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getRandomSampling());
      }
      if (overallSampling_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getOverallSampling());
      }
      if (verbose_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(6, verbose_);
      }
      if (maxPathTagLength_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getMaxPathTagLength());
      }
      for (int i = 0; i < customTags_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, customTags_.get(i));
      }
      if (provider_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, getProvider());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing other = (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing) obj;

      if (hasClientSampling() != other.hasClientSampling()) return false;
      if (hasClientSampling()) {
        if (!getClientSampling()
            .equals(other.getClientSampling())) return false;
      }
      if (hasRandomSampling() != other.hasRandomSampling()) return false;
      if (hasRandomSampling()) {
        if (!getRandomSampling()
            .equals(other.getRandomSampling())) return false;
      }
      if (hasOverallSampling() != other.hasOverallSampling()) return false;
      if (hasOverallSampling()) {
        if (!getOverallSampling()
            .equals(other.getOverallSampling())) return false;
      }
      if (getVerbose()
          != other.getVerbose()) return false;
      if (hasMaxPathTagLength() != other.hasMaxPathTagLength()) return false;
      if (hasMaxPathTagLength()) {
        if (!getMaxPathTagLength()
            .equals(other.getMaxPathTagLength())) return false;
      }
      if (!getCustomTagsList()
          .equals(other.getCustomTagsList())) return false;
      if (hasProvider() != other.hasProvider()) return false;
      if (hasProvider()) {
        if (!getProvider()
            .equals(other.getProvider())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasClientSampling()) {
        hash = (37 * hash) + CLIENT_SAMPLING_FIELD_NUMBER;
        hash = (53 * hash) + getClientSampling().hashCode();
      }
      if (hasRandomSampling()) {
        hash = (37 * hash) + RANDOM_SAMPLING_FIELD_NUMBER;
        hash = (53 * hash) + getRandomSampling().hashCode();
      }
      if (hasOverallSampling()) {
        hash = (37 * hash) + OVERALL_SAMPLING_FIELD_NUMBER;
        hash = (53 * hash) + getOverallSampling().hashCode();
      }
      hash = (37 * hash) + VERBOSE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getVerbose());
      if (hasMaxPathTagLength()) {
        hash = (37 * hash) + MAX_PATH_TAG_LENGTH_FIELD_NUMBER;
        hash = (53 * hash) + getMaxPathTagLength().hashCode();
      }
      if (getCustomTagsCount() > 0) {
        hash = (37 * hash) + CUSTOM_TAGS_FIELD_NUMBER;
        hash = (53 * hash) + getCustomTagsList().hashCode();
      }
      if (hasProvider()) {
        hash = (37 * hash) + PROVIDER_FIELD_NUMBER;
        hash = (53 * hash) + getProvider().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * [#next-free-field: 10]
     * </pre>
     *
     * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing)
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.TracingOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_Tracing_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_Tracing_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        clientSampling_ = null;
        if (clientSamplingBuilder_ != null) {
          clientSamplingBuilder_.dispose();
          clientSamplingBuilder_ = null;
        }
        randomSampling_ = null;
        if (randomSamplingBuilder_ != null) {
          randomSamplingBuilder_.dispose();
          randomSamplingBuilder_ = null;
        }
        overallSampling_ = null;
        if (overallSamplingBuilder_ != null) {
          overallSamplingBuilder_.dispose();
          overallSamplingBuilder_ = null;
        }
        verbose_ = false;
        maxPathTagLength_ = null;
        if (maxPathTagLengthBuilder_ != null) {
          maxPathTagLengthBuilder_.dispose();
          maxPathTagLengthBuilder_ = null;
        }
        if (customTagsBuilder_ == null) {
          customTags_ = java.util.Collections.emptyList();
        } else {
          customTags_ = null;
          customTagsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        provider_ = null;
        if (providerBuilder_ != null) {
          providerBuilder_.dispose();
          providerBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_Tracing_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing getDefaultInstanceForType() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing build() {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing buildPartial() {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing result = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing result) {
        if (customTagsBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0)) {
            customTags_ = java.util.Collections.unmodifiableList(customTags_);
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.customTags_ = customTags_;
        } else {
          result.customTags_ = customTagsBuilder_.build();
        }
      }

      private void buildPartial0(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.clientSampling_ = clientSamplingBuilder_ == null
              ? clientSampling_
              : clientSamplingBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.randomSampling_ = randomSamplingBuilder_ == null
              ? randomSampling_
              : randomSamplingBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.overallSampling_ = overallSamplingBuilder_ == null
              ? overallSampling_
              : overallSamplingBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.verbose_ = verbose_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.maxPathTagLength_ = maxPathTagLengthBuilder_ == null
              ? maxPathTagLength_
              : maxPathTagLengthBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.provider_ = providerBuilder_ == null
              ? provider_
              : providerBuilder_.build();
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing) {
          return mergeFrom((io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing other) {
        if (other == io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.getDefaultInstance()) return this;
        if (other.hasClientSampling()) {
          mergeClientSampling(other.getClientSampling());
        }
        if (other.hasRandomSampling()) {
          mergeRandomSampling(other.getRandomSampling());
        }
        if (other.hasOverallSampling()) {
          mergeOverallSampling(other.getOverallSampling());
        }
        if (other.getVerbose() != false) {
          setVerbose(other.getVerbose());
        }
        if (other.hasMaxPathTagLength()) {
          mergeMaxPathTagLength(other.getMaxPathTagLength());
        }
        if (customTagsBuilder_ == null) {
          if (!other.customTags_.isEmpty()) {
            if (customTags_.isEmpty()) {
              customTags_ = other.customTags_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensureCustomTagsIsMutable();
              customTags_.addAll(other.customTags_);
            }
            onChanged();
          }
        } else {
          if (!other.customTags_.isEmpty()) {
            if (customTagsBuilder_.isEmpty()) {
              customTagsBuilder_.dispose();
              customTagsBuilder_ = null;
              customTags_ = other.customTags_;
              bitField0_ = (bitField0_ & ~0x00000020);
              customTagsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getCustomTagsFieldBuilder() : null;
            } else {
              customTagsBuilder_.addAllMessages(other.customTags_);
            }
          }
        }
        if (other.hasProvider()) {
          mergeProvider(other.getProvider());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 26: {
                input.readMessage(
                    getClientSamplingFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 26
              case 34: {
                input.readMessage(
                    getRandomSamplingFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 34
              case 42: {
                input.readMessage(
                    getOverallSamplingFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 42
              case 48: {
                verbose_ = input.readBool();
                bitField0_ |= 0x00000008;
                break;
              } // case 48
              case 58: {
                input.readMessage(
                    getMaxPathTagLengthFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000010;
                break;
              } // case 58
              case 66: {
                io.envoyproxy.envoy.type.tracing.v3.CustomTag m =
                    input.readMessage(
                        io.envoyproxy.envoy.type.tracing.v3.CustomTag.parser(),
                        extensionRegistry);
                if (customTagsBuilder_ == null) {
                  ensureCustomTagsIsMutable();
                  customTags_.add(m);
                } else {
                  customTagsBuilder_.addMessage(m);
                }
                break;
              } // case 66
              case 74: {
                input.readMessage(
                    getProviderFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000040;
                break;
              } // case 74
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.envoyproxy.envoy.type.v3.Percent clientSampling_;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder> clientSamplingBuilder_;
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be force
       * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
       * header is set. This field is a direct analog for the runtime variable
       * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
       * &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
       * @return Whether the clientSampling field is set.
       */
      public boolean hasClientSampling() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be force
       * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
       * header is set. This field is a direct analog for the runtime variable
       * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
       * &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
       * @return The clientSampling.
       */
      public io.envoyproxy.envoy.type.v3.Percent getClientSampling() {
        if (clientSamplingBuilder_ == null) {
          return clientSampling_ == null ? io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : clientSampling_;
        } else {
          return clientSamplingBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be force
       * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
       * header is set. This field is a direct analog for the runtime variable
       * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
       * &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
       */
      public Builder setClientSampling(io.envoyproxy.envoy.type.v3.Percent value) {
        if (clientSamplingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          clientSampling_ = value;
        } else {
          clientSamplingBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be force
       * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
       * header is set. This field is a direct analog for the runtime variable
       * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
       * &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
       */
      public Builder setClientSampling(
          io.envoyproxy.envoy.type.v3.Percent.Builder builderForValue) {
        if (clientSamplingBuilder_ == null) {
          clientSampling_ = builderForValue.build();
        } else {
          clientSamplingBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be force
       * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
       * header is set. This field is a direct analog for the runtime variable
       * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
       * &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
       */
      public Builder mergeClientSampling(io.envoyproxy.envoy.type.v3.Percent value) {
        if (clientSamplingBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            clientSampling_ != null &&
            clientSampling_ != io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance()) {
            getClientSamplingBuilder().mergeFrom(value);
          } else {
            clientSampling_ = value;
          }
        } else {
          clientSamplingBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be force
       * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
       * header is set. This field is a direct analog for the runtime variable
       * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
       * &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
       */
      public Builder clearClientSampling() {
        bitField0_ = (bitField0_ & ~0x00000001);
        clientSampling_ = null;
        if (clientSamplingBuilder_ != null) {
          clientSamplingBuilder_.dispose();
          clientSamplingBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be force
       * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
       * header is set. This field is a direct analog for the runtime variable
       * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
       * &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
       */
      public io.envoyproxy.envoy.type.v3.Percent.Builder getClientSamplingBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getClientSamplingFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be force
       * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
       * header is set. This field is a direct analog for the runtime variable
       * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
       * &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
       */
      public io.envoyproxy.envoy.type.v3.PercentOrBuilder getClientSamplingOrBuilder() {
        if (clientSamplingBuilder_ != null) {
          return clientSamplingBuilder_.getMessageOrBuilder();
        } else {
          return clientSampling_ == null ?
              io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : clientSampling_;
        }
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be force
       * traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id&gt;`
       * header is set. This field is a direct analog for the runtime variable
       * 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
       * &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent client_sampling = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder> 
          getClientSamplingFieldBuilder() {
        if (clientSamplingBuilder_ == null) {
          clientSamplingBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder>(
                  getClientSampling(),
                  getParentForChildren(),
                  isClean());
          clientSampling_ = null;
        }
        return clientSamplingBuilder_;
      }

      private io.envoyproxy.envoy.type.v3.Percent randomSampling_;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder> randomSamplingBuilder_;
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be randomly
       * selected for trace generation, if not requested by the client or not forced. This field is
       * a direct analog for the runtime variable 'tracing.random_sampling' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
       * @return Whether the randomSampling field is set.
       */
      public boolean hasRandomSampling() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be randomly
       * selected for trace generation, if not requested by the client or not forced. This field is
       * a direct analog for the runtime variable 'tracing.random_sampling' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
       * @return The randomSampling.
       */
      public io.envoyproxy.envoy.type.v3.Percent getRandomSampling() {
        if (randomSamplingBuilder_ == null) {
          return randomSampling_ == null ? io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : randomSampling_;
        } else {
          return randomSamplingBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be randomly
       * selected for trace generation, if not requested by the client or not forced. This field is
       * a direct analog for the runtime variable 'tracing.random_sampling' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
       */
      public Builder setRandomSampling(io.envoyproxy.envoy.type.v3.Percent value) {
        if (randomSamplingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          randomSampling_ = value;
        } else {
          randomSamplingBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be randomly
       * selected for trace generation, if not requested by the client or not forced. This field is
       * a direct analog for the runtime variable 'tracing.random_sampling' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
       */
      public Builder setRandomSampling(
          io.envoyproxy.envoy.type.v3.Percent.Builder builderForValue) {
        if (randomSamplingBuilder_ == null) {
          randomSampling_ = builderForValue.build();
        } else {
          randomSamplingBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be randomly
       * selected for trace generation, if not requested by the client or not forced. This field is
       * a direct analog for the runtime variable 'tracing.random_sampling' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
       */
      public Builder mergeRandomSampling(io.envoyproxy.envoy.type.v3.Percent value) {
        if (randomSamplingBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            randomSampling_ != null &&
            randomSampling_ != io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance()) {
            getRandomSamplingBuilder().mergeFrom(value);
          } else {
            randomSampling_ = value;
          }
        } else {
          randomSamplingBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be randomly
       * selected for trace generation, if not requested by the client or not forced. This field is
       * a direct analog for the runtime variable 'tracing.random_sampling' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
       */
      public Builder clearRandomSampling() {
        bitField0_ = (bitField0_ & ~0x00000002);
        randomSampling_ = null;
        if (randomSamplingBuilder_ != null) {
          randomSamplingBuilder_.dispose();
          randomSamplingBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be randomly
       * selected for trace generation, if not requested by the client or not forced. This field is
       * a direct analog for the runtime variable 'tracing.random_sampling' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
       */
      public io.envoyproxy.envoy.type.v3.Percent.Builder getRandomSamplingBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getRandomSamplingFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be randomly
       * selected for trace generation, if not requested by the client or not forced. This field is
       * a direct analog for the runtime variable 'tracing.random_sampling' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
       */
      public io.envoyproxy.envoy.type.v3.PercentOrBuilder getRandomSamplingOrBuilder() {
        if (randomSamplingBuilder_ != null) {
          return randomSamplingBuilder_.getMessageOrBuilder();
        } else {
          return randomSampling_ == null ?
              io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : randomSampling_;
        }
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be randomly
       * selected for trace generation, if not requested by the client or not forced. This field is
       * a direct analog for the runtime variable 'tracing.random_sampling' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent random_sampling = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder> 
          getRandomSamplingFieldBuilder() {
        if (randomSamplingBuilder_ == null) {
          randomSamplingBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder>(
                  getRandomSampling(),
                  getParentForChildren(),
                  isClean());
          randomSampling_ = null;
        }
        return randomSamplingBuilder_;
      }

      private io.envoyproxy.envoy.type.v3.Percent overallSampling_;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder> overallSamplingBuilder_;
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be traced
       * after all other sampling checks have been applied (client-directed, force tracing, random
       * sampling). This field functions as an upper limit on the total configured sampling rate. For
       * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
       * of client requests with the appropriate headers to be force traced. This field is a direct
       * analog for the runtime variable 'tracing.global_enabled' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
       * @return Whether the overallSampling field is set.
       */
      public boolean hasOverallSampling() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be traced
       * after all other sampling checks have been applied (client-directed, force tracing, random
       * sampling). This field functions as an upper limit on the total configured sampling rate. For
       * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
       * of client requests with the appropriate headers to be force traced. This field is a direct
       * analog for the runtime variable 'tracing.global_enabled' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
       * @return The overallSampling.
       */
      public io.envoyproxy.envoy.type.v3.Percent getOverallSampling() {
        if (overallSamplingBuilder_ == null) {
          return overallSampling_ == null ? io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : overallSampling_;
        } else {
          return overallSamplingBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be traced
       * after all other sampling checks have been applied (client-directed, force tracing, random
       * sampling). This field functions as an upper limit on the total configured sampling rate. For
       * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
       * of client requests with the appropriate headers to be force traced. This field is a direct
       * analog for the runtime variable 'tracing.global_enabled' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
       */
      public Builder setOverallSampling(io.envoyproxy.envoy.type.v3.Percent value) {
        if (overallSamplingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          overallSampling_ = value;
        } else {
          overallSamplingBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be traced
       * after all other sampling checks have been applied (client-directed, force tracing, random
       * sampling). This field functions as an upper limit on the total configured sampling rate. For
       * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
       * of client requests with the appropriate headers to be force traced. This field is a direct
       * analog for the runtime variable 'tracing.global_enabled' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
       */
      public Builder setOverallSampling(
          io.envoyproxy.envoy.type.v3.Percent.Builder builderForValue) {
        if (overallSamplingBuilder_ == null) {
          overallSampling_ = builderForValue.build();
        } else {
          overallSamplingBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be traced
       * after all other sampling checks have been applied (client-directed, force tracing, random
       * sampling). This field functions as an upper limit on the total configured sampling rate. For
       * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
       * of client requests with the appropriate headers to be force traced. This field is a direct
       * analog for the runtime variable 'tracing.global_enabled' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
       */
      public Builder mergeOverallSampling(io.envoyproxy.envoy.type.v3.Percent value) {
        if (overallSamplingBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            overallSampling_ != null &&
            overallSampling_ != io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance()) {
            getOverallSamplingBuilder().mergeFrom(value);
          } else {
            overallSampling_ = value;
          }
        } else {
          overallSamplingBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be traced
       * after all other sampling checks have been applied (client-directed, force tracing, random
       * sampling). This field functions as an upper limit on the total configured sampling rate. For
       * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
       * of client requests with the appropriate headers to be force traced. This field is a direct
       * analog for the runtime variable 'tracing.global_enabled' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
       */
      public Builder clearOverallSampling() {
        bitField0_ = (bitField0_ & ~0x00000004);
        overallSampling_ = null;
        if (overallSamplingBuilder_ != null) {
          overallSamplingBuilder_.dispose();
          overallSamplingBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be traced
       * after all other sampling checks have been applied (client-directed, force tracing, random
       * sampling). This field functions as an upper limit on the total configured sampling rate. For
       * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
       * of client requests with the appropriate headers to be force traced. This field is a direct
       * analog for the runtime variable 'tracing.global_enabled' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
       */
      public io.envoyproxy.envoy.type.v3.Percent.Builder getOverallSamplingBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getOverallSamplingFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be traced
       * after all other sampling checks have been applied (client-directed, force tracing, random
       * sampling). This field functions as an upper limit on the total configured sampling rate. For
       * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
       * of client requests with the appropriate headers to be force traced. This field is a direct
       * analog for the runtime variable 'tracing.global_enabled' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
       */
      public io.envoyproxy.envoy.type.v3.PercentOrBuilder getOverallSamplingOrBuilder() {
        if (overallSamplingBuilder_ != null) {
          return overallSamplingBuilder_.getMessageOrBuilder();
        } else {
          return overallSampling_ == null ?
              io.envoyproxy.envoy.type.v3.Percent.getDefaultInstance() : overallSampling_;
        }
      }
      /**
       * <pre>
       * Target percentage of requests managed by this HTTP connection manager that will be traced
       * after all other sampling checks have been applied (client-directed, force tracing, random
       * sampling). This field functions as an upper limit on the total configured sampling rate. For
       * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
       * of client requests with the appropriate headers to be force traced. This field is a direct
       * analog for the runtime variable 'tracing.global_enabled' in the
       * :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime&gt;`.
       * Default: 100%
       * </pre>
       *
       * <code>.envoy.type.v3.Percent overall_sampling = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder> 
          getOverallSamplingFieldBuilder() {
        if (overallSamplingBuilder_ == null) {
          overallSamplingBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.envoyproxy.envoy.type.v3.Percent, io.envoyproxy.envoy.type.v3.Percent.Builder, io.envoyproxy.envoy.type.v3.PercentOrBuilder>(
                  getOverallSampling(),
                  getParentForChildren(),
                  isClean());
          overallSampling_ = null;
        }
        return overallSamplingBuilder_;
      }

      private boolean verbose_ ;
      /**
       * <pre>
       * Whether to annotate spans with additional data. If true, spans will include logs for stream
       * events.
       * </pre>
       *
       * <code>bool verbose = 6;</code>
       * @return The verbose.
       */
      @java.lang.Override
      public boolean getVerbose() {
        return verbose_;
      }
      /**
       * <pre>
       * Whether to annotate spans with additional data. If true, spans will include logs for stream
       * events.
       * </pre>
       *
       * <code>bool verbose = 6;</code>
       * @param value The verbose to set.
       * @return This builder for chaining.
       */
      public Builder setVerbose(boolean value) {
        
        verbose_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to annotate spans with additional data. If true, spans will include logs for stream
       * events.
       * </pre>
       *
       * <code>bool verbose = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearVerbose() {
        bitField0_ = (bitField0_ & ~0x00000008);
        verbose_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.UInt32Value maxPathTagLength_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> maxPathTagLengthBuilder_;
      /**
       * <pre>
       * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
       * truncate lengthy request paths to meet the needs of a tracing backend.
       * Default: 256
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
       * @return Whether the maxPathTagLength field is set.
       */
      public boolean hasMaxPathTagLength() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
       * truncate lengthy request paths to meet the needs of a tracing backend.
       * Default: 256
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
       * @return The maxPathTagLength.
       */
      public com.google.protobuf.UInt32Value getMaxPathTagLength() {
        if (maxPathTagLengthBuilder_ == null) {
          return maxPathTagLength_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : maxPathTagLength_;
        } else {
          return maxPathTagLengthBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
       * truncate lengthy request paths to meet the needs of a tracing backend.
       * Default: 256
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
       */
      public Builder setMaxPathTagLength(com.google.protobuf.UInt32Value value) {
        if (maxPathTagLengthBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          maxPathTagLength_ = value;
        } else {
          maxPathTagLengthBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
       * truncate lengthy request paths to meet the needs of a tracing backend.
       * Default: 256
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
       */
      public Builder setMaxPathTagLength(
          com.google.protobuf.UInt32Value.Builder builderForValue) {
        if (maxPathTagLengthBuilder_ == null) {
          maxPathTagLength_ = builderForValue.build();
        } else {
          maxPathTagLengthBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
       * truncate lengthy request paths to meet the needs of a tracing backend.
       * Default: 256
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
       */
      public Builder mergeMaxPathTagLength(com.google.protobuf.UInt32Value value) {
        if (maxPathTagLengthBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0) &&
            maxPathTagLength_ != null &&
            maxPathTagLength_ != com.google.protobuf.UInt32Value.getDefaultInstance()) {
            getMaxPathTagLengthBuilder().mergeFrom(value);
          } else {
            maxPathTagLength_ = value;
          }
        } else {
          maxPathTagLengthBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
       * truncate lengthy request paths to meet the needs of a tracing backend.
       * Default: 256
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
       */
      public Builder clearMaxPathTagLength() {
        bitField0_ = (bitField0_ & ~0x00000010);
        maxPathTagLength_ = null;
        if (maxPathTagLengthBuilder_ != null) {
          maxPathTagLengthBuilder_.dispose();
          maxPathTagLengthBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
       * truncate lengthy request paths to meet the needs of a tracing backend.
       * Default: 256
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
       */
      public com.google.protobuf.UInt32Value.Builder getMaxPathTagLengthBuilder() {
        bitField0_ |= 0x00000010;
        onChanged();
        return getMaxPathTagLengthFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
       * truncate lengthy request paths to meet the needs of a tracing backend.
       * Default: 256
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
       */
      public com.google.protobuf.UInt32ValueOrBuilder getMaxPathTagLengthOrBuilder() {
        if (maxPathTagLengthBuilder_ != null) {
          return maxPathTagLengthBuilder_.getMessageOrBuilder();
        } else {
          return maxPathTagLength_ == null ?
              com.google.protobuf.UInt32Value.getDefaultInstance() : maxPathTagLength_;
        }
      }
      /**
       * <pre>
       * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
       * truncate lengthy request paths to meet the needs of a tracing backend.
       * Default: 256
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_path_tag_length = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
          getMaxPathTagLengthFieldBuilder() {
        if (maxPathTagLengthBuilder_ == null) {
          maxPathTagLengthBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                  getMaxPathTagLength(),
                  getParentForChildren(),
                  isClean());
          maxPathTagLength_ = null;
        }
        return maxPathTagLengthBuilder_;
      }

      private java.util.List<io.envoyproxy.envoy.type.tracing.v3.CustomTag> customTags_ =
        java.util.Collections.emptyList();
      private void ensureCustomTagsIsMutable() {
        if (!((bitField0_ & 0x00000020) != 0)) {
          customTags_ = new java.util.ArrayList<io.envoyproxy.envoy.type.tracing.v3.CustomTag>(customTags_);
          bitField0_ |= 0x00000020;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.type.tracing.v3.CustomTag, io.envoyproxy.envoy.type.tracing.v3.CustomTag.Builder, io.envoyproxy.envoy.type.tracing.v3.CustomTagOrBuilder> customTagsBuilder_;

      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public java.util.List<io.envoyproxy.envoy.type.tracing.v3.CustomTag> getCustomTagsList() {
        if (customTagsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(customTags_);
        } else {
          return customTagsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public int getCustomTagsCount() {
        if (customTagsBuilder_ == null) {
          return customTags_.size();
        } else {
          return customTagsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public io.envoyproxy.envoy.type.tracing.v3.CustomTag getCustomTags(int index) {
        if (customTagsBuilder_ == null) {
          return customTags_.get(index);
        } else {
          return customTagsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public Builder setCustomTags(
          int index, io.envoyproxy.envoy.type.tracing.v3.CustomTag value) {
        if (customTagsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCustomTagsIsMutable();
          customTags_.set(index, value);
          onChanged();
        } else {
          customTagsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public Builder setCustomTags(
          int index, io.envoyproxy.envoy.type.tracing.v3.CustomTag.Builder builderForValue) {
        if (customTagsBuilder_ == null) {
          ensureCustomTagsIsMutable();
          customTags_.set(index, builderForValue.build());
          onChanged();
        } else {
          customTagsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public Builder addCustomTags(io.envoyproxy.envoy.type.tracing.v3.CustomTag value) {
        if (customTagsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCustomTagsIsMutable();
          customTags_.add(value);
          onChanged();
        } else {
          customTagsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public Builder addCustomTags(
          int index, io.envoyproxy.envoy.type.tracing.v3.CustomTag value) {
        if (customTagsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCustomTagsIsMutable();
          customTags_.add(index, value);
          onChanged();
        } else {
          customTagsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public Builder addCustomTags(
          io.envoyproxy.envoy.type.tracing.v3.CustomTag.Builder builderForValue) {
        if (customTagsBuilder_ == null) {
          ensureCustomTagsIsMutable();
          customTags_.add(builderForValue.build());
          onChanged();
        } else {
          customTagsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public Builder addCustomTags(
          int index, io.envoyproxy.envoy.type.tracing.v3.CustomTag.Builder builderForValue) {
        if (customTagsBuilder_ == null) {
          ensureCustomTagsIsMutable();
          customTags_.add(index, builderForValue.build());
          onChanged();
        } else {
          customTagsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public Builder addAllCustomTags(
          java.lang.Iterable<? extends io.envoyproxy.envoy.type.tracing.v3.CustomTag> values) {
        if (customTagsBuilder_ == null) {
          ensureCustomTagsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, customTags_);
          onChanged();
        } else {
          customTagsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public Builder clearCustomTags() {
        if (customTagsBuilder_ == null) {
          customTags_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
        } else {
          customTagsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public Builder removeCustomTags(int index) {
        if (customTagsBuilder_ == null) {
          ensureCustomTagsIsMutable();
          customTags_.remove(index);
          onChanged();
        } else {
          customTagsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public io.envoyproxy.envoy.type.tracing.v3.CustomTag.Builder getCustomTagsBuilder(
          int index) {
        return getCustomTagsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public io.envoyproxy.envoy.type.tracing.v3.CustomTagOrBuilder getCustomTagsOrBuilder(
          int index) {
        if (customTagsBuilder_ == null) {
          return customTags_.get(index);  } else {
          return customTagsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public java.util.List<? extends io.envoyproxy.envoy.type.tracing.v3.CustomTagOrBuilder> 
           getCustomTagsOrBuilderList() {
        if (customTagsBuilder_ != null) {
          return customTagsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(customTags_);
        }
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public io.envoyproxy.envoy.type.tracing.v3.CustomTag.Builder addCustomTagsBuilder() {
        return getCustomTagsFieldBuilder().addBuilder(
            io.envoyproxy.envoy.type.tracing.v3.CustomTag.getDefaultInstance());
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public io.envoyproxy.envoy.type.tracing.v3.CustomTag.Builder addCustomTagsBuilder(
          int index) {
        return getCustomTagsFieldBuilder().addBuilder(
            index, io.envoyproxy.envoy.type.tracing.v3.CustomTag.getDefaultInstance());
      }
      /**
       * <pre>
       * A list of custom tags with unique tag name to create tags for the active span.
       * </pre>
       *
       * <code>repeated .envoy.type.tracing.v3.CustomTag custom_tags = 8;</code>
       */
      public java.util.List<io.envoyproxy.envoy.type.tracing.v3.CustomTag.Builder> 
           getCustomTagsBuilderList() {
        return getCustomTagsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.type.tracing.v3.CustomTag, io.envoyproxy.envoy.type.tracing.v3.CustomTag.Builder, io.envoyproxy.envoy.type.tracing.v3.CustomTagOrBuilder> 
          getCustomTagsFieldBuilder() {
        if (customTagsBuilder_ == null) {
          customTagsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.envoyproxy.envoy.type.tracing.v3.CustomTag, io.envoyproxy.envoy.type.tracing.v3.CustomTag.Builder, io.envoyproxy.envoy.type.tracing.v3.CustomTagOrBuilder>(
                  customTags_,
                  ((bitField0_ & 0x00000020) != 0),
                  getParentForChildren(),
                  isClean());
          customTags_ = null;
        }
        return customTagsBuilder_;
      }

      private io.envoyproxy.envoy.config.trace.v3.Tracing.Http provider_;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.trace.v3.Tracing.Http, io.envoyproxy.envoy.config.trace.v3.Tracing.Http.Builder, io.envoyproxy.envoy.config.trace.v3.Tracing.HttpOrBuilder> providerBuilder_;
      /**
       * <pre>
       * Configuration for an external tracing provider.
       * If not specified, no tracing will be performed.
       * .. attention::
       *   Please be aware that ``envoy.tracers.opencensus`` provider can only be configured once
       *   in Envoy lifetime.
       *   Any attempts to reconfigure it or to use different configurations for different HCM filters
       *   will be rejected.
       *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
       *   on OpenCensus side.
       * </pre>
       *
       * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
       * @return Whether the provider field is set.
       */
      public boolean hasProvider() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Configuration for an external tracing provider.
       * If not specified, no tracing will be performed.
       * .. attention::
       *   Please be aware that ``envoy.tracers.opencensus`` provider can only be configured once
       *   in Envoy lifetime.
       *   Any attempts to reconfigure it or to use different configurations for different HCM filters
       *   will be rejected.
       *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
       *   on OpenCensus side.
       * </pre>
       *
       * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
       * @return The provider.
       */
      public io.envoyproxy.envoy.config.trace.v3.Tracing.Http getProvider() {
        if (providerBuilder_ == null) {
          return provider_ == null ? io.envoyproxy.envoy.config.trace.v3.Tracing.Http.getDefaultInstance() : provider_;
        } else {
          return providerBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Configuration for an external tracing provider.
       * If not specified, no tracing will be performed.
       * .. attention::
       *   Please be aware that ``envoy.tracers.opencensus`` provider can only be configured once
       *   in Envoy lifetime.
       *   Any attempts to reconfigure it or to use different configurations for different HCM filters
       *   will be rejected.
       *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
       *   on OpenCensus side.
       * </pre>
       *
       * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
       */
      public Builder setProvider(io.envoyproxy.envoy.config.trace.v3.Tracing.Http value) {
        if (providerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          provider_ = value;
        } else {
          providerBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Configuration for an external tracing provider.
       * If not specified, no tracing will be performed.
       * .. attention::
       *   Please be aware that ``envoy.tracers.opencensus`` provider can only be configured once
       *   in Envoy lifetime.
       *   Any attempts to reconfigure it or to use different configurations for different HCM filters
       *   will be rejected.
       *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
       *   on OpenCensus side.
       * </pre>
       *
       * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
       */
      public Builder setProvider(
          io.envoyproxy.envoy.config.trace.v3.Tracing.Http.Builder builderForValue) {
        if (providerBuilder_ == null) {
          provider_ = builderForValue.build();
        } else {
          providerBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Configuration for an external tracing provider.
       * If not specified, no tracing will be performed.
       * .. attention::
       *   Please be aware that ``envoy.tracers.opencensus`` provider can only be configured once
       *   in Envoy lifetime.
       *   Any attempts to reconfigure it or to use different configurations for different HCM filters
       *   will be rejected.
       *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
       *   on OpenCensus side.
       * </pre>
       *
       * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
       */
      public Builder mergeProvider(io.envoyproxy.envoy.config.trace.v3.Tracing.Http value) {
        if (providerBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
            provider_ != null &&
            provider_ != io.envoyproxy.envoy.config.trace.v3.Tracing.Http.getDefaultInstance()) {
            getProviderBuilder().mergeFrom(value);
          } else {
            provider_ = value;
          }
        } else {
          providerBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Configuration for an external tracing provider.
       * If not specified, no tracing will be performed.
       * .. attention::
       *   Please be aware that ``envoy.tracers.opencensus`` provider can only be configured once
       *   in Envoy lifetime.
       *   Any attempts to reconfigure it or to use different configurations for different HCM filters
       *   will be rejected.
       *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
       *   on OpenCensus side.
       * </pre>
       *
       * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
       */
      public Builder clearProvider() {
        bitField0_ = (bitField0_ & ~0x00000040);
        provider_ = null;
        if (providerBuilder_ != null) {
          providerBuilder_.dispose();
          providerBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Configuration for an external tracing provider.
       * If not specified, no tracing will be performed.
       * .. attention::
       *   Please be aware that ``envoy.tracers.opencensus`` provider can only be configured once
       *   in Envoy lifetime.
       *   Any attempts to reconfigure it or to use different configurations for different HCM filters
       *   will be rejected.
       *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
       *   on OpenCensus side.
       * </pre>
       *
       * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
       */
      public io.envoyproxy.envoy.config.trace.v3.Tracing.Http.Builder getProviderBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getProviderFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Configuration for an external tracing provider.
       * If not specified, no tracing will be performed.
       * .. attention::
       *   Please be aware that ``envoy.tracers.opencensus`` provider can only be configured once
       *   in Envoy lifetime.
       *   Any attempts to reconfigure it or to use different configurations for different HCM filters
       *   will be rejected.
       *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
       *   on OpenCensus side.
       * </pre>
       *
       * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
       */
      public io.envoyproxy.envoy.config.trace.v3.Tracing.HttpOrBuilder getProviderOrBuilder() {
        if (providerBuilder_ != null) {
          return providerBuilder_.getMessageOrBuilder();
        } else {
          return provider_ == null ?
              io.envoyproxy.envoy.config.trace.v3.Tracing.Http.getDefaultInstance() : provider_;
        }
      }
      /**
       * <pre>
       * Configuration for an external tracing provider.
       * If not specified, no tracing will be performed.
       * .. attention::
       *   Please be aware that ``envoy.tracers.opencensus`` provider can only be configured once
       *   in Envoy lifetime.
       *   Any attempts to reconfigure it or to use different configurations for different HCM filters
       *   will be rejected.
       *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
       *   on OpenCensus side.
       * </pre>
       *
       * <code>.envoy.config.trace.v3.Tracing.Http provider = 9;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.config.trace.v3.Tracing.Http, io.envoyproxy.envoy.config.trace.v3.Tracing.Http.Builder, io.envoyproxy.envoy.config.trace.v3.Tracing.HttpOrBuilder> 
          getProviderFieldBuilder() {
        if (providerBuilder_ == null) {
          providerBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.envoyproxy.envoy.config.trace.v3.Tracing.Http, io.envoyproxy.envoy.config.trace.v3.Tracing.Http.Builder, io.envoyproxy.envoy.config.trace.v3.Tracing.HttpOrBuilder>(
                  getProvider(),
                  getParentForChildren(),
                  isClean());
          provider_ = null;
        }
        return providerBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing)
    }

    // @@protoc_insertion_point(class_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing)
    private static final io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing();
    }

    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Tracing>
        PARSER = new com.google.protobuf.AbstractParser<Tracing>() {
      @java.lang.Override
      public Tracing parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Tracing> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Tracing> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface InternalAddressConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Whether unix socket addresses should be considered internal.
     * </pre>
     *
     * <code>bool unix_sockets = 1;</code>
     * @return The unixSockets.
     */
    boolean getUnixSockets();

    /**
     * <pre>
     * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
     * IP addresses will be considered internal.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
     */
    java.util.List<io.envoyproxy.envoy.config.core.v3.CidrRange> 
        getCidrRangesList();
    /**
     * <pre>
     * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
     * IP addresses will be considered internal.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
     */
    io.envoyproxy.envoy.config.core.v3.CidrRange getCidrRanges(int index);
    /**
     * <pre>
     * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
     * IP addresses will be considered internal.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
     */
    int getCidrRangesCount();
    /**
     * <pre>
     * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
     * IP addresses will be considered internal.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
     */
    java.util.List<? extends io.envoyproxy.envoy.config.core.v3.CidrRangeOrBuilder> 
        getCidrRangesOrBuilderList();
    /**
     * <pre>
     * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
     * IP addresses will be considered internal.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
     */
    io.envoyproxy.envoy.config.core.v3.CidrRangeOrBuilder getCidrRangesOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig}
   */
  public static final class InternalAddressConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig)
      InternalAddressConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use InternalAddressConfig.newBuilder() to construct.
    private InternalAddressConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private InternalAddressConfig() {
      cidrRanges_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new InternalAddressConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_InternalAddressConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_InternalAddressConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.Builder.class);
    }

    public static final int UNIX_SOCKETS_FIELD_NUMBER = 1;
    private boolean unixSockets_ = false;
    /**
     * <pre>
     * Whether unix socket addresses should be considered internal.
     * </pre>
     *
     * <code>bool unix_sockets = 1;</code>
     * @return The unixSockets.
     */
    @java.lang.Override
    public boolean getUnixSockets() {
      return unixSockets_;
    }

    public static final int CIDR_RANGES_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.envoyproxy.envoy.config.core.v3.CidrRange> cidrRanges_;
    /**
     * <pre>
     * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
     * IP addresses will be considered internal.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.envoyproxy.envoy.config.core.v3.CidrRange> getCidrRangesList() {
      return cidrRanges_;
    }
    /**
     * <pre>
     * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
     * IP addresses will be considered internal.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.envoyproxy.envoy.config.core.v3.CidrRangeOrBuilder> 
        getCidrRangesOrBuilderList() {
      return cidrRanges_;
    }
    /**
     * <pre>
     * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
     * IP addresses will be considered internal.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
     */
    @java.lang.Override
    public int getCidrRangesCount() {
      return cidrRanges_.size();
    }
    /**
     * <pre>
     * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
     * IP addresses will be considered internal.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.CidrRange getCidrRanges(int index) {
      return cidrRanges_.get(index);
    }
    /**
     * <pre>
     * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
     * IP addresses will be considered internal.
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.core.v3.CidrRangeOrBuilder getCidrRangesOrBuilder(
        int index) {
      return cidrRanges_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (unixSockets_ != false) {
        output.writeBool(1, unixSockets_);
      }
      for (int i = 0; i < cidrRanges_.size(); i++) {
        output.writeMessage(2, cidrRanges_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (unixSockets_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(1, unixSockets_);
      }
      for (int i = 0; i < cidrRanges_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, cidrRanges_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig other = (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig) obj;

      if (getUnixSockets()
          != other.getUnixSockets()) return false;
      if (!getCidrRangesList()
          .equals(other.getCidrRangesList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + UNIX_SOCKETS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getUnixSockets());
      if (getCidrRangesCount() > 0) {
        hash = (37 * hash) + CIDR_RANGES_FIELD_NUMBER;
        hash = (53 * hash) + getCidrRangesList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig)
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_InternalAddressConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_InternalAddressConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        unixSockets_ = false;
        if (cidrRangesBuilder_ == null) {
          cidrRanges_ = java.util.Collections.emptyList();
        } else {
          cidrRanges_ = null;
          cidrRangesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_InternalAddressConfig_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig getDefaultInstanceForType() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig build() {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig buildPartial() {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig result = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig result) {
        if (cidrRangesBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            cidrRanges_ = java.util.Collections.unmodifiableList(cidrRanges_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.cidrRanges_ = cidrRanges_;
        } else {
          result.cidrRanges_ = cidrRangesBuilder_.build();
        }
      }

      private void buildPartial0(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.unixSockets_ = unixSockets_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig) {
          return mergeFrom((io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig other) {
        if (other == io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.getDefaultInstance()) return this;
        if (other.getUnixSockets() != false) {
          setUnixSockets(other.getUnixSockets());
        }
        if (cidrRangesBuilder_ == null) {
          if (!other.cidrRanges_.isEmpty()) {
            if (cidrRanges_.isEmpty()) {
              cidrRanges_ = other.cidrRanges_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureCidrRangesIsMutable();
              cidrRanges_.addAll(other.cidrRanges_);
            }
            onChanged();
          }
        } else {
          if (!other.cidrRanges_.isEmpty()) {
            if (cidrRangesBuilder_.isEmpty()) {
              cidrRangesBuilder_.dispose();
              cidrRangesBuilder_ = null;
              cidrRanges_ = other.cidrRanges_;
              bitField0_ = (bitField0_ & ~0x00000002);
              cidrRangesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getCidrRangesFieldBuilder() : null;
            } else {
              cidrRangesBuilder_.addAllMessages(other.cidrRanges_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                unixSockets_ = input.readBool();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                io.envoyproxy.envoy.config.core.v3.CidrRange m =
                    input.readMessage(
                        io.envoyproxy.envoy.config.core.v3.CidrRange.parser(),
                        extensionRegistry);
                if (cidrRangesBuilder_ == null) {
                  ensureCidrRangesIsMutable();
                  cidrRanges_.add(m);
                } else {
                  cidrRangesBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private boolean unixSockets_ ;
      /**
       * <pre>
       * Whether unix socket addresses should be considered internal.
       * </pre>
       *
       * <code>bool unix_sockets = 1;</code>
       * @return The unixSockets.
       */
      @java.lang.Override
      public boolean getUnixSockets() {
        return unixSockets_;
      }
      /**
       * <pre>
       * Whether unix socket addresses should be considered internal.
       * </pre>
       *
       * <code>bool unix_sockets = 1;</code>
       * @param value The unixSockets to set.
       * @return This builder for chaining.
       */
      public Builder setUnixSockets(boolean value) {
        
        unixSockets_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether unix socket addresses should be considered internal.
       * </pre>
       *
       * <code>bool unix_sockets = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearUnixSockets() {
        bitField0_ = (bitField0_ & ~0x00000001);
        unixSockets_ = false;
        onChanged();
        return this;
      }

      private java.util.List<io.envoyproxy.envoy.config.core.v3.CidrRange> cidrRanges_ =
        java.util.Collections.emptyList();
      private void ensureCidrRangesIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          cidrRanges_ = new java.util.ArrayList<io.envoyproxy.envoy.config.core.v3.CidrRange>(cidrRanges_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.config.core.v3.CidrRange, io.envoyproxy.envoy.config.core.v3.CidrRange.Builder, io.envoyproxy.envoy.config.core.v3.CidrRangeOrBuilder> cidrRangesBuilder_;

      /**
       * <pre>
       * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
       * IP addresses will be considered internal.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
       */
      public java.util.List<io.envoyproxy.envoy.config.core.v3.CidrRange> getCidrRangesList() {
        if (cidrRangesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(cidrRanges_);
        } else {
          return cidrRangesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
       * IP addresses will be considered internal.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
       */
      public int getCidrRangesCount() {
        if (cidrRangesBuilder_ == null) {
          return cidrRanges_.size();
        } else {
          return cidrRangesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
       * IP addresses will be considered internal.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.CidrRange getCidrRanges(int index) {
        if (cidrRangesBuilder_ == null) {
          return cidrRanges_.get(index);
        } else {
          return cidrRangesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
       * IP addresses will be considered internal.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
       */
      public Builder setCidrRanges(
          int index, io.envoyproxy.envoy.config.core.v3.CidrRange value) {
        if (cidrRangesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCidrRangesIsMutable();
          cidrRanges_.set(index, value);
          onChanged();
        } else {
          cidrRangesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
       * IP addresses will be considered internal.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
       */
      public Builder setCidrRanges(
          int index, io.envoyproxy.envoy.config.core.v3.CidrRange.Builder builderForValue) {
        if (cidrRangesBuilder_ == null) {
          ensureCidrRangesIsMutable();
          cidrRanges_.set(index, builderForValue.build());
          onChanged();
        } else {
          cidrRangesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
       * IP addresses will be considered internal.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
       */
      public Builder addCidrRanges(io.envoyproxy.envoy.config.core.v3.CidrRange value) {
        if (cidrRangesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCidrRangesIsMutable();
          cidrRanges_.add(value);
          onChanged();
        } else {
          cidrRangesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
       * IP addresses will be considered internal.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
       */
      public Builder addCidrRanges(
          int index, io.envoyproxy.envoy.config.core.v3.CidrRange value) {
        if (cidrRangesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCidrRangesIsMutable();
          cidrRanges_.add(index, value);
          onChanged();
        } else {
          cidrRangesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
       * IP addresses will be considered internal.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
       */
      public Builder addCidrRanges(
          io.envoyproxy.envoy.config.core.v3.CidrRange.Builder builderForValue) {
        if (cidrRangesBuilder_ == null) {
          ensureCidrRangesIsMutable();
          cidrRanges_.add(builderForValue.build());
          onChanged();
        } else {
          cidrRangesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
       * IP addresses will be considered internal.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
       */
      public Builder addCidrRanges(
          int index, io.envoyproxy.envoy.config.core.v3.CidrRange.Builder builderForValue) {
        if (cidrRangesBuilder_ == null) {
          ensureCidrRangesIsMutable();
          cidrRanges_.add(index, builderForValue.build());
          onChanged();
        } else {
          cidrRangesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
       * IP addresses will be considered internal.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
       */
      public Builder addAllCidrRanges(
          java.lang.Iterable<? extends io.envoyproxy.envoy.config.core.v3.CidrRange> values) {
        if (cidrRangesBuilder_ == null) {
          ensureCidrRangesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, cidrRanges_);
          onChanged();
        } else {
          cidrRangesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
       * IP addresses will be considered internal.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
       */
      public Builder clearCidrRanges() {
        if (cidrRangesBuilder_ == null) {
          cidrRanges_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          cidrRangesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
       * IP addresses will be considered internal.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
       */
      public Builder removeCidrRanges(int index) {
        if (cidrRangesBuilder_ == null) {
          ensureCidrRangesIsMutable();
          cidrRanges_.remove(index);
          onChanged();
        } else {
          cidrRangesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
       * IP addresses will be considered internal.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.CidrRange.Builder getCidrRangesBuilder(
          int index) {
        return getCidrRangesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
       * IP addresses will be considered internal.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.CidrRangeOrBuilder getCidrRangesOrBuilder(
          int index) {
        if (cidrRangesBuilder_ == null) {
          return cidrRanges_.get(index);  } else {
          return cidrRangesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
       * IP addresses will be considered internal.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
       */
      public java.util.List<? extends io.envoyproxy.envoy.config.core.v3.CidrRangeOrBuilder> 
           getCidrRangesOrBuilderList() {
        if (cidrRangesBuilder_ != null) {
          return cidrRangesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(cidrRanges_);
        }
      }
      /**
       * <pre>
       * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
       * IP addresses will be considered internal.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.CidrRange.Builder addCidrRangesBuilder() {
        return getCidrRangesFieldBuilder().addBuilder(
            io.envoyproxy.envoy.config.core.v3.CidrRange.getDefaultInstance());
      }
      /**
       * <pre>
       * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
       * IP addresses will be considered internal.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
       */
      public io.envoyproxy.envoy.config.core.v3.CidrRange.Builder addCidrRangesBuilder(
          int index) {
        return getCidrRangesFieldBuilder().addBuilder(
            index, io.envoyproxy.envoy.config.core.v3.CidrRange.getDefaultInstance());
      }
      /**
       * <pre>
       * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
       * IP addresses will be considered internal.
       * </pre>
       *
       * <code>repeated .envoy.config.core.v3.CidrRange cidr_ranges = 2;</code>
       */
      public java.util.List<io.envoyproxy.envoy.config.core.v3.CidrRange.Builder> 
           getCidrRangesBuilderList() {
        return getCidrRangesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.config.core.v3.CidrRange, io.envoyproxy.envoy.config.core.v3.CidrRange.Builder, io.envoyproxy.envoy.config.core.v3.CidrRangeOrBuilder> 
          getCidrRangesFieldBuilder() {
        if (cidrRangesBuilder_ == null) {
          cidrRangesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.envoyproxy.envoy.config.core.v3.CidrRange, io.envoyproxy.envoy.config.core.v3.CidrRange.Builder, io.envoyproxy.envoy.config.core.v3.CidrRangeOrBuilder>(
                  cidrRanges_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          cidrRanges_ = null;
        }
        return cidrRangesBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig)
    }

    // @@protoc_insertion_point(class_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig)
    private static final io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig();
    }

    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<InternalAddressConfig>
        PARSER = new com.google.protobuf.AbstractParser<InternalAddressConfig>() {
      @java.lang.Override
      public InternalAddressConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<InternalAddressConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<InternalAddressConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SetCurrentClientCertDetailsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Whether to forward the subject of the client cert. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue subject = 1;</code>
     * @return Whether the subject field is set.
     */
    boolean hasSubject();
    /**
     * <pre>
     * Whether to forward the subject of the client cert. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue subject = 1;</code>
     * @return The subject.
     */
    com.google.protobuf.BoolValue getSubject();
    /**
     * <pre>
     * Whether to forward the subject of the client cert. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue subject = 1;</code>
     */
    com.google.protobuf.BoolValueOrBuilder getSubjectOrBuilder();

    /**
     * <pre>
     * Whether to forward the entire client cert in URL encoded PEM format. This will appear in the
     * XFCC header comma separated from other values with the value Cert="PEM".
     * Defaults to false.
     * </pre>
     *
     * <code>bool cert = 3;</code>
     * @return The cert.
     */
    boolean getCert();

    /**
     * <pre>
     * Whether to forward the entire client cert chain (including the leaf cert) in URL encoded PEM
     * format. This will appear in the XFCC header comma separated from other values with the value
     * Chain="PEM".
     * Defaults to false.
     * </pre>
     *
     * <code>bool chain = 6;</code>
     * @return The chain.
     */
    boolean getChain();

    /**
     * <pre>
     * Whether to forward the DNS type Subject Alternative Names of the client cert.
     * Defaults to false.
     * </pre>
     *
     * <code>bool dns = 4;</code>
     * @return The dns.
     */
    boolean getDns();

    /**
     * <pre>
     * Whether to forward the URI type Subject Alternative Name of the client cert. Defaults to
     * false.
     * </pre>
     *
     * <code>bool uri = 5;</code>
     * @return The uri.
     */
    boolean getUri();
  }
  /**
   * <pre>
   * [#next-free-field: 7]
   * </pre>
   *
   * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails}
   */
  public static final class SetCurrentClientCertDetails extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails)
      SetCurrentClientCertDetailsOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SetCurrentClientCertDetails.newBuilder() to construct.
    private SetCurrentClientCertDetails(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SetCurrentClientCertDetails() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SetCurrentClientCertDetails();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_SetCurrentClientCertDetails_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_SetCurrentClientCertDetails_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.Builder.class);
    }

    public static final int SUBJECT_FIELD_NUMBER = 1;
    private com.google.protobuf.BoolValue subject_;
    /**
     * <pre>
     * Whether to forward the subject of the client cert. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue subject = 1;</code>
     * @return Whether the subject field is set.
     */
    @java.lang.Override
    public boolean hasSubject() {
      return subject_ != null;
    }
    /**
     * <pre>
     * Whether to forward the subject of the client cert. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue subject = 1;</code>
     * @return The subject.
     */
    @java.lang.Override
    public com.google.protobuf.BoolValue getSubject() {
      return subject_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : subject_;
    }
    /**
     * <pre>
     * Whether to forward the subject of the client cert. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue subject = 1;</code>
     */
    @java.lang.Override
    public com.google.protobuf.BoolValueOrBuilder getSubjectOrBuilder() {
      return subject_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : subject_;
    }

    public static final int CERT_FIELD_NUMBER = 3;
    private boolean cert_ = false;
    /**
     * <pre>
     * Whether to forward the entire client cert in URL encoded PEM format. This will appear in the
     * XFCC header comma separated from other values with the value Cert="PEM".
     * Defaults to false.
     * </pre>
     *
     * <code>bool cert = 3;</code>
     * @return The cert.
     */
    @java.lang.Override
    public boolean getCert() {
      return cert_;
    }

    public static final int CHAIN_FIELD_NUMBER = 6;
    private boolean chain_ = false;
    /**
     * <pre>
     * Whether to forward the entire client cert chain (including the leaf cert) in URL encoded PEM
     * format. This will appear in the XFCC header comma separated from other values with the value
     * Chain="PEM".
     * Defaults to false.
     * </pre>
     *
     * <code>bool chain = 6;</code>
     * @return The chain.
     */
    @java.lang.Override
    public boolean getChain() {
      return chain_;
    }

    public static final int DNS_FIELD_NUMBER = 4;
    private boolean dns_ = false;
    /**
     * <pre>
     * Whether to forward the DNS type Subject Alternative Names of the client cert.
     * Defaults to false.
     * </pre>
     *
     * <code>bool dns = 4;</code>
     * @return The dns.
     */
    @java.lang.Override
    public boolean getDns() {
      return dns_;
    }

    public static final int URI_FIELD_NUMBER = 5;
    private boolean uri_ = false;
    /**
     * <pre>
     * Whether to forward the URI type Subject Alternative Name of the client cert. Defaults to
     * false.
     * </pre>
     *
     * <code>bool uri = 5;</code>
     * @return The uri.
     */
    @java.lang.Override
    public boolean getUri() {
      return uri_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (subject_ != null) {
        output.writeMessage(1, getSubject());
      }
      if (cert_ != false) {
        output.writeBool(3, cert_);
      }
      if (dns_ != false) {
        output.writeBool(4, dns_);
      }
      if (uri_ != false) {
        output.writeBool(5, uri_);
      }
      if (chain_ != false) {
        output.writeBool(6, chain_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (subject_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getSubject());
      }
      if (cert_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, cert_);
      }
      if (dns_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(4, dns_);
      }
      if (uri_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(5, uri_);
      }
      if (chain_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(6, chain_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails other = (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails) obj;

      if (hasSubject() != other.hasSubject()) return false;
      if (hasSubject()) {
        if (!getSubject()
            .equals(other.getSubject())) return false;
      }
      if (getCert()
          != other.getCert()) return false;
      if (getChain()
          != other.getChain()) return false;
      if (getDns()
          != other.getDns()) return false;
      if (getUri()
          != other.getUri()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasSubject()) {
        hash = (37 * hash) + SUBJECT_FIELD_NUMBER;
        hash = (53 * hash) + getSubject().hashCode();
      }
      hash = (37 * hash) + CERT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getCert());
      hash = (37 * hash) + CHAIN_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getChain());
      hash = (37 * hash) + DNS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getDns());
      hash = (37 * hash) + URI_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getUri());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * [#next-free-field: 7]
     * </pre>
     *
     * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails)
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetailsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_SetCurrentClientCertDetails_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_SetCurrentClientCertDetails_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        subject_ = null;
        if (subjectBuilder_ != null) {
          subjectBuilder_.dispose();
          subjectBuilder_ = null;
        }
        cert_ = false;
        chain_ = false;
        dns_ = false;
        uri_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_SetCurrentClientCertDetails_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails getDefaultInstanceForType() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails build() {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails buildPartial() {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails result = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.subject_ = subjectBuilder_ == null
              ? subject_
              : subjectBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.cert_ = cert_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.chain_ = chain_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.dns_ = dns_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.uri_ = uri_;
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails) {
          return mergeFrom((io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails other) {
        if (other == io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.getDefaultInstance()) return this;
        if (other.hasSubject()) {
          mergeSubject(other.getSubject());
        }
        if (other.getCert() != false) {
          setCert(other.getCert());
        }
        if (other.getChain() != false) {
          setChain(other.getChain());
        }
        if (other.getDns() != false) {
          setDns(other.getDns());
        }
        if (other.getUri() != false) {
          setUri(other.getUri());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getSubjectFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 24: {
                cert_ = input.readBool();
                bitField0_ |= 0x00000002;
                break;
              } // case 24
              case 32: {
                dns_ = input.readBool();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 40: {
                uri_ = input.readBool();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              case 48: {
                chain_ = input.readBool();
                bitField0_ |= 0x00000004;
                break;
              } // case 48
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.BoolValue subject_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> subjectBuilder_;
      /**
       * <pre>
       * Whether to forward the subject of the client cert. Defaults to false.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue subject = 1;</code>
       * @return Whether the subject field is set.
       */
      public boolean hasSubject() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Whether to forward the subject of the client cert. Defaults to false.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue subject = 1;</code>
       * @return The subject.
       */
      public com.google.protobuf.BoolValue getSubject() {
        if (subjectBuilder_ == null) {
          return subject_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : subject_;
        } else {
          return subjectBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Whether to forward the subject of the client cert. Defaults to false.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue subject = 1;</code>
       */
      public Builder setSubject(com.google.protobuf.BoolValue value) {
        if (subjectBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          subject_ = value;
        } else {
          subjectBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to forward the subject of the client cert. Defaults to false.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue subject = 1;</code>
       */
      public Builder setSubject(
          com.google.protobuf.BoolValue.Builder builderForValue) {
        if (subjectBuilder_ == null) {
          subject_ = builderForValue.build();
        } else {
          subjectBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to forward the subject of the client cert. Defaults to false.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue subject = 1;</code>
       */
      public Builder mergeSubject(com.google.protobuf.BoolValue value) {
        if (subjectBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            subject_ != null &&
            subject_ != com.google.protobuf.BoolValue.getDefaultInstance()) {
            getSubjectBuilder().mergeFrom(value);
          } else {
            subject_ = value;
          }
        } else {
          subjectBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to forward the subject of the client cert. Defaults to false.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue subject = 1;</code>
       */
      public Builder clearSubject() {
        bitField0_ = (bitField0_ & ~0x00000001);
        subject_ = null;
        if (subjectBuilder_ != null) {
          subjectBuilder_.dispose();
          subjectBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to forward the subject of the client cert. Defaults to false.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue subject = 1;</code>
       */
      public com.google.protobuf.BoolValue.Builder getSubjectBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getSubjectFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Whether to forward the subject of the client cert. Defaults to false.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue subject = 1;</code>
       */
      public com.google.protobuf.BoolValueOrBuilder getSubjectOrBuilder() {
        if (subjectBuilder_ != null) {
          return subjectBuilder_.getMessageOrBuilder();
        } else {
          return subject_ == null ?
              com.google.protobuf.BoolValue.getDefaultInstance() : subject_;
        }
      }
      /**
       * <pre>
       * Whether to forward the subject of the client cert. Defaults to false.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue subject = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
          getSubjectFieldBuilder() {
        if (subjectBuilder_ == null) {
          subjectBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                  getSubject(),
                  getParentForChildren(),
                  isClean());
          subject_ = null;
        }
        return subjectBuilder_;
      }

      private boolean cert_ ;
      /**
       * <pre>
       * Whether to forward the entire client cert in URL encoded PEM format. This will appear in the
       * XFCC header comma separated from other values with the value Cert="PEM".
       * Defaults to false.
       * </pre>
       *
       * <code>bool cert = 3;</code>
       * @return The cert.
       */
      @java.lang.Override
      public boolean getCert() {
        return cert_;
      }
      /**
       * <pre>
       * Whether to forward the entire client cert in URL encoded PEM format. This will appear in the
       * XFCC header comma separated from other values with the value Cert="PEM".
       * Defaults to false.
       * </pre>
       *
       * <code>bool cert = 3;</code>
       * @param value The cert to set.
       * @return This builder for chaining.
       */
      public Builder setCert(boolean value) {
        
        cert_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to forward the entire client cert in URL encoded PEM format. This will appear in the
       * XFCC header comma separated from other values with the value Cert="PEM".
       * Defaults to false.
       * </pre>
       *
       * <code>bool cert = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearCert() {
        bitField0_ = (bitField0_ & ~0x00000002);
        cert_ = false;
        onChanged();
        return this;
      }

      private boolean chain_ ;
      /**
       * <pre>
       * Whether to forward the entire client cert chain (including the leaf cert) in URL encoded PEM
       * format. This will appear in the XFCC header comma separated from other values with the value
       * Chain="PEM".
       * Defaults to false.
       * </pre>
       *
       * <code>bool chain = 6;</code>
       * @return The chain.
       */
      @java.lang.Override
      public boolean getChain() {
        return chain_;
      }
      /**
       * <pre>
       * Whether to forward the entire client cert chain (including the leaf cert) in URL encoded PEM
       * format. This will appear in the XFCC header comma separated from other values with the value
       * Chain="PEM".
       * Defaults to false.
       * </pre>
       *
       * <code>bool chain = 6;</code>
       * @param value The chain to set.
       * @return This builder for chaining.
       */
      public Builder setChain(boolean value) {
        
        chain_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to forward the entire client cert chain (including the leaf cert) in URL encoded PEM
       * format. This will appear in the XFCC header comma separated from other values with the value
       * Chain="PEM".
       * Defaults to false.
       * </pre>
       *
       * <code>bool chain = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearChain() {
        bitField0_ = (bitField0_ & ~0x00000004);
        chain_ = false;
        onChanged();
        return this;
      }

      private boolean dns_ ;
      /**
       * <pre>
       * Whether to forward the DNS type Subject Alternative Names of the client cert.
       * Defaults to false.
       * </pre>
       *
       * <code>bool dns = 4;</code>
       * @return The dns.
       */
      @java.lang.Override
      public boolean getDns() {
        return dns_;
      }
      /**
       * <pre>
       * Whether to forward the DNS type Subject Alternative Names of the client cert.
       * Defaults to false.
       * </pre>
       *
       * <code>bool dns = 4;</code>
       * @param value The dns to set.
       * @return This builder for chaining.
       */
      public Builder setDns(boolean value) {
        
        dns_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to forward the DNS type Subject Alternative Names of the client cert.
       * Defaults to false.
       * </pre>
       *
       * <code>bool dns = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearDns() {
        bitField0_ = (bitField0_ & ~0x00000008);
        dns_ = false;
        onChanged();
        return this;
      }

      private boolean uri_ ;
      /**
       * <pre>
       * Whether to forward the URI type Subject Alternative Name of the client cert. Defaults to
       * false.
       * </pre>
       *
       * <code>bool uri = 5;</code>
       * @return The uri.
       */
      @java.lang.Override
      public boolean getUri() {
        return uri_;
      }
      /**
       * <pre>
       * Whether to forward the URI type Subject Alternative Name of the client cert. Defaults to
       * false.
       * </pre>
       *
       * <code>bool uri = 5;</code>
       * @param value The uri to set.
       * @return This builder for chaining.
       */
      public Builder setUri(boolean value) {
        
        uri_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to forward the URI type Subject Alternative Name of the client cert. Defaults to
       * false.
       * </pre>
       *
       * <code>bool uri = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearUri() {
        bitField0_ = (bitField0_ & ~0x00000010);
        uri_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails)
    }

    // @@protoc_insertion_point(class_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails)
    private static final io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails();
    }

    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SetCurrentClientCertDetails>
        PARSER = new com.google.protobuf.AbstractParser<SetCurrentClientCertDetails>() {
      @java.lang.Override
      public SetCurrentClientCertDetails parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SetCurrentClientCertDetails> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SetCurrentClientCertDetails> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface UpgradeConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The case-insensitive name of this upgrade, e.g. "websocket".
     * For each upgrade type present in upgrade_configs, requests with
     * Upgrade: [upgrade_type]
     * will be proxied upstream.
     * </pre>
     *
     * <code>string upgrade_type = 1;</code>
     * @return The upgradeType.
     */
    java.lang.String getUpgradeType();
    /**
     * <pre>
     * The case-insensitive name of this upgrade, e.g. "websocket".
     * For each upgrade type present in upgrade_configs, requests with
     * Upgrade: [upgrade_type]
     * will be proxied upstream.
     * </pre>
     *
     * <code>string upgrade_type = 1;</code>
     * @return The bytes for upgradeType.
     */
    com.google.protobuf.ByteString
        getUpgradeTypeBytes();

    /**
     * <pre>
     * If present, this represents the filter chain which will be created for
     * this type of upgrade. If no filters are present, the filter chain for
     * HTTP connections will be used for this upgrade type.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
     */
    java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> 
        getFiltersList();
    /**
     * <pre>
     * If present, this represents the filter chain which will be created for
     * this type of upgrade. If no filters are present, the filter chain for
     * HTTP connections will be used for this upgrade type.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
     */
    io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter getFilters(int index);
    /**
     * <pre>
     * If present, this represents the filter chain which will be created for
     * this type of upgrade. If no filters are present, the filter chain for
     * HTTP connections will be used for this upgrade type.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
     */
    int getFiltersCount();
    /**
     * <pre>
     * If present, this represents the filter chain which will be created for
     * this type of upgrade. If no filters are present, the filter chain for
     * HTTP connections will be used for this upgrade type.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
     */
    java.util.List<? extends io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder> 
        getFiltersOrBuilderList();
    /**
     * <pre>
     * If present, this represents the filter chain which will be created for
     * this type of upgrade. If no filters are present, the filter chain for
     * HTTP connections will be used for this upgrade type.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
     */
    io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder getFiltersOrBuilder(
        int index);

    /**
     * <pre>
     * Determines if upgrades are enabled or disabled by default. Defaults to true.
     * This can be overridden on a per-route basis with :ref:`cluster
     * &lt;envoy_v3_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
     * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue enabled = 3;</code>
     * @return Whether the enabled field is set.
     */
    boolean hasEnabled();
    /**
     * <pre>
     * Determines if upgrades are enabled or disabled by default. Defaults to true.
     * This can be overridden on a per-route basis with :ref:`cluster
     * &lt;envoy_v3_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
     * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue enabled = 3;</code>
     * @return The enabled.
     */
    com.google.protobuf.BoolValue getEnabled();
    /**
     * <pre>
     * Determines if upgrades are enabled or disabled by default. Defaults to true.
     * This can be overridden on a per-route basis with :ref:`cluster
     * &lt;envoy_v3_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
     * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue enabled = 3;</code>
     */
    com.google.protobuf.BoolValueOrBuilder getEnabledOrBuilder();
  }
  /**
   * <pre>
   * The configuration for HTTP upgrades.
   * For each upgrade type desired, an UpgradeConfig must be added.
   * .. warning::
   *    The current implementation of upgrade headers does not handle
   *    multi-valued upgrade headers. Support for multi-valued headers may be
   *    added in the future if needed.
   * .. warning::
   *    The current implementation of upgrade headers does not work with HTTP/2
   *    upstreams.
   * </pre>
   *
   * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig}
   */
  public static final class UpgradeConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig)
      UpgradeConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use UpgradeConfig.newBuilder() to construct.
    private UpgradeConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private UpgradeConfig() {
      upgradeType_ = "";
      filters_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new UpgradeConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_UpgradeConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_UpgradeConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder.class);
    }

    public static final int UPGRADE_TYPE_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object upgradeType_ = "";
    /**
     * <pre>
     * The case-insensitive name of this upgrade, e.g. "websocket".
     * For each upgrade type present in upgrade_configs, requests with
     * Upgrade: [upgrade_type]
     * will be proxied upstream.
     * </pre>
     *
     * <code>string upgrade_type = 1;</code>
     * @return The upgradeType.
     */
    @java.lang.Override
    public java.lang.String getUpgradeType() {
      java.lang.Object ref = upgradeType_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        upgradeType_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The case-insensitive name of this upgrade, e.g. "websocket".
     * For each upgrade type present in upgrade_configs, requests with
     * Upgrade: [upgrade_type]
     * will be proxied upstream.
     * </pre>
     *
     * <code>string upgrade_type = 1;</code>
     * @return The bytes for upgradeType.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getUpgradeTypeBytes() {
      java.lang.Object ref = upgradeType_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        upgradeType_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FILTERS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> filters_;
    /**
     * <pre>
     * If present, this represents the filter chain which will be created for
     * this type of upgrade. If no filters are present, the filter chain for
     * HTTP connections will be used for this upgrade type.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
     */
    @java.lang.Override
    public java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> getFiltersList() {
      return filters_;
    }
    /**
     * <pre>
     * If present, this represents the filter chain which will be created for
     * this type of upgrade. If no filters are present, the filter chain for
     * HTTP connections will be used for this upgrade type.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder> 
        getFiltersOrBuilderList() {
      return filters_;
    }
    /**
     * <pre>
     * If present, this represents the filter chain which will be created for
     * this type of upgrade. If no filters are present, the filter chain for
     * HTTP connections will be used for this upgrade type.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
     */
    @java.lang.Override
    public int getFiltersCount() {
      return filters_.size();
    }
    /**
     * <pre>
     * If present, this represents the filter chain which will be created for
     * this type of upgrade. If no filters are present, the filter chain for
     * HTTP connections will be used for this upgrade type.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter getFilters(int index) {
      return filters_.get(index);
    }
    /**
     * <pre>
     * If present, this represents the filter chain which will be created for
     * this type of upgrade. If no filters are present, the filter chain for
     * HTTP connections will be used for this upgrade type.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder getFiltersOrBuilder(
        int index) {
      return filters_.get(index);
    }

    public static final int ENABLED_FIELD_NUMBER = 3;
    private com.google.protobuf.BoolValue enabled_;
    /**
     * <pre>
     * Determines if upgrades are enabled or disabled by default. Defaults to true.
     * This can be overridden on a per-route basis with :ref:`cluster
     * &lt;envoy_v3_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
     * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue enabled = 3;</code>
     * @return Whether the enabled field is set.
     */
    @java.lang.Override
    public boolean hasEnabled() {
      return enabled_ != null;
    }
    /**
     * <pre>
     * Determines if upgrades are enabled or disabled by default. Defaults to true.
     * This can be overridden on a per-route basis with :ref:`cluster
     * &lt;envoy_v3_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
     * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue enabled = 3;</code>
     * @return The enabled.
     */
    @java.lang.Override
    public com.google.protobuf.BoolValue getEnabled() {
      return enabled_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : enabled_;
    }
    /**
     * <pre>
     * Determines if upgrades are enabled or disabled by default. Defaults to true.
     * This can be overridden on a per-route basis with :ref:`cluster
     * &lt;envoy_v3_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
     * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue enabled = 3;</code>
     */
    @java.lang.Override
    public com.google.protobuf.BoolValueOrBuilder getEnabledOrBuilder() {
      return enabled_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : enabled_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(upgradeType_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, upgradeType_);
      }
      for (int i = 0; i < filters_.size(); i++) {
        output.writeMessage(2, filters_.get(i));
      }
      if (enabled_ != null) {
        output.writeMessage(3, getEnabled());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(upgradeType_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, upgradeType_);
      }
      for (int i = 0; i < filters_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, filters_.get(i));
      }
      if (enabled_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getEnabled());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig other = (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig) obj;

      if (!getUpgradeType()
          .equals(other.getUpgradeType())) return false;
      if (!getFiltersList()
          .equals(other.getFiltersList())) return false;
      if (hasEnabled() != other.hasEnabled()) return false;
      if (hasEnabled()) {
        if (!getEnabled()
            .equals(other.getEnabled())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + UPGRADE_TYPE_FIELD_NUMBER;
      hash = (53 * hash) + getUpgradeType().hashCode();
      if (getFiltersCount() > 0) {
        hash = (37 * hash) + FILTERS_FIELD_NUMBER;
        hash = (53 * hash) + getFiltersList().hashCode();
      }
      if (hasEnabled()) {
        hash = (37 * hash) + ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + getEnabled().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The configuration for HTTP upgrades.
     * For each upgrade type desired, an UpgradeConfig must be added.
     * .. warning::
     *    The current implementation of upgrade headers does not handle
     *    multi-valued upgrade headers. Support for multi-valued headers may be
     *    added in the future if needed.
     * .. warning::
     *    The current implementation of upgrade headers does not work with HTTP/2
     *    upstreams.
     * </pre>
     *
     * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig)
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_UpgradeConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_UpgradeConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        upgradeType_ = "";
        if (filtersBuilder_ == null) {
          filters_ = java.util.Collections.emptyList();
        } else {
          filters_ = null;
          filtersBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        enabled_ = null;
        if (enabledBuilder_ != null) {
          enabledBuilder_.dispose();
          enabledBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_UpgradeConfig_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig getDefaultInstanceForType() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig build() {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig buildPartial() {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig result = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig result) {
        if (filtersBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            filters_ = java.util.Collections.unmodifiableList(filters_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.filters_ = filters_;
        } else {
          result.filters_ = filtersBuilder_.build();
        }
      }

      private void buildPartial0(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.upgradeType_ = upgradeType_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.enabled_ = enabledBuilder_ == null
              ? enabled_
              : enabledBuilder_.build();
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig) {
          return mergeFrom((io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig other) {
        if (other == io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.getDefaultInstance()) return this;
        if (!other.getUpgradeType().isEmpty()) {
          upgradeType_ = other.upgradeType_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (filtersBuilder_ == null) {
          if (!other.filters_.isEmpty()) {
            if (filters_.isEmpty()) {
              filters_ = other.filters_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureFiltersIsMutable();
              filters_.addAll(other.filters_);
            }
            onChanged();
          }
        } else {
          if (!other.filters_.isEmpty()) {
            if (filtersBuilder_.isEmpty()) {
              filtersBuilder_.dispose();
              filtersBuilder_ = null;
              filters_ = other.filters_;
              bitField0_ = (bitField0_ & ~0x00000002);
              filtersBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getFiltersFieldBuilder() : null;
            } else {
              filtersBuilder_.addAllMessages(other.filters_);
            }
          }
        }
        if (other.hasEnabled()) {
          mergeEnabled(other.getEnabled());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                upgradeType_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter m =
                    input.readMessage(
                        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.parser(),
                        extensionRegistry);
                if (filtersBuilder_ == null) {
                  ensureFiltersIsMutable();
                  filters_.add(m);
                } else {
                  filtersBuilder_.addMessage(m);
                }
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getEnabledFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object upgradeType_ = "";
      /**
       * <pre>
       * The case-insensitive name of this upgrade, e.g. "websocket".
       * For each upgrade type present in upgrade_configs, requests with
       * Upgrade: [upgrade_type]
       * will be proxied upstream.
       * </pre>
       *
       * <code>string upgrade_type = 1;</code>
       * @return The upgradeType.
       */
      public java.lang.String getUpgradeType() {
        java.lang.Object ref = upgradeType_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          upgradeType_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The case-insensitive name of this upgrade, e.g. "websocket".
       * For each upgrade type present in upgrade_configs, requests with
       * Upgrade: [upgrade_type]
       * will be proxied upstream.
       * </pre>
       *
       * <code>string upgrade_type = 1;</code>
       * @return The bytes for upgradeType.
       */
      public com.google.protobuf.ByteString
          getUpgradeTypeBytes() {
        java.lang.Object ref = upgradeType_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          upgradeType_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The case-insensitive name of this upgrade, e.g. "websocket".
       * For each upgrade type present in upgrade_configs, requests with
       * Upgrade: [upgrade_type]
       * will be proxied upstream.
       * </pre>
       *
       * <code>string upgrade_type = 1;</code>
       * @param value The upgradeType to set.
       * @return This builder for chaining.
       */
      public Builder setUpgradeType(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        upgradeType_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The case-insensitive name of this upgrade, e.g. "websocket".
       * For each upgrade type present in upgrade_configs, requests with
       * Upgrade: [upgrade_type]
       * will be proxied upstream.
       * </pre>
       *
       * <code>string upgrade_type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearUpgradeType() {
        upgradeType_ = getDefaultInstance().getUpgradeType();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The case-insensitive name of this upgrade, e.g. "websocket".
       * For each upgrade type present in upgrade_configs, requests with
       * Upgrade: [upgrade_type]
       * will be proxied upstream.
       * </pre>
       *
       * <code>string upgrade_type = 1;</code>
       * @param value The bytes for upgradeType to set.
       * @return This builder for chaining.
       */
      public Builder setUpgradeTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        upgradeType_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> filters_ =
        java.util.Collections.emptyList();
      private void ensureFiltersIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          filters_ = new java.util.ArrayList<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter>(filters_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder> filtersBuilder_;

      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> getFiltersList() {
        if (filtersBuilder_ == null) {
          return java.util.Collections.unmodifiableList(filters_);
        } else {
          return filtersBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public int getFiltersCount() {
        if (filtersBuilder_ == null) {
          return filters_.size();
        } else {
          return filtersBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter getFilters(int index) {
        if (filtersBuilder_ == null) {
          return filters_.get(index);
        } else {
          return filtersBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public Builder setFilters(
          int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter value) {
        if (filtersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureFiltersIsMutable();
          filters_.set(index, value);
          onChanged();
        } else {
          filtersBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public Builder setFilters(
          int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder builderForValue) {
        if (filtersBuilder_ == null) {
          ensureFiltersIsMutable();
          filters_.set(index, builderForValue.build());
          onChanged();
        } else {
          filtersBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public Builder addFilters(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter value) {
        if (filtersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureFiltersIsMutable();
          filters_.add(value);
          onChanged();
        } else {
          filtersBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public Builder addFilters(
          int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter value) {
        if (filtersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureFiltersIsMutable();
          filters_.add(index, value);
          onChanged();
        } else {
          filtersBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public Builder addFilters(
          io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder builderForValue) {
        if (filtersBuilder_ == null) {
          ensureFiltersIsMutable();
          filters_.add(builderForValue.build());
          onChanged();
        } else {
          filtersBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public Builder addFilters(
          int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder builderForValue) {
        if (filtersBuilder_ == null) {
          ensureFiltersIsMutable();
          filters_.add(index, builderForValue.build());
          onChanged();
        } else {
          filtersBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public Builder addAllFilters(
          java.lang.Iterable<? extends io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> values) {
        if (filtersBuilder_ == null) {
          ensureFiltersIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, filters_);
          onChanged();
        } else {
          filtersBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public Builder clearFilters() {
        if (filtersBuilder_ == null) {
          filters_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          filtersBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public Builder removeFilters(int index) {
        if (filtersBuilder_ == null) {
          ensureFiltersIsMutable();
          filters_.remove(index);
          onChanged();
        } else {
          filtersBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder getFiltersBuilder(
          int index) {
        return getFiltersFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder getFiltersOrBuilder(
          int index) {
        if (filtersBuilder_ == null) {
          return filters_.get(index);  } else {
          return filtersBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public java.util.List<? extends io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder> 
           getFiltersOrBuilderList() {
        if (filtersBuilder_ != null) {
          return filtersBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(filters_);
        }
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder addFiltersBuilder() {
        return getFiltersFieldBuilder().addBuilder(
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.getDefaultInstance());
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder addFiltersBuilder(
          int index) {
        return getFiltersFieldBuilder().addBuilder(
            index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.getDefaultInstance());
      }
      /**
       * <pre>
       * If present, this represents the filter chain which will be created for
       * this type of upgrade. If no filters are present, the filter chain for
       * HTTP connections will be used for this upgrade type.
       * </pre>
       *
       * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;</code>
       */
      public java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder> 
           getFiltersBuilderList() {
        return getFiltersFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder> 
          getFiltersFieldBuilder() {
        if (filtersBuilder_ == null) {
          filtersBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder>(
                  filters_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          filters_ = null;
        }
        return filtersBuilder_;
      }

      private com.google.protobuf.BoolValue enabled_;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> enabledBuilder_;
      /**
       * <pre>
       * Determines if upgrades are enabled or disabled by default. Defaults to true.
       * This can be overridden on a per-route basis with :ref:`cluster
       * &lt;envoy_v3_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
       * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue enabled = 3;</code>
       * @return Whether the enabled field is set.
       */
      public boolean hasEnabled() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Determines if upgrades are enabled or disabled by default. Defaults to true.
       * This can be overridden on a per-route basis with :ref:`cluster
       * &lt;envoy_v3_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
       * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue enabled = 3;</code>
       * @return The enabled.
       */
      public com.google.protobuf.BoolValue getEnabled() {
        if (enabledBuilder_ == null) {
          return enabled_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : enabled_;
        } else {
          return enabledBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Determines if upgrades are enabled or disabled by default. Defaults to true.
       * This can be overridden on a per-route basis with :ref:`cluster
       * &lt;envoy_v3_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
       * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue enabled = 3;</code>
       */
      public Builder setEnabled(com.google.protobuf.BoolValue value) {
        if (enabledBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          enabled_ = value;
        } else {
          enabledBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Determines if upgrades are enabled or disabled by default. Defaults to true.
       * This can be overridden on a per-route basis with :ref:`cluster
       * &lt;envoy_v3_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
       * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue enabled = 3;</code>
       */
      public Builder setEnabled(
          com.google.protobuf.BoolValue.Builder builderForValue) {
        if (enabledBuilder_ == null) {
          enabled_ = builderForValue.build();
        } else {
          enabledBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Determines if upgrades are enabled or disabled by default. Defaults to true.
       * This can be overridden on a per-route basis with :ref:`cluster
       * &lt;envoy_v3_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
       * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue enabled = 3;</code>
       */
      public Builder mergeEnabled(com.google.protobuf.BoolValue value) {
        if (enabledBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            enabled_ != null &&
            enabled_ != com.google.protobuf.BoolValue.getDefaultInstance()) {
            getEnabledBuilder().mergeFrom(value);
          } else {
            enabled_ = value;
          }
        } else {
          enabledBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Determines if upgrades are enabled or disabled by default. Defaults to true.
       * This can be overridden on a per-route basis with :ref:`cluster
       * &lt;envoy_v3_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
       * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue enabled = 3;</code>
       */
      public Builder clearEnabled() {
        bitField0_ = (bitField0_ & ~0x00000004);
        enabled_ = null;
        if (enabledBuilder_ != null) {
          enabledBuilder_.dispose();
          enabledBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Determines if upgrades are enabled or disabled by default. Defaults to true.
       * This can be overridden on a per-route basis with :ref:`cluster
       * &lt;envoy_v3_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
       * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue enabled = 3;</code>
       */
      public com.google.protobuf.BoolValue.Builder getEnabledBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getEnabledFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Determines if upgrades are enabled or disabled by default. Defaults to true.
       * This can be overridden on a per-route basis with :ref:`cluster
       * &lt;envoy_v3_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
       * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue enabled = 3;</code>
       */
      public com.google.protobuf.BoolValueOrBuilder getEnabledOrBuilder() {
        if (enabledBuilder_ != null) {
          return enabledBuilder_.getMessageOrBuilder();
        } else {
          return enabled_ == null ?
              com.google.protobuf.BoolValue.getDefaultInstance() : enabled_;
        }
      }
      /**
       * <pre>
       * Determines if upgrades are enabled or disabled by default. Defaults to true.
       * This can be overridden on a per-route basis with :ref:`cluster
       * &lt;envoy_v3_api_field_config.route.v3.RouteAction.upgrade_configs&gt;` as documented in the
       * :ref:`upgrade documentation &lt;arch_overview_upgrades&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue enabled = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
          getEnabledFieldBuilder() {
        if (enabledBuilder_ == null) {
          enabledBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                  getEnabled(),
                  getParentForChildren(),
                  isClean());
          enabled_ = null;
        }
        return enabledBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig)
    }

    // @@protoc_insertion_point(class_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig)
    private static final io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig();
    }

    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<UpgradeConfig>
        PARSER = new com.google.protobuf.AbstractParser<UpgradeConfig>() {
      @java.lang.Override
      public UpgradeConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<UpgradeConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<UpgradeConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PathNormalizationOptionsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * [#not-implemented-hide:] Normalization applies internally before any processing of requests by
     * HTTP filters, routing, and matching *and* will affect the forwarded ``:path`` header. Defaults
     * to :ref:`NormalizePathRFC3986
     * &lt;envoy_v3_api_msg_type.http.v3.PathTransformation.Operation.NormalizePathRFC3986&gt;`. When not
     * specified, this value may be overridden by the runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * Envoy will respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
     * normalization due to disallowed characters.)
     * </pre>
     *
     * <code>.envoy.type.http.v3.PathTransformation forwarding_transformation = 1;</code>
     * @return Whether the forwardingTransformation field is set.
     */
    boolean hasForwardingTransformation();
    /**
     * <pre>
     * [#not-implemented-hide:] Normalization applies internally before any processing of requests by
     * HTTP filters, routing, and matching *and* will affect the forwarded ``:path`` header. Defaults
     * to :ref:`NormalizePathRFC3986
     * &lt;envoy_v3_api_msg_type.http.v3.PathTransformation.Operation.NormalizePathRFC3986&gt;`. When not
     * specified, this value may be overridden by the runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * Envoy will respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
     * normalization due to disallowed characters.)
     * </pre>
     *
     * <code>.envoy.type.http.v3.PathTransformation forwarding_transformation = 1;</code>
     * @return The forwardingTransformation.
     */
    io.envoyproxy.envoy.type.http.v3.PathTransformation getForwardingTransformation();
    /**
     * <pre>
     * [#not-implemented-hide:] Normalization applies internally before any processing of requests by
     * HTTP filters, routing, and matching *and* will affect the forwarded ``:path`` header. Defaults
     * to :ref:`NormalizePathRFC3986
     * &lt;envoy_v3_api_msg_type.http.v3.PathTransformation.Operation.NormalizePathRFC3986&gt;`. When not
     * specified, this value may be overridden by the runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * Envoy will respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
     * normalization due to disallowed characters.)
     * </pre>
     *
     * <code>.envoy.type.http.v3.PathTransformation forwarding_transformation = 1;</code>
     */
    io.envoyproxy.envoy.type.http.v3.PathTransformationOrBuilder getForwardingTransformationOrBuilder();

    /**
     * <pre>
     * [#not-implemented-hide:] Normalization only applies internally before any processing of
     * requests by HTTP filters, routing, and matching. These will be applied after full
     * transformation is applied. The ``:path`` header before this transformation will be restored in
     * the router filter and sent upstream unless it was mutated by a filter. Defaults to no
     * transformations.
     * Multiple actions can be applied in the same Transformation, forming a sequential
     * pipeline. The transformations will be performed in the order that they appear. Envoy will
     * respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
     * normalization due to disallowed characters.)
     * </pre>
     *
     * <code>.envoy.type.http.v3.PathTransformation http_filter_transformation = 2;</code>
     * @return Whether the httpFilterTransformation field is set.
     */
    boolean hasHttpFilterTransformation();
    /**
     * <pre>
     * [#not-implemented-hide:] Normalization only applies internally before any processing of
     * requests by HTTP filters, routing, and matching. These will be applied after full
     * transformation is applied. The ``:path`` header before this transformation will be restored in
     * the router filter and sent upstream unless it was mutated by a filter. Defaults to no
     * transformations.
     * Multiple actions can be applied in the same Transformation, forming a sequential
     * pipeline. The transformations will be performed in the order that they appear. Envoy will
     * respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
     * normalization due to disallowed characters.)
     * </pre>
     *
     * <code>.envoy.type.http.v3.PathTransformation http_filter_transformation = 2;</code>
     * @return The httpFilterTransformation.
     */
    io.envoyproxy.envoy.type.http.v3.PathTransformation getHttpFilterTransformation();
    /**
     * <pre>
     * [#not-implemented-hide:] Normalization only applies internally before any processing of
     * requests by HTTP filters, routing, and matching. These will be applied after full
     * transformation is applied. The ``:path`` header before this transformation will be restored in
     * the router filter and sent upstream unless it was mutated by a filter. Defaults to no
     * transformations.
     * Multiple actions can be applied in the same Transformation, forming a sequential
     * pipeline. The transformations will be performed in the order that they appear. Envoy will
     * respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
     * normalization due to disallowed characters.)
     * </pre>
     *
     * <code>.envoy.type.http.v3.PathTransformation http_filter_transformation = 2;</code>
     */
    io.envoyproxy.envoy.type.http.v3.PathTransformationOrBuilder getHttpFilterTransformationOrBuilder();
  }
  /**
   * <pre>
   * [#not-implemented-hide:] Transformations that apply to path headers. Transformations are applied
   * before any processing of requests by HTTP filters, routing, and matching. Only the normalized
   * path will be visible internally if a transformation is enabled. Any path rewrites that the
   * router performs (e.g. :ref:`regex_rewrite
   * &lt;envoy_v3_api_field_config.route.v3.RouteAction.regex_rewrite&gt;` or :ref:`prefix_rewrite
   * &lt;envoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite&gt;`) will apply to the ``:path`` header
   * destined for the upstream.
   * Note: access logging and tracing will show the original ``:path`` header.
   * </pre>
   *
   * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions}
   */
  public static final class PathNormalizationOptions extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions)
      PathNormalizationOptionsOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PathNormalizationOptions.newBuilder() to construct.
    private PathNormalizationOptions(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PathNormalizationOptions() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new PathNormalizationOptions();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_PathNormalizationOptions_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_PathNormalizationOptions_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions.Builder.class);
    }

    public static final int FORWARDING_TRANSFORMATION_FIELD_NUMBER = 1;
    private io.envoyproxy.envoy.type.http.v3.PathTransformation forwardingTransformation_;
    /**
     * <pre>
     * [#not-implemented-hide:] Normalization applies internally before any processing of requests by
     * HTTP filters, routing, and matching *and* will affect the forwarded ``:path`` header. Defaults
     * to :ref:`NormalizePathRFC3986
     * &lt;envoy_v3_api_msg_type.http.v3.PathTransformation.Operation.NormalizePathRFC3986&gt;`. When not
     * specified, this value may be overridden by the runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * Envoy will respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
     * normalization due to disallowed characters.)
     * </pre>
     *
     * <code>.envoy.type.http.v3.PathTransformation forwarding_transformation = 1;</code>
     * @return Whether the forwardingTransformation field is set.
     */
    @java.lang.Override
    public boolean hasForwardingTransformation() {
      return forwardingTransformation_ != null;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Normalization applies internally before any processing of requests by
     * HTTP filters, routing, and matching *and* will affect the forwarded ``:path`` header. Defaults
     * to :ref:`NormalizePathRFC3986
     * &lt;envoy_v3_api_msg_type.http.v3.PathTransformation.Operation.NormalizePathRFC3986&gt;`. When not
     * specified, this value may be overridden by the runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * Envoy will respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
     * normalization due to disallowed characters.)
     * </pre>
     *
     * <code>.envoy.type.http.v3.PathTransformation forwarding_transformation = 1;</code>
     * @return The forwardingTransformation.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.http.v3.PathTransformation getForwardingTransformation() {
      return forwardingTransformation_ == null ? io.envoyproxy.envoy.type.http.v3.PathTransformation.getDefaultInstance() : forwardingTransformation_;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Normalization applies internally before any processing of requests by
     * HTTP filters, routing, and matching *and* will affect the forwarded ``:path`` header. Defaults
     * to :ref:`NormalizePathRFC3986
     * &lt;envoy_v3_api_msg_type.http.v3.PathTransformation.Operation.NormalizePathRFC3986&gt;`. When not
     * specified, this value may be overridden by the runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * Envoy will respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
     * normalization due to disallowed characters.)
     * </pre>
     *
     * <code>.envoy.type.http.v3.PathTransformation forwarding_transformation = 1;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.http.v3.PathTransformationOrBuilder getForwardingTransformationOrBuilder() {
      return forwardingTransformation_ == null ? io.envoyproxy.envoy.type.http.v3.PathTransformation.getDefaultInstance() : forwardingTransformation_;
    }

    public static final int HTTP_FILTER_TRANSFORMATION_FIELD_NUMBER = 2;
    private io.envoyproxy.envoy.type.http.v3.PathTransformation httpFilterTransformation_;
    /**
     * <pre>
     * [#not-implemented-hide:] Normalization only applies internally before any processing of
     * requests by HTTP filters, routing, and matching. These will be applied after full
     * transformation is applied. The ``:path`` header before this transformation will be restored in
     * the router filter and sent upstream unless it was mutated by a filter. Defaults to no
     * transformations.
     * Multiple actions can be applied in the same Transformation, forming a sequential
     * pipeline. The transformations will be performed in the order that they appear. Envoy will
     * respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
     * normalization due to disallowed characters.)
     * </pre>
     *
     * <code>.envoy.type.http.v3.PathTransformation http_filter_transformation = 2;</code>
     * @return Whether the httpFilterTransformation field is set.
     */
    @java.lang.Override
    public boolean hasHttpFilterTransformation() {
      return httpFilterTransformation_ != null;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Normalization only applies internally before any processing of
     * requests by HTTP filters, routing, and matching. These will be applied after full
     * transformation is applied. The ``:path`` header before this transformation will be restored in
     * the router filter and sent upstream unless it was mutated by a filter. Defaults to no
     * transformations.
     * Multiple actions can be applied in the same Transformation, forming a sequential
     * pipeline. The transformations will be performed in the order that they appear. Envoy will
     * respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
     * normalization due to disallowed characters.)
     * </pre>
     *
     * <code>.envoy.type.http.v3.PathTransformation http_filter_transformation = 2;</code>
     * @return The httpFilterTransformation.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.http.v3.PathTransformation getHttpFilterTransformation() {
      return httpFilterTransformation_ == null ? io.envoyproxy.envoy.type.http.v3.PathTransformation.getDefaultInstance() : httpFilterTransformation_;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Normalization only applies internally before any processing of
     * requests by HTTP filters, routing, and matching. These will be applied after full
     * transformation is applied. The ``:path`` header before this transformation will be restored in
     * the router filter and sent upstream unless it was mutated by a filter. Defaults to no
     * transformations.
     * Multiple actions can be applied in the same Transformation, forming a sequential
     * pipeline. The transformations will be performed in the order that they appear. Envoy will
     * respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
     * normalization due to disallowed characters.)
     * </pre>
     *
     * <code>.envoy.type.http.v3.PathTransformation http_filter_transformation = 2;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.type.http.v3.PathTransformationOrBuilder getHttpFilterTransformationOrBuilder() {
      return httpFilterTransformation_ == null ? io.envoyproxy.envoy.type.http.v3.PathTransformation.getDefaultInstance() : httpFilterTransformation_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (forwardingTransformation_ != null) {
        output.writeMessage(1, getForwardingTransformation());
      }
      if (httpFilterTransformation_ != null) {
        output.writeMessage(2, getHttpFilterTransformation());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (forwardingTransformation_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getForwardingTransformation());
      }
      if (httpFilterTransformation_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getHttpFilterTransformation());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions other = (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions) obj;

      if (hasForwardingTransformation() != other.hasForwardingTransformation()) return false;
      if (hasForwardingTransformation()) {
        if (!getForwardingTransformation()
            .equals(other.getForwardingTransformation())) return false;
      }
      if (hasHttpFilterTransformation() != other.hasHttpFilterTransformation()) return false;
      if (hasHttpFilterTransformation()) {
        if (!getHttpFilterTransformation()
            .equals(other.getHttpFilterTransformation())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasForwardingTransformation()) {
        hash = (37 * hash) + FORWARDING_TRANSFORMATION_FIELD_NUMBER;
        hash = (53 * hash) + getForwardingTransformation().hashCode();
      }
      if (hasHttpFilterTransformation()) {
        hash = (37 * hash) + HTTP_FILTER_TRANSFORMATION_FIELD_NUMBER;
        hash = (53 * hash) + getHttpFilterTransformation().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Transformations that apply to path headers. Transformations are applied
     * before any processing of requests by HTTP filters, routing, and matching. Only the normalized
     * path will be visible internally if a transformation is enabled. Any path rewrites that the
     * router performs (e.g. :ref:`regex_rewrite
     * &lt;envoy_v3_api_field_config.route.v3.RouteAction.regex_rewrite&gt;` or :ref:`prefix_rewrite
     * &lt;envoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite&gt;`) will apply to the ``:path`` header
     * destined for the upstream.
     * Note: access logging and tracing will show the original ``:path`` header.
     * </pre>
     *
     * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions)
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptionsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_PathNormalizationOptions_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_PathNormalizationOptions_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        forwardingTransformation_ = null;
        if (forwardingTransformationBuilder_ != null) {
          forwardingTransformationBuilder_.dispose();
          forwardingTransformationBuilder_ = null;
        }
        httpFilterTransformation_ = null;
        if (httpFilterTransformationBuilder_ != null) {
          httpFilterTransformationBuilder_.dispose();
          httpFilterTransformationBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_PathNormalizationOptions_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions getDefaultInstanceForType() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions build() {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions buildPartial() {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions result = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.forwardingTransformation_ = forwardingTransformationBuilder_ == null
              ? forwardingTransformation_
              : forwardingTransformationBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.httpFilterTransformation_ = httpFilterTransformationBuilder_ == null
              ? httpFilterTransformation_
              : httpFilterTransformationBuilder_.build();
        }
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions) {
          return mergeFrom((io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions other) {
        if (other == io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions.getDefaultInstance()) return this;
        if (other.hasForwardingTransformation()) {
          mergeForwardingTransformation(other.getForwardingTransformation());
        }
        if (other.hasHttpFilterTransformation()) {
          mergeHttpFilterTransformation(other.getHttpFilterTransformation());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    getForwardingTransformationFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    getHttpFilterTransformationFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private io.envoyproxy.envoy.type.http.v3.PathTransformation forwardingTransformation_;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.type.http.v3.PathTransformation, io.envoyproxy.envoy.type.http.v3.PathTransformation.Builder, io.envoyproxy.envoy.type.http.v3.PathTransformationOrBuilder> forwardingTransformationBuilder_;
      /**
       * <pre>
       * [#not-implemented-hide:] Normalization applies internally before any processing of requests by
       * HTTP filters, routing, and matching *and* will affect the forwarded ``:path`` header. Defaults
       * to :ref:`NormalizePathRFC3986
       * &lt;envoy_v3_api_msg_type.http.v3.PathTransformation.Operation.NormalizePathRFC3986&gt;`. When not
       * specified, this value may be overridden by the runtime variable
       * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
       * Envoy will respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
       * normalization due to disallowed characters.)
       * </pre>
       *
       * <code>.envoy.type.http.v3.PathTransformation forwarding_transformation = 1;</code>
       * @return Whether the forwardingTransformation field is set.
       */
      public boolean hasForwardingTransformation() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Normalization applies internally before any processing of requests by
       * HTTP filters, routing, and matching *and* will affect the forwarded ``:path`` header. Defaults
       * to :ref:`NormalizePathRFC3986
       * &lt;envoy_v3_api_msg_type.http.v3.PathTransformation.Operation.NormalizePathRFC3986&gt;`. When not
       * specified, this value may be overridden by the runtime variable
       * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
       * Envoy will respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
       * normalization due to disallowed characters.)
       * </pre>
       *
       * <code>.envoy.type.http.v3.PathTransformation forwarding_transformation = 1;</code>
       * @return The forwardingTransformation.
       */
      public io.envoyproxy.envoy.type.http.v3.PathTransformation getForwardingTransformation() {
        if (forwardingTransformationBuilder_ == null) {
          return forwardingTransformation_ == null ? io.envoyproxy.envoy.type.http.v3.PathTransformation.getDefaultInstance() : forwardingTransformation_;
        } else {
          return forwardingTransformationBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Normalization applies internally before any processing of requests by
       * HTTP filters, routing, and matching *and* will affect the forwarded ``:path`` header. Defaults
       * to :ref:`NormalizePathRFC3986
       * &lt;envoy_v3_api_msg_type.http.v3.PathTransformation.Operation.NormalizePathRFC3986&gt;`. When not
       * specified, this value may be overridden by the runtime variable
       * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
       * Envoy will respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
       * normalization due to disallowed characters.)
       * </pre>
       *
       * <code>.envoy.type.http.v3.PathTransformation forwarding_transformation = 1;</code>
       */
      public Builder setForwardingTransformation(io.envoyproxy.envoy.type.http.v3.PathTransformation value) {
        if (forwardingTransformationBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          forwardingTransformation_ = value;
        } else {
          forwardingTransformationBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Normalization applies internally before any processing of requests by
       * HTTP filters, routing, and matching *and* will affect the forwarded ``:path`` header. Defaults
       * to :ref:`NormalizePathRFC3986
       * &lt;envoy_v3_api_msg_type.http.v3.PathTransformation.Operation.NormalizePathRFC3986&gt;`. When not
       * specified, this value may be overridden by the runtime variable
       * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
       * Envoy will respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
       * normalization due to disallowed characters.)
       * </pre>
       *
       * <code>.envoy.type.http.v3.PathTransformation forwarding_transformation = 1;</code>
       */
      public Builder setForwardingTransformation(
          io.envoyproxy.envoy.type.http.v3.PathTransformation.Builder builderForValue) {
        if (forwardingTransformationBuilder_ == null) {
          forwardingTransformation_ = builderForValue.build();
        } else {
          forwardingTransformationBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Normalization applies internally before any processing of requests by
       * HTTP filters, routing, and matching *and* will affect the forwarded ``:path`` header. Defaults
       * to :ref:`NormalizePathRFC3986
       * &lt;envoy_v3_api_msg_type.http.v3.PathTransformation.Operation.NormalizePathRFC3986&gt;`. When not
       * specified, this value may be overridden by the runtime variable
       * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
       * Envoy will respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
       * normalization due to disallowed characters.)
       * </pre>
       *
       * <code>.envoy.type.http.v3.PathTransformation forwarding_transformation = 1;</code>
       */
      public Builder mergeForwardingTransformation(io.envoyproxy.envoy.type.http.v3.PathTransformation value) {
        if (forwardingTransformationBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            forwardingTransformation_ != null &&
            forwardingTransformation_ != io.envoyproxy.envoy.type.http.v3.PathTransformation.getDefaultInstance()) {
            getForwardingTransformationBuilder().mergeFrom(value);
          } else {
            forwardingTransformation_ = value;
          }
        } else {
          forwardingTransformationBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Normalization applies internally before any processing of requests by
       * HTTP filters, routing, and matching *and* will affect the forwarded ``:path`` header. Defaults
       * to :ref:`NormalizePathRFC3986
       * &lt;envoy_v3_api_msg_type.http.v3.PathTransformation.Operation.NormalizePathRFC3986&gt;`. When not
       * specified, this value may be overridden by the runtime variable
       * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
       * Envoy will respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
       * normalization due to disallowed characters.)
       * </pre>
       *
       * <code>.envoy.type.http.v3.PathTransformation forwarding_transformation = 1;</code>
       */
      public Builder clearForwardingTransformation() {
        bitField0_ = (bitField0_ & ~0x00000001);
        forwardingTransformation_ = null;
        if (forwardingTransformationBuilder_ != null) {
          forwardingTransformationBuilder_.dispose();
          forwardingTransformationBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Normalization applies internally before any processing of requests by
       * HTTP filters, routing, and matching *and* will affect the forwarded ``:path`` header. Defaults
       * to :ref:`NormalizePathRFC3986
       * &lt;envoy_v3_api_msg_type.http.v3.PathTransformation.Operation.NormalizePathRFC3986&gt;`. When not
       * specified, this value may be overridden by the runtime variable
       * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
       * Envoy will respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
       * normalization due to disallowed characters.)
       * </pre>
       *
       * <code>.envoy.type.http.v3.PathTransformation forwarding_transformation = 1;</code>
       */
      public io.envoyproxy.envoy.type.http.v3.PathTransformation.Builder getForwardingTransformationBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getForwardingTransformationFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Normalization applies internally before any processing of requests by
       * HTTP filters, routing, and matching *and* will affect the forwarded ``:path`` header. Defaults
       * to :ref:`NormalizePathRFC3986
       * &lt;envoy_v3_api_msg_type.http.v3.PathTransformation.Operation.NormalizePathRFC3986&gt;`. When not
       * specified, this value may be overridden by the runtime variable
       * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
       * Envoy will respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
       * normalization due to disallowed characters.)
       * </pre>
       *
       * <code>.envoy.type.http.v3.PathTransformation forwarding_transformation = 1;</code>
       */
      public io.envoyproxy.envoy.type.http.v3.PathTransformationOrBuilder getForwardingTransformationOrBuilder() {
        if (forwardingTransformationBuilder_ != null) {
          return forwardingTransformationBuilder_.getMessageOrBuilder();
        } else {
          return forwardingTransformation_ == null ?
              io.envoyproxy.envoy.type.http.v3.PathTransformation.getDefaultInstance() : forwardingTransformation_;
        }
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Normalization applies internally before any processing of requests by
       * HTTP filters, routing, and matching *and* will affect the forwarded ``:path`` header. Defaults
       * to :ref:`NormalizePathRFC3986
       * &lt;envoy_v3_api_msg_type.http.v3.PathTransformation.Operation.NormalizePathRFC3986&gt;`. When not
       * specified, this value may be overridden by the runtime variable
       * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
       * Envoy will respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
       * normalization due to disallowed characters.)
       * </pre>
       *
       * <code>.envoy.type.http.v3.PathTransformation forwarding_transformation = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.type.http.v3.PathTransformation, io.envoyproxy.envoy.type.http.v3.PathTransformation.Builder, io.envoyproxy.envoy.type.http.v3.PathTransformationOrBuilder> 
          getForwardingTransformationFieldBuilder() {
        if (forwardingTransformationBuilder_ == null) {
          forwardingTransformationBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.envoyproxy.envoy.type.http.v3.PathTransformation, io.envoyproxy.envoy.type.http.v3.PathTransformation.Builder, io.envoyproxy.envoy.type.http.v3.PathTransformationOrBuilder>(
                  getForwardingTransformation(),
                  getParentForChildren(),
                  isClean());
          forwardingTransformation_ = null;
        }
        return forwardingTransformationBuilder_;
      }

      private io.envoyproxy.envoy.type.http.v3.PathTransformation httpFilterTransformation_;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.type.http.v3.PathTransformation, io.envoyproxy.envoy.type.http.v3.PathTransformation.Builder, io.envoyproxy.envoy.type.http.v3.PathTransformationOrBuilder> httpFilterTransformationBuilder_;
      /**
       * <pre>
       * [#not-implemented-hide:] Normalization only applies internally before any processing of
       * requests by HTTP filters, routing, and matching. These will be applied after full
       * transformation is applied. The ``:path`` header before this transformation will be restored in
       * the router filter and sent upstream unless it was mutated by a filter. Defaults to no
       * transformations.
       * Multiple actions can be applied in the same Transformation, forming a sequential
       * pipeline. The transformations will be performed in the order that they appear. Envoy will
       * respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
       * normalization due to disallowed characters.)
       * </pre>
       *
       * <code>.envoy.type.http.v3.PathTransformation http_filter_transformation = 2;</code>
       * @return Whether the httpFilterTransformation field is set.
       */
      public boolean hasHttpFilterTransformation() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Normalization only applies internally before any processing of
       * requests by HTTP filters, routing, and matching. These will be applied after full
       * transformation is applied. The ``:path`` header before this transformation will be restored in
       * the router filter and sent upstream unless it was mutated by a filter. Defaults to no
       * transformations.
       * Multiple actions can be applied in the same Transformation, forming a sequential
       * pipeline. The transformations will be performed in the order that they appear. Envoy will
       * respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
       * normalization due to disallowed characters.)
       * </pre>
       *
       * <code>.envoy.type.http.v3.PathTransformation http_filter_transformation = 2;</code>
       * @return The httpFilterTransformation.
       */
      public io.envoyproxy.envoy.type.http.v3.PathTransformation getHttpFilterTransformation() {
        if (httpFilterTransformationBuilder_ == null) {
          return httpFilterTransformation_ == null ? io.envoyproxy.envoy.type.http.v3.PathTransformation.getDefaultInstance() : httpFilterTransformation_;
        } else {
          return httpFilterTransformationBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Normalization only applies internally before any processing of
       * requests by HTTP filters, routing, and matching. These will be applied after full
       * transformation is applied. The ``:path`` header before this transformation will be restored in
       * the router filter and sent upstream unless it was mutated by a filter. Defaults to no
       * transformations.
       * Multiple actions can be applied in the same Transformation, forming a sequential
       * pipeline. The transformations will be performed in the order that they appear. Envoy will
       * respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
       * normalization due to disallowed characters.)
       * </pre>
       *
       * <code>.envoy.type.http.v3.PathTransformation http_filter_transformation = 2;</code>
       */
      public Builder setHttpFilterTransformation(io.envoyproxy.envoy.type.http.v3.PathTransformation value) {
        if (httpFilterTransformationBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          httpFilterTransformation_ = value;
        } else {
          httpFilterTransformationBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Normalization only applies internally before any processing of
       * requests by HTTP filters, routing, and matching. These will be applied after full
       * transformation is applied. The ``:path`` header before this transformation will be restored in
       * the router filter and sent upstream unless it was mutated by a filter. Defaults to no
       * transformations.
       * Multiple actions can be applied in the same Transformation, forming a sequential
       * pipeline. The transformations will be performed in the order that they appear. Envoy will
       * respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
       * normalization due to disallowed characters.)
       * </pre>
       *
       * <code>.envoy.type.http.v3.PathTransformation http_filter_transformation = 2;</code>
       */
      public Builder setHttpFilterTransformation(
          io.envoyproxy.envoy.type.http.v3.PathTransformation.Builder builderForValue) {
        if (httpFilterTransformationBuilder_ == null) {
          httpFilterTransformation_ = builderForValue.build();
        } else {
          httpFilterTransformationBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Normalization only applies internally before any processing of
       * requests by HTTP filters, routing, and matching. These will be applied after full
       * transformation is applied. The ``:path`` header before this transformation will be restored in
       * the router filter and sent upstream unless it was mutated by a filter. Defaults to no
       * transformations.
       * Multiple actions can be applied in the same Transformation, forming a sequential
       * pipeline. The transformations will be performed in the order that they appear. Envoy will
       * respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
       * normalization due to disallowed characters.)
       * </pre>
       *
       * <code>.envoy.type.http.v3.PathTransformation http_filter_transformation = 2;</code>
       */
      public Builder mergeHttpFilterTransformation(io.envoyproxy.envoy.type.http.v3.PathTransformation value) {
        if (httpFilterTransformationBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            httpFilterTransformation_ != null &&
            httpFilterTransformation_ != io.envoyproxy.envoy.type.http.v3.PathTransformation.getDefaultInstance()) {
            getHttpFilterTransformationBuilder().mergeFrom(value);
          } else {
            httpFilterTransformation_ = value;
          }
        } else {
          httpFilterTransformationBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Normalization only applies internally before any processing of
       * requests by HTTP filters, routing, and matching. These will be applied after full
       * transformation is applied. The ``:path`` header before this transformation will be restored in
       * the router filter and sent upstream unless it was mutated by a filter. Defaults to no
       * transformations.
       * Multiple actions can be applied in the same Transformation, forming a sequential
       * pipeline. The transformations will be performed in the order that they appear. Envoy will
       * respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
       * normalization due to disallowed characters.)
       * </pre>
       *
       * <code>.envoy.type.http.v3.PathTransformation http_filter_transformation = 2;</code>
       */
      public Builder clearHttpFilterTransformation() {
        bitField0_ = (bitField0_ & ~0x00000002);
        httpFilterTransformation_ = null;
        if (httpFilterTransformationBuilder_ != null) {
          httpFilterTransformationBuilder_.dispose();
          httpFilterTransformationBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Normalization only applies internally before any processing of
       * requests by HTTP filters, routing, and matching. These will be applied after full
       * transformation is applied. The ``:path`` header before this transformation will be restored in
       * the router filter and sent upstream unless it was mutated by a filter. Defaults to no
       * transformations.
       * Multiple actions can be applied in the same Transformation, forming a sequential
       * pipeline. The transformations will be performed in the order that they appear. Envoy will
       * respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
       * normalization due to disallowed characters.)
       * </pre>
       *
       * <code>.envoy.type.http.v3.PathTransformation http_filter_transformation = 2;</code>
       */
      public io.envoyproxy.envoy.type.http.v3.PathTransformation.Builder getHttpFilterTransformationBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getHttpFilterTransformationFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Normalization only applies internally before any processing of
       * requests by HTTP filters, routing, and matching. These will be applied after full
       * transformation is applied. The ``:path`` header before this transformation will be restored in
       * the router filter and sent upstream unless it was mutated by a filter. Defaults to no
       * transformations.
       * Multiple actions can be applied in the same Transformation, forming a sequential
       * pipeline. The transformations will be performed in the order that they appear. Envoy will
       * respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
       * normalization due to disallowed characters.)
       * </pre>
       *
       * <code>.envoy.type.http.v3.PathTransformation http_filter_transformation = 2;</code>
       */
      public io.envoyproxy.envoy.type.http.v3.PathTransformationOrBuilder getHttpFilterTransformationOrBuilder() {
        if (httpFilterTransformationBuilder_ != null) {
          return httpFilterTransformationBuilder_.getMessageOrBuilder();
        } else {
          return httpFilterTransformation_ == null ?
              io.envoyproxy.envoy.type.http.v3.PathTransformation.getDefaultInstance() : httpFilterTransformation_;
        }
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Normalization only applies internally before any processing of
       * requests by HTTP filters, routing, and matching. These will be applied after full
       * transformation is applied. The ``:path`` header before this transformation will be restored in
       * the router filter and sent upstream unless it was mutated by a filter. Defaults to no
       * transformations.
       * Multiple actions can be applied in the same Transformation, forming a sequential
       * pipeline. The transformations will be performed in the order that they appear. Envoy will
       * respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
       * normalization due to disallowed characters.)
       * </pre>
       *
       * <code>.envoy.type.http.v3.PathTransformation http_filter_transformation = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.envoyproxy.envoy.type.http.v3.PathTransformation, io.envoyproxy.envoy.type.http.v3.PathTransformation.Builder, io.envoyproxy.envoy.type.http.v3.PathTransformationOrBuilder> 
          getHttpFilterTransformationFieldBuilder() {
        if (httpFilterTransformationBuilder_ == null) {
          httpFilterTransformationBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.envoyproxy.envoy.type.http.v3.PathTransformation, io.envoyproxy.envoy.type.http.v3.PathTransformation.Builder, io.envoyproxy.envoy.type.http.v3.PathTransformationOrBuilder>(
                  getHttpFilterTransformation(),
                  getParentForChildren(),
                  isClean());
          httpFilterTransformation_ = null;
        }
        return httpFilterTransformationBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions)
    }

    // @@protoc_insertion_point(class_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions)
    private static final io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions();
    }

    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PathNormalizationOptions>
        PARSER = new com.google.protobuf.AbstractParser<PathNormalizationOptions>() {
      @java.lang.Override
      public PathNormalizationOptions parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<PathNormalizationOptions> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PathNormalizationOptions> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ProxyStatusConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * If true, the details field of the Proxy-Status header is not populated with stream_info.response_code_details.
     * This value defaults to ``false``, i.e. the ``details`` field is populated by default.
     * </pre>
     *
     * <code>bool remove_details = 1;</code>
     * @return The removeDetails.
     */
    boolean getRemoveDetails();

    /**
     * <pre>
     * If true, the details field of the Proxy-Status header will not contain
     * connection termination details. This value defaults to ``false``, i.e. the
     * ``details`` field will contain connection termination details by default.
     * </pre>
     *
     * <code>bool remove_connection_termination_details = 2;</code>
     * @return The removeConnectionTerminationDetails.
     */
    boolean getRemoveConnectionTerminationDetails();

    /**
     * <pre>
     * If true, the details field of the Proxy-Status header will not contain an
     * enumeration of the Envoy ResponseFlags. This value defaults to ``false``,
     * i.e. the ``details`` field will contain a list of ResponseFlags by default.
     * </pre>
     *
     * <code>bool remove_response_flags = 3;</code>
     * @return The removeResponseFlags.
     */
    boolean getRemoveResponseFlags();

    /**
     * <pre>
     * If true, overwrites the existing Status header with the response code
     * recommended by the Proxy-Status spec.
     * This value defaults to ``false``, i.e. the HTTP response code is not
     * overwritten.
     * </pre>
     *
     * <code>bool set_recommended_response_code = 4;</code>
     * @return The setRecommendedResponseCode.
     */
    boolean getSetRecommendedResponseCode();

    /**
     * <pre>
     * If ``use_node_id`` is set, Proxy-Status headers will use the Envoy's node
     * ID as the name of the proxy.
     * </pre>
     *
     * <code>bool use_node_id = 5;</code>
     * @return Whether the useNodeId field is set.
     */
    boolean hasUseNodeId();
    /**
     * <pre>
     * If ``use_node_id`` is set, Proxy-Status headers will use the Envoy's node
     * ID as the name of the proxy.
     * </pre>
     *
     * <code>bool use_node_id = 5;</code>
     * @return The useNodeId.
     */
    boolean getUseNodeId();

    /**
     * <pre>
     * If ``literal_proxy_name`` is set, Proxy-Status headers will use this
     * value as the name of the proxy.
     * </pre>
     *
     * <code>string literal_proxy_name = 6;</code>
     * @return Whether the literalProxyName field is set.
     */
    boolean hasLiteralProxyName();
    /**
     * <pre>
     * If ``literal_proxy_name`` is set, Proxy-Status headers will use this
     * value as the name of the proxy.
     * </pre>
     *
     * <code>string literal_proxy_name = 6;</code>
     * @return The literalProxyName.
     */
    java.lang.String getLiteralProxyName();
    /**
     * <pre>
     * If ``literal_proxy_name`` is set, Proxy-Status headers will use this
     * value as the name of the proxy.
     * </pre>
     *
     * <code>string literal_proxy_name = 6;</code>
     * @return The bytes for literalProxyName.
     */
    com.google.protobuf.ByteString
        getLiteralProxyNameBytes();

    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig.ProxyNameCase getProxyNameCase();
  }
  /**
   * <pre>
   * Configures the manner in which the Proxy-Status HTTP response header is
   * populated.
   * See the [Proxy-Status
   * RFC](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-proxy-status-08).
   * [#comment:TODO: Update this with the non-draft URL when finalized.]
   * The Proxy-Status header is a string of the form:
   *   "&lt;server_name&gt;; error=&lt;error_type&gt;; details=&lt;details&gt;"
   * [#next-free-field: 7]
   * </pre>
   *
   * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig}
   */
  public static final class ProxyStatusConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig)
      ProxyStatusConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ProxyStatusConfig.newBuilder() to construct.
    private ProxyStatusConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ProxyStatusConfig() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ProxyStatusConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_ProxyStatusConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_ProxyStatusConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig.Builder.class);
    }

    private int proxyNameCase_ = 0;
    private java.lang.Object proxyName_;
    public enum ProxyNameCase
        implements com.google.protobuf.Internal.EnumLite,
            com.google.protobuf.AbstractMessage.InternalOneOfEnum {
      USE_NODE_ID(5),
      LITERAL_PROXY_NAME(6),
      PROXYNAME_NOT_SET(0);
      private final int value;
      private ProxyNameCase(int value) {
        this.value = value;
      }
      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ProxyNameCase valueOf(int value) {
        return forNumber(value);
      }

      public static ProxyNameCase forNumber(int value) {
        switch (value) {
          case 5: return USE_NODE_ID;
          case 6: return LITERAL_PROXY_NAME;
          case 0: return PROXYNAME_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public ProxyNameCase
    getProxyNameCase() {
      return ProxyNameCase.forNumber(
          proxyNameCase_);
    }

    public static final int REMOVE_DETAILS_FIELD_NUMBER = 1;
    private boolean removeDetails_ = false;
    /**
     * <pre>
     * If true, the details field of the Proxy-Status header is not populated with stream_info.response_code_details.
     * This value defaults to ``false``, i.e. the ``details`` field is populated by default.
     * </pre>
     *
     * <code>bool remove_details = 1;</code>
     * @return The removeDetails.
     */
    @java.lang.Override
    public boolean getRemoveDetails() {
      return removeDetails_;
    }

    public static final int REMOVE_CONNECTION_TERMINATION_DETAILS_FIELD_NUMBER = 2;
    private boolean removeConnectionTerminationDetails_ = false;
    /**
     * <pre>
     * If true, the details field of the Proxy-Status header will not contain
     * connection termination details. This value defaults to ``false``, i.e. the
     * ``details`` field will contain connection termination details by default.
     * </pre>
     *
     * <code>bool remove_connection_termination_details = 2;</code>
     * @return The removeConnectionTerminationDetails.
     */
    @java.lang.Override
    public boolean getRemoveConnectionTerminationDetails() {
      return removeConnectionTerminationDetails_;
    }

    public static final int REMOVE_RESPONSE_FLAGS_FIELD_NUMBER = 3;
    private boolean removeResponseFlags_ = false;
    /**
     * <pre>
     * If true, the details field of the Proxy-Status header will not contain an
     * enumeration of the Envoy ResponseFlags. This value defaults to ``false``,
     * i.e. the ``details`` field will contain a list of ResponseFlags by default.
     * </pre>
     *
     * <code>bool remove_response_flags = 3;</code>
     * @return The removeResponseFlags.
     */
    @java.lang.Override
    public boolean getRemoveResponseFlags() {
      return removeResponseFlags_;
    }

    public static final int SET_RECOMMENDED_RESPONSE_CODE_FIELD_NUMBER = 4;
    private boolean setRecommendedResponseCode_ = false;
    /**
     * <pre>
     * If true, overwrites the existing Status header with the response code
     * recommended by the Proxy-Status spec.
     * This value defaults to ``false``, i.e. the HTTP response code is not
     * overwritten.
     * </pre>
     *
     * <code>bool set_recommended_response_code = 4;</code>
     * @return The setRecommendedResponseCode.
     */
    @java.lang.Override
    public boolean getSetRecommendedResponseCode() {
      return setRecommendedResponseCode_;
    }

    public static final int USE_NODE_ID_FIELD_NUMBER = 5;
    /**
     * <pre>
     * If ``use_node_id`` is set, Proxy-Status headers will use the Envoy's node
     * ID as the name of the proxy.
     * </pre>
     *
     * <code>bool use_node_id = 5;</code>
     * @return Whether the useNodeId field is set.
     */
    @java.lang.Override
    public boolean hasUseNodeId() {
      return proxyNameCase_ == 5;
    }
    /**
     * <pre>
     * If ``use_node_id`` is set, Proxy-Status headers will use the Envoy's node
     * ID as the name of the proxy.
     * </pre>
     *
     * <code>bool use_node_id = 5;</code>
     * @return The useNodeId.
     */
    @java.lang.Override
    public boolean getUseNodeId() {
      if (proxyNameCase_ == 5) {
        return (java.lang.Boolean) proxyName_;
      }
      return false;
    }

    public static final int LITERAL_PROXY_NAME_FIELD_NUMBER = 6;
    /**
     * <pre>
     * If ``literal_proxy_name`` is set, Proxy-Status headers will use this
     * value as the name of the proxy.
     * </pre>
     *
     * <code>string literal_proxy_name = 6;</code>
     * @return Whether the literalProxyName field is set.
     */
    public boolean hasLiteralProxyName() {
      return proxyNameCase_ == 6;
    }
    /**
     * <pre>
     * If ``literal_proxy_name`` is set, Proxy-Status headers will use this
     * value as the name of the proxy.
     * </pre>
     *
     * <code>string literal_proxy_name = 6;</code>
     * @return The literalProxyName.
     */
    public java.lang.String getLiteralProxyName() {
      java.lang.Object ref = "";
      if (proxyNameCase_ == 6) {
        ref = proxyName_;
      }
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (proxyNameCase_ == 6) {
          proxyName_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * If ``literal_proxy_name`` is set, Proxy-Status headers will use this
     * value as the name of the proxy.
     * </pre>
     *
     * <code>string literal_proxy_name = 6;</code>
     * @return The bytes for literalProxyName.
     */
    public com.google.protobuf.ByteString
        getLiteralProxyNameBytes() {
      java.lang.Object ref = "";
      if (proxyNameCase_ == 6) {
        ref = proxyName_;
      }
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        if (proxyNameCase_ == 6) {
          proxyName_ = b;
        }
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (removeDetails_ != false) {
        output.writeBool(1, removeDetails_);
      }
      if (removeConnectionTerminationDetails_ != false) {
        output.writeBool(2, removeConnectionTerminationDetails_);
      }
      if (removeResponseFlags_ != false) {
        output.writeBool(3, removeResponseFlags_);
      }
      if (setRecommendedResponseCode_ != false) {
        output.writeBool(4, setRecommendedResponseCode_);
      }
      if (proxyNameCase_ == 5) {
        output.writeBool(
            5, (boolean)((java.lang.Boolean) proxyName_));
      }
      if (proxyNameCase_ == 6) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, proxyName_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (removeDetails_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(1, removeDetails_);
      }
      if (removeConnectionTerminationDetails_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, removeConnectionTerminationDetails_);
      }
      if (removeResponseFlags_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, removeResponseFlags_);
      }
      if (setRecommendedResponseCode_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(4, setRecommendedResponseCode_);
      }
      if (proxyNameCase_ == 5) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(
              5, (boolean)((java.lang.Boolean) proxyName_));
      }
      if (proxyNameCase_ == 6) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, proxyName_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig)) {
        return super.equals(obj);
      }
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig other = (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig) obj;

      if (getRemoveDetails()
          != other.getRemoveDetails()) return false;
      if (getRemoveConnectionTerminationDetails()
          != other.getRemoveConnectionTerminationDetails()) return false;
      if (getRemoveResponseFlags()
          != other.getRemoveResponseFlags()) return false;
      if (getSetRecommendedResponseCode()
          != other.getSetRecommendedResponseCode()) return false;
      if (!getProxyNameCase().equals(other.getProxyNameCase())) return false;
      switch (proxyNameCase_) {
        case 5:
          if (getUseNodeId()
              != other.getUseNodeId()) return false;
          break;
        case 6:
          if (!getLiteralProxyName()
              .equals(other.getLiteralProxyName())) return false;
          break;
        case 0:
        default:
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + REMOVE_DETAILS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getRemoveDetails());
      hash = (37 * hash) + REMOVE_CONNECTION_TERMINATION_DETAILS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getRemoveConnectionTerminationDetails());
      hash = (37 * hash) + REMOVE_RESPONSE_FLAGS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getRemoveResponseFlags());
      hash = (37 * hash) + SET_RECOMMENDED_RESPONSE_CODE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getSetRecommendedResponseCode());
      switch (proxyNameCase_) {
        case 5:
          hash = (37 * hash) + USE_NODE_ID_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
              getUseNodeId());
          break;
        case 6:
          hash = (37 * hash) + LITERAL_PROXY_NAME_FIELD_NUMBER;
          hash = (53 * hash) + getLiteralProxyName().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Configures the manner in which the Proxy-Status HTTP response header is
     * populated.
     * See the [Proxy-Status
     * RFC](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-proxy-status-08).
     * [#comment:TODO: Update this with the non-draft URL when finalized.]
     * The Proxy-Status header is a string of the form:
     *   "&lt;server_name&gt;; error=&lt;error_type&gt;; details=&lt;details&gt;"
     * [#next-free-field: 7]
     * </pre>
     *
     * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig)
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_ProxyStatusConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_ProxyStatusConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig.Builder.class);
      }

      // Construct using io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        removeDetails_ = false;
        removeConnectionTerminationDetails_ = false;
        removeResponseFlags_ = false;
        setRecommendedResponseCode_ = false;
        proxyNameCase_ = 0;
        proxyName_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_ProxyStatusConfig_descriptor;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig getDefaultInstanceForType() {
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig.getDefaultInstance();
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig build() {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig buildPartial() {
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig result = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        buildPartialOneofs(result);
        onBuilt();
        return result;
      }

      private void buildPartial0(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.removeDetails_ = removeDetails_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.removeConnectionTerminationDetails_ = removeConnectionTerminationDetails_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.removeResponseFlags_ = removeResponseFlags_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.setRecommendedResponseCode_ = setRecommendedResponseCode_;
        }
      }

      private void buildPartialOneofs(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig result) {
        result.proxyNameCase_ = proxyNameCase_;
        result.proxyName_ = this.proxyName_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig) {
          return mergeFrom((io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig other) {
        if (other == io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig.getDefaultInstance()) return this;
        if (other.getRemoveDetails() != false) {
          setRemoveDetails(other.getRemoveDetails());
        }
        if (other.getRemoveConnectionTerminationDetails() != false) {
          setRemoveConnectionTerminationDetails(other.getRemoveConnectionTerminationDetails());
        }
        if (other.getRemoveResponseFlags() != false) {
          setRemoveResponseFlags(other.getRemoveResponseFlags());
        }
        if (other.getSetRecommendedResponseCode() != false) {
          setSetRecommendedResponseCode(other.getSetRecommendedResponseCode());
        }
        switch (other.getProxyNameCase()) {
          case USE_NODE_ID: {
            setUseNodeId(other.getUseNodeId());
            break;
          }
          case LITERAL_PROXY_NAME: {
            proxyNameCase_ = 6;
            proxyName_ = other.proxyName_;
            onChanged();
            break;
          }
          case PROXYNAME_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                removeDetails_ = input.readBool();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                removeConnectionTerminationDetails_ = input.readBool();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 24: {
                removeResponseFlags_ = input.readBool();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                setRecommendedResponseCode_ = input.readBool();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 40: {
                proxyName_ = input.readBool();
                proxyNameCase_ = 5;
                break;
              } // case 40
              case 50: {
                java.lang.String s = input.readStringRequireUtf8();
                proxyNameCase_ = 6;
                proxyName_ = s;
                break;
              } // case 50
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int proxyNameCase_ = 0;
      private java.lang.Object proxyName_;
      public ProxyNameCase
          getProxyNameCase() {
        return ProxyNameCase.forNumber(
            proxyNameCase_);
      }

      public Builder clearProxyName() {
        proxyNameCase_ = 0;
        proxyName_ = null;
        onChanged();
        return this;
      }

      private int bitField0_;

      private boolean removeDetails_ ;
      /**
       * <pre>
       * If true, the details field of the Proxy-Status header is not populated with stream_info.response_code_details.
       * This value defaults to ``false``, i.e. the ``details`` field is populated by default.
       * </pre>
       *
       * <code>bool remove_details = 1;</code>
       * @return The removeDetails.
       */
      @java.lang.Override
      public boolean getRemoveDetails() {
        return removeDetails_;
      }
      /**
       * <pre>
       * If true, the details field of the Proxy-Status header is not populated with stream_info.response_code_details.
       * This value defaults to ``false``, i.e. the ``details`` field is populated by default.
       * </pre>
       *
       * <code>bool remove_details = 1;</code>
       * @param value The removeDetails to set.
       * @return This builder for chaining.
       */
      public Builder setRemoveDetails(boolean value) {
        
        removeDetails_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, the details field of the Proxy-Status header is not populated with stream_info.response_code_details.
       * This value defaults to ``false``, i.e. the ``details`` field is populated by default.
       * </pre>
       *
       * <code>bool remove_details = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearRemoveDetails() {
        bitField0_ = (bitField0_ & ~0x00000001);
        removeDetails_ = false;
        onChanged();
        return this;
      }

      private boolean removeConnectionTerminationDetails_ ;
      /**
       * <pre>
       * If true, the details field of the Proxy-Status header will not contain
       * connection termination details. This value defaults to ``false``, i.e. the
       * ``details`` field will contain connection termination details by default.
       * </pre>
       *
       * <code>bool remove_connection_termination_details = 2;</code>
       * @return The removeConnectionTerminationDetails.
       */
      @java.lang.Override
      public boolean getRemoveConnectionTerminationDetails() {
        return removeConnectionTerminationDetails_;
      }
      /**
       * <pre>
       * If true, the details field of the Proxy-Status header will not contain
       * connection termination details. This value defaults to ``false``, i.e. the
       * ``details`` field will contain connection termination details by default.
       * </pre>
       *
       * <code>bool remove_connection_termination_details = 2;</code>
       * @param value The removeConnectionTerminationDetails to set.
       * @return This builder for chaining.
       */
      public Builder setRemoveConnectionTerminationDetails(boolean value) {
        
        removeConnectionTerminationDetails_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, the details field of the Proxy-Status header will not contain
       * connection termination details. This value defaults to ``false``, i.e. the
       * ``details`` field will contain connection termination details by default.
       * </pre>
       *
       * <code>bool remove_connection_termination_details = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearRemoveConnectionTerminationDetails() {
        bitField0_ = (bitField0_ & ~0x00000002);
        removeConnectionTerminationDetails_ = false;
        onChanged();
        return this;
      }

      private boolean removeResponseFlags_ ;
      /**
       * <pre>
       * If true, the details field of the Proxy-Status header will not contain an
       * enumeration of the Envoy ResponseFlags. This value defaults to ``false``,
       * i.e. the ``details`` field will contain a list of ResponseFlags by default.
       * </pre>
       *
       * <code>bool remove_response_flags = 3;</code>
       * @return The removeResponseFlags.
       */
      @java.lang.Override
      public boolean getRemoveResponseFlags() {
        return removeResponseFlags_;
      }
      /**
       * <pre>
       * If true, the details field of the Proxy-Status header will not contain an
       * enumeration of the Envoy ResponseFlags. This value defaults to ``false``,
       * i.e. the ``details`` field will contain a list of ResponseFlags by default.
       * </pre>
       *
       * <code>bool remove_response_flags = 3;</code>
       * @param value The removeResponseFlags to set.
       * @return This builder for chaining.
       */
      public Builder setRemoveResponseFlags(boolean value) {
        
        removeResponseFlags_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, the details field of the Proxy-Status header will not contain an
       * enumeration of the Envoy ResponseFlags. This value defaults to ``false``,
       * i.e. the ``details`` field will contain a list of ResponseFlags by default.
       * </pre>
       *
       * <code>bool remove_response_flags = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearRemoveResponseFlags() {
        bitField0_ = (bitField0_ & ~0x00000004);
        removeResponseFlags_ = false;
        onChanged();
        return this;
      }

      private boolean setRecommendedResponseCode_ ;
      /**
       * <pre>
       * If true, overwrites the existing Status header with the response code
       * recommended by the Proxy-Status spec.
       * This value defaults to ``false``, i.e. the HTTP response code is not
       * overwritten.
       * </pre>
       *
       * <code>bool set_recommended_response_code = 4;</code>
       * @return The setRecommendedResponseCode.
       */
      @java.lang.Override
      public boolean getSetRecommendedResponseCode() {
        return setRecommendedResponseCode_;
      }
      /**
       * <pre>
       * If true, overwrites the existing Status header with the response code
       * recommended by the Proxy-Status spec.
       * This value defaults to ``false``, i.e. the HTTP response code is not
       * overwritten.
       * </pre>
       *
       * <code>bool set_recommended_response_code = 4;</code>
       * @param value The setRecommendedResponseCode to set.
       * @return This builder for chaining.
       */
      public Builder setSetRecommendedResponseCode(boolean value) {
        
        setRecommendedResponseCode_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, overwrites the existing Status header with the response code
       * recommended by the Proxy-Status spec.
       * This value defaults to ``false``, i.e. the HTTP response code is not
       * overwritten.
       * </pre>
       *
       * <code>bool set_recommended_response_code = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearSetRecommendedResponseCode() {
        bitField0_ = (bitField0_ & ~0x00000008);
        setRecommendedResponseCode_ = false;
        onChanged();
        return this;
      }

      /**
       * <pre>
       * If ``use_node_id`` is set, Proxy-Status headers will use the Envoy's node
       * ID as the name of the proxy.
       * </pre>
       *
       * <code>bool use_node_id = 5;</code>
       * @return Whether the useNodeId field is set.
       */
      public boolean hasUseNodeId() {
        return proxyNameCase_ == 5;
      }
      /**
       * <pre>
       * If ``use_node_id`` is set, Proxy-Status headers will use the Envoy's node
       * ID as the name of the proxy.
       * </pre>
       *
       * <code>bool use_node_id = 5;</code>
       * @return The useNodeId.
       */
      public boolean getUseNodeId() {
        if (proxyNameCase_ == 5) {
          return (java.lang.Boolean) proxyName_;
        }
        return false;
      }
      /**
       * <pre>
       * If ``use_node_id`` is set, Proxy-Status headers will use the Envoy's node
       * ID as the name of the proxy.
       * </pre>
       *
       * <code>bool use_node_id = 5;</code>
       * @param value The useNodeId to set.
       * @return This builder for chaining.
       */
      public Builder setUseNodeId(boolean value) {
        
        proxyNameCase_ = 5;
        proxyName_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If ``use_node_id`` is set, Proxy-Status headers will use the Envoy's node
       * ID as the name of the proxy.
       * </pre>
       *
       * <code>bool use_node_id = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearUseNodeId() {
        if (proxyNameCase_ == 5) {
          proxyNameCase_ = 0;
          proxyName_ = null;
          onChanged();
        }
        return this;
      }

      /**
       * <pre>
       * If ``literal_proxy_name`` is set, Proxy-Status headers will use this
       * value as the name of the proxy.
       * </pre>
       *
       * <code>string literal_proxy_name = 6;</code>
       * @return Whether the literalProxyName field is set.
       */
      @java.lang.Override
      public boolean hasLiteralProxyName() {
        return proxyNameCase_ == 6;
      }
      /**
       * <pre>
       * If ``literal_proxy_name`` is set, Proxy-Status headers will use this
       * value as the name of the proxy.
       * </pre>
       *
       * <code>string literal_proxy_name = 6;</code>
       * @return The literalProxyName.
       */
      @java.lang.Override
      public java.lang.String getLiteralProxyName() {
        java.lang.Object ref = "";
        if (proxyNameCase_ == 6) {
          ref = proxyName_;
        }
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (proxyNameCase_ == 6) {
            proxyName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * If ``literal_proxy_name`` is set, Proxy-Status headers will use this
       * value as the name of the proxy.
       * </pre>
       *
       * <code>string literal_proxy_name = 6;</code>
       * @return The bytes for literalProxyName.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getLiteralProxyNameBytes() {
        java.lang.Object ref = "";
        if (proxyNameCase_ == 6) {
          ref = proxyName_;
        }
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          if (proxyNameCase_ == 6) {
            proxyName_ = b;
          }
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * If ``literal_proxy_name`` is set, Proxy-Status headers will use this
       * value as the name of the proxy.
       * </pre>
       *
       * <code>string literal_proxy_name = 6;</code>
       * @param value The literalProxyName to set.
       * @return This builder for chaining.
       */
      public Builder setLiteralProxyName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        proxyNameCase_ = 6;
        proxyName_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If ``literal_proxy_name`` is set, Proxy-Status headers will use this
       * value as the name of the proxy.
       * </pre>
       *
       * <code>string literal_proxy_name = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearLiteralProxyName() {
        if (proxyNameCase_ == 6) {
          proxyNameCase_ = 0;
          proxyName_ = null;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * If ``literal_proxy_name`` is set, Proxy-Status headers will use this
       * value as the name of the proxy.
       * </pre>
       *
       * <code>string literal_proxy_name = 6;</code>
       * @param value The bytes for literalProxyName to set.
       * @return This builder for chaining.
       */
      public Builder setLiteralProxyNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        proxyNameCase_ = 6;
        proxyName_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig)
    }

    // @@protoc_insertion_point(class_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig)
    private static final io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig();
    }

    public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ProxyStatusConfig>
        PARSER = new com.google.protobuf.AbstractParser<ProxyStatusConfig>() {
      @java.lang.Override
      public ProxyStatusConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ProxyStatusConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ProxyStatusConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private int routeSpecifierCase_ = 0;
  private java.lang.Object routeSpecifier_;
  public enum RouteSpecifierCase
      implements com.google.protobuf.Internal.EnumLite,
          com.google.protobuf.AbstractMessage.InternalOneOfEnum {
    RDS(3),
    ROUTE_CONFIG(4),
    SCOPED_ROUTES(31),
    ROUTESPECIFIER_NOT_SET(0);
    private final int value;
    private RouteSpecifierCase(int value) {
      this.value = value;
    }
    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static RouteSpecifierCase valueOf(int value) {
      return forNumber(value);
    }

    public static RouteSpecifierCase forNumber(int value) {
      switch (value) {
        case 3: return RDS;
        case 4: return ROUTE_CONFIG;
        case 31: return SCOPED_ROUTES;
        case 0: return ROUTESPECIFIER_NOT_SET;
        default: return null;
      }
    }
    public int getNumber() {
      return this.value;
    }
  };

  public RouteSpecifierCase
  getRouteSpecifierCase() {
    return RouteSpecifierCase.forNumber(
        routeSpecifierCase_);
  }

  private int stripPortModeCase_ = 0;
  private java.lang.Object stripPortMode_;
  public enum StripPortModeCase
      implements com.google.protobuf.Internal.EnumLite,
          com.google.protobuf.AbstractMessage.InternalOneOfEnum {
    STRIP_ANY_HOST_PORT(42),
    STRIPPORTMODE_NOT_SET(0);
    private final int value;
    private StripPortModeCase(int value) {
      this.value = value;
    }
    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static StripPortModeCase valueOf(int value) {
      return forNumber(value);
    }

    public static StripPortModeCase forNumber(int value) {
      switch (value) {
        case 42: return STRIP_ANY_HOST_PORT;
        case 0: return STRIPPORTMODE_NOT_SET;
        default: return null;
      }
    }
    public int getNumber() {
      return this.value;
    }
  };

  public StripPortModeCase
  getStripPortModeCase() {
    return StripPortModeCase.forNumber(
        stripPortModeCase_);
  }

  public static final int CODEC_TYPE_FIELD_NUMBER = 1;
  private int codecType_ = 0;
  /**
   * <pre>
   * Supplies the type of codec that the connection manager should use.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType codec_type = 1 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for codecType.
   */
  @java.lang.Override public int getCodecTypeValue() {
    return codecType_;
  }
  /**
   * <pre>
   * Supplies the type of codec that the connection manager should use.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType codec_type = 1 [(.validate.rules) = { ... }</code>
   * @return The codecType.
   */
  @java.lang.Override public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType getCodecType() {
    io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType result = io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType.forNumber(codecType_);
    return result == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType.UNRECOGNIZED : result;
  }

  public static final int STAT_PREFIX_FIELD_NUMBER = 2;
  @SuppressWarnings("serial")
  private volatile java.lang.Object statPrefix_ = "";
  /**
   * <pre>
   * The human readable prefix to use when emitting statistics for the
   * connection manager. See the :ref:`statistics documentation &lt;config_http_conn_man_stats&gt;` for
   * more information.
   * </pre>
   *
   * <code>string stat_prefix = 2 [(.validate.rules) = { ... }</code>
   * @return The statPrefix.
   */
  @java.lang.Override
  public java.lang.String getStatPrefix() {
    java.lang.Object ref = statPrefix_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      statPrefix_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * The human readable prefix to use when emitting statistics for the
   * connection manager. See the :ref:`statistics documentation &lt;config_http_conn_man_stats&gt;` for
   * more information.
   * </pre>
   *
   * <code>string stat_prefix = 2 [(.validate.rules) = { ... }</code>
   * @return The bytes for statPrefix.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getStatPrefixBytes() {
    java.lang.Object ref = statPrefix_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      statPrefix_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int RDS_FIELD_NUMBER = 3;
  /**
   * <pre>
   * The connection manager’s route table will be dynamically loaded via the RDS API.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
   * @return Whether the rds field is set.
   */
  @java.lang.Override
  public boolean hasRds() {
    return routeSpecifierCase_ == 3;
  }
  /**
   * <pre>
   * The connection manager’s route table will be dynamically loaded via the RDS API.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
   * @return The rds.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds getRds() {
    if (routeSpecifierCase_ == 3) {
       return (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds) routeSpecifier_;
    }
    return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.getDefaultInstance();
  }
  /**
   * <pre>
   * The connection manager’s route table will be dynamically loaded via the RDS API.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RdsOrBuilder getRdsOrBuilder() {
    if (routeSpecifierCase_ == 3) {
       return (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds) routeSpecifier_;
    }
    return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.getDefaultInstance();
  }

  public static final int ROUTE_CONFIG_FIELD_NUMBER = 4;
  /**
   * <pre>
   * The route table for the connection manager is static and is specified in this property.
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
   * @return Whether the routeConfig field is set.
   */
  @java.lang.Override
  public boolean hasRouteConfig() {
    return routeSpecifierCase_ == 4;
  }
  /**
   * <pre>
   * The route table for the connection manager is static and is specified in this property.
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
   * @return The routeConfig.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.route.v3.RouteConfiguration getRouteConfig() {
    if (routeSpecifierCase_ == 4) {
       return (io.envoyproxy.envoy.config.route.v3.RouteConfiguration) routeSpecifier_;
    }
    return io.envoyproxy.envoy.config.route.v3.RouteConfiguration.getDefaultInstance();
  }
  /**
   * <pre>
   * The route table for the connection manager is static and is specified in this property.
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.route.v3.RouteConfigurationOrBuilder getRouteConfigOrBuilder() {
    if (routeSpecifierCase_ == 4) {
       return (io.envoyproxy.envoy.config.route.v3.RouteConfiguration) routeSpecifier_;
    }
    return io.envoyproxy.envoy.config.route.v3.RouteConfiguration.getDefaultInstance();
  }

  public static final int SCOPED_ROUTES_FIELD_NUMBER = 31;
  /**
   * <pre>
   * A route table will be dynamically assigned to each request based on request attributes
   * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
   * specified in this message.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
   * @return Whether the scopedRoutes field is set.
   */
  @java.lang.Override
  public boolean hasScopedRoutes() {
    return routeSpecifierCase_ == 31;
  }
  /**
   * <pre>
   * A route table will be dynamically assigned to each request based on request attributes
   * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
   * specified in this message.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
   * @return The scopedRoutes.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes getScopedRoutes() {
    if (routeSpecifierCase_ == 31) {
       return (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes) routeSpecifier_;
    }
    return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.getDefaultInstance();
  }
  /**
   * <pre>
   * A route table will be dynamically assigned to each request based on request attributes
   * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
   * specified in this message.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutesOrBuilder getScopedRoutesOrBuilder() {
    if (routeSpecifierCase_ == 31) {
       return (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes) routeSpecifier_;
    }
    return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.getDefaultInstance();
  }

  public static final int HTTP_FILTERS_FIELD_NUMBER = 5;
  @SuppressWarnings("serial")
  private java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> httpFilters_;
  /**
   * <pre>
   * A list of individual HTTP filters that make up the filter chain for
   * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
   * as the filters are processed sequentially as request events happen.
   * </pre>
   *
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
   */
  @java.lang.Override
  public java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> getHttpFiltersList() {
    return httpFilters_;
  }
  /**
   * <pre>
   * A list of individual HTTP filters that make up the filter chain for
   * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
   * as the filters are processed sequentially as request events happen.
   * </pre>
   *
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
   */
  @java.lang.Override
  public java.util.List<? extends io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder> 
      getHttpFiltersOrBuilderList() {
    return httpFilters_;
  }
  /**
   * <pre>
   * A list of individual HTTP filters that make up the filter chain for
   * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
   * as the filters are processed sequentially as request events happen.
   * </pre>
   *
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
   */
  @java.lang.Override
  public int getHttpFiltersCount() {
    return httpFilters_.size();
  }
  /**
   * <pre>
   * A list of individual HTTP filters that make up the filter chain for
   * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
   * as the filters are processed sequentially as request events happen.
   * </pre>
   *
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter getHttpFilters(int index) {
    return httpFilters_.get(index);
  }
  /**
   * <pre>
   * A list of individual HTTP filters that make up the filter chain for
   * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
   * as the filters are processed sequentially as request events happen.
   * </pre>
   *
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder getHttpFiltersOrBuilder(
      int index) {
    return httpFilters_.get(index);
  }

  public static final int ADD_USER_AGENT_FIELD_NUMBER = 6;
  private com.google.protobuf.BoolValue addUserAgent_;
  /**
   * <pre>
   * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
   * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
   * documentation for more information. Defaults to false.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
   * @return Whether the addUserAgent field is set.
   */
  @java.lang.Override
  public boolean hasAddUserAgent() {
    return addUserAgent_ != null;
  }
  /**
   * <pre>
   * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
   * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
   * documentation for more information. Defaults to false.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
   * @return The addUserAgent.
   */
  @java.lang.Override
  public com.google.protobuf.BoolValue getAddUserAgent() {
    return addUserAgent_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : addUserAgent_;
  }
  /**
   * <pre>
   * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
   * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
   * documentation for more information. Defaults to false.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
   */
  @java.lang.Override
  public com.google.protobuf.BoolValueOrBuilder getAddUserAgentOrBuilder() {
    return addUserAgent_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : addUserAgent_;
  }

  public static final int TRACING_FIELD_NUMBER = 7;
  private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing_;
  /**
   * <pre>
   * Presence of the object defines whether the connection manager
   * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
   * &lt;envoy_v3_api_msg_config.trace.v3.Tracing&gt;`.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
   * @return Whether the tracing field is set.
   */
  @java.lang.Override
  public boolean hasTracing() {
    return tracing_ != null;
  }
  /**
   * <pre>
   * Presence of the object defines whether the connection manager
   * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
   * &lt;envoy_v3_api_msg_config.trace.v3.Tracing&gt;`.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
   * @return The tracing.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing getTracing() {
    return tracing_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.getDefaultInstance() : tracing_;
  }
  /**
   * <pre>
   * Presence of the object defines whether the connection manager
   * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
   * &lt;envoy_v3_api_msg_config.trace.v3.Tracing&gt;`.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.TracingOrBuilder getTracingOrBuilder() {
    return tracing_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.getDefaultInstance() : tracing_;
  }

  public static final int COMMON_HTTP_PROTOCOL_OPTIONS_FIELD_NUMBER = 35;
  private io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions commonHttpProtocolOptions_;
  /**
   * <pre>
   * Additional settings for HTTP requests handled by the connection manager. These will be
   * applicable to both HTTP1 and HTTP2 requests.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
   * @return Whether the commonHttpProtocolOptions field is set.
   */
  @java.lang.Override
  public boolean hasCommonHttpProtocolOptions() {
    return commonHttpProtocolOptions_ != null;
  }
  /**
   * <pre>
   * Additional settings for HTTP requests handled by the connection manager. These will be
   * applicable to both HTTP1 and HTTP2 requests.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
   * @return The commonHttpProtocolOptions.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions getCommonHttpProtocolOptions() {
    return commonHttpProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.getDefaultInstance() : commonHttpProtocolOptions_;
  }
  /**
   * <pre>
   * Additional settings for HTTP requests handled by the connection manager. These will be
   * applicable to both HTTP1 and HTTP2 requests.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.HttpProtocolOptionsOrBuilder getCommonHttpProtocolOptionsOrBuilder() {
    return commonHttpProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.getDefaultInstance() : commonHttpProtocolOptions_;
  }

  public static final int HTTP_PROTOCOL_OPTIONS_FIELD_NUMBER = 8;
  private io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions httpProtocolOptions_;
  /**
   * <pre>
   * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
   * [#comment:TODO: The following fields are ignored when the
   * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
   * is present:
   * 1. :ref:`allow_chunked_length &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.allow_chunked_length&gt;`]
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
   * @return Whether the httpProtocolOptions field is set.
   */
  @java.lang.Override
  public boolean hasHttpProtocolOptions() {
    return httpProtocolOptions_ != null;
  }
  /**
   * <pre>
   * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
   * [#comment:TODO: The following fields are ignored when the
   * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
   * is present:
   * 1. :ref:`allow_chunked_length &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.allow_chunked_length&gt;`]
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
   * @return The httpProtocolOptions.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions getHttpProtocolOptions() {
    return httpProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.getDefaultInstance() : httpProtocolOptions_;
  }
  /**
   * <pre>
   * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
   * [#comment:TODO: The following fields are ignored when the
   * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
   * is present:
   * 1. :ref:`allow_chunked_length &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.allow_chunked_length&gt;`]
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptionsOrBuilder getHttpProtocolOptionsOrBuilder() {
    return httpProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.getDefaultInstance() : httpProtocolOptions_;
  }

  public static final int HTTP2_PROTOCOL_OPTIONS_FIELD_NUMBER = 9;
  private io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions http2ProtocolOptions_;
  /**
   * <pre>
   * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
   * @return Whether the http2ProtocolOptions field is set.
   */
  @java.lang.Override
  public boolean hasHttp2ProtocolOptions() {
    return http2ProtocolOptions_ != null;
  }
  /**
   * <pre>
   * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
   * @return The http2ProtocolOptions.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions getHttp2ProtocolOptions() {
    return http2ProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.getDefaultInstance() : http2ProtocolOptions_;
  }
  /**
   * <pre>
   * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptionsOrBuilder getHttp2ProtocolOptionsOrBuilder() {
    return http2ProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.getDefaultInstance() : http2ProtocolOptions_;
  }

  public static final int HTTP3_PROTOCOL_OPTIONS_FIELD_NUMBER = 44;
  private io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptions http3ProtocolOptions_;
  /**
   * <pre>
   * Additional HTTP/3 settings that are passed directly to the HTTP/3 codec.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 44;</code>
   * @return Whether the http3ProtocolOptions field is set.
   */
  @java.lang.Override
  public boolean hasHttp3ProtocolOptions() {
    return http3ProtocolOptions_ != null;
  }
  /**
   * <pre>
   * Additional HTTP/3 settings that are passed directly to the HTTP/3 codec.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 44;</code>
   * @return The http3ProtocolOptions.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptions getHttp3ProtocolOptions() {
    return http3ProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptions.getDefaultInstance() : http3ProtocolOptions_;
  }
  /**
   * <pre>
   * Additional HTTP/3 settings that are passed directly to the HTTP/3 codec.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 44;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptionsOrBuilder getHttp3ProtocolOptionsOrBuilder() {
    return http3ProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptions.getDefaultInstance() : http3ProtocolOptions_;
  }

  public static final int SERVER_NAME_FIELD_NUMBER = 10;
  @SuppressWarnings("serial")
  private volatile java.lang.Object serverName_ = "";
  /**
   * <pre>
   * An optional override that the connection manager will write to the server
   * header in responses. If not set, the default is ``envoy``.
   * </pre>
   *
   * <code>string server_name = 10 [(.validate.rules) = { ... }</code>
   * @return The serverName.
   */
  @java.lang.Override
  public java.lang.String getServerName() {
    java.lang.Object ref = serverName_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      serverName_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * An optional override that the connection manager will write to the server
   * header in responses. If not set, the default is ``envoy``.
   * </pre>
   *
   * <code>string server_name = 10 [(.validate.rules) = { ... }</code>
   * @return The bytes for serverName.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getServerNameBytes() {
    java.lang.Object ref = serverName_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      serverName_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int SERVER_HEADER_TRANSFORMATION_FIELD_NUMBER = 34;
  private int serverHeaderTransformation_ = 0;
  /**
   * <pre>
   * Defines the action to be applied to the Server header on the response path.
   * By default, Envoy will overwrite the header with the value specified in
   * server_name.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation server_header_transformation = 34 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for serverHeaderTransformation.
   */
  @java.lang.Override public int getServerHeaderTransformationValue() {
    return serverHeaderTransformation_;
  }
  /**
   * <pre>
   * Defines the action to be applied to the Server header on the response path.
   * By default, Envoy will overwrite the header with the value specified in
   * server_name.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation server_header_transformation = 34 [(.validate.rules) = { ... }</code>
   * @return The serverHeaderTransformation.
   */
  @java.lang.Override public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation getServerHeaderTransformation() {
    io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation result = io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation.forNumber(serverHeaderTransformation_);
    return result == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation.UNRECOGNIZED : result;
  }

  public static final int SCHEME_HEADER_TRANSFORMATION_FIELD_NUMBER = 48;
  private io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformation schemeHeaderTransformation_;
  /**
   * <pre>
   * Allows for explicit transformation of the :scheme header on the request path.
   * If not set, Envoy's default :ref:`scheme  &lt;config_http_conn_man_headers_scheme&gt;`
   * handling applies.
   * </pre>
   *
   * <code>.envoy.config.core.v3.SchemeHeaderTransformation scheme_header_transformation = 48;</code>
   * @return Whether the schemeHeaderTransformation field is set.
   */
  @java.lang.Override
  public boolean hasSchemeHeaderTransformation() {
    return schemeHeaderTransformation_ != null;
  }
  /**
   * <pre>
   * Allows for explicit transformation of the :scheme header on the request path.
   * If not set, Envoy's default :ref:`scheme  &lt;config_http_conn_man_headers_scheme&gt;`
   * handling applies.
   * </pre>
   *
   * <code>.envoy.config.core.v3.SchemeHeaderTransformation scheme_header_transformation = 48;</code>
   * @return The schemeHeaderTransformation.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformation getSchemeHeaderTransformation() {
    return schemeHeaderTransformation_ == null ? io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformation.getDefaultInstance() : schemeHeaderTransformation_;
  }
  /**
   * <pre>
   * Allows for explicit transformation of the :scheme header on the request path.
   * If not set, Envoy's default :ref:`scheme  &lt;config_http_conn_man_headers_scheme&gt;`
   * handling applies.
   * </pre>
   *
   * <code>.envoy.config.core.v3.SchemeHeaderTransformation scheme_header_transformation = 48;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformationOrBuilder getSchemeHeaderTransformationOrBuilder() {
    return schemeHeaderTransformation_ == null ? io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformation.getDefaultInstance() : schemeHeaderTransformation_;
  }

  public static final int MAX_REQUEST_HEADERS_KB_FIELD_NUMBER = 29;
  private com.google.protobuf.UInt32Value maxRequestHeadersKb_;
  /**
   * <pre>
   * The maximum request headers size for incoming connections.
   * If unconfigured, the default max request headers allowed is 60 KiB.
   * Requests that exceed this limit will receive a 431 response.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
   * @return Whether the maxRequestHeadersKb field is set.
   */
  @java.lang.Override
  public boolean hasMaxRequestHeadersKb() {
    return maxRequestHeadersKb_ != null;
  }
  /**
   * <pre>
   * The maximum request headers size for incoming connections.
   * If unconfigured, the default max request headers allowed is 60 KiB.
   * Requests that exceed this limit will receive a 431 response.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
   * @return The maxRequestHeadersKb.
   */
  @java.lang.Override
  public com.google.protobuf.UInt32Value getMaxRequestHeadersKb() {
    return maxRequestHeadersKb_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : maxRequestHeadersKb_;
  }
  /**
   * <pre>
   * The maximum request headers size for incoming connections.
   * If unconfigured, the default max request headers allowed is 60 KiB.
   * Requests that exceed this limit will receive a 431 response.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.UInt32ValueOrBuilder getMaxRequestHeadersKbOrBuilder() {
    return maxRequestHeadersKb_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : maxRequestHeadersKb_;
  }

  public static final int STREAM_IDLE_TIMEOUT_FIELD_NUMBER = 24;
  private com.google.protobuf.Duration streamIdleTimeout_;
  /**
   * <pre>
   * The stream idle timeout for connections managed by the connection manager.
   * If not specified, this defaults to 5 minutes. The default value was selected
   * so as not to interfere with any smaller configured timeouts that may have
   * existed in configurations prior to the introduction of this feature, while
   * introducing robustness to TCP connections that terminate without a FIN.
   * This idle timeout applies to new streams and is overridable by the
   * :ref:`route-level idle_timeout
   * &lt;envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
   * which the override applies, prior to receipt of the initial request
   * headers, the :ref:`stream_idle_timeout
   * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
   * applies. Each time an encode/decode event for headers or data is processed
   * for the stream, the timer will be reset. If the timeout fires, the stream
   * is terminated with a 408 Request Timeout error code if no upstream response
   * header has been received, otherwise a stream reset occurs.
   * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
   * window to write any remaining stream data once the entirety of stream data (local end stream is
   * true) has been buffered pending available window. In other words, this timeout defends against
   * a peer that does not release enough window to completely write the stream, even though all
   * data has been proxied within available flow control windows. If the timeout is hit in this
   * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
   * incremented. Note that :ref:`max_stream_duration
   * &lt;envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
   * this corner case.
   * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
   * is configured, this timeout is scaled according to the value for
   * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
   * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
   * to the granularity of events presented to the connection manager. For example, while receiving
   * very large request headers, it may be the case that there is traffic regularly arriving on the
   * wire while the connection manage is only able to observe the end-of-headers event, hence the
   * stream may still idle timeout.
   * A value of 0 will completely disable the connection manager stream idle
   * timeout, although per-route idle timeout overrides will continue to apply.
   * </pre>
   *
   * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
   * @return Whether the streamIdleTimeout field is set.
   */
  @java.lang.Override
  public boolean hasStreamIdleTimeout() {
    return streamIdleTimeout_ != null;
  }
  /**
   * <pre>
   * The stream idle timeout for connections managed by the connection manager.
   * If not specified, this defaults to 5 minutes. The default value was selected
   * so as not to interfere with any smaller configured timeouts that may have
   * existed in configurations prior to the introduction of this feature, while
   * introducing robustness to TCP connections that terminate without a FIN.
   * This idle timeout applies to new streams and is overridable by the
   * :ref:`route-level idle_timeout
   * &lt;envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
   * which the override applies, prior to receipt of the initial request
   * headers, the :ref:`stream_idle_timeout
   * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
   * applies. Each time an encode/decode event for headers or data is processed
   * for the stream, the timer will be reset. If the timeout fires, the stream
   * is terminated with a 408 Request Timeout error code if no upstream response
   * header has been received, otherwise a stream reset occurs.
   * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
   * window to write any remaining stream data once the entirety of stream data (local end stream is
   * true) has been buffered pending available window. In other words, this timeout defends against
   * a peer that does not release enough window to completely write the stream, even though all
   * data has been proxied within available flow control windows. If the timeout is hit in this
   * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
   * incremented. Note that :ref:`max_stream_duration
   * &lt;envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
   * this corner case.
   * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
   * is configured, this timeout is scaled according to the value for
   * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
   * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
   * to the granularity of events presented to the connection manager. For example, while receiving
   * very large request headers, it may be the case that there is traffic regularly arriving on the
   * wire while the connection manage is only able to observe the end-of-headers event, hence the
   * stream may still idle timeout.
   * A value of 0 will completely disable the connection manager stream idle
   * timeout, although per-route idle timeout overrides will continue to apply.
   * </pre>
   *
   * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
   * @return The streamIdleTimeout.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getStreamIdleTimeout() {
    return streamIdleTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : streamIdleTimeout_;
  }
  /**
   * <pre>
   * The stream idle timeout for connections managed by the connection manager.
   * If not specified, this defaults to 5 minutes. The default value was selected
   * so as not to interfere with any smaller configured timeouts that may have
   * existed in configurations prior to the introduction of this feature, while
   * introducing robustness to TCP connections that terminate without a FIN.
   * This idle timeout applies to new streams and is overridable by the
   * :ref:`route-level idle_timeout
   * &lt;envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
   * which the override applies, prior to receipt of the initial request
   * headers, the :ref:`stream_idle_timeout
   * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
   * applies. Each time an encode/decode event for headers or data is processed
   * for the stream, the timer will be reset. If the timeout fires, the stream
   * is terminated with a 408 Request Timeout error code if no upstream response
   * header has been received, otherwise a stream reset occurs.
   * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
   * window to write any remaining stream data once the entirety of stream data (local end stream is
   * true) has been buffered pending available window. In other words, this timeout defends against
   * a peer that does not release enough window to completely write the stream, even though all
   * data has been proxied within available flow control windows. If the timeout is hit in this
   * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
   * incremented. Note that :ref:`max_stream_duration
   * &lt;envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
   * this corner case.
   * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
   * is configured, this timeout is scaled according to the value for
   * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
   * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
   * to the granularity of events presented to the connection manager. For example, while receiving
   * very large request headers, it may be the case that there is traffic regularly arriving on the
   * wire while the connection manage is only able to observe the end-of-headers event, hence the
   * stream may still idle timeout.
   * A value of 0 will completely disable the connection manager stream idle
   * timeout, although per-route idle timeout overrides will continue to apply.
   * </pre>
   *
   * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getStreamIdleTimeoutOrBuilder() {
    return streamIdleTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : streamIdleTimeout_;
  }

  public static final int REQUEST_TIMEOUT_FIELD_NUMBER = 28;
  private com.google.protobuf.Duration requestTimeout_;
  /**
   * <pre>
   * The amount of time that Envoy will wait for the entire request to be received.
   * The timer is activated when the request is initiated, and is disarmed when the last byte of the
   * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
   * response is initiated. If not specified or set to 0, this timeout is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
   * @return Whether the requestTimeout field is set.
   */
  @java.lang.Override
  public boolean hasRequestTimeout() {
    return requestTimeout_ != null;
  }
  /**
   * <pre>
   * The amount of time that Envoy will wait for the entire request to be received.
   * The timer is activated when the request is initiated, and is disarmed when the last byte of the
   * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
   * response is initiated. If not specified or set to 0, this timeout is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
   * @return The requestTimeout.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getRequestTimeout() {
    return requestTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : requestTimeout_;
  }
  /**
   * <pre>
   * The amount of time that Envoy will wait for the entire request to be received.
   * The timer is activated when the request is initiated, and is disarmed when the last byte of the
   * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
   * response is initiated. If not specified or set to 0, this timeout is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getRequestTimeoutOrBuilder() {
    return requestTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : requestTimeout_;
  }

  public static final int REQUEST_HEADERS_TIMEOUT_FIELD_NUMBER = 41;
  private com.google.protobuf.Duration requestHeadersTimeout_;
  /**
   * <pre>
   * The amount of time that Envoy will wait for the request headers to be received. The timer is
   * activated when the first byte of the headers is received, and is disarmed when the last byte of
   * the headers has been received. If not specified or set to 0, this timeout is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
   * @return Whether the requestHeadersTimeout field is set.
   */
  @java.lang.Override
  public boolean hasRequestHeadersTimeout() {
    return requestHeadersTimeout_ != null;
  }
  /**
   * <pre>
   * The amount of time that Envoy will wait for the request headers to be received. The timer is
   * activated when the first byte of the headers is received, and is disarmed when the last byte of
   * the headers has been received. If not specified or set to 0, this timeout is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
   * @return The requestHeadersTimeout.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getRequestHeadersTimeout() {
    return requestHeadersTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : requestHeadersTimeout_;
  }
  /**
   * <pre>
   * The amount of time that Envoy will wait for the request headers to be received. The timer is
   * activated when the first byte of the headers is received, and is disarmed when the last byte of
   * the headers has been received. If not specified or set to 0, this timeout is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getRequestHeadersTimeoutOrBuilder() {
    return requestHeadersTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : requestHeadersTimeout_;
  }

  public static final int DRAIN_TIMEOUT_FIELD_NUMBER = 12;
  private com.google.protobuf.Duration drainTimeout_;
  /**
   * <pre>
   * The time that Envoy will wait between sending an HTTP/2 “shutdown
   * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
   * This is used so that Envoy provides a grace period for new streams that
   * race with the final GOAWAY frame. During this grace period, Envoy will
   * continue to accept new streams. After the grace period, a final GOAWAY
   * frame is sent and Envoy will start refusing new streams. Draining occurs
   * both when a connection hits the idle timeout or during general server
   * draining. The default grace period is 5000 milliseconds (5 seconds) if this
   * option is not specified.
   * </pre>
   *
   * <code>.google.protobuf.Duration drain_timeout = 12;</code>
   * @return Whether the drainTimeout field is set.
   */
  @java.lang.Override
  public boolean hasDrainTimeout() {
    return drainTimeout_ != null;
  }
  /**
   * <pre>
   * The time that Envoy will wait between sending an HTTP/2 “shutdown
   * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
   * This is used so that Envoy provides a grace period for new streams that
   * race with the final GOAWAY frame. During this grace period, Envoy will
   * continue to accept new streams. After the grace period, a final GOAWAY
   * frame is sent and Envoy will start refusing new streams. Draining occurs
   * both when a connection hits the idle timeout or during general server
   * draining. The default grace period is 5000 milliseconds (5 seconds) if this
   * option is not specified.
   * </pre>
   *
   * <code>.google.protobuf.Duration drain_timeout = 12;</code>
   * @return The drainTimeout.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getDrainTimeout() {
    return drainTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : drainTimeout_;
  }
  /**
   * <pre>
   * The time that Envoy will wait between sending an HTTP/2 “shutdown
   * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
   * This is used so that Envoy provides a grace period for new streams that
   * race with the final GOAWAY frame. During this grace period, Envoy will
   * continue to accept new streams. After the grace period, a final GOAWAY
   * frame is sent and Envoy will start refusing new streams. Draining occurs
   * both when a connection hits the idle timeout or during general server
   * draining. The default grace period is 5000 milliseconds (5 seconds) if this
   * option is not specified.
   * </pre>
   *
   * <code>.google.protobuf.Duration drain_timeout = 12;</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getDrainTimeoutOrBuilder() {
    return drainTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : drainTimeout_;
  }

  public static final int DELAYED_CLOSE_TIMEOUT_FIELD_NUMBER = 26;
  private com.google.protobuf.Duration delayedCloseTimeout_;
  /**
   * <pre>
   * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
   * It is defined as a grace period after connection close processing has been locally initiated
   * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
   * from the downstream connection) prior to Envoy closing the socket associated with that
   * connection.
   * NOTE: This timeout is enforced even when the socket associated with the downstream connection
   * is pending a flush of the write buffer. However, any progress made writing data to the socket
   * will restart the timer associated with this timeout. This means that the total grace period for
   * a socket in this state will be
   * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
   * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
   * sequence mitigates a race condition that exists when downstream clients do not drain/process
   * data in a connection's receive buffer after a remote close has been detected via a socket
   * write(). This race leads to such clients failing to process the response code sent by Envoy,
   * which could result in erroneous downstream processing.
   * If the timeout triggers, Envoy will close the connection's socket.
   * The default timeout is 1000 ms if this option is not specified.
   * .. NOTE::
   *    To be useful in avoiding the race condition described above, this timeout must be set
   *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
   *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
   * .. WARNING::
   *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
   *    connection's socket will be closed immediately after the write flush is completed or will
   *    never close if the write flush does not complete.
   * </pre>
   *
   * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
   * @return Whether the delayedCloseTimeout field is set.
   */
  @java.lang.Override
  public boolean hasDelayedCloseTimeout() {
    return delayedCloseTimeout_ != null;
  }
  /**
   * <pre>
   * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
   * It is defined as a grace period after connection close processing has been locally initiated
   * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
   * from the downstream connection) prior to Envoy closing the socket associated with that
   * connection.
   * NOTE: This timeout is enforced even when the socket associated with the downstream connection
   * is pending a flush of the write buffer. However, any progress made writing data to the socket
   * will restart the timer associated with this timeout. This means that the total grace period for
   * a socket in this state will be
   * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
   * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
   * sequence mitigates a race condition that exists when downstream clients do not drain/process
   * data in a connection's receive buffer after a remote close has been detected via a socket
   * write(). This race leads to such clients failing to process the response code sent by Envoy,
   * which could result in erroneous downstream processing.
   * If the timeout triggers, Envoy will close the connection's socket.
   * The default timeout is 1000 ms if this option is not specified.
   * .. NOTE::
   *    To be useful in avoiding the race condition described above, this timeout must be set
   *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
   *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
   * .. WARNING::
   *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
   *    connection's socket will be closed immediately after the write flush is completed or will
   *    never close if the write flush does not complete.
   * </pre>
   *
   * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
   * @return The delayedCloseTimeout.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getDelayedCloseTimeout() {
    return delayedCloseTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : delayedCloseTimeout_;
  }
  /**
   * <pre>
   * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
   * It is defined as a grace period after connection close processing has been locally initiated
   * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
   * from the downstream connection) prior to Envoy closing the socket associated with that
   * connection.
   * NOTE: This timeout is enforced even when the socket associated with the downstream connection
   * is pending a flush of the write buffer. However, any progress made writing data to the socket
   * will restart the timer associated with this timeout. This means that the total grace period for
   * a socket in this state will be
   * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
   * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
   * sequence mitigates a race condition that exists when downstream clients do not drain/process
   * data in a connection's receive buffer after a remote close has been detected via a socket
   * write(). This race leads to such clients failing to process the response code sent by Envoy,
   * which could result in erroneous downstream processing.
   * If the timeout triggers, Envoy will close the connection's socket.
   * The default timeout is 1000 ms if this option is not specified.
   * .. NOTE::
   *    To be useful in avoiding the race condition described above, this timeout must be set
   *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
   *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
   * .. WARNING::
   *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
   *    connection's socket will be closed immediately after the write flush is completed or will
   *    never close if the write flush does not complete.
   * </pre>
   *
   * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getDelayedCloseTimeoutOrBuilder() {
    return delayedCloseTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : delayedCloseTimeout_;
  }

  public static final int ACCESS_LOG_FIELD_NUMBER = 13;
  @SuppressWarnings("serial")
  private java.util.List<io.envoyproxy.envoy.config.accesslog.v3.AccessLog> accessLog_;
  /**
   * <pre>
   * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
   * emitted by the connection manager.
   * </pre>
   *
   * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
   */
  @java.lang.Override
  public java.util.List<io.envoyproxy.envoy.config.accesslog.v3.AccessLog> getAccessLogList() {
    return accessLog_;
  }
  /**
   * <pre>
   * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
   * emitted by the connection manager.
   * </pre>
   *
   * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
   */
  @java.lang.Override
  public java.util.List<? extends io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder> 
      getAccessLogOrBuilderList() {
    return accessLog_;
  }
  /**
   * <pre>
   * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
   * emitted by the connection manager.
   * </pre>
   *
   * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
   */
  @java.lang.Override
  public int getAccessLogCount() {
    return accessLog_.size();
  }
  /**
   * <pre>
   * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
   * emitted by the connection manager.
   * </pre>
   *
   * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.accesslog.v3.AccessLog getAccessLog(int index) {
    return accessLog_.get(index);
  }
  /**
   * <pre>
   * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
   * emitted by the connection manager.
   * </pre>
   *
   * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder getAccessLogOrBuilder(
      int index) {
    return accessLog_.get(index);
  }

  public static final int USE_REMOTE_ADDRESS_FIELD_NUMBER = 14;
  private com.google.protobuf.BoolValue useRemoteAddress_;
  /**
   * <pre>
   * If set to true, the connection manager will use the real remote address
   * of the client connection when determining internal versus external origin and manipulating
   * various headers. If set to false or absent, the connection manager will use the
   * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
   * :ref:`config_http_conn_man_headers_x-forwarded-for`,
   * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
   * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
   * @return Whether the useRemoteAddress field is set.
   */
  @java.lang.Override
  public boolean hasUseRemoteAddress() {
    return useRemoteAddress_ != null;
  }
  /**
   * <pre>
   * If set to true, the connection manager will use the real remote address
   * of the client connection when determining internal versus external origin and manipulating
   * various headers. If set to false or absent, the connection manager will use the
   * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
   * :ref:`config_http_conn_man_headers_x-forwarded-for`,
   * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
   * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
   * @return The useRemoteAddress.
   */
  @java.lang.Override
  public com.google.protobuf.BoolValue getUseRemoteAddress() {
    return useRemoteAddress_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : useRemoteAddress_;
  }
  /**
   * <pre>
   * If set to true, the connection manager will use the real remote address
   * of the client connection when determining internal versus external origin and manipulating
   * various headers. If set to false or absent, the connection manager will use the
   * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
   * :ref:`config_http_conn_man_headers_x-forwarded-for`,
   * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
   * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
   */
  @java.lang.Override
  public com.google.protobuf.BoolValueOrBuilder getUseRemoteAddressOrBuilder() {
    return useRemoteAddress_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : useRemoteAddress_;
  }

  public static final int XFF_NUM_TRUSTED_HOPS_FIELD_NUMBER = 19;
  private int xffNumTrustedHops_ = 0;
  /**
   * <pre>
   * The number of additional ingress proxy hops from the right side of the
   * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
   * determining the origin client's IP address. The default is zero if this option
   * is not specified. See the documentation for
   * :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
   * </pre>
   *
   * <code>uint32 xff_num_trusted_hops = 19;</code>
   * @return The xffNumTrustedHops.
   */
  @java.lang.Override
  public int getXffNumTrustedHops() {
    return xffNumTrustedHops_;
  }

  public static final int ORIGINAL_IP_DETECTION_EXTENSIONS_FIELD_NUMBER = 46;
  @SuppressWarnings("serial")
  private java.util.List<io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig> originalIpDetectionExtensions_;
  /**
   * <pre>
   * The configuration for the original IP detection extensions.
   * When configured the extensions will be called along with the request headers
   * and information about the downstream connection, such as the directly connected address.
   * Each extension will then use these parameters to decide the request's effective remote address.
   * If an extension fails to detect the original IP address and isn't configured to reject
   * the request, the HCM will try the remaining extensions until one succeeds or rejects
   * the request. If the request isn't rejected nor any extension succeeds, the HCM will
   * fallback to using the remote address.
   * .. WARNING::
   *    Extensions cannot be used in conjunction with :ref:`use_remote_address
   *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
   *    nor :ref:`xff_num_trusted_hops
   *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
   * [#extension-category: envoy.http.original_ip_detection]
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
   */
  @java.lang.Override
  public java.util.List<io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig> getOriginalIpDetectionExtensionsList() {
    return originalIpDetectionExtensions_;
  }
  /**
   * <pre>
   * The configuration for the original IP detection extensions.
   * When configured the extensions will be called along with the request headers
   * and information about the downstream connection, such as the directly connected address.
   * Each extension will then use these parameters to decide the request's effective remote address.
   * If an extension fails to detect the original IP address and isn't configured to reject
   * the request, the HCM will try the remaining extensions until one succeeds or rejects
   * the request. If the request isn't rejected nor any extension succeeds, the HCM will
   * fallback to using the remote address.
   * .. WARNING::
   *    Extensions cannot be used in conjunction with :ref:`use_remote_address
   *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
   *    nor :ref:`xff_num_trusted_hops
   *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
   * [#extension-category: envoy.http.original_ip_detection]
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
   */
  @java.lang.Override
  public java.util.List<? extends io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder> 
      getOriginalIpDetectionExtensionsOrBuilderList() {
    return originalIpDetectionExtensions_;
  }
  /**
   * <pre>
   * The configuration for the original IP detection extensions.
   * When configured the extensions will be called along with the request headers
   * and information about the downstream connection, such as the directly connected address.
   * Each extension will then use these parameters to decide the request's effective remote address.
   * If an extension fails to detect the original IP address and isn't configured to reject
   * the request, the HCM will try the remaining extensions until one succeeds or rejects
   * the request. If the request isn't rejected nor any extension succeeds, the HCM will
   * fallback to using the remote address.
   * .. WARNING::
   *    Extensions cannot be used in conjunction with :ref:`use_remote_address
   *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
   *    nor :ref:`xff_num_trusted_hops
   *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
   * [#extension-category: envoy.http.original_ip_detection]
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
   */
  @java.lang.Override
  public int getOriginalIpDetectionExtensionsCount() {
    return originalIpDetectionExtensions_.size();
  }
  /**
   * <pre>
   * The configuration for the original IP detection extensions.
   * When configured the extensions will be called along with the request headers
   * and information about the downstream connection, such as the directly connected address.
   * Each extension will then use these parameters to decide the request's effective remote address.
   * If an extension fails to detect the original IP address and isn't configured to reject
   * the request, the HCM will try the remaining extensions until one succeeds or rejects
   * the request. If the request isn't rejected nor any extension succeeds, the HCM will
   * fallback to using the remote address.
   * .. WARNING::
   *    Extensions cannot be used in conjunction with :ref:`use_remote_address
   *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
   *    nor :ref:`xff_num_trusted_hops
   *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
   * [#extension-category: envoy.http.original_ip_detection]
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig getOriginalIpDetectionExtensions(int index) {
    return originalIpDetectionExtensions_.get(index);
  }
  /**
   * <pre>
   * The configuration for the original IP detection extensions.
   * When configured the extensions will be called along with the request headers
   * and information about the downstream connection, such as the directly connected address.
   * Each extension will then use these parameters to decide the request's effective remote address.
   * If an extension fails to detect the original IP address and isn't configured to reject
   * the request, the HCM will try the remaining extensions until one succeeds or rejects
   * the request. If the request isn't rejected nor any extension succeeds, the HCM will
   * fallback to using the remote address.
   * .. WARNING::
   *    Extensions cannot be used in conjunction with :ref:`use_remote_address
   *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
   *    nor :ref:`xff_num_trusted_hops
   *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
   * [#extension-category: envoy.http.original_ip_detection]
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder getOriginalIpDetectionExtensionsOrBuilder(
      int index) {
    return originalIpDetectionExtensions_.get(index);
  }

  public static final int EARLY_HEADER_MUTATION_EXTENSIONS_FIELD_NUMBER = 52;
  @SuppressWarnings("serial")
  private java.util.List<io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig> earlyHeaderMutationExtensions_;
  /**
   * <pre>
   * The configuration for the early header mutation extensions.
   * When configured the extensions will be called before any routing, tracing, or any filter processing.
   * Each extension will be applied in the order they are configured.
   * If the same header is mutated by multiple extensions, then the last extension will win.
   * [#extension-category: envoy.http.early_header_mutation]
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
   */
  @java.lang.Override
  public java.util.List<io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig> getEarlyHeaderMutationExtensionsList() {
    return earlyHeaderMutationExtensions_;
  }
  /**
   * <pre>
   * The configuration for the early header mutation extensions.
   * When configured the extensions will be called before any routing, tracing, or any filter processing.
   * Each extension will be applied in the order they are configured.
   * If the same header is mutated by multiple extensions, then the last extension will win.
   * [#extension-category: envoy.http.early_header_mutation]
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
   */
  @java.lang.Override
  public java.util.List<? extends io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder> 
      getEarlyHeaderMutationExtensionsOrBuilderList() {
    return earlyHeaderMutationExtensions_;
  }
  /**
   * <pre>
   * The configuration for the early header mutation extensions.
   * When configured the extensions will be called before any routing, tracing, or any filter processing.
   * Each extension will be applied in the order they are configured.
   * If the same header is mutated by multiple extensions, then the last extension will win.
   * [#extension-category: envoy.http.early_header_mutation]
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
   */
  @java.lang.Override
  public int getEarlyHeaderMutationExtensionsCount() {
    return earlyHeaderMutationExtensions_.size();
  }
  /**
   * <pre>
   * The configuration for the early header mutation extensions.
   * When configured the extensions will be called before any routing, tracing, or any filter processing.
   * Each extension will be applied in the order they are configured.
   * If the same header is mutated by multiple extensions, then the last extension will win.
   * [#extension-category: envoy.http.early_header_mutation]
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig getEarlyHeaderMutationExtensions(int index) {
    return earlyHeaderMutationExtensions_.get(index);
  }
  /**
   * <pre>
   * The configuration for the early header mutation extensions.
   * When configured the extensions will be called before any routing, tracing, or any filter processing.
   * Each extension will be applied in the order they are configured.
   * If the same header is mutated by multiple extensions, then the last extension will win.
   * [#extension-category: envoy.http.early_header_mutation]
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder getEarlyHeaderMutationExtensionsOrBuilder(
      int index) {
    return earlyHeaderMutationExtensions_.get(index);
  }

  public static final int INTERNAL_ADDRESS_CONFIG_FIELD_NUMBER = 25;
  private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internalAddressConfig_;
  /**
   * <pre>
   * Configures what network addresses are considered internal for stats and header sanitation
   * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
   * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
   * information about internal/external addresses.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
   * @return Whether the internalAddressConfig field is set.
   */
  @java.lang.Override
  public boolean hasInternalAddressConfig() {
    return internalAddressConfig_ != null;
  }
  /**
   * <pre>
   * Configures what network addresses are considered internal for stats and header sanitation
   * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
   * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
   * information about internal/external addresses.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
   * @return The internalAddressConfig.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig getInternalAddressConfig() {
    return internalAddressConfig_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.getDefaultInstance() : internalAddressConfig_;
  }
  /**
   * <pre>
   * Configures what network addresses are considered internal for stats and header sanitation
   * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
   * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
   * information about internal/external addresses.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfigOrBuilder getInternalAddressConfigOrBuilder() {
    return internalAddressConfig_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.getDefaultInstance() : internalAddressConfig_;
  }

  public static final int SKIP_XFF_APPEND_FIELD_NUMBER = 21;
  private boolean skipXffAppend_ = false;
  /**
   * <pre>
   * If set, Envoy will not append the remote address to the
   * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. This may be used in
   * conjunction with HTTP filters that explicitly manipulate XFF after the HTTP connection manager
   * has mutated the request headers. While :ref:`use_remote_address
   * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
   * will also suppress XFF addition, it has consequences for logging and other
   * Envoy uses of the remote address, so ``skip_xff_append`` should be used
   * when only an elision of XFF addition is intended.
   * </pre>
   *
   * <code>bool skip_xff_append = 21;</code>
   * @return The skipXffAppend.
   */
  @java.lang.Override
  public boolean getSkipXffAppend() {
    return skipXffAppend_;
  }

  public static final int VIA_FIELD_NUMBER = 22;
  @SuppressWarnings("serial")
  private volatile java.lang.Object via_ = "";
  /**
   * <pre>
   * Via header value to append to request and response headers. If this is
   * empty, no via header will be appended.
   * </pre>
   *
   * <code>string via = 22 [(.validate.rules) = { ... }</code>
   * @return The via.
   */
  @java.lang.Override
  public java.lang.String getVia() {
    java.lang.Object ref = via_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      via_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Via header value to append to request and response headers. If this is
   * empty, no via header will be appended.
   * </pre>
   *
   * <code>string via = 22 [(.validate.rules) = { ... }</code>
   * @return The bytes for via.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getViaBytes() {
    java.lang.Object ref = via_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      via_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int GENERATE_REQUEST_ID_FIELD_NUMBER = 15;
  private com.google.protobuf.BoolValue generateRequestId_;
  /**
   * <pre>
   * Whether the connection manager will generate the :ref:`x-request-id
   * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
   * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
   * is not desired it can be disabled.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
   * @return Whether the generateRequestId field is set.
   */
  @java.lang.Override
  public boolean hasGenerateRequestId() {
    return generateRequestId_ != null;
  }
  /**
   * <pre>
   * Whether the connection manager will generate the :ref:`x-request-id
   * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
   * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
   * is not desired it can be disabled.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
   * @return The generateRequestId.
   */
  @java.lang.Override
  public com.google.protobuf.BoolValue getGenerateRequestId() {
    return generateRequestId_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : generateRequestId_;
  }
  /**
   * <pre>
   * Whether the connection manager will generate the :ref:`x-request-id
   * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
   * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
   * is not desired it can be disabled.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
   */
  @java.lang.Override
  public com.google.protobuf.BoolValueOrBuilder getGenerateRequestIdOrBuilder() {
    return generateRequestId_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : generateRequestId_;
  }

  public static final int PRESERVE_EXTERNAL_REQUEST_ID_FIELD_NUMBER = 32;
  private boolean preserveExternalRequestId_ = false;
  /**
   * <pre>
   * Whether the connection manager will keep the :ref:`x-request-id
   * &lt;config_http_conn_man_headers_x-request-id&gt;` header if passed for a request that is edge
   * (Edge request is the request from external clients to front Envoy) and not reset it, which
   * is the current Envoy behaviour. This defaults to false.
   * </pre>
   *
   * <code>bool preserve_external_request_id = 32;</code>
   * @return The preserveExternalRequestId.
   */
  @java.lang.Override
  public boolean getPreserveExternalRequestId() {
    return preserveExternalRequestId_;
  }

  public static final int ALWAYS_SET_REQUEST_ID_IN_RESPONSE_FIELD_NUMBER = 37;
  private boolean alwaysSetRequestIdInResponse_ = false;
  /**
   * <pre>
   * If set, Envoy will always set :ref:`x-request-id &lt;config_http_conn_man_headers_x-request-id&gt;` header in response.
   * If this is false or not set, the request ID is returned in responses only if tracing is forced using
   * :ref:`x-envoy-force-trace &lt;config_http_conn_man_headers_x-envoy-force-trace&gt;` header.
   * </pre>
   *
   * <code>bool always_set_request_id_in_response = 37;</code>
   * @return The alwaysSetRequestIdInResponse.
   */
  @java.lang.Override
  public boolean getAlwaysSetRequestIdInResponse() {
    return alwaysSetRequestIdInResponse_;
  }

  public static final int FORWARD_CLIENT_CERT_DETAILS_FIELD_NUMBER = 16;
  private int forwardClientCertDetails_ = 0;
  /**
   * <pre>
   * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
   * header.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails forward_client_cert_details = 16 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for forwardClientCertDetails.
   */
  @java.lang.Override public int getForwardClientCertDetailsValue() {
    return forwardClientCertDetails_;
  }
  /**
   * <pre>
   * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
   * header.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails forward_client_cert_details = 16 [(.validate.rules) = { ... }</code>
   * @return The forwardClientCertDetails.
   */
  @java.lang.Override public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails getForwardClientCertDetails() {
    io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails result = io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails.forNumber(forwardClientCertDetails_);
    return result == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails.UNRECOGNIZED : result;
  }

  public static final int SET_CURRENT_CLIENT_CERT_DETAILS_FIELD_NUMBER = 17;
  private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails setCurrentClientCertDetails_;
  /**
   * <pre>
   * This field is valid only when :ref:`forward_client_cert_details
   * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
   * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
   * the client certificate to be forwarded. Note that in the
   * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, ``Hash`` is always set, and
   * ``By`` is always set when the client certificate presents the URI type Subject Alternative Name
   * value.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
   * @return Whether the setCurrentClientCertDetails field is set.
   */
  @java.lang.Override
  public boolean hasSetCurrentClientCertDetails() {
    return setCurrentClientCertDetails_ != null;
  }
  /**
   * <pre>
   * This field is valid only when :ref:`forward_client_cert_details
   * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
   * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
   * the client certificate to be forwarded. Note that in the
   * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, ``Hash`` is always set, and
   * ``By`` is always set when the client certificate presents the URI type Subject Alternative Name
   * value.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
   * @return The setCurrentClientCertDetails.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails getSetCurrentClientCertDetails() {
    return setCurrentClientCertDetails_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.getDefaultInstance() : setCurrentClientCertDetails_;
  }
  /**
   * <pre>
   * This field is valid only when :ref:`forward_client_cert_details
   * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
   * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
   * the client certificate to be forwarded. Note that in the
   * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, ``Hash`` is always set, and
   * ``By`` is always set when the client certificate presents the URI type Subject Alternative Name
   * value.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetailsOrBuilder getSetCurrentClientCertDetailsOrBuilder() {
    return setCurrentClientCertDetails_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.getDefaultInstance() : setCurrentClientCertDetails_;
  }

  public static final int PROXY_100_CONTINUE_FIELD_NUMBER = 18;
  private boolean proxy100Continue_ = false;
  /**
   * <pre>
   * If proxy_100_continue is true, Envoy will proxy incoming "Expect:
   * 100-continue" headers upstream, and forward "100 Continue" responses
   * downstream. If this is false or not set, Envoy will instead strip the
   * "Expect: 100-continue" header, and send a "100 Continue" response itself.
   * </pre>
   *
   * <code>bool proxy_100_continue = 18;</code>
   * @return The proxy100Continue.
   */
  @java.lang.Override
  public boolean getProxy100Continue() {
    return proxy100Continue_;
  }

  public static final int REPRESENT_IPV4_REMOTE_ADDRESS_AS_IPV4_MAPPED_IPV6_FIELD_NUMBER = 20;
  private boolean representIpv4RemoteAddressAsIpv4MappedIpv6_ = false;
  /**
   * <pre>
   * If
   * :ref:`use_remote_address
   * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
   * is true and represent_ipv4_remote_address_as_ipv4_mapped_ipv6 is true and the remote address is
   * an IPv4 address, the address will be mapped to IPv6 before it is appended to ``x-forwarded-for``.
   * This is useful for testing compatibility of upstream services that parse the header value. For
   * example, 50.0.0.1 is represented as ::FFFF:50.0.0.1. See `IPv4-Mapped IPv6 Addresses
   * &lt;https://tools.ietf.org/html/rfc4291#section-2.5.5.2&gt;`_ for details. This will also affect the
   * :ref:`config_http_conn_man_headers_x-envoy-external-address` header. See
   * :ref:`http_connection_manager.represent_ipv4_remote_address_as_ipv4_mapped_ipv6
   * &lt;config_http_conn_man_runtime_represent_ipv4_remote_address_as_ipv4_mapped_ipv6&gt;` for runtime
   * control.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>bool represent_ipv4_remote_address_as_ipv4_mapped_ipv6 = 20;</code>
   * @return The representIpv4RemoteAddressAsIpv4MappedIpv6.
   */
  @java.lang.Override
  public boolean getRepresentIpv4RemoteAddressAsIpv4MappedIpv6() {
    return representIpv4RemoteAddressAsIpv4MappedIpv6_;
  }

  public static final int UPGRADE_CONFIGS_FIELD_NUMBER = 23;
  @SuppressWarnings("serial")
  private java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig> upgradeConfigs_;
  /**
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
   */
  @java.lang.Override
  public java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig> getUpgradeConfigsList() {
    return upgradeConfigs_;
  }
  /**
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
   */
  @java.lang.Override
  public java.util.List<? extends io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfigOrBuilder> 
      getUpgradeConfigsOrBuilderList() {
    return upgradeConfigs_;
  }
  /**
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
   */
  @java.lang.Override
  public int getUpgradeConfigsCount() {
    return upgradeConfigs_.size();
  }
  /**
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig getUpgradeConfigs(int index) {
    return upgradeConfigs_.get(index);
  }
  /**
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfigOrBuilder getUpgradeConfigsOrBuilder(
      int index) {
    return upgradeConfigs_.get(index);
  }

  public static final int NORMALIZE_PATH_FIELD_NUMBER = 30;
  private com.google.protobuf.BoolValue normalizePath_;
  /**
   * <pre>
   * Should paths be normalized according to RFC 3986 before any processing of
   * requests by HTTP filters or routing? This affects the upstream ``:path`` header
   * as well. For paths that fail this check, Envoy will respond with 400 to
   * paths that are malformed. This defaults to false currently but will default
   * true in the future. When not specified, this value may be overridden by the
   * runtime variable
   * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
   * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
   * for details of normalization.
   * Note that Envoy does not perform
   * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
   * [#comment:TODO: This field is ignored when the
   * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
   * is present.]
   * </pre>
   *
   * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
   * @return Whether the normalizePath field is set.
   */
  @java.lang.Override
  public boolean hasNormalizePath() {
    return normalizePath_ != null;
  }
  /**
   * <pre>
   * Should paths be normalized according to RFC 3986 before any processing of
   * requests by HTTP filters or routing? This affects the upstream ``:path`` header
   * as well. For paths that fail this check, Envoy will respond with 400 to
   * paths that are malformed. This defaults to false currently but will default
   * true in the future. When not specified, this value may be overridden by the
   * runtime variable
   * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
   * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
   * for details of normalization.
   * Note that Envoy does not perform
   * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
   * [#comment:TODO: This field is ignored when the
   * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
   * is present.]
   * </pre>
   *
   * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
   * @return The normalizePath.
   */
  @java.lang.Override
  public com.google.protobuf.BoolValue getNormalizePath() {
    return normalizePath_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : normalizePath_;
  }
  /**
   * <pre>
   * Should paths be normalized according to RFC 3986 before any processing of
   * requests by HTTP filters or routing? This affects the upstream ``:path`` header
   * as well. For paths that fail this check, Envoy will respond with 400 to
   * paths that are malformed. This defaults to false currently but will default
   * true in the future. When not specified, this value may be overridden by the
   * runtime variable
   * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
   * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
   * for details of normalization.
   * Note that Envoy does not perform
   * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
   * [#comment:TODO: This field is ignored when the
   * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
   * is present.]
   * </pre>
   *
   * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
   */
  @java.lang.Override
  public com.google.protobuf.BoolValueOrBuilder getNormalizePathOrBuilder() {
    return normalizePath_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : normalizePath_;
  }

  public static final int MERGE_SLASHES_FIELD_NUMBER = 33;
  private boolean mergeSlashes_ = false;
  /**
   * <pre>
   * Determines if adjacent slashes in the path are merged into one before any processing of
   * requests by HTTP filters or routing. This affects the upstream ``:path`` header as well. Without
   * setting this option, incoming requests with path ``//dir///file`` will not match against route
   * with ``prefix`` match set to ``/dir``. Defaults to ``false``. Note that slash merging is not part of
   * `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
   * [#comment:TODO: This field is ignored when the
   * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
   * is present.]
   * </pre>
   *
   * <code>bool merge_slashes = 33;</code>
   * @return The mergeSlashes.
   */
  @java.lang.Override
  public boolean getMergeSlashes() {
    return mergeSlashes_;
  }

  public static final int PATH_WITH_ESCAPED_SLASHES_ACTION_FIELD_NUMBER = 45;
  private int pathWithEscapedSlashesAction_ = 0;
  /**
   * <pre>
   * Action to take when request URL path contains escaped slash sequences (%2F, %2f, %5C and %5c).
   * The default value can be overridden by the :ref:`http_connection_manager.path_with_escaped_slashes_action&lt;config_http_conn_man_runtime_path_with_escaped_slashes_action&gt;`
   * runtime variable.
   * The :ref:`http_connection_manager.path_with_escaped_slashes_action_sampling&lt;config_http_conn_man_runtime_path_with_escaped_slashes_action_enabled&gt;` runtime
   * variable can be used to apply the action to a portion of all requests.
   * [#comment:TODO: This field is ignored when the
   * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
   * is present.]
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction path_with_escaped_slashes_action = 45;</code>
   * @return The enum numeric value on the wire for pathWithEscapedSlashesAction.
   */
  @java.lang.Override public int getPathWithEscapedSlashesActionValue() {
    return pathWithEscapedSlashesAction_;
  }
  /**
   * <pre>
   * Action to take when request URL path contains escaped slash sequences (%2F, %2f, %5C and %5c).
   * The default value can be overridden by the :ref:`http_connection_manager.path_with_escaped_slashes_action&lt;config_http_conn_man_runtime_path_with_escaped_slashes_action&gt;`
   * runtime variable.
   * The :ref:`http_connection_manager.path_with_escaped_slashes_action_sampling&lt;config_http_conn_man_runtime_path_with_escaped_slashes_action_enabled&gt;` runtime
   * variable can be used to apply the action to a portion of all requests.
   * [#comment:TODO: This field is ignored when the
   * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
   * is present.]
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction path_with_escaped_slashes_action = 45;</code>
   * @return The pathWithEscapedSlashesAction.
   */
  @java.lang.Override public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction getPathWithEscapedSlashesAction() {
    io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction result = io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction.forNumber(pathWithEscapedSlashesAction_);
    return result == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction.UNRECOGNIZED : result;
  }

  public static final int REQUEST_ID_EXTENSION_FIELD_NUMBER = 36;
  private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension requestIdExtension_;
  /**
   * <pre>
   * The configuration of the request ID extension. This includes operations such as
   * generation, validation, and associated tracing operations. If empty, the
   * :ref:`UuidRequestIdConfig &lt;envoy_v3_api_msg_extensions.request_id.uuid.v3.UuidRequestIdConfig&gt;`
   * default extension is used with default parameters. See the documentation for that extension
   * for details on what it does. Customizing the configuration for the default extension can be
   * achieved by configuring it explicitly here. For example, to disable trace reason packing,
   * the following configuration can be used:
   * .. validated-code-block:: yaml
   *   :type-name: envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension
   *   typed_config:
   *     "&#64;type": type.googleapis.com/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig
   *     pack_trace_reason: false
   * [#extension-category: envoy.request_id]
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
   * @return Whether the requestIdExtension field is set.
   */
  @java.lang.Override
  public boolean hasRequestIdExtension() {
    return requestIdExtension_ != null;
  }
  /**
   * <pre>
   * The configuration of the request ID extension. This includes operations such as
   * generation, validation, and associated tracing operations. If empty, the
   * :ref:`UuidRequestIdConfig &lt;envoy_v3_api_msg_extensions.request_id.uuid.v3.UuidRequestIdConfig&gt;`
   * default extension is used with default parameters. See the documentation for that extension
   * for details on what it does. Customizing the configuration for the default extension can be
   * achieved by configuring it explicitly here. For example, to disable trace reason packing,
   * the following configuration can be used:
   * .. validated-code-block:: yaml
   *   :type-name: envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension
   *   typed_config:
   *     "&#64;type": type.googleapis.com/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig
   *     pack_trace_reason: false
   * [#extension-category: envoy.request_id]
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
   * @return The requestIdExtension.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension getRequestIdExtension() {
    return requestIdExtension_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension.getDefaultInstance() : requestIdExtension_;
  }
  /**
   * <pre>
   * The configuration of the request ID extension. This includes operations such as
   * generation, validation, and associated tracing operations. If empty, the
   * :ref:`UuidRequestIdConfig &lt;envoy_v3_api_msg_extensions.request_id.uuid.v3.UuidRequestIdConfig&gt;`
   * default extension is used with default parameters. See the documentation for that extension
   * for details on what it does. Customizing the configuration for the default extension can be
   * achieved by configuring it explicitly here. For example, to disable trace reason packing,
   * the following configuration can be used:
   * .. validated-code-block:: yaml
   *   :type-name: envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension
   *   typed_config:
   *     "&#64;type": type.googleapis.com/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig
   *     pack_trace_reason: false
   * [#extension-category: envoy.request_id]
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtensionOrBuilder getRequestIdExtensionOrBuilder() {
    return requestIdExtension_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension.getDefaultInstance() : requestIdExtension_;
  }

  public static final int LOCAL_REPLY_CONFIG_FIELD_NUMBER = 38;
  private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig localReplyConfig_;
  /**
   * <pre>
   * The configuration to customize local reply returned by Envoy. It can customize status code,
   * body text and response content type. If not specified, status code and text body are hard
   * coded in Envoy, the response content type is plain text.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
   * @return Whether the localReplyConfig field is set.
   */
  @java.lang.Override
  public boolean hasLocalReplyConfig() {
    return localReplyConfig_ != null;
  }
  /**
   * <pre>
   * The configuration to customize local reply returned by Envoy. It can customize status code,
   * body text and response content type. If not specified, status code and text body are hard
   * coded in Envoy, the response content type is plain text.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
   * @return The localReplyConfig.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig getLocalReplyConfig() {
    return localReplyConfig_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.getDefaultInstance() : localReplyConfig_;
  }
  /**
   * <pre>
   * The configuration to customize local reply returned by Envoy. It can customize status code,
   * body text and response content type. If not specified, status code and text body are hard
   * coded in Envoy, the response content type is plain text.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfigOrBuilder getLocalReplyConfigOrBuilder() {
    return localReplyConfig_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.getDefaultInstance() : localReplyConfig_;
  }

  public static final int STRIP_MATCHING_HOST_PORT_FIELD_NUMBER = 39;
  private boolean stripMatchingHostPort_ = false;
  /**
   * <pre>
   * Determines if the port part should be removed from host/authority header before any processing
   * of request by HTTP filters or routing. The port would be removed only if it is equal to the :ref:`listener's&lt;envoy_v3_api_field_config.listener.v3.Listener.address&gt;`
   * local port. This affects the upstream host header unless the method is
   * CONNECT in which case if no filter adds a port the original port will be restored before headers are
   * sent upstream.
   * Without setting this option, incoming requests with host ``example:443`` will not match against
   * route with :ref:`domains&lt;envoy_v3_api_field_config.route.v3.VirtualHost.domains&gt;` match set to ``example``. Defaults to ``false``. Note that port removal is not part
   * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
   * Only one of ``strip_matching_host_port`` or ``strip_any_host_port`` can be set.
   * </pre>
   *
   * <code>bool strip_matching_host_port = 39 [(.udpa.annotations.field_migrate) = { ... }</code>
   * @return The stripMatchingHostPort.
   */
  @java.lang.Override
  public boolean getStripMatchingHostPort() {
    return stripMatchingHostPort_;
  }

  public static final int STRIP_ANY_HOST_PORT_FIELD_NUMBER = 42;
  /**
   * <pre>
   * Determines if the port part should be removed from host/authority header before any processing
   * of request by HTTP filters or routing.
   * This affects the upstream host header unless the method is CONNECT in
   * which case if no filter adds a port the original port will be restored before headers are sent upstream.
   * Without setting this option, incoming requests with host ``example:443`` will not match against
   * route with :ref:`domains&lt;envoy_v3_api_field_config.route.v3.VirtualHost.domains&gt;` match set to ``example``. Defaults to ``false``. Note that port removal is not part
   * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
   * Only one of ``strip_matching_host_port`` or ``strip_any_host_port`` can be set.
   * </pre>
   *
   * <code>bool strip_any_host_port = 42;</code>
   * @return Whether the stripAnyHostPort field is set.
   */
  @java.lang.Override
  public boolean hasStripAnyHostPort() {
    return stripPortModeCase_ == 42;
  }
  /**
   * <pre>
   * Determines if the port part should be removed from host/authority header before any processing
   * of request by HTTP filters or routing.
   * This affects the upstream host header unless the method is CONNECT in
   * which case if no filter adds a port the original port will be restored before headers are sent upstream.
   * Without setting this option, incoming requests with host ``example:443`` will not match against
   * route with :ref:`domains&lt;envoy_v3_api_field_config.route.v3.VirtualHost.domains&gt;` match set to ``example``. Defaults to ``false``. Note that port removal is not part
   * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
   * Only one of ``strip_matching_host_port`` or ``strip_any_host_port`` can be set.
   * </pre>
   *
   * <code>bool strip_any_host_port = 42;</code>
   * @return The stripAnyHostPort.
   */
  @java.lang.Override
  public boolean getStripAnyHostPort() {
    if (stripPortModeCase_ == 42) {
      return (java.lang.Boolean) stripPortMode_;
    }
    return false;
  }

  public static final int STREAM_ERROR_ON_INVALID_HTTP_MESSAGE_FIELD_NUMBER = 40;
  private com.google.protobuf.BoolValue streamErrorOnInvalidHttpMessage_;
  /**
   * <pre>
   * Governs Envoy's behavior when receiving invalid HTTP from downstream.
   * If this option is false (default), Envoy will err on the conservative side handling HTTP
   * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
   * If this option is set to true, Envoy will be more permissive, only resetting the invalid
   * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
   * request is read for HTTP/1.1)
   * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
   * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
   * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
   * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
   * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
   * :ref:`override_stream_error_on_invalid_http_message
   * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
   * ``not`` the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
   * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
   * </pre>
   *
   * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
   * @return Whether the streamErrorOnInvalidHttpMessage field is set.
   */
  @java.lang.Override
  public boolean hasStreamErrorOnInvalidHttpMessage() {
    return streamErrorOnInvalidHttpMessage_ != null;
  }
  /**
   * <pre>
   * Governs Envoy's behavior when receiving invalid HTTP from downstream.
   * If this option is false (default), Envoy will err on the conservative side handling HTTP
   * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
   * If this option is set to true, Envoy will be more permissive, only resetting the invalid
   * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
   * request is read for HTTP/1.1)
   * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
   * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
   * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
   * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
   * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
   * :ref:`override_stream_error_on_invalid_http_message
   * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
   * ``not`` the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
   * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
   * </pre>
   *
   * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
   * @return The streamErrorOnInvalidHttpMessage.
   */
  @java.lang.Override
  public com.google.protobuf.BoolValue getStreamErrorOnInvalidHttpMessage() {
    return streamErrorOnInvalidHttpMessage_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : streamErrorOnInvalidHttpMessage_;
  }
  /**
   * <pre>
   * Governs Envoy's behavior when receiving invalid HTTP from downstream.
   * If this option is false (default), Envoy will err on the conservative side handling HTTP
   * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
   * If this option is set to true, Envoy will be more permissive, only resetting the invalid
   * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
   * request is read for HTTP/1.1)
   * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
   * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
   * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
   * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
   * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
   * :ref:`override_stream_error_on_invalid_http_message
   * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
   * ``not`` the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
   * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
   * </pre>
   *
   * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
   */
  @java.lang.Override
  public com.google.protobuf.BoolValueOrBuilder getStreamErrorOnInvalidHttpMessageOrBuilder() {
    return streamErrorOnInvalidHttpMessage_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : streamErrorOnInvalidHttpMessage_;
  }

  public static final int PATH_NORMALIZATION_OPTIONS_FIELD_NUMBER = 43;
  private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions pathNormalizationOptions_;
  /**
   * <pre>
   * [#not-implemented-hide:] Path normalization configuration. This includes
   * configurations for transformations (e.g. RFC 3986 normalization or merge
   * adjacent slashes) and the policy to apply them. The policy determines
   * whether transformations affect the forwarded ``:path`` header. RFC 3986 path
   * normalization is enabled by default and the default policy is that the
   * normalized header will be forwarded. See :ref:`PathNormalizationOptions
   * &lt;envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.PathNormalizationOptions&gt;`
   * for details.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions path_normalization_options = 43;</code>
   * @return Whether the pathNormalizationOptions field is set.
   */
  @java.lang.Override
  public boolean hasPathNormalizationOptions() {
    return pathNormalizationOptions_ != null;
  }
  /**
   * <pre>
   * [#not-implemented-hide:] Path normalization configuration. This includes
   * configurations for transformations (e.g. RFC 3986 normalization or merge
   * adjacent slashes) and the policy to apply them. The policy determines
   * whether transformations affect the forwarded ``:path`` header. RFC 3986 path
   * normalization is enabled by default and the default policy is that the
   * normalized header will be forwarded. See :ref:`PathNormalizationOptions
   * &lt;envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.PathNormalizationOptions&gt;`
   * for details.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions path_normalization_options = 43;</code>
   * @return The pathNormalizationOptions.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions getPathNormalizationOptions() {
    return pathNormalizationOptions_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions.getDefaultInstance() : pathNormalizationOptions_;
  }
  /**
   * <pre>
   * [#not-implemented-hide:] Path normalization configuration. This includes
   * configurations for transformations (e.g. RFC 3986 normalization or merge
   * adjacent slashes) and the policy to apply them. The policy determines
   * whether transformations affect the forwarded ``:path`` header. RFC 3986 path
   * normalization is enabled by default and the default policy is that the
   * normalized header will be forwarded. See :ref:`PathNormalizationOptions
   * &lt;envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.PathNormalizationOptions&gt;`
   * for details.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions path_normalization_options = 43;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptionsOrBuilder getPathNormalizationOptionsOrBuilder() {
    return pathNormalizationOptions_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions.getDefaultInstance() : pathNormalizationOptions_;
  }

  public static final int STRIP_TRAILING_HOST_DOT_FIELD_NUMBER = 47;
  private boolean stripTrailingHostDot_ = false;
  /**
   * <pre>
   * Determines if trailing dot of the host should be removed from host/authority header before any
   * processing of request by HTTP filters or routing.
   * This affects the upstream host header.
   * Without setting this option, incoming requests with host ``example.com.`` will not match against
   * route with :ref:`domains&lt;envoy_v3_api_field_config.route.v3.VirtualHost.domains&gt;` match set to ``example.com``. Defaults to ``false``.
   * When the incoming request contains a host/authority header that includes a port number,
   * setting this option will strip a trailing dot, if present, from the host section,
   * leaving the port as is (e.g. host value ``example.com.:443`` will be updated to ``example.com:443``).
   * </pre>
   *
   * <code>bool strip_trailing_host_dot = 47;</code>
   * @return The stripTrailingHostDot.
   */
  @java.lang.Override
  public boolean getStripTrailingHostDot() {
    return stripTrailingHostDot_;
  }

  public static final int PROXY_STATUS_CONFIG_FIELD_NUMBER = 49;
  private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig proxyStatusConfig_;
  /**
   * <pre>
   * Proxy-Status HTTP response header configuration.
   * If this config is set, the Proxy-Status HTTP response header field is
   * populated. By default, it is not.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig proxy_status_config = 49;</code>
   * @return Whether the proxyStatusConfig field is set.
   */
  @java.lang.Override
  public boolean hasProxyStatusConfig() {
    return proxyStatusConfig_ != null;
  }
  /**
   * <pre>
   * Proxy-Status HTTP response header configuration.
   * If this config is set, the Proxy-Status HTTP response header field is
   * populated. By default, it is not.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig proxy_status_config = 49;</code>
   * @return The proxyStatusConfig.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig getProxyStatusConfig() {
    return proxyStatusConfig_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig.getDefaultInstance() : proxyStatusConfig_;
  }
  /**
   * <pre>
   * Proxy-Status HTTP response header configuration.
   * If this config is set, the Proxy-Status HTTP response header field is
   * populated. By default, it is not.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig proxy_status_config = 49;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfigOrBuilder getProxyStatusConfigOrBuilder() {
    return proxyStatusConfig_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig.getDefaultInstance() : proxyStatusConfig_;
  }

  public static final int TYPED_HEADER_VALIDATION_CONFIG_FIELD_NUMBER = 50;
  private io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig typedHeaderValidationConfig_;
  /**
   * <pre>
   * Configuration options for Header Validation (UHV).
   * UHV is an extensible mechanism for checking validity of HTTP requests as well as providing
   * normalization for request attributes, such as URI path.
   * If the typed_header_validation_config is present it overrides the following options:
   * ``normalize_path``, ``merge_slashes``, ``path_with_escaped_slashes_action``
   * ``http_protocol_options.allow_chunked_length``, ``common_http_protocol_options.headers_with_underscores_action``.
   * The default UHV checks the following:
   * #. HTTP/1 header map validity according to `RFC 7230 section 3.2&lt;https://datatracker.ietf.org/doc/html/rfc7230#section-3.2&gt;`_
   * #. Syntax of HTTP/1 request target URI and response status
   * #. HTTP/2 header map validity according to `RFC 7540 section 8.1.2&lt;https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2`_
   * #. Syntax of HTTP/2 pseudo headers
   * #. HTTP/3 header map validity according to `RFC 9114 section 4.3 &lt;https://www.rfc-editor.org/rfc/rfc9114.html&gt;`_
   * #. Syntax of HTTP/3 pseudo headers
   * #. Syntax of ``Content-Length`` and ``Transfer-Encoding``
   * #. Validation of HTTP/1 requests with both ``Content-Length`` and ``Transfer-Encoding`` headers
   * #. Normalization of the URI path according to `Normalization and Comparison &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6&gt;`_
   *    without `case normalization &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1&gt;`_
   * [#not-implemented-hide:]
   * [#extension-category: envoy.http.header_validators]
   * </pre>
   *
   * <code>.envoy.config.core.v3.TypedExtensionConfig typed_header_validation_config = 50;</code>
   * @return Whether the typedHeaderValidationConfig field is set.
   */
  @java.lang.Override
  public boolean hasTypedHeaderValidationConfig() {
    return typedHeaderValidationConfig_ != null;
  }
  /**
   * <pre>
   * Configuration options for Header Validation (UHV).
   * UHV is an extensible mechanism for checking validity of HTTP requests as well as providing
   * normalization for request attributes, such as URI path.
   * If the typed_header_validation_config is present it overrides the following options:
   * ``normalize_path``, ``merge_slashes``, ``path_with_escaped_slashes_action``
   * ``http_protocol_options.allow_chunked_length``, ``common_http_protocol_options.headers_with_underscores_action``.
   * The default UHV checks the following:
   * #. HTTP/1 header map validity according to `RFC 7230 section 3.2&lt;https://datatracker.ietf.org/doc/html/rfc7230#section-3.2&gt;`_
   * #. Syntax of HTTP/1 request target URI and response status
   * #. HTTP/2 header map validity according to `RFC 7540 section 8.1.2&lt;https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2`_
   * #. Syntax of HTTP/2 pseudo headers
   * #. HTTP/3 header map validity according to `RFC 9114 section 4.3 &lt;https://www.rfc-editor.org/rfc/rfc9114.html&gt;`_
   * #. Syntax of HTTP/3 pseudo headers
   * #. Syntax of ``Content-Length`` and ``Transfer-Encoding``
   * #. Validation of HTTP/1 requests with both ``Content-Length`` and ``Transfer-Encoding`` headers
   * #. Normalization of the URI path according to `Normalization and Comparison &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6&gt;`_
   *    without `case normalization &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1&gt;`_
   * [#not-implemented-hide:]
   * [#extension-category: envoy.http.header_validators]
   * </pre>
   *
   * <code>.envoy.config.core.v3.TypedExtensionConfig typed_header_validation_config = 50;</code>
   * @return The typedHeaderValidationConfig.
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig getTypedHeaderValidationConfig() {
    return typedHeaderValidationConfig_ == null ? io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.getDefaultInstance() : typedHeaderValidationConfig_;
  }
  /**
   * <pre>
   * Configuration options for Header Validation (UHV).
   * UHV is an extensible mechanism for checking validity of HTTP requests as well as providing
   * normalization for request attributes, such as URI path.
   * If the typed_header_validation_config is present it overrides the following options:
   * ``normalize_path``, ``merge_slashes``, ``path_with_escaped_slashes_action``
   * ``http_protocol_options.allow_chunked_length``, ``common_http_protocol_options.headers_with_underscores_action``.
   * The default UHV checks the following:
   * #. HTTP/1 header map validity according to `RFC 7230 section 3.2&lt;https://datatracker.ietf.org/doc/html/rfc7230#section-3.2&gt;`_
   * #. Syntax of HTTP/1 request target URI and response status
   * #. HTTP/2 header map validity according to `RFC 7540 section 8.1.2&lt;https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2`_
   * #. Syntax of HTTP/2 pseudo headers
   * #. HTTP/3 header map validity according to `RFC 9114 section 4.3 &lt;https://www.rfc-editor.org/rfc/rfc9114.html&gt;`_
   * #. Syntax of HTTP/3 pseudo headers
   * #. Syntax of ``Content-Length`` and ``Transfer-Encoding``
   * #. Validation of HTTP/1 requests with both ``Content-Length`` and ``Transfer-Encoding`` headers
   * #. Normalization of the URI path according to `Normalization and Comparison &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6&gt;`_
   *    without `case normalization &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1&gt;`_
   * [#not-implemented-hide:]
   * [#extension-category: envoy.http.header_validators]
   * </pre>
   *
   * <code>.envoy.config.core.v3.TypedExtensionConfig typed_header_validation_config = 50;</code>
   */
  @java.lang.Override
  public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder getTypedHeaderValidationConfigOrBuilder() {
    return typedHeaderValidationConfig_ == null ? io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.getDefaultInstance() : typedHeaderValidationConfig_;
  }

  public static final int APPEND_X_FORWARDED_PORT_FIELD_NUMBER = 51;
  private boolean appendXForwardedPort_ = false;
  /**
   * <pre>
   * Append the `x-forwarded-port` header with the port value client used to connect to Envoy. It
   * will be ignored if the `x-forwarded-port` header has been set by any trusted proxy in front of Envoy.
   * </pre>
   *
   * <code>bool append_x_forwarded_port = 51;</code>
   * @return The appendXForwardedPort.
   */
  @java.lang.Override
  public boolean getAppendXForwardedPort() {
    return appendXForwardedPort_;
  }

  private byte memoizedIsInitialized = -1;
  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (codecType_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType.AUTO.getNumber()) {
      output.writeEnum(1, codecType_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(statPrefix_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 2, statPrefix_);
    }
    if (routeSpecifierCase_ == 3) {
      output.writeMessage(3, (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds) routeSpecifier_);
    }
    if (routeSpecifierCase_ == 4) {
      output.writeMessage(4, (io.envoyproxy.envoy.config.route.v3.RouteConfiguration) routeSpecifier_);
    }
    for (int i = 0; i < httpFilters_.size(); i++) {
      output.writeMessage(5, httpFilters_.get(i));
    }
    if (addUserAgent_ != null) {
      output.writeMessage(6, getAddUserAgent());
    }
    if (tracing_ != null) {
      output.writeMessage(7, getTracing());
    }
    if (httpProtocolOptions_ != null) {
      output.writeMessage(8, getHttpProtocolOptions());
    }
    if (http2ProtocolOptions_ != null) {
      output.writeMessage(9, getHttp2ProtocolOptions());
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(serverName_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 10, serverName_);
    }
    if (drainTimeout_ != null) {
      output.writeMessage(12, getDrainTimeout());
    }
    for (int i = 0; i < accessLog_.size(); i++) {
      output.writeMessage(13, accessLog_.get(i));
    }
    if (useRemoteAddress_ != null) {
      output.writeMessage(14, getUseRemoteAddress());
    }
    if (generateRequestId_ != null) {
      output.writeMessage(15, getGenerateRequestId());
    }
    if (forwardClientCertDetails_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails.SANITIZE.getNumber()) {
      output.writeEnum(16, forwardClientCertDetails_);
    }
    if (setCurrentClientCertDetails_ != null) {
      output.writeMessage(17, getSetCurrentClientCertDetails());
    }
    if (proxy100Continue_ != false) {
      output.writeBool(18, proxy100Continue_);
    }
    if (xffNumTrustedHops_ != 0) {
      output.writeUInt32(19, xffNumTrustedHops_);
    }
    if (representIpv4RemoteAddressAsIpv4MappedIpv6_ != false) {
      output.writeBool(20, representIpv4RemoteAddressAsIpv4MappedIpv6_);
    }
    if (skipXffAppend_ != false) {
      output.writeBool(21, skipXffAppend_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(via_)) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 22, via_);
    }
    for (int i = 0; i < upgradeConfigs_.size(); i++) {
      output.writeMessage(23, upgradeConfigs_.get(i));
    }
    if (streamIdleTimeout_ != null) {
      output.writeMessage(24, getStreamIdleTimeout());
    }
    if (internalAddressConfig_ != null) {
      output.writeMessage(25, getInternalAddressConfig());
    }
    if (delayedCloseTimeout_ != null) {
      output.writeMessage(26, getDelayedCloseTimeout());
    }
    if (requestTimeout_ != null) {
      output.writeMessage(28, getRequestTimeout());
    }
    if (maxRequestHeadersKb_ != null) {
      output.writeMessage(29, getMaxRequestHeadersKb());
    }
    if (normalizePath_ != null) {
      output.writeMessage(30, getNormalizePath());
    }
    if (routeSpecifierCase_ == 31) {
      output.writeMessage(31, (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes) routeSpecifier_);
    }
    if (preserveExternalRequestId_ != false) {
      output.writeBool(32, preserveExternalRequestId_);
    }
    if (mergeSlashes_ != false) {
      output.writeBool(33, mergeSlashes_);
    }
    if (serverHeaderTransformation_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation.OVERWRITE.getNumber()) {
      output.writeEnum(34, serverHeaderTransformation_);
    }
    if (commonHttpProtocolOptions_ != null) {
      output.writeMessage(35, getCommonHttpProtocolOptions());
    }
    if (requestIdExtension_ != null) {
      output.writeMessage(36, getRequestIdExtension());
    }
    if (alwaysSetRequestIdInResponse_ != false) {
      output.writeBool(37, alwaysSetRequestIdInResponse_);
    }
    if (localReplyConfig_ != null) {
      output.writeMessage(38, getLocalReplyConfig());
    }
    if (stripMatchingHostPort_ != false) {
      output.writeBool(39, stripMatchingHostPort_);
    }
    if (streamErrorOnInvalidHttpMessage_ != null) {
      output.writeMessage(40, getStreamErrorOnInvalidHttpMessage());
    }
    if (requestHeadersTimeout_ != null) {
      output.writeMessage(41, getRequestHeadersTimeout());
    }
    if (stripPortModeCase_ == 42) {
      output.writeBool(
          42, (boolean)((java.lang.Boolean) stripPortMode_));
    }
    if (pathNormalizationOptions_ != null) {
      output.writeMessage(43, getPathNormalizationOptions());
    }
    if (http3ProtocolOptions_ != null) {
      output.writeMessage(44, getHttp3ProtocolOptions());
    }
    if (pathWithEscapedSlashesAction_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction.IMPLEMENTATION_SPECIFIC_DEFAULT.getNumber()) {
      output.writeEnum(45, pathWithEscapedSlashesAction_);
    }
    for (int i = 0; i < originalIpDetectionExtensions_.size(); i++) {
      output.writeMessage(46, originalIpDetectionExtensions_.get(i));
    }
    if (stripTrailingHostDot_ != false) {
      output.writeBool(47, stripTrailingHostDot_);
    }
    if (schemeHeaderTransformation_ != null) {
      output.writeMessage(48, getSchemeHeaderTransformation());
    }
    if (proxyStatusConfig_ != null) {
      output.writeMessage(49, getProxyStatusConfig());
    }
    if (typedHeaderValidationConfig_ != null) {
      output.writeMessage(50, getTypedHeaderValidationConfig());
    }
    if (appendXForwardedPort_ != false) {
      output.writeBool(51, appendXForwardedPort_);
    }
    for (int i = 0; i < earlyHeaderMutationExtensions_.size(); i++) {
      output.writeMessage(52, earlyHeaderMutationExtensions_.get(i));
    }
    getUnknownFields().writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (codecType_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType.AUTO.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(1, codecType_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(statPrefix_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, statPrefix_);
    }
    if (routeSpecifierCase_ == 3) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(3, (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds) routeSpecifier_);
    }
    if (routeSpecifierCase_ == 4) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(4, (io.envoyproxy.envoy.config.route.v3.RouteConfiguration) routeSpecifier_);
    }
    for (int i = 0; i < httpFilters_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(5, httpFilters_.get(i));
    }
    if (addUserAgent_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(6, getAddUserAgent());
    }
    if (tracing_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(7, getTracing());
    }
    if (httpProtocolOptions_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(8, getHttpProtocolOptions());
    }
    if (http2ProtocolOptions_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(9, getHttp2ProtocolOptions());
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(serverName_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(10, serverName_);
    }
    if (drainTimeout_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(12, getDrainTimeout());
    }
    for (int i = 0; i < accessLog_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(13, accessLog_.get(i));
    }
    if (useRemoteAddress_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(14, getUseRemoteAddress());
    }
    if (generateRequestId_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(15, getGenerateRequestId());
    }
    if (forwardClientCertDetails_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails.SANITIZE.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(16, forwardClientCertDetails_);
    }
    if (setCurrentClientCertDetails_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(17, getSetCurrentClientCertDetails());
    }
    if (proxy100Continue_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(18, proxy100Continue_);
    }
    if (xffNumTrustedHops_ != 0) {
      size += com.google.protobuf.CodedOutputStream
        .computeUInt32Size(19, xffNumTrustedHops_);
    }
    if (representIpv4RemoteAddressAsIpv4MappedIpv6_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(20, representIpv4RemoteAddressAsIpv4MappedIpv6_);
    }
    if (skipXffAppend_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(21, skipXffAppend_);
    }
    if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(via_)) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(22, via_);
    }
    for (int i = 0; i < upgradeConfigs_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(23, upgradeConfigs_.get(i));
    }
    if (streamIdleTimeout_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(24, getStreamIdleTimeout());
    }
    if (internalAddressConfig_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(25, getInternalAddressConfig());
    }
    if (delayedCloseTimeout_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(26, getDelayedCloseTimeout());
    }
    if (requestTimeout_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(28, getRequestTimeout());
    }
    if (maxRequestHeadersKb_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(29, getMaxRequestHeadersKb());
    }
    if (normalizePath_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(30, getNormalizePath());
    }
    if (routeSpecifierCase_ == 31) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(31, (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes) routeSpecifier_);
    }
    if (preserveExternalRequestId_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(32, preserveExternalRequestId_);
    }
    if (mergeSlashes_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(33, mergeSlashes_);
    }
    if (serverHeaderTransformation_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation.OVERWRITE.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(34, serverHeaderTransformation_);
    }
    if (commonHttpProtocolOptions_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(35, getCommonHttpProtocolOptions());
    }
    if (requestIdExtension_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(36, getRequestIdExtension());
    }
    if (alwaysSetRequestIdInResponse_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(37, alwaysSetRequestIdInResponse_);
    }
    if (localReplyConfig_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(38, getLocalReplyConfig());
    }
    if (stripMatchingHostPort_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(39, stripMatchingHostPort_);
    }
    if (streamErrorOnInvalidHttpMessage_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(40, getStreamErrorOnInvalidHttpMessage());
    }
    if (requestHeadersTimeout_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(41, getRequestHeadersTimeout());
    }
    if (stripPortModeCase_ == 42) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(
            42, (boolean)((java.lang.Boolean) stripPortMode_));
    }
    if (pathNormalizationOptions_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(43, getPathNormalizationOptions());
    }
    if (http3ProtocolOptions_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(44, getHttp3ProtocolOptions());
    }
    if (pathWithEscapedSlashesAction_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction.IMPLEMENTATION_SPECIFIC_DEFAULT.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(45, pathWithEscapedSlashesAction_);
    }
    for (int i = 0; i < originalIpDetectionExtensions_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(46, originalIpDetectionExtensions_.get(i));
    }
    if (stripTrailingHostDot_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(47, stripTrailingHostDot_);
    }
    if (schemeHeaderTransformation_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(48, getSchemeHeaderTransformation());
    }
    if (proxyStatusConfig_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(49, getProxyStatusConfig());
    }
    if (typedHeaderValidationConfig_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(50, getTypedHeaderValidationConfig());
    }
    if (appendXForwardedPort_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(51, appendXForwardedPort_);
    }
    for (int i = 0; i < earlyHeaderMutationExtensions_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(52, earlyHeaderMutationExtensions_.get(i));
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
     return true;
    }
    if (!(obj instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager)) {
      return super.equals(obj);
    }
    io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager other = (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager) obj;

    if (codecType_ != other.codecType_) return false;
    if (!getStatPrefix()
        .equals(other.getStatPrefix())) return false;
    if (!getHttpFiltersList()
        .equals(other.getHttpFiltersList())) return false;
    if (hasAddUserAgent() != other.hasAddUserAgent()) return false;
    if (hasAddUserAgent()) {
      if (!getAddUserAgent()
          .equals(other.getAddUserAgent())) return false;
    }
    if (hasTracing() != other.hasTracing()) return false;
    if (hasTracing()) {
      if (!getTracing()
          .equals(other.getTracing())) return false;
    }
    if (hasCommonHttpProtocolOptions() != other.hasCommonHttpProtocolOptions()) return false;
    if (hasCommonHttpProtocolOptions()) {
      if (!getCommonHttpProtocolOptions()
          .equals(other.getCommonHttpProtocolOptions())) return false;
    }
    if (hasHttpProtocolOptions() != other.hasHttpProtocolOptions()) return false;
    if (hasHttpProtocolOptions()) {
      if (!getHttpProtocolOptions()
          .equals(other.getHttpProtocolOptions())) return false;
    }
    if (hasHttp2ProtocolOptions() != other.hasHttp2ProtocolOptions()) return false;
    if (hasHttp2ProtocolOptions()) {
      if (!getHttp2ProtocolOptions()
          .equals(other.getHttp2ProtocolOptions())) return false;
    }
    if (hasHttp3ProtocolOptions() != other.hasHttp3ProtocolOptions()) return false;
    if (hasHttp3ProtocolOptions()) {
      if (!getHttp3ProtocolOptions()
          .equals(other.getHttp3ProtocolOptions())) return false;
    }
    if (!getServerName()
        .equals(other.getServerName())) return false;
    if (serverHeaderTransformation_ != other.serverHeaderTransformation_) return false;
    if (hasSchemeHeaderTransformation() != other.hasSchemeHeaderTransformation()) return false;
    if (hasSchemeHeaderTransformation()) {
      if (!getSchemeHeaderTransformation()
          .equals(other.getSchemeHeaderTransformation())) return false;
    }
    if (hasMaxRequestHeadersKb() != other.hasMaxRequestHeadersKb()) return false;
    if (hasMaxRequestHeadersKb()) {
      if (!getMaxRequestHeadersKb()
          .equals(other.getMaxRequestHeadersKb())) return false;
    }
    if (hasStreamIdleTimeout() != other.hasStreamIdleTimeout()) return false;
    if (hasStreamIdleTimeout()) {
      if (!getStreamIdleTimeout()
          .equals(other.getStreamIdleTimeout())) return false;
    }
    if (hasRequestTimeout() != other.hasRequestTimeout()) return false;
    if (hasRequestTimeout()) {
      if (!getRequestTimeout()
          .equals(other.getRequestTimeout())) return false;
    }
    if (hasRequestHeadersTimeout() != other.hasRequestHeadersTimeout()) return false;
    if (hasRequestHeadersTimeout()) {
      if (!getRequestHeadersTimeout()
          .equals(other.getRequestHeadersTimeout())) return false;
    }
    if (hasDrainTimeout() != other.hasDrainTimeout()) return false;
    if (hasDrainTimeout()) {
      if (!getDrainTimeout()
          .equals(other.getDrainTimeout())) return false;
    }
    if (hasDelayedCloseTimeout() != other.hasDelayedCloseTimeout()) return false;
    if (hasDelayedCloseTimeout()) {
      if (!getDelayedCloseTimeout()
          .equals(other.getDelayedCloseTimeout())) return false;
    }
    if (!getAccessLogList()
        .equals(other.getAccessLogList())) return false;
    if (hasUseRemoteAddress() != other.hasUseRemoteAddress()) return false;
    if (hasUseRemoteAddress()) {
      if (!getUseRemoteAddress()
          .equals(other.getUseRemoteAddress())) return false;
    }
    if (getXffNumTrustedHops()
        != other.getXffNumTrustedHops()) return false;
    if (!getOriginalIpDetectionExtensionsList()
        .equals(other.getOriginalIpDetectionExtensionsList())) return false;
    if (!getEarlyHeaderMutationExtensionsList()
        .equals(other.getEarlyHeaderMutationExtensionsList())) return false;
    if (hasInternalAddressConfig() != other.hasInternalAddressConfig()) return false;
    if (hasInternalAddressConfig()) {
      if (!getInternalAddressConfig()
          .equals(other.getInternalAddressConfig())) return false;
    }
    if (getSkipXffAppend()
        != other.getSkipXffAppend()) return false;
    if (!getVia()
        .equals(other.getVia())) return false;
    if (hasGenerateRequestId() != other.hasGenerateRequestId()) return false;
    if (hasGenerateRequestId()) {
      if (!getGenerateRequestId()
          .equals(other.getGenerateRequestId())) return false;
    }
    if (getPreserveExternalRequestId()
        != other.getPreserveExternalRequestId()) return false;
    if (getAlwaysSetRequestIdInResponse()
        != other.getAlwaysSetRequestIdInResponse()) return false;
    if (forwardClientCertDetails_ != other.forwardClientCertDetails_) return false;
    if (hasSetCurrentClientCertDetails() != other.hasSetCurrentClientCertDetails()) return false;
    if (hasSetCurrentClientCertDetails()) {
      if (!getSetCurrentClientCertDetails()
          .equals(other.getSetCurrentClientCertDetails())) return false;
    }
    if (getProxy100Continue()
        != other.getProxy100Continue()) return false;
    if (getRepresentIpv4RemoteAddressAsIpv4MappedIpv6()
        != other.getRepresentIpv4RemoteAddressAsIpv4MappedIpv6()) return false;
    if (!getUpgradeConfigsList()
        .equals(other.getUpgradeConfigsList())) return false;
    if (hasNormalizePath() != other.hasNormalizePath()) return false;
    if (hasNormalizePath()) {
      if (!getNormalizePath()
          .equals(other.getNormalizePath())) return false;
    }
    if (getMergeSlashes()
        != other.getMergeSlashes()) return false;
    if (pathWithEscapedSlashesAction_ != other.pathWithEscapedSlashesAction_) return false;
    if (hasRequestIdExtension() != other.hasRequestIdExtension()) return false;
    if (hasRequestIdExtension()) {
      if (!getRequestIdExtension()
          .equals(other.getRequestIdExtension())) return false;
    }
    if (hasLocalReplyConfig() != other.hasLocalReplyConfig()) return false;
    if (hasLocalReplyConfig()) {
      if (!getLocalReplyConfig()
          .equals(other.getLocalReplyConfig())) return false;
    }
    if (getStripMatchingHostPort()
        != other.getStripMatchingHostPort()) return false;
    if (hasStreamErrorOnInvalidHttpMessage() != other.hasStreamErrorOnInvalidHttpMessage()) return false;
    if (hasStreamErrorOnInvalidHttpMessage()) {
      if (!getStreamErrorOnInvalidHttpMessage()
          .equals(other.getStreamErrorOnInvalidHttpMessage())) return false;
    }
    if (hasPathNormalizationOptions() != other.hasPathNormalizationOptions()) return false;
    if (hasPathNormalizationOptions()) {
      if (!getPathNormalizationOptions()
          .equals(other.getPathNormalizationOptions())) return false;
    }
    if (getStripTrailingHostDot()
        != other.getStripTrailingHostDot()) return false;
    if (hasProxyStatusConfig() != other.hasProxyStatusConfig()) return false;
    if (hasProxyStatusConfig()) {
      if (!getProxyStatusConfig()
          .equals(other.getProxyStatusConfig())) return false;
    }
    if (hasTypedHeaderValidationConfig() != other.hasTypedHeaderValidationConfig()) return false;
    if (hasTypedHeaderValidationConfig()) {
      if (!getTypedHeaderValidationConfig()
          .equals(other.getTypedHeaderValidationConfig())) return false;
    }
    if (getAppendXForwardedPort()
        != other.getAppendXForwardedPort()) return false;
    if (!getRouteSpecifierCase().equals(other.getRouteSpecifierCase())) return false;
    switch (routeSpecifierCase_) {
      case 3:
        if (!getRds()
            .equals(other.getRds())) return false;
        break;
      case 4:
        if (!getRouteConfig()
            .equals(other.getRouteConfig())) return false;
        break;
      case 31:
        if (!getScopedRoutes()
            .equals(other.getScopedRoutes())) return false;
        break;
      case 0:
      default:
    }
    if (!getStripPortModeCase().equals(other.getStripPortModeCase())) return false;
    switch (stripPortModeCase_) {
      case 42:
        if (getStripAnyHostPort()
            != other.getStripAnyHostPort()) return false;
        break;
      case 0:
      default:
    }
    if (!getUnknownFields().equals(other.getUnknownFields())) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    hash = (37 * hash) + CODEC_TYPE_FIELD_NUMBER;
    hash = (53 * hash) + codecType_;
    hash = (37 * hash) + STAT_PREFIX_FIELD_NUMBER;
    hash = (53 * hash) + getStatPrefix().hashCode();
    if (getHttpFiltersCount() > 0) {
      hash = (37 * hash) + HTTP_FILTERS_FIELD_NUMBER;
      hash = (53 * hash) + getHttpFiltersList().hashCode();
    }
    if (hasAddUserAgent()) {
      hash = (37 * hash) + ADD_USER_AGENT_FIELD_NUMBER;
      hash = (53 * hash) + getAddUserAgent().hashCode();
    }
    if (hasTracing()) {
      hash = (37 * hash) + TRACING_FIELD_NUMBER;
      hash = (53 * hash) + getTracing().hashCode();
    }
    if (hasCommonHttpProtocolOptions()) {
      hash = (37 * hash) + COMMON_HTTP_PROTOCOL_OPTIONS_FIELD_NUMBER;
      hash = (53 * hash) + getCommonHttpProtocolOptions().hashCode();
    }
    if (hasHttpProtocolOptions()) {
      hash = (37 * hash) + HTTP_PROTOCOL_OPTIONS_FIELD_NUMBER;
      hash = (53 * hash) + getHttpProtocolOptions().hashCode();
    }
    if (hasHttp2ProtocolOptions()) {
      hash = (37 * hash) + HTTP2_PROTOCOL_OPTIONS_FIELD_NUMBER;
      hash = (53 * hash) + getHttp2ProtocolOptions().hashCode();
    }
    if (hasHttp3ProtocolOptions()) {
      hash = (37 * hash) + HTTP3_PROTOCOL_OPTIONS_FIELD_NUMBER;
      hash = (53 * hash) + getHttp3ProtocolOptions().hashCode();
    }
    hash = (37 * hash) + SERVER_NAME_FIELD_NUMBER;
    hash = (53 * hash) + getServerName().hashCode();
    hash = (37 * hash) + SERVER_HEADER_TRANSFORMATION_FIELD_NUMBER;
    hash = (53 * hash) + serverHeaderTransformation_;
    if (hasSchemeHeaderTransformation()) {
      hash = (37 * hash) + SCHEME_HEADER_TRANSFORMATION_FIELD_NUMBER;
      hash = (53 * hash) + getSchemeHeaderTransformation().hashCode();
    }
    if (hasMaxRequestHeadersKb()) {
      hash = (37 * hash) + MAX_REQUEST_HEADERS_KB_FIELD_NUMBER;
      hash = (53 * hash) + getMaxRequestHeadersKb().hashCode();
    }
    if (hasStreamIdleTimeout()) {
      hash = (37 * hash) + STREAM_IDLE_TIMEOUT_FIELD_NUMBER;
      hash = (53 * hash) + getStreamIdleTimeout().hashCode();
    }
    if (hasRequestTimeout()) {
      hash = (37 * hash) + REQUEST_TIMEOUT_FIELD_NUMBER;
      hash = (53 * hash) + getRequestTimeout().hashCode();
    }
    if (hasRequestHeadersTimeout()) {
      hash = (37 * hash) + REQUEST_HEADERS_TIMEOUT_FIELD_NUMBER;
      hash = (53 * hash) + getRequestHeadersTimeout().hashCode();
    }
    if (hasDrainTimeout()) {
      hash = (37 * hash) + DRAIN_TIMEOUT_FIELD_NUMBER;
      hash = (53 * hash) + getDrainTimeout().hashCode();
    }
    if (hasDelayedCloseTimeout()) {
      hash = (37 * hash) + DELAYED_CLOSE_TIMEOUT_FIELD_NUMBER;
      hash = (53 * hash) + getDelayedCloseTimeout().hashCode();
    }
    if (getAccessLogCount() > 0) {
      hash = (37 * hash) + ACCESS_LOG_FIELD_NUMBER;
      hash = (53 * hash) + getAccessLogList().hashCode();
    }
    if (hasUseRemoteAddress()) {
      hash = (37 * hash) + USE_REMOTE_ADDRESS_FIELD_NUMBER;
      hash = (53 * hash) + getUseRemoteAddress().hashCode();
    }
    hash = (37 * hash) + XFF_NUM_TRUSTED_HOPS_FIELD_NUMBER;
    hash = (53 * hash) + getXffNumTrustedHops();
    if (getOriginalIpDetectionExtensionsCount() > 0) {
      hash = (37 * hash) + ORIGINAL_IP_DETECTION_EXTENSIONS_FIELD_NUMBER;
      hash = (53 * hash) + getOriginalIpDetectionExtensionsList().hashCode();
    }
    if (getEarlyHeaderMutationExtensionsCount() > 0) {
      hash = (37 * hash) + EARLY_HEADER_MUTATION_EXTENSIONS_FIELD_NUMBER;
      hash = (53 * hash) + getEarlyHeaderMutationExtensionsList().hashCode();
    }
    if (hasInternalAddressConfig()) {
      hash = (37 * hash) + INTERNAL_ADDRESS_CONFIG_FIELD_NUMBER;
      hash = (53 * hash) + getInternalAddressConfig().hashCode();
    }
    hash = (37 * hash) + SKIP_XFF_APPEND_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getSkipXffAppend());
    hash = (37 * hash) + VIA_FIELD_NUMBER;
    hash = (53 * hash) + getVia().hashCode();
    if (hasGenerateRequestId()) {
      hash = (37 * hash) + GENERATE_REQUEST_ID_FIELD_NUMBER;
      hash = (53 * hash) + getGenerateRequestId().hashCode();
    }
    hash = (37 * hash) + PRESERVE_EXTERNAL_REQUEST_ID_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getPreserveExternalRequestId());
    hash = (37 * hash) + ALWAYS_SET_REQUEST_ID_IN_RESPONSE_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getAlwaysSetRequestIdInResponse());
    hash = (37 * hash) + FORWARD_CLIENT_CERT_DETAILS_FIELD_NUMBER;
    hash = (53 * hash) + forwardClientCertDetails_;
    if (hasSetCurrentClientCertDetails()) {
      hash = (37 * hash) + SET_CURRENT_CLIENT_CERT_DETAILS_FIELD_NUMBER;
      hash = (53 * hash) + getSetCurrentClientCertDetails().hashCode();
    }
    hash = (37 * hash) + PROXY_100_CONTINUE_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getProxy100Continue());
    hash = (37 * hash) + REPRESENT_IPV4_REMOTE_ADDRESS_AS_IPV4_MAPPED_IPV6_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getRepresentIpv4RemoteAddressAsIpv4MappedIpv6());
    if (getUpgradeConfigsCount() > 0) {
      hash = (37 * hash) + UPGRADE_CONFIGS_FIELD_NUMBER;
      hash = (53 * hash) + getUpgradeConfigsList().hashCode();
    }
    if (hasNormalizePath()) {
      hash = (37 * hash) + NORMALIZE_PATH_FIELD_NUMBER;
      hash = (53 * hash) + getNormalizePath().hashCode();
    }
    hash = (37 * hash) + MERGE_SLASHES_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getMergeSlashes());
    hash = (37 * hash) + PATH_WITH_ESCAPED_SLASHES_ACTION_FIELD_NUMBER;
    hash = (53 * hash) + pathWithEscapedSlashesAction_;
    if (hasRequestIdExtension()) {
      hash = (37 * hash) + REQUEST_ID_EXTENSION_FIELD_NUMBER;
      hash = (53 * hash) + getRequestIdExtension().hashCode();
    }
    if (hasLocalReplyConfig()) {
      hash = (37 * hash) + LOCAL_REPLY_CONFIG_FIELD_NUMBER;
      hash = (53 * hash) + getLocalReplyConfig().hashCode();
    }
    hash = (37 * hash) + STRIP_MATCHING_HOST_PORT_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getStripMatchingHostPort());
    if (hasStreamErrorOnInvalidHttpMessage()) {
      hash = (37 * hash) + STREAM_ERROR_ON_INVALID_HTTP_MESSAGE_FIELD_NUMBER;
      hash = (53 * hash) + getStreamErrorOnInvalidHttpMessage().hashCode();
    }
    if (hasPathNormalizationOptions()) {
      hash = (37 * hash) + PATH_NORMALIZATION_OPTIONS_FIELD_NUMBER;
      hash = (53 * hash) + getPathNormalizationOptions().hashCode();
    }
    hash = (37 * hash) + STRIP_TRAILING_HOST_DOT_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getStripTrailingHostDot());
    if (hasProxyStatusConfig()) {
      hash = (37 * hash) + PROXY_STATUS_CONFIG_FIELD_NUMBER;
      hash = (53 * hash) + getProxyStatusConfig().hashCode();
    }
    if (hasTypedHeaderValidationConfig()) {
      hash = (37 * hash) + TYPED_HEADER_VALIDATION_CONFIG_FIELD_NUMBER;
      hash = (53 * hash) + getTypedHeaderValidationConfig().hashCode();
    }
    hash = (37 * hash) + APPEND_X_FORWARDED_PORT_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getAppendXForwardedPort());
    switch (routeSpecifierCase_) {
      case 3:
        hash = (37 * hash) + RDS_FIELD_NUMBER;
        hash = (53 * hash) + getRds().hashCode();
        break;
      case 4:
        hash = (37 * hash) + ROUTE_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getRouteConfig().hashCode();
        break;
      case 31:
        hash = (37 * hash) + SCOPED_ROUTES_FIELD_NUMBER;
        hash = (53 * hash) + getScopedRoutes().hashCode();
        break;
      case 0:
      default:
    }
    switch (stripPortModeCase_) {
      case 42:
        hash = (37 * hash) + STRIP_ANY_HOST_PORT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getStripAnyHostPort());
        break;
      case 0:
      default:
    }
    hash = (29 * hash) + getUnknownFields().hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input);
  }
  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * <pre>
   * [#next-free-field: 53]
   * </pre>
   *
   * Protobuf type {@code envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager)
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.class, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Builder.class);
    }

    // Construct using io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.newBuilder()
    private Builder() {

    }

    private Builder(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);

    }
    @java.lang.Override
    public Builder clear() {
      super.clear();
      bitField0_ = 0;
      bitField1_ = 0;
      codecType_ = 0;
      statPrefix_ = "";
      if (rdsBuilder_ != null) {
        rdsBuilder_.clear();
      }
      if (routeConfigBuilder_ != null) {
        routeConfigBuilder_.clear();
      }
      if (scopedRoutesBuilder_ != null) {
        scopedRoutesBuilder_.clear();
      }
      if (httpFiltersBuilder_ == null) {
        httpFilters_ = java.util.Collections.emptyList();
      } else {
        httpFilters_ = null;
        httpFiltersBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00000020);
      addUserAgent_ = null;
      if (addUserAgentBuilder_ != null) {
        addUserAgentBuilder_.dispose();
        addUserAgentBuilder_ = null;
      }
      tracing_ = null;
      if (tracingBuilder_ != null) {
        tracingBuilder_.dispose();
        tracingBuilder_ = null;
      }
      commonHttpProtocolOptions_ = null;
      if (commonHttpProtocolOptionsBuilder_ != null) {
        commonHttpProtocolOptionsBuilder_.dispose();
        commonHttpProtocolOptionsBuilder_ = null;
      }
      httpProtocolOptions_ = null;
      if (httpProtocolOptionsBuilder_ != null) {
        httpProtocolOptionsBuilder_.dispose();
        httpProtocolOptionsBuilder_ = null;
      }
      http2ProtocolOptions_ = null;
      if (http2ProtocolOptionsBuilder_ != null) {
        http2ProtocolOptionsBuilder_.dispose();
        http2ProtocolOptionsBuilder_ = null;
      }
      http3ProtocolOptions_ = null;
      if (http3ProtocolOptionsBuilder_ != null) {
        http3ProtocolOptionsBuilder_.dispose();
        http3ProtocolOptionsBuilder_ = null;
      }
      serverName_ = "";
      serverHeaderTransformation_ = 0;
      schemeHeaderTransformation_ = null;
      if (schemeHeaderTransformationBuilder_ != null) {
        schemeHeaderTransformationBuilder_.dispose();
        schemeHeaderTransformationBuilder_ = null;
      }
      maxRequestHeadersKb_ = null;
      if (maxRequestHeadersKbBuilder_ != null) {
        maxRequestHeadersKbBuilder_.dispose();
        maxRequestHeadersKbBuilder_ = null;
      }
      streamIdleTimeout_ = null;
      if (streamIdleTimeoutBuilder_ != null) {
        streamIdleTimeoutBuilder_.dispose();
        streamIdleTimeoutBuilder_ = null;
      }
      requestTimeout_ = null;
      if (requestTimeoutBuilder_ != null) {
        requestTimeoutBuilder_.dispose();
        requestTimeoutBuilder_ = null;
      }
      requestHeadersTimeout_ = null;
      if (requestHeadersTimeoutBuilder_ != null) {
        requestHeadersTimeoutBuilder_.dispose();
        requestHeadersTimeoutBuilder_ = null;
      }
      drainTimeout_ = null;
      if (drainTimeoutBuilder_ != null) {
        drainTimeoutBuilder_.dispose();
        drainTimeoutBuilder_ = null;
      }
      delayedCloseTimeout_ = null;
      if (delayedCloseTimeoutBuilder_ != null) {
        delayedCloseTimeoutBuilder_.dispose();
        delayedCloseTimeoutBuilder_ = null;
      }
      if (accessLogBuilder_ == null) {
        accessLog_ = java.util.Collections.emptyList();
      } else {
        accessLog_ = null;
        accessLogBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x00200000);
      useRemoteAddress_ = null;
      if (useRemoteAddressBuilder_ != null) {
        useRemoteAddressBuilder_.dispose();
        useRemoteAddressBuilder_ = null;
      }
      xffNumTrustedHops_ = 0;
      if (originalIpDetectionExtensionsBuilder_ == null) {
        originalIpDetectionExtensions_ = java.util.Collections.emptyList();
      } else {
        originalIpDetectionExtensions_ = null;
        originalIpDetectionExtensionsBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x01000000);
      if (earlyHeaderMutationExtensionsBuilder_ == null) {
        earlyHeaderMutationExtensions_ = java.util.Collections.emptyList();
      } else {
        earlyHeaderMutationExtensions_ = null;
        earlyHeaderMutationExtensionsBuilder_.clear();
      }
      bitField0_ = (bitField0_ & ~0x02000000);
      internalAddressConfig_ = null;
      if (internalAddressConfigBuilder_ != null) {
        internalAddressConfigBuilder_.dispose();
        internalAddressConfigBuilder_ = null;
      }
      skipXffAppend_ = false;
      via_ = "";
      generateRequestId_ = null;
      if (generateRequestIdBuilder_ != null) {
        generateRequestIdBuilder_.dispose();
        generateRequestIdBuilder_ = null;
      }
      preserveExternalRequestId_ = false;
      alwaysSetRequestIdInResponse_ = false;
      forwardClientCertDetails_ = 0;
      setCurrentClientCertDetails_ = null;
      if (setCurrentClientCertDetailsBuilder_ != null) {
        setCurrentClientCertDetailsBuilder_.dispose();
        setCurrentClientCertDetailsBuilder_ = null;
      }
      proxy100Continue_ = false;
      representIpv4RemoteAddressAsIpv4MappedIpv6_ = false;
      if (upgradeConfigsBuilder_ == null) {
        upgradeConfigs_ = java.util.Collections.emptyList();
      } else {
        upgradeConfigs_ = null;
        upgradeConfigsBuilder_.clear();
      }
      bitField1_ = (bitField1_ & ~0x00000010);
      normalizePath_ = null;
      if (normalizePathBuilder_ != null) {
        normalizePathBuilder_.dispose();
        normalizePathBuilder_ = null;
      }
      mergeSlashes_ = false;
      pathWithEscapedSlashesAction_ = 0;
      requestIdExtension_ = null;
      if (requestIdExtensionBuilder_ != null) {
        requestIdExtensionBuilder_.dispose();
        requestIdExtensionBuilder_ = null;
      }
      localReplyConfig_ = null;
      if (localReplyConfigBuilder_ != null) {
        localReplyConfigBuilder_.dispose();
        localReplyConfigBuilder_ = null;
      }
      stripMatchingHostPort_ = false;
      streamErrorOnInvalidHttpMessage_ = null;
      if (streamErrorOnInvalidHttpMessageBuilder_ != null) {
        streamErrorOnInvalidHttpMessageBuilder_.dispose();
        streamErrorOnInvalidHttpMessageBuilder_ = null;
      }
      pathNormalizationOptions_ = null;
      if (pathNormalizationOptionsBuilder_ != null) {
        pathNormalizationOptionsBuilder_.dispose();
        pathNormalizationOptionsBuilder_ = null;
      }
      stripTrailingHostDot_ = false;
      proxyStatusConfig_ = null;
      if (proxyStatusConfigBuilder_ != null) {
        proxyStatusConfigBuilder_.dispose();
        proxyStatusConfigBuilder_ = null;
      }
      typedHeaderValidationConfig_ = null;
      if (typedHeaderValidationConfigBuilder_ != null) {
        typedHeaderValidationConfigBuilder_.dispose();
        typedHeaderValidationConfigBuilder_ = null;
      }
      appendXForwardedPort_ = false;
      routeSpecifierCase_ = 0;
      routeSpecifier_ = null;
      stripPortModeCase_ = 0;
      stripPortMode_ = null;
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManagerProto.internal_static_envoy_extensions_filters_network_http_connection_manager_v3_HttpConnectionManager_descriptor;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager getDefaultInstanceForType() {
      return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.getDefaultInstance();
    }

    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager build() {
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager buildPartial() {
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager result = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager(this);
      buildPartialRepeatedFields(result);
      if (bitField0_ != 0) { buildPartial0(result); }
      if (bitField1_ != 0) { buildPartial1(result); }
      buildPartialOneofs(result);
      onBuilt();
      return result;
    }

    private void buildPartialRepeatedFields(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager result) {
      if (httpFiltersBuilder_ == null) {
        if (((bitField0_ & 0x00000020) != 0)) {
          httpFilters_ = java.util.Collections.unmodifiableList(httpFilters_);
          bitField0_ = (bitField0_ & ~0x00000020);
        }
        result.httpFilters_ = httpFilters_;
      } else {
        result.httpFilters_ = httpFiltersBuilder_.build();
      }
      if (accessLogBuilder_ == null) {
        if (((bitField0_ & 0x00200000) != 0)) {
          accessLog_ = java.util.Collections.unmodifiableList(accessLog_);
          bitField0_ = (bitField0_ & ~0x00200000);
        }
        result.accessLog_ = accessLog_;
      } else {
        result.accessLog_ = accessLogBuilder_.build();
      }
      if (originalIpDetectionExtensionsBuilder_ == null) {
        if (((bitField0_ & 0x01000000) != 0)) {
          originalIpDetectionExtensions_ = java.util.Collections.unmodifiableList(originalIpDetectionExtensions_);
          bitField0_ = (bitField0_ & ~0x01000000);
        }
        result.originalIpDetectionExtensions_ = originalIpDetectionExtensions_;
      } else {
        result.originalIpDetectionExtensions_ = originalIpDetectionExtensionsBuilder_.build();
      }
      if (earlyHeaderMutationExtensionsBuilder_ == null) {
        if (((bitField0_ & 0x02000000) != 0)) {
          earlyHeaderMutationExtensions_ = java.util.Collections.unmodifiableList(earlyHeaderMutationExtensions_);
          bitField0_ = (bitField0_ & ~0x02000000);
        }
        result.earlyHeaderMutationExtensions_ = earlyHeaderMutationExtensions_;
      } else {
        result.earlyHeaderMutationExtensions_ = earlyHeaderMutationExtensionsBuilder_.build();
      }
      if (upgradeConfigsBuilder_ == null) {
        if (((bitField1_ & 0x00000010) != 0)) {
          upgradeConfigs_ = java.util.Collections.unmodifiableList(upgradeConfigs_);
          bitField1_ = (bitField1_ & ~0x00000010);
        }
        result.upgradeConfigs_ = upgradeConfigs_;
      } else {
        result.upgradeConfigs_ = upgradeConfigsBuilder_.build();
      }
    }

    private void buildPartial0(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager result) {
      int from_bitField0_ = bitField0_;
      if (((from_bitField0_ & 0x00000001) != 0)) {
        result.codecType_ = codecType_;
      }
      if (((from_bitField0_ & 0x00000002) != 0)) {
        result.statPrefix_ = statPrefix_;
      }
      if (((from_bitField0_ & 0x00000040) != 0)) {
        result.addUserAgent_ = addUserAgentBuilder_ == null
            ? addUserAgent_
            : addUserAgentBuilder_.build();
      }
      if (((from_bitField0_ & 0x00000080) != 0)) {
        result.tracing_ = tracingBuilder_ == null
            ? tracing_
            : tracingBuilder_.build();
      }
      if (((from_bitField0_ & 0x00000100) != 0)) {
        result.commonHttpProtocolOptions_ = commonHttpProtocolOptionsBuilder_ == null
            ? commonHttpProtocolOptions_
            : commonHttpProtocolOptionsBuilder_.build();
      }
      if (((from_bitField0_ & 0x00000200) != 0)) {
        result.httpProtocolOptions_ = httpProtocolOptionsBuilder_ == null
            ? httpProtocolOptions_
            : httpProtocolOptionsBuilder_.build();
      }
      if (((from_bitField0_ & 0x00000400) != 0)) {
        result.http2ProtocolOptions_ = http2ProtocolOptionsBuilder_ == null
            ? http2ProtocolOptions_
            : http2ProtocolOptionsBuilder_.build();
      }
      if (((from_bitField0_ & 0x00000800) != 0)) {
        result.http3ProtocolOptions_ = http3ProtocolOptionsBuilder_ == null
            ? http3ProtocolOptions_
            : http3ProtocolOptionsBuilder_.build();
      }
      if (((from_bitField0_ & 0x00001000) != 0)) {
        result.serverName_ = serverName_;
      }
      if (((from_bitField0_ & 0x00002000) != 0)) {
        result.serverHeaderTransformation_ = serverHeaderTransformation_;
      }
      if (((from_bitField0_ & 0x00004000) != 0)) {
        result.schemeHeaderTransformation_ = schemeHeaderTransformationBuilder_ == null
            ? schemeHeaderTransformation_
            : schemeHeaderTransformationBuilder_.build();
      }
      if (((from_bitField0_ & 0x00008000) != 0)) {
        result.maxRequestHeadersKb_ = maxRequestHeadersKbBuilder_ == null
            ? maxRequestHeadersKb_
            : maxRequestHeadersKbBuilder_.build();
      }
      if (((from_bitField0_ & 0x00010000) != 0)) {
        result.streamIdleTimeout_ = streamIdleTimeoutBuilder_ == null
            ? streamIdleTimeout_
            : streamIdleTimeoutBuilder_.build();
      }
      if (((from_bitField0_ & 0x00020000) != 0)) {
        result.requestTimeout_ = requestTimeoutBuilder_ == null
            ? requestTimeout_
            : requestTimeoutBuilder_.build();
      }
      if (((from_bitField0_ & 0x00040000) != 0)) {
        result.requestHeadersTimeout_ = requestHeadersTimeoutBuilder_ == null
            ? requestHeadersTimeout_
            : requestHeadersTimeoutBuilder_.build();
      }
      if (((from_bitField0_ & 0x00080000) != 0)) {
        result.drainTimeout_ = drainTimeoutBuilder_ == null
            ? drainTimeout_
            : drainTimeoutBuilder_.build();
      }
      if (((from_bitField0_ & 0x00100000) != 0)) {
        result.delayedCloseTimeout_ = delayedCloseTimeoutBuilder_ == null
            ? delayedCloseTimeout_
            : delayedCloseTimeoutBuilder_.build();
      }
      if (((from_bitField0_ & 0x00400000) != 0)) {
        result.useRemoteAddress_ = useRemoteAddressBuilder_ == null
            ? useRemoteAddress_
            : useRemoteAddressBuilder_.build();
      }
      if (((from_bitField0_ & 0x00800000) != 0)) {
        result.xffNumTrustedHops_ = xffNumTrustedHops_;
      }
      if (((from_bitField0_ & 0x04000000) != 0)) {
        result.internalAddressConfig_ = internalAddressConfigBuilder_ == null
            ? internalAddressConfig_
            : internalAddressConfigBuilder_.build();
      }
      if (((from_bitField0_ & 0x08000000) != 0)) {
        result.skipXffAppend_ = skipXffAppend_;
      }
      if (((from_bitField0_ & 0x10000000) != 0)) {
        result.via_ = via_;
      }
      if (((from_bitField0_ & 0x20000000) != 0)) {
        result.generateRequestId_ = generateRequestIdBuilder_ == null
            ? generateRequestId_
            : generateRequestIdBuilder_.build();
      }
      if (((from_bitField0_ & 0x40000000) != 0)) {
        result.preserveExternalRequestId_ = preserveExternalRequestId_;
      }
      if (((from_bitField0_ & 0x80000000) != 0)) {
        result.alwaysSetRequestIdInResponse_ = alwaysSetRequestIdInResponse_;
      }
    }

    private void buildPartial1(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager result) {
      int from_bitField1_ = bitField1_;
      if (((from_bitField1_ & 0x00000001) != 0)) {
        result.forwardClientCertDetails_ = forwardClientCertDetails_;
      }
      if (((from_bitField1_ & 0x00000002) != 0)) {
        result.setCurrentClientCertDetails_ = setCurrentClientCertDetailsBuilder_ == null
            ? setCurrentClientCertDetails_
            : setCurrentClientCertDetailsBuilder_.build();
      }
      if (((from_bitField1_ & 0x00000004) != 0)) {
        result.proxy100Continue_ = proxy100Continue_;
      }
      if (((from_bitField1_ & 0x00000008) != 0)) {
        result.representIpv4RemoteAddressAsIpv4MappedIpv6_ = representIpv4RemoteAddressAsIpv4MappedIpv6_;
      }
      if (((from_bitField1_ & 0x00000020) != 0)) {
        result.normalizePath_ = normalizePathBuilder_ == null
            ? normalizePath_
            : normalizePathBuilder_.build();
      }
      if (((from_bitField1_ & 0x00000040) != 0)) {
        result.mergeSlashes_ = mergeSlashes_;
      }
      if (((from_bitField1_ & 0x00000080) != 0)) {
        result.pathWithEscapedSlashesAction_ = pathWithEscapedSlashesAction_;
      }
      if (((from_bitField1_ & 0x00000100) != 0)) {
        result.requestIdExtension_ = requestIdExtensionBuilder_ == null
            ? requestIdExtension_
            : requestIdExtensionBuilder_.build();
      }
      if (((from_bitField1_ & 0x00000200) != 0)) {
        result.localReplyConfig_ = localReplyConfigBuilder_ == null
            ? localReplyConfig_
            : localReplyConfigBuilder_.build();
      }
      if (((from_bitField1_ & 0x00000400) != 0)) {
        result.stripMatchingHostPort_ = stripMatchingHostPort_;
      }
      if (((from_bitField1_ & 0x00001000) != 0)) {
        result.streamErrorOnInvalidHttpMessage_ = streamErrorOnInvalidHttpMessageBuilder_ == null
            ? streamErrorOnInvalidHttpMessage_
            : streamErrorOnInvalidHttpMessageBuilder_.build();
      }
      if (((from_bitField1_ & 0x00002000) != 0)) {
        result.pathNormalizationOptions_ = pathNormalizationOptionsBuilder_ == null
            ? pathNormalizationOptions_
            : pathNormalizationOptionsBuilder_.build();
      }
      if (((from_bitField1_ & 0x00004000) != 0)) {
        result.stripTrailingHostDot_ = stripTrailingHostDot_;
      }
      if (((from_bitField1_ & 0x00008000) != 0)) {
        result.proxyStatusConfig_ = proxyStatusConfigBuilder_ == null
            ? proxyStatusConfig_
            : proxyStatusConfigBuilder_.build();
      }
      if (((from_bitField1_ & 0x00010000) != 0)) {
        result.typedHeaderValidationConfig_ = typedHeaderValidationConfigBuilder_ == null
            ? typedHeaderValidationConfig_
            : typedHeaderValidationConfigBuilder_.build();
      }
      if (((from_bitField1_ & 0x00020000) != 0)) {
        result.appendXForwardedPort_ = appendXForwardedPort_;
      }
    }

    private void buildPartialOneofs(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager result) {
      result.routeSpecifierCase_ = routeSpecifierCase_;
      result.routeSpecifier_ = this.routeSpecifier_;
      if (routeSpecifierCase_ == 3 &&
          rdsBuilder_ != null) {
        result.routeSpecifier_ = rdsBuilder_.build();
      }
      if (routeSpecifierCase_ == 4 &&
          routeConfigBuilder_ != null) {
        result.routeSpecifier_ = routeConfigBuilder_.build();
      }
      if (routeSpecifierCase_ == 31 &&
          scopedRoutesBuilder_ != null) {
        result.routeSpecifier_ = scopedRoutesBuilder_.build();
      }
      result.stripPortModeCase_ = stripPortModeCase_;
      result.stripPortMode_ = this.stripPortMode_;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }
    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.setField(field, value);
    }
    @java.lang.Override
    public Builder clearField(
        com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }
    @java.lang.Override
    public Builder clearOneof(
        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }
    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }
    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }
    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager) {
        return mergeFrom((io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager)other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager other) {
      if (other == io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.getDefaultInstance()) return this;
      if (other.codecType_ != 0) {
        setCodecTypeValue(other.getCodecTypeValue());
      }
      if (!other.getStatPrefix().isEmpty()) {
        statPrefix_ = other.statPrefix_;
        bitField0_ |= 0x00000002;
        onChanged();
      }
      if (httpFiltersBuilder_ == null) {
        if (!other.httpFilters_.isEmpty()) {
          if (httpFilters_.isEmpty()) {
            httpFilters_ = other.httpFilters_;
            bitField0_ = (bitField0_ & ~0x00000020);
          } else {
            ensureHttpFiltersIsMutable();
            httpFilters_.addAll(other.httpFilters_);
          }
          onChanged();
        }
      } else {
        if (!other.httpFilters_.isEmpty()) {
          if (httpFiltersBuilder_.isEmpty()) {
            httpFiltersBuilder_.dispose();
            httpFiltersBuilder_ = null;
            httpFilters_ = other.httpFilters_;
            bitField0_ = (bitField0_ & ~0x00000020);
            httpFiltersBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getHttpFiltersFieldBuilder() : null;
          } else {
            httpFiltersBuilder_.addAllMessages(other.httpFilters_);
          }
        }
      }
      if (other.hasAddUserAgent()) {
        mergeAddUserAgent(other.getAddUserAgent());
      }
      if (other.hasTracing()) {
        mergeTracing(other.getTracing());
      }
      if (other.hasCommonHttpProtocolOptions()) {
        mergeCommonHttpProtocolOptions(other.getCommonHttpProtocolOptions());
      }
      if (other.hasHttpProtocolOptions()) {
        mergeHttpProtocolOptions(other.getHttpProtocolOptions());
      }
      if (other.hasHttp2ProtocolOptions()) {
        mergeHttp2ProtocolOptions(other.getHttp2ProtocolOptions());
      }
      if (other.hasHttp3ProtocolOptions()) {
        mergeHttp3ProtocolOptions(other.getHttp3ProtocolOptions());
      }
      if (!other.getServerName().isEmpty()) {
        serverName_ = other.serverName_;
        bitField0_ |= 0x00001000;
        onChanged();
      }
      if (other.serverHeaderTransformation_ != 0) {
        setServerHeaderTransformationValue(other.getServerHeaderTransformationValue());
      }
      if (other.hasSchemeHeaderTransformation()) {
        mergeSchemeHeaderTransformation(other.getSchemeHeaderTransformation());
      }
      if (other.hasMaxRequestHeadersKb()) {
        mergeMaxRequestHeadersKb(other.getMaxRequestHeadersKb());
      }
      if (other.hasStreamIdleTimeout()) {
        mergeStreamIdleTimeout(other.getStreamIdleTimeout());
      }
      if (other.hasRequestTimeout()) {
        mergeRequestTimeout(other.getRequestTimeout());
      }
      if (other.hasRequestHeadersTimeout()) {
        mergeRequestHeadersTimeout(other.getRequestHeadersTimeout());
      }
      if (other.hasDrainTimeout()) {
        mergeDrainTimeout(other.getDrainTimeout());
      }
      if (other.hasDelayedCloseTimeout()) {
        mergeDelayedCloseTimeout(other.getDelayedCloseTimeout());
      }
      if (accessLogBuilder_ == null) {
        if (!other.accessLog_.isEmpty()) {
          if (accessLog_.isEmpty()) {
            accessLog_ = other.accessLog_;
            bitField0_ = (bitField0_ & ~0x00200000);
          } else {
            ensureAccessLogIsMutable();
            accessLog_.addAll(other.accessLog_);
          }
          onChanged();
        }
      } else {
        if (!other.accessLog_.isEmpty()) {
          if (accessLogBuilder_.isEmpty()) {
            accessLogBuilder_.dispose();
            accessLogBuilder_ = null;
            accessLog_ = other.accessLog_;
            bitField0_ = (bitField0_ & ~0x00200000);
            accessLogBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getAccessLogFieldBuilder() : null;
          } else {
            accessLogBuilder_.addAllMessages(other.accessLog_);
          }
        }
      }
      if (other.hasUseRemoteAddress()) {
        mergeUseRemoteAddress(other.getUseRemoteAddress());
      }
      if (other.getXffNumTrustedHops() != 0) {
        setXffNumTrustedHops(other.getXffNumTrustedHops());
      }
      if (originalIpDetectionExtensionsBuilder_ == null) {
        if (!other.originalIpDetectionExtensions_.isEmpty()) {
          if (originalIpDetectionExtensions_.isEmpty()) {
            originalIpDetectionExtensions_ = other.originalIpDetectionExtensions_;
            bitField0_ = (bitField0_ & ~0x01000000);
          } else {
            ensureOriginalIpDetectionExtensionsIsMutable();
            originalIpDetectionExtensions_.addAll(other.originalIpDetectionExtensions_);
          }
          onChanged();
        }
      } else {
        if (!other.originalIpDetectionExtensions_.isEmpty()) {
          if (originalIpDetectionExtensionsBuilder_.isEmpty()) {
            originalIpDetectionExtensionsBuilder_.dispose();
            originalIpDetectionExtensionsBuilder_ = null;
            originalIpDetectionExtensions_ = other.originalIpDetectionExtensions_;
            bitField0_ = (bitField0_ & ~0x01000000);
            originalIpDetectionExtensionsBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getOriginalIpDetectionExtensionsFieldBuilder() : null;
          } else {
            originalIpDetectionExtensionsBuilder_.addAllMessages(other.originalIpDetectionExtensions_);
          }
        }
      }
      if (earlyHeaderMutationExtensionsBuilder_ == null) {
        if (!other.earlyHeaderMutationExtensions_.isEmpty()) {
          if (earlyHeaderMutationExtensions_.isEmpty()) {
            earlyHeaderMutationExtensions_ = other.earlyHeaderMutationExtensions_;
            bitField0_ = (bitField0_ & ~0x02000000);
          } else {
            ensureEarlyHeaderMutationExtensionsIsMutable();
            earlyHeaderMutationExtensions_.addAll(other.earlyHeaderMutationExtensions_);
          }
          onChanged();
        }
      } else {
        if (!other.earlyHeaderMutationExtensions_.isEmpty()) {
          if (earlyHeaderMutationExtensionsBuilder_.isEmpty()) {
            earlyHeaderMutationExtensionsBuilder_.dispose();
            earlyHeaderMutationExtensionsBuilder_ = null;
            earlyHeaderMutationExtensions_ = other.earlyHeaderMutationExtensions_;
            bitField0_ = (bitField0_ & ~0x02000000);
            earlyHeaderMutationExtensionsBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getEarlyHeaderMutationExtensionsFieldBuilder() : null;
          } else {
            earlyHeaderMutationExtensionsBuilder_.addAllMessages(other.earlyHeaderMutationExtensions_);
          }
        }
      }
      if (other.hasInternalAddressConfig()) {
        mergeInternalAddressConfig(other.getInternalAddressConfig());
      }
      if (other.getSkipXffAppend() != false) {
        setSkipXffAppend(other.getSkipXffAppend());
      }
      if (!other.getVia().isEmpty()) {
        via_ = other.via_;
        bitField0_ |= 0x10000000;
        onChanged();
      }
      if (other.hasGenerateRequestId()) {
        mergeGenerateRequestId(other.getGenerateRequestId());
      }
      if (other.getPreserveExternalRequestId() != false) {
        setPreserveExternalRequestId(other.getPreserveExternalRequestId());
      }
      if (other.getAlwaysSetRequestIdInResponse() != false) {
        setAlwaysSetRequestIdInResponse(other.getAlwaysSetRequestIdInResponse());
      }
      if (other.forwardClientCertDetails_ != 0) {
        setForwardClientCertDetailsValue(other.getForwardClientCertDetailsValue());
      }
      if (other.hasSetCurrentClientCertDetails()) {
        mergeSetCurrentClientCertDetails(other.getSetCurrentClientCertDetails());
      }
      if (other.getProxy100Continue() != false) {
        setProxy100Continue(other.getProxy100Continue());
      }
      if (other.getRepresentIpv4RemoteAddressAsIpv4MappedIpv6() != false) {
        setRepresentIpv4RemoteAddressAsIpv4MappedIpv6(other.getRepresentIpv4RemoteAddressAsIpv4MappedIpv6());
      }
      if (upgradeConfigsBuilder_ == null) {
        if (!other.upgradeConfigs_.isEmpty()) {
          if (upgradeConfigs_.isEmpty()) {
            upgradeConfigs_ = other.upgradeConfigs_;
            bitField1_ = (bitField1_ & ~0x00000010);
          } else {
            ensureUpgradeConfigsIsMutable();
            upgradeConfigs_.addAll(other.upgradeConfigs_);
          }
          onChanged();
        }
      } else {
        if (!other.upgradeConfigs_.isEmpty()) {
          if (upgradeConfigsBuilder_.isEmpty()) {
            upgradeConfigsBuilder_.dispose();
            upgradeConfigsBuilder_ = null;
            upgradeConfigs_ = other.upgradeConfigs_;
            bitField1_ = (bitField1_ & ~0x00000010);
            upgradeConfigsBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getUpgradeConfigsFieldBuilder() : null;
          } else {
            upgradeConfigsBuilder_.addAllMessages(other.upgradeConfigs_);
          }
        }
      }
      if (other.hasNormalizePath()) {
        mergeNormalizePath(other.getNormalizePath());
      }
      if (other.getMergeSlashes() != false) {
        setMergeSlashes(other.getMergeSlashes());
      }
      if (other.pathWithEscapedSlashesAction_ != 0) {
        setPathWithEscapedSlashesActionValue(other.getPathWithEscapedSlashesActionValue());
      }
      if (other.hasRequestIdExtension()) {
        mergeRequestIdExtension(other.getRequestIdExtension());
      }
      if (other.hasLocalReplyConfig()) {
        mergeLocalReplyConfig(other.getLocalReplyConfig());
      }
      if (other.getStripMatchingHostPort() != false) {
        setStripMatchingHostPort(other.getStripMatchingHostPort());
      }
      if (other.hasStreamErrorOnInvalidHttpMessage()) {
        mergeStreamErrorOnInvalidHttpMessage(other.getStreamErrorOnInvalidHttpMessage());
      }
      if (other.hasPathNormalizationOptions()) {
        mergePathNormalizationOptions(other.getPathNormalizationOptions());
      }
      if (other.getStripTrailingHostDot() != false) {
        setStripTrailingHostDot(other.getStripTrailingHostDot());
      }
      if (other.hasProxyStatusConfig()) {
        mergeProxyStatusConfig(other.getProxyStatusConfig());
      }
      if (other.hasTypedHeaderValidationConfig()) {
        mergeTypedHeaderValidationConfig(other.getTypedHeaderValidationConfig());
      }
      if (other.getAppendXForwardedPort() != false) {
        setAppendXForwardedPort(other.getAppendXForwardedPort());
      }
      switch (other.getRouteSpecifierCase()) {
        case RDS: {
          mergeRds(other.getRds());
          break;
        }
        case ROUTE_CONFIG: {
          mergeRouteConfig(other.getRouteConfig());
          break;
        }
        case SCOPED_ROUTES: {
          mergeScopedRoutes(other.getScopedRoutes());
          break;
        }
        case ROUTESPECIFIER_NOT_SET: {
          break;
        }
      }
      switch (other.getStripPortModeCase()) {
        case STRIP_ANY_HOST_PORT: {
          setStripAnyHostPort(other.getStripAnyHostPort());
          break;
        }
        case STRIPPORTMODE_NOT_SET: {
          break;
        }
      }
      this.mergeUnknownFields(other.getUnknownFields());
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              codecType_ = input.readEnum();
              bitField0_ |= 0x00000001;
              break;
            } // case 8
            case 18: {
              statPrefix_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00000002;
              break;
            } // case 18
            case 26: {
              input.readMessage(
                  getRdsFieldBuilder().getBuilder(),
                  extensionRegistry);
              routeSpecifierCase_ = 3;
              break;
            } // case 26
            case 34: {
              input.readMessage(
                  getRouteConfigFieldBuilder().getBuilder(),
                  extensionRegistry);
              routeSpecifierCase_ = 4;
              break;
            } // case 34
            case 42: {
              io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter m =
                  input.readMessage(
                      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.parser(),
                      extensionRegistry);
              if (httpFiltersBuilder_ == null) {
                ensureHttpFiltersIsMutable();
                httpFilters_.add(m);
              } else {
                httpFiltersBuilder_.addMessage(m);
              }
              break;
            } // case 42
            case 50: {
              input.readMessage(
                  getAddUserAgentFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000040;
              break;
            } // case 50
            case 58: {
              input.readMessage(
                  getTracingFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000080;
              break;
            } // case 58
            case 66: {
              input.readMessage(
                  getHttpProtocolOptionsFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000200;
              break;
            } // case 66
            case 74: {
              input.readMessage(
                  getHttp2ProtocolOptionsFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000400;
              break;
            } // case 74
            case 82: {
              serverName_ = input.readStringRequireUtf8();
              bitField0_ |= 0x00001000;
              break;
            } // case 82
            case 98: {
              input.readMessage(
                  getDrainTimeoutFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00080000;
              break;
            } // case 98
            case 106: {
              io.envoyproxy.envoy.config.accesslog.v3.AccessLog m =
                  input.readMessage(
                      io.envoyproxy.envoy.config.accesslog.v3.AccessLog.parser(),
                      extensionRegistry);
              if (accessLogBuilder_ == null) {
                ensureAccessLogIsMutable();
                accessLog_.add(m);
              } else {
                accessLogBuilder_.addMessage(m);
              }
              break;
            } // case 106
            case 114: {
              input.readMessage(
                  getUseRemoteAddressFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00400000;
              break;
            } // case 114
            case 122: {
              input.readMessage(
                  getGenerateRequestIdFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x20000000;
              break;
            } // case 122
            case 128: {
              forwardClientCertDetails_ = input.readEnum();
              bitField1_ |= 0x00000001;
              break;
            } // case 128
            case 138: {
              input.readMessage(
                  getSetCurrentClientCertDetailsFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField1_ |= 0x00000002;
              break;
            } // case 138
            case 144: {
              proxy100Continue_ = input.readBool();
              bitField1_ |= 0x00000004;
              break;
            } // case 144
            case 152: {
              xffNumTrustedHops_ = input.readUInt32();
              bitField0_ |= 0x00800000;
              break;
            } // case 152
            case 160: {
              representIpv4RemoteAddressAsIpv4MappedIpv6_ = input.readBool();
              bitField1_ |= 0x00000008;
              break;
            } // case 160
            case 168: {
              skipXffAppend_ = input.readBool();
              bitField0_ |= 0x08000000;
              break;
            } // case 168
            case 178: {
              via_ = input.readStringRequireUtf8();
              bitField0_ |= 0x10000000;
              break;
            } // case 178
            case 186: {
              io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig m =
                  input.readMessage(
                      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.parser(),
                      extensionRegistry);
              if (upgradeConfigsBuilder_ == null) {
                ensureUpgradeConfigsIsMutable();
                upgradeConfigs_.add(m);
              } else {
                upgradeConfigsBuilder_.addMessage(m);
              }
              break;
            } // case 186
            case 194: {
              input.readMessage(
                  getStreamIdleTimeoutFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00010000;
              break;
            } // case 194
            case 202: {
              input.readMessage(
                  getInternalAddressConfigFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x04000000;
              break;
            } // case 202
            case 210: {
              input.readMessage(
                  getDelayedCloseTimeoutFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00100000;
              break;
            } // case 210
            case 226: {
              input.readMessage(
                  getRequestTimeoutFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00020000;
              break;
            } // case 226
            case 234: {
              input.readMessage(
                  getMaxRequestHeadersKbFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00008000;
              break;
            } // case 234
            case 242: {
              input.readMessage(
                  getNormalizePathFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField1_ |= 0x00000020;
              break;
            } // case 242
            case 250: {
              input.readMessage(
                  getScopedRoutesFieldBuilder().getBuilder(),
                  extensionRegistry);
              routeSpecifierCase_ = 31;
              break;
            } // case 250
            case 256: {
              preserveExternalRequestId_ = input.readBool();
              bitField0_ |= 0x40000000;
              break;
            } // case 256
            case 264: {
              mergeSlashes_ = input.readBool();
              bitField1_ |= 0x00000040;
              break;
            } // case 264
            case 272: {
              serverHeaderTransformation_ = input.readEnum();
              bitField0_ |= 0x00002000;
              break;
            } // case 272
            case 282: {
              input.readMessage(
                  getCommonHttpProtocolOptionsFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000100;
              break;
            } // case 282
            case 290: {
              input.readMessage(
                  getRequestIdExtensionFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField1_ |= 0x00000100;
              break;
            } // case 290
            case 296: {
              alwaysSetRequestIdInResponse_ = input.readBool();
              bitField0_ |= 0x80000000;
              break;
            } // case 296
            case 306: {
              input.readMessage(
                  getLocalReplyConfigFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField1_ |= 0x00000200;
              break;
            } // case 306
            case 312: {
              stripMatchingHostPort_ = input.readBool();
              bitField1_ |= 0x00000400;
              break;
            } // case 312
            case 322: {
              input.readMessage(
                  getStreamErrorOnInvalidHttpMessageFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField1_ |= 0x00001000;
              break;
            } // case 322
            case 330: {
              input.readMessage(
                  getRequestHeadersTimeoutFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00040000;
              break;
            } // case 330
            case 336: {
              stripPortMode_ = input.readBool();
              stripPortModeCase_ = 42;
              break;
            } // case 336
            case 346: {
              input.readMessage(
                  getPathNormalizationOptionsFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField1_ |= 0x00002000;
              break;
            } // case 346
            case 354: {
              input.readMessage(
                  getHttp3ProtocolOptionsFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00000800;
              break;
            } // case 354
            case 360: {
              pathWithEscapedSlashesAction_ = input.readEnum();
              bitField1_ |= 0x00000080;
              break;
            } // case 360
            case 370: {
              io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig m =
                  input.readMessage(
                      io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.parser(),
                      extensionRegistry);
              if (originalIpDetectionExtensionsBuilder_ == null) {
                ensureOriginalIpDetectionExtensionsIsMutable();
                originalIpDetectionExtensions_.add(m);
              } else {
                originalIpDetectionExtensionsBuilder_.addMessage(m);
              }
              break;
            } // case 370
            case 376: {
              stripTrailingHostDot_ = input.readBool();
              bitField1_ |= 0x00004000;
              break;
            } // case 376
            case 386: {
              input.readMessage(
                  getSchemeHeaderTransformationFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField0_ |= 0x00004000;
              break;
            } // case 386
            case 394: {
              input.readMessage(
                  getProxyStatusConfigFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField1_ |= 0x00008000;
              break;
            } // case 394
            case 402: {
              input.readMessage(
                  getTypedHeaderValidationConfigFieldBuilder().getBuilder(),
                  extensionRegistry);
              bitField1_ |= 0x00010000;
              break;
            } // case 402
            case 408: {
              appendXForwardedPort_ = input.readBool();
              bitField1_ |= 0x00020000;
              break;
            } // case 408
            case 418: {
              io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig m =
                  input.readMessage(
                      io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.parser(),
                      extensionRegistry);
              if (earlyHeaderMutationExtensionsBuilder_ == null) {
                ensureEarlyHeaderMutationExtensionsIsMutable();
                earlyHeaderMutationExtensions_.add(m);
              } else {
                earlyHeaderMutationExtensionsBuilder_.addMessage(m);
              }
              break;
            } // case 418
            default: {
              if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                done = true; // was an endgroup tag
              }
              break;
            } // default:
          } // switch (tag)
        } // while (!done)
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.unwrapIOException();
      } finally {
        onChanged();
      } // finally
      return this;
    }
    private int routeSpecifierCase_ = 0;
    private java.lang.Object routeSpecifier_;
    public RouteSpecifierCase
        getRouteSpecifierCase() {
      return RouteSpecifierCase.forNumber(
          routeSpecifierCase_);
    }

    public Builder clearRouteSpecifier() {
      routeSpecifierCase_ = 0;
      routeSpecifier_ = null;
      onChanged();
      return this;
    }

    private int stripPortModeCase_ = 0;
    private java.lang.Object stripPortMode_;
    public StripPortModeCase
        getStripPortModeCase() {
      return StripPortModeCase.forNumber(
          stripPortModeCase_);
    }

    public Builder clearStripPortMode() {
      stripPortModeCase_ = 0;
      stripPortMode_ = null;
      onChanged();
      return this;
    }

    private int bitField0_;
    private int bitField1_;

    private int codecType_ = 0;
    /**
     * <pre>
     * Supplies the type of codec that the connection manager should use.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType codec_type = 1 [(.validate.rules) = { ... }</code>
     * @return The enum numeric value on the wire for codecType.
     */
    @java.lang.Override public int getCodecTypeValue() {
      return codecType_;
    }
    /**
     * <pre>
     * Supplies the type of codec that the connection manager should use.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType codec_type = 1 [(.validate.rules) = { ... }</code>
     * @param value The enum numeric value on the wire for codecType to set.
     * @return This builder for chaining.
     */
    public Builder setCodecTypeValue(int value) {
      codecType_ = value;
      bitField0_ |= 0x00000001;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Supplies the type of codec that the connection manager should use.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType codec_type = 1 [(.validate.rules) = { ... }</code>
     * @return The codecType.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType getCodecType() {
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType result = io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType.forNumber(codecType_);
      return result == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * Supplies the type of codec that the connection manager should use.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType codec_type = 1 [(.validate.rules) = { ... }</code>
     * @param value The codecType to set.
     * @return This builder for chaining.
     */
    public Builder setCodecType(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000001;
      codecType_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Supplies the type of codec that the connection manager should use.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType codec_type = 1 [(.validate.rules) = { ... }</code>
     * @return This builder for chaining.
     */
    public Builder clearCodecType() {
      bitField0_ = (bitField0_ & ~0x00000001);
      codecType_ = 0;
      onChanged();
      return this;
    }

    private java.lang.Object statPrefix_ = "";
    /**
     * <pre>
     * The human readable prefix to use when emitting statistics for the
     * connection manager. See the :ref:`statistics documentation &lt;config_http_conn_man_stats&gt;` for
     * more information.
     * </pre>
     *
     * <code>string stat_prefix = 2 [(.validate.rules) = { ... }</code>
     * @return The statPrefix.
     */
    public java.lang.String getStatPrefix() {
      java.lang.Object ref = statPrefix_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        statPrefix_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * The human readable prefix to use when emitting statistics for the
     * connection manager. See the :ref:`statistics documentation &lt;config_http_conn_man_stats&gt;` for
     * more information.
     * </pre>
     *
     * <code>string stat_prefix = 2 [(.validate.rules) = { ... }</code>
     * @return The bytes for statPrefix.
     */
    public com.google.protobuf.ByteString
        getStatPrefixBytes() {
      java.lang.Object ref = statPrefix_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        statPrefix_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * The human readable prefix to use when emitting statistics for the
     * connection manager. See the :ref:`statistics documentation &lt;config_http_conn_man_stats&gt;` for
     * more information.
     * </pre>
     *
     * <code>string stat_prefix = 2 [(.validate.rules) = { ... }</code>
     * @param value The statPrefix to set.
     * @return This builder for chaining.
     */
    public Builder setStatPrefix(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      statPrefix_ = value;
      bitField0_ |= 0x00000002;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The human readable prefix to use when emitting statistics for the
     * connection manager. See the :ref:`statistics documentation &lt;config_http_conn_man_stats&gt;` for
     * more information.
     * </pre>
     *
     * <code>string stat_prefix = 2 [(.validate.rules) = { ... }</code>
     * @return This builder for chaining.
     */
    public Builder clearStatPrefix() {
      statPrefix_ = getDefaultInstance().getStatPrefix();
      bitField0_ = (bitField0_ & ~0x00000002);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The human readable prefix to use when emitting statistics for the
     * connection manager. See the :ref:`statistics documentation &lt;config_http_conn_man_stats&gt;` for
     * more information.
     * </pre>
     *
     * <code>string stat_prefix = 2 [(.validate.rules) = { ... }</code>
     * @param value The bytes for statPrefix to set.
     * @return This builder for chaining.
     */
    public Builder setStatPrefixBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      statPrefix_ = value;
      bitField0_ |= 0x00000002;
      onChanged();
      return this;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RdsOrBuilder> rdsBuilder_;
    /**
     * <pre>
     * The connection manager’s route table will be dynamically loaded via the RDS API.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
     * @return Whether the rds field is set.
     */
    @java.lang.Override
    public boolean hasRds() {
      return routeSpecifierCase_ == 3;
    }
    /**
     * <pre>
     * The connection manager’s route table will be dynamically loaded via the RDS API.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
     * @return The rds.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds getRds() {
      if (rdsBuilder_ == null) {
        if (routeSpecifierCase_ == 3) {
          return (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds) routeSpecifier_;
        }
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.getDefaultInstance();
      } else {
        if (routeSpecifierCase_ == 3) {
          return rdsBuilder_.getMessage();
        }
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * The connection manager’s route table will be dynamically loaded via the RDS API.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
     */
    public Builder setRds(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds value) {
      if (rdsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        routeSpecifier_ = value;
        onChanged();
      } else {
        rdsBuilder_.setMessage(value);
      }
      routeSpecifierCase_ = 3;
      return this;
    }
    /**
     * <pre>
     * The connection manager’s route table will be dynamically loaded via the RDS API.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
     */
    public Builder setRds(
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.Builder builderForValue) {
      if (rdsBuilder_ == null) {
        routeSpecifier_ = builderForValue.build();
        onChanged();
      } else {
        rdsBuilder_.setMessage(builderForValue.build());
      }
      routeSpecifierCase_ = 3;
      return this;
    }
    /**
     * <pre>
     * The connection manager’s route table will be dynamically loaded via the RDS API.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
     */
    public Builder mergeRds(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds value) {
      if (rdsBuilder_ == null) {
        if (routeSpecifierCase_ == 3 &&
            routeSpecifier_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.getDefaultInstance()) {
          routeSpecifier_ = io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.newBuilder((io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds) routeSpecifier_)
              .mergeFrom(value).buildPartial();
        } else {
          routeSpecifier_ = value;
        }
        onChanged();
      } else {
        if (routeSpecifierCase_ == 3) {
          rdsBuilder_.mergeFrom(value);
        } else {
          rdsBuilder_.setMessage(value);
        }
      }
      routeSpecifierCase_ = 3;
      return this;
    }
    /**
     * <pre>
     * The connection manager’s route table will be dynamically loaded via the RDS API.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
     */
    public Builder clearRds() {
      if (rdsBuilder_ == null) {
        if (routeSpecifierCase_ == 3) {
          routeSpecifierCase_ = 0;
          routeSpecifier_ = null;
          onChanged();
        }
      } else {
        if (routeSpecifierCase_ == 3) {
          routeSpecifierCase_ = 0;
          routeSpecifier_ = null;
        }
        rdsBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * The connection manager’s route table will be dynamically loaded via the RDS API.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.Builder getRdsBuilder() {
      return getRdsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The connection manager’s route table will be dynamically loaded via the RDS API.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RdsOrBuilder getRdsOrBuilder() {
      if ((routeSpecifierCase_ == 3) && (rdsBuilder_ != null)) {
        return rdsBuilder_.getMessageOrBuilder();
      } else {
        if (routeSpecifierCase_ == 3) {
          return (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds) routeSpecifier_;
        }
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * The connection manager’s route table will be dynamically loaded via the RDS API.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RdsOrBuilder> 
        getRdsFieldBuilder() {
      if (rdsBuilder_ == null) {
        if (!(routeSpecifierCase_ == 3)) {
          routeSpecifier_ = io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.getDefaultInstance();
        }
        rdsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RdsOrBuilder>(
                (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds) routeSpecifier_,
                getParentForChildren(),
                isClean());
        routeSpecifier_ = null;
      }
      routeSpecifierCase_ = 3;
      onChanged();
      return rdsBuilder_;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.route.v3.RouteConfiguration, io.envoyproxy.envoy.config.route.v3.RouteConfiguration.Builder, io.envoyproxy.envoy.config.route.v3.RouteConfigurationOrBuilder> routeConfigBuilder_;
    /**
     * <pre>
     * The route table for the connection manager is static and is specified in this property.
     * </pre>
     *
     * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
     * @return Whether the routeConfig field is set.
     */
    @java.lang.Override
    public boolean hasRouteConfig() {
      return routeSpecifierCase_ == 4;
    }
    /**
     * <pre>
     * The route table for the connection manager is static and is specified in this property.
     * </pre>
     *
     * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
     * @return The routeConfig.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.route.v3.RouteConfiguration getRouteConfig() {
      if (routeConfigBuilder_ == null) {
        if (routeSpecifierCase_ == 4) {
          return (io.envoyproxy.envoy.config.route.v3.RouteConfiguration) routeSpecifier_;
        }
        return io.envoyproxy.envoy.config.route.v3.RouteConfiguration.getDefaultInstance();
      } else {
        if (routeSpecifierCase_ == 4) {
          return routeConfigBuilder_.getMessage();
        }
        return io.envoyproxy.envoy.config.route.v3.RouteConfiguration.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * The route table for the connection manager is static and is specified in this property.
     * </pre>
     *
     * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
     */
    public Builder setRouteConfig(io.envoyproxy.envoy.config.route.v3.RouteConfiguration value) {
      if (routeConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        routeSpecifier_ = value;
        onChanged();
      } else {
        routeConfigBuilder_.setMessage(value);
      }
      routeSpecifierCase_ = 4;
      return this;
    }
    /**
     * <pre>
     * The route table for the connection manager is static and is specified in this property.
     * </pre>
     *
     * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
     */
    public Builder setRouteConfig(
        io.envoyproxy.envoy.config.route.v3.RouteConfiguration.Builder builderForValue) {
      if (routeConfigBuilder_ == null) {
        routeSpecifier_ = builderForValue.build();
        onChanged();
      } else {
        routeConfigBuilder_.setMessage(builderForValue.build());
      }
      routeSpecifierCase_ = 4;
      return this;
    }
    /**
     * <pre>
     * The route table for the connection manager is static and is specified in this property.
     * </pre>
     *
     * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
     */
    public Builder mergeRouteConfig(io.envoyproxy.envoy.config.route.v3.RouteConfiguration value) {
      if (routeConfigBuilder_ == null) {
        if (routeSpecifierCase_ == 4 &&
            routeSpecifier_ != io.envoyproxy.envoy.config.route.v3.RouteConfiguration.getDefaultInstance()) {
          routeSpecifier_ = io.envoyproxy.envoy.config.route.v3.RouteConfiguration.newBuilder((io.envoyproxy.envoy.config.route.v3.RouteConfiguration) routeSpecifier_)
              .mergeFrom(value).buildPartial();
        } else {
          routeSpecifier_ = value;
        }
        onChanged();
      } else {
        if (routeSpecifierCase_ == 4) {
          routeConfigBuilder_.mergeFrom(value);
        } else {
          routeConfigBuilder_.setMessage(value);
        }
      }
      routeSpecifierCase_ = 4;
      return this;
    }
    /**
     * <pre>
     * The route table for the connection manager is static and is specified in this property.
     * </pre>
     *
     * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
     */
    public Builder clearRouteConfig() {
      if (routeConfigBuilder_ == null) {
        if (routeSpecifierCase_ == 4) {
          routeSpecifierCase_ = 0;
          routeSpecifier_ = null;
          onChanged();
        }
      } else {
        if (routeSpecifierCase_ == 4) {
          routeSpecifierCase_ = 0;
          routeSpecifier_ = null;
        }
        routeConfigBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * The route table for the connection manager is static and is specified in this property.
     * </pre>
     *
     * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
     */
    public io.envoyproxy.envoy.config.route.v3.RouteConfiguration.Builder getRouteConfigBuilder() {
      return getRouteConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The route table for the connection manager is static and is specified in this property.
     * </pre>
     *
     * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.config.route.v3.RouteConfigurationOrBuilder getRouteConfigOrBuilder() {
      if ((routeSpecifierCase_ == 4) && (routeConfigBuilder_ != null)) {
        return routeConfigBuilder_.getMessageOrBuilder();
      } else {
        if (routeSpecifierCase_ == 4) {
          return (io.envoyproxy.envoy.config.route.v3.RouteConfiguration) routeSpecifier_;
        }
        return io.envoyproxy.envoy.config.route.v3.RouteConfiguration.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * The route table for the connection manager is static and is specified in this property.
     * </pre>
     *
     * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.route.v3.RouteConfiguration, io.envoyproxy.envoy.config.route.v3.RouteConfiguration.Builder, io.envoyproxy.envoy.config.route.v3.RouteConfigurationOrBuilder> 
        getRouteConfigFieldBuilder() {
      if (routeConfigBuilder_ == null) {
        if (!(routeSpecifierCase_ == 4)) {
          routeSpecifier_ = io.envoyproxy.envoy.config.route.v3.RouteConfiguration.getDefaultInstance();
        }
        routeConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.route.v3.RouteConfiguration, io.envoyproxy.envoy.config.route.v3.RouteConfiguration.Builder, io.envoyproxy.envoy.config.route.v3.RouteConfigurationOrBuilder>(
                (io.envoyproxy.envoy.config.route.v3.RouteConfiguration) routeSpecifier_,
                getParentForChildren(),
                isClean());
        routeSpecifier_ = null;
      }
      routeSpecifierCase_ = 4;
      onChanged();
      return routeConfigBuilder_;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutesOrBuilder> scopedRoutesBuilder_;
    /**
     * <pre>
     * A route table will be dynamically assigned to each request based on request attributes
     * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
     * specified in this message.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
     * @return Whether the scopedRoutes field is set.
     */
    @java.lang.Override
    public boolean hasScopedRoutes() {
      return routeSpecifierCase_ == 31;
    }
    /**
     * <pre>
     * A route table will be dynamically assigned to each request based on request attributes
     * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
     * specified in this message.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
     * @return The scopedRoutes.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes getScopedRoutes() {
      if (scopedRoutesBuilder_ == null) {
        if (routeSpecifierCase_ == 31) {
          return (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes) routeSpecifier_;
        }
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.getDefaultInstance();
      } else {
        if (routeSpecifierCase_ == 31) {
          return scopedRoutesBuilder_.getMessage();
        }
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * A route table will be dynamically assigned to each request based on request attributes
     * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
     * specified in this message.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
     */
    public Builder setScopedRoutes(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes value) {
      if (scopedRoutesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        routeSpecifier_ = value;
        onChanged();
      } else {
        scopedRoutesBuilder_.setMessage(value);
      }
      routeSpecifierCase_ = 31;
      return this;
    }
    /**
     * <pre>
     * A route table will be dynamically assigned to each request based on request attributes
     * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
     * specified in this message.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
     */
    public Builder setScopedRoutes(
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.Builder builderForValue) {
      if (scopedRoutesBuilder_ == null) {
        routeSpecifier_ = builderForValue.build();
        onChanged();
      } else {
        scopedRoutesBuilder_.setMessage(builderForValue.build());
      }
      routeSpecifierCase_ = 31;
      return this;
    }
    /**
     * <pre>
     * A route table will be dynamically assigned to each request based on request attributes
     * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
     * specified in this message.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
     */
    public Builder mergeScopedRoutes(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes value) {
      if (scopedRoutesBuilder_ == null) {
        if (routeSpecifierCase_ == 31 &&
            routeSpecifier_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.getDefaultInstance()) {
          routeSpecifier_ = io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.newBuilder((io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes) routeSpecifier_)
              .mergeFrom(value).buildPartial();
        } else {
          routeSpecifier_ = value;
        }
        onChanged();
      } else {
        if (routeSpecifierCase_ == 31) {
          scopedRoutesBuilder_.mergeFrom(value);
        } else {
          scopedRoutesBuilder_.setMessage(value);
        }
      }
      routeSpecifierCase_ = 31;
      return this;
    }
    /**
     * <pre>
     * A route table will be dynamically assigned to each request based on request attributes
     * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
     * specified in this message.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
     */
    public Builder clearScopedRoutes() {
      if (scopedRoutesBuilder_ == null) {
        if (routeSpecifierCase_ == 31) {
          routeSpecifierCase_ = 0;
          routeSpecifier_ = null;
          onChanged();
        }
      } else {
        if (routeSpecifierCase_ == 31) {
          routeSpecifierCase_ = 0;
          routeSpecifier_ = null;
        }
        scopedRoutesBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * A route table will be dynamically assigned to each request based on request attributes
     * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
     * specified in this message.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.Builder getScopedRoutesBuilder() {
      return getScopedRoutesFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * A route table will be dynamically assigned to each request based on request attributes
     * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
     * specified in this message.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
     */
    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutesOrBuilder getScopedRoutesOrBuilder() {
      if ((routeSpecifierCase_ == 31) && (scopedRoutesBuilder_ != null)) {
        return scopedRoutesBuilder_.getMessageOrBuilder();
      } else {
        if (routeSpecifierCase_ == 31) {
          return (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes) routeSpecifier_;
        }
        return io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * A route table will be dynamically assigned to each request based on request attributes
     * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
     * specified in this message.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutesOrBuilder> 
        getScopedRoutesFieldBuilder() {
      if (scopedRoutesBuilder_ == null) {
        if (!(routeSpecifierCase_ == 31)) {
          routeSpecifier_ = io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.getDefaultInstance();
        }
        scopedRoutesBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutesOrBuilder>(
                (io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes) routeSpecifier_,
                getParentForChildren(),
                isClean());
        routeSpecifier_ = null;
      }
      routeSpecifierCase_ = 31;
      onChanged();
      return scopedRoutesBuilder_;
    }

    private java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> httpFilters_ =
      java.util.Collections.emptyList();
    private void ensureHttpFiltersIsMutable() {
      if (!((bitField0_ & 0x00000020) != 0)) {
        httpFilters_ = new java.util.ArrayList<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter>(httpFilters_);
        bitField0_ |= 0x00000020;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder> httpFiltersBuilder_;

    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> getHttpFiltersList() {
      if (httpFiltersBuilder_ == null) {
        return java.util.Collections.unmodifiableList(httpFilters_);
      } else {
        return httpFiltersBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public int getHttpFiltersCount() {
      if (httpFiltersBuilder_ == null) {
        return httpFilters_.size();
      } else {
        return httpFiltersBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter getHttpFilters(int index) {
      if (httpFiltersBuilder_ == null) {
        return httpFilters_.get(index);
      } else {
        return httpFiltersBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public Builder setHttpFilters(
        int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter value) {
      if (httpFiltersBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureHttpFiltersIsMutable();
        httpFilters_.set(index, value);
        onChanged();
      } else {
        httpFiltersBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public Builder setHttpFilters(
        int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder builderForValue) {
      if (httpFiltersBuilder_ == null) {
        ensureHttpFiltersIsMutable();
        httpFilters_.set(index, builderForValue.build());
        onChanged();
      } else {
        httpFiltersBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public Builder addHttpFilters(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter value) {
      if (httpFiltersBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureHttpFiltersIsMutable();
        httpFilters_.add(value);
        onChanged();
      } else {
        httpFiltersBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public Builder addHttpFilters(
        int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter value) {
      if (httpFiltersBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureHttpFiltersIsMutable();
        httpFilters_.add(index, value);
        onChanged();
      } else {
        httpFiltersBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public Builder addHttpFilters(
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder builderForValue) {
      if (httpFiltersBuilder_ == null) {
        ensureHttpFiltersIsMutable();
        httpFilters_.add(builderForValue.build());
        onChanged();
      } else {
        httpFiltersBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public Builder addHttpFilters(
        int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder builderForValue) {
      if (httpFiltersBuilder_ == null) {
        ensureHttpFiltersIsMutable();
        httpFilters_.add(index, builderForValue.build());
        onChanged();
      } else {
        httpFiltersBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public Builder addAllHttpFilters(
        java.lang.Iterable<? extends io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> values) {
      if (httpFiltersBuilder_ == null) {
        ensureHttpFiltersIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, httpFilters_);
        onChanged();
      } else {
        httpFiltersBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public Builder clearHttpFilters() {
      if (httpFiltersBuilder_ == null) {
        httpFilters_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
      } else {
        httpFiltersBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public Builder removeHttpFilters(int index) {
      if (httpFiltersBuilder_ == null) {
        ensureHttpFiltersIsMutable();
        httpFilters_.remove(index);
        onChanged();
      } else {
        httpFiltersBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder getHttpFiltersBuilder(
        int index) {
      return getHttpFiltersFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder getHttpFiltersOrBuilder(
        int index) {
      if (httpFiltersBuilder_ == null) {
        return httpFilters_.get(index);  } else {
        return httpFiltersBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public java.util.List<? extends io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder> 
         getHttpFiltersOrBuilderList() {
      if (httpFiltersBuilder_ != null) {
        return httpFiltersBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(httpFilters_);
      }
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder addHttpFiltersBuilder() {
      return getHttpFiltersFieldBuilder().addBuilder(
          io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.getDefaultInstance());
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder addHttpFiltersBuilder(
        int index) {
      return getHttpFiltersFieldBuilder().addBuilder(
          index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.getDefaultInstance());
    }
    /**
     * <pre>
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
     * as the filters are processed sequentially as request events happen.
     * </pre>
     *
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
     */
    public java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder> 
         getHttpFiltersBuilderList() {
      return getHttpFiltersFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder> 
        getHttpFiltersFieldBuilder() {
      if (httpFiltersBuilder_ == null) {
        httpFiltersBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder>(
                httpFilters_,
                ((bitField0_ & 0x00000020) != 0),
                getParentForChildren(),
                isClean());
        httpFilters_ = null;
      }
      return httpFiltersBuilder_;
    }

    private com.google.protobuf.BoolValue addUserAgent_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> addUserAgentBuilder_;
    /**
     * <pre>
     * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
     * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
     * documentation for more information. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
     * @return Whether the addUserAgent field is set.
     */
    public boolean hasAddUserAgent() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
     * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
     * documentation for more information. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
     * @return The addUserAgent.
     */
    public com.google.protobuf.BoolValue getAddUserAgent() {
      if (addUserAgentBuilder_ == null) {
        return addUserAgent_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : addUserAgent_;
      } else {
        return addUserAgentBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
     * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
     * documentation for more information. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
     */
    public Builder setAddUserAgent(com.google.protobuf.BoolValue value) {
      if (addUserAgentBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        addUserAgent_ = value;
      } else {
        addUserAgentBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000040;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
     * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
     * documentation for more information. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
     */
    public Builder setAddUserAgent(
        com.google.protobuf.BoolValue.Builder builderForValue) {
      if (addUserAgentBuilder_ == null) {
        addUserAgent_ = builderForValue.build();
      } else {
        addUserAgentBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000040;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
     * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
     * documentation for more information. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
     */
    public Builder mergeAddUserAgent(com.google.protobuf.BoolValue value) {
      if (addUserAgentBuilder_ == null) {
        if (((bitField0_ & 0x00000040) != 0) &&
          addUserAgent_ != null &&
          addUserAgent_ != com.google.protobuf.BoolValue.getDefaultInstance()) {
          getAddUserAgentBuilder().mergeFrom(value);
        } else {
          addUserAgent_ = value;
        }
      } else {
        addUserAgentBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000040;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
     * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
     * documentation for more information. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
     */
    public Builder clearAddUserAgent() {
      bitField0_ = (bitField0_ & ~0x00000040);
      addUserAgent_ = null;
      if (addUserAgentBuilder_ != null) {
        addUserAgentBuilder_.dispose();
        addUserAgentBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
     * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
     * documentation for more information. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
     */
    public com.google.protobuf.BoolValue.Builder getAddUserAgentBuilder() {
      bitField0_ |= 0x00000040;
      onChanged();
      return getAddUserAgentFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
     * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
     * documentation for more information. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getAddUserAgentOrBuilder() {
      if (addUserAgentBuilder_ != null) {
        return addUserAgentBuilder_.getMessageOrBuilder();
      } else {
        return addUserAgent_ == null ?
            com.google.protobuf.BoolValue.getDefaultInstance() : addUserAgent_;
      }
    }
    /**
     * <pre>
     * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
     * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
     * documentation for more information. Defaults to false.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
        getAddUserAgentFieldBuilder() {
      if (addUserAgentBuilder_ == null) {
        addUserAgentBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                getAddUserAgent(),
                getParentForChildren(),
                isClean());
        addUserAgent_ = null;
      }
      return addUserAgentBuilder_;
    }

    private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.TracingOrBuilder> tracingBuilder_;
    /**
     * <pre>
     * Presence of the object defines whether the connection manager
     * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
     * &lt;envoy_v3_api_msg_config.trace.v3.Tracing&gt;`.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
     * @return Whether the tracing field is set.
     */
    public boolean hasTracing() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Presence of the object defines whether the connection manager
     * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
     * &lt;envoy_v3_api_msg_config.trace.v3.Tracing&gt;`.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
     * @return The tracing.
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing getTracing() {
      if (tracingBuilder_ == null) {
        return tracing_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.getDefaultInstance() : tracing_;
      } else {
        return tracingBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Presence of the object defines whether the connection manager
     * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
     * &lt;envoy_v3_api_msg_config.trace.v3.Tracing&gt;`.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
     */
    public Builder setTracing(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing value) {
      if (tracingBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        tracing_ = value;
      } else {
        tracingBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000080;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Presence of the object defines whether the connection manager
     * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
     * &lt;envoy_v3_api_msg_config.trace.v3.Tracing&gt;`.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
     */
    public Builder setTracing(
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.Builder builderForValue) {
      if (tracingBuilder_ == null) {
        tracing_ = builderForValue.build();
      } else {
        tracingBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000080;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Presence of the object defines whether the connection manager
     * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
     * &lt;envoy_v3_api_msg_config.trace.v3.Tracing&gt;`.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
     */
    public Builder mergeTracing(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing value) {
      if (tracingBuilder_ == null) {
        if (((bitField0_ & 0x00000080) != 0) &&
          tracing_ != null &&
          tracing_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.getDefaultInstance()) {
          getTracingBuilder().mergeFrom(value);
        } else {
          tracing_ = value;
        }
      } else {
        tracingBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000080;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Presence of the object defines whether the connection manager
     * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
     * &lt;envoy_v3_api_msg_config.trace.v3.Tracing&gt;`.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
     */
    public Builder clearTracing() {
      bitField0_ = (bitField0_ & ~0x00000080);
      tracing_ = null;
      if (tracingBuilder_ != null) {
        tracingBuilder_.dispose();
        tracingBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Presence of the object defines whether the connection manager
     * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
     * &lt;envoy_v3_api_msg_config.trace.v3.Tracing&gt;`.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.Builder getTracingBuilder() {
      bitField0_ |= 0x00000080;
      onChanged();
      return getTracingFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Presence of the object defines whether the connection manager
     * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
     * &lt;envoy_v3_api_msg_config.trace.v3.Tracing&gt;`.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.TracingOrBuilder getTracingOrBuilder() {
      if (tracingBuilder_ != null) {
        return tracingBuilder_.getMessageOrBuilder();
      } else {
        return tracing_ == null ?
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.getDefaultInstance() : tracing_;
      }
    }
    /**
     * <pre>
     * Presence of the object defines whether the connection manager
     * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
     * &lt;envoy_v3_api_msg_config.trace.v3.Tracing&gt;`.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.TracingOrBuilder> 
        getTracingFieldBuilder() {
      if (tracingBuilder_ == null) {
        tracingBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.TracingOrBuilder>(
                getTracing(),
                getParentForChildren(),
                isClean());
        tracing_ = null;
      }
      return tracingBuilder_;
    }

    private io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions commonHttpProtocolOptions_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions, io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.HttpProtocolOptionsOrBuilder> commonHttpProtocolOptionsBuilder_;
    /**
     * <pre>
     * Additional settings for HTTP requests handled by the connection manager. These will be
     * applicable to both HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
     * @return Whether the commonHttpProtocolOptions field is set.
     */
    public boolean hasCommonHttpProtocolOptions() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Additional settings for HTTP requests handled by the connection manager. These will be
     * applicable to both HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
     * @return The commonHttpProtocolOptions.
     */
    public io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions getCommonHttpProtocolOptions() {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        return commonHttpProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.getDefaultInstance() : commonHttpProtocolOptions_;
      } else {
        return commonHttpProtocolOptionsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Additional settings for HTTP requests handled by the connection manager. These will be
     * applicable to both HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setCommonHttpProtocolOptions(io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions value) {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        commonHttpProtocolOptions_ = value;
      } else {
        commonHttpProtocolOptionsBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000100;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Additional settings for HTTP requests handled by the connection manager. These will be
     * applicable to both HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setCommonHttpProtocolOptions(
        io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.Builder builderForValue) {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        commonHttpProtocolOptions_ = builderForValue.build();
      } else {
        commonHttpProtocolOptionsBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000100;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Additional settings for HTTP requests handled by the connection manager. These will be
     * applicable to both HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder mergeCommonHttpProtocolOptions(io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions value) {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        if (((bitField0_ & 0x00000100) != 0) &&
          commonHttpProtocolOptions_ != null &&
          commonHttpProtocolOptions_ != io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.getDefaultInstance()) {
          getCommonHttpProtocolOptionsBuilder().mergeFrom(value);
        } else {
          commonHttpProtocolOptions_ = value;
        }
      } else {
        commonHttpProtocolOptionsBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000100;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Additional settings for HTTP requests handled by the connection manager. These will be
     * applicable to both HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder clearCommonHttpProtocolOptions() {
      bitField0_ = (bitField0_ & ~0x00000100);
      commonHttpProtocolOptions_ = null;
      if (commonHttpProtocolOptionsBuilder_ != null) {
        commonHttpProtocolOptionsBuilder_.dispose();
        commonHttpProtocolOptionsBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Additional settings for HTTP requests handled by the connection manager. These will be
     * applicable to both HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
     */
    public io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.Builder getCommonHttpProtocolOptionsBuilder() {
      bitField0_ |= 0x00000100;
      onChanged();
      return getCommonHttpProtocolOptionsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Additional settings for HTTP requests handled by the connection manager. These will be
     * applicable to both HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
     */
    public io.envoyproxy.envoy.config.core.v3.HttpProtocolOptionsOrBuilder getCommonHttpProtocolOptionsOrBuilder() {
      if (commonHttpProtocolOptionsBuilder_ != null) {
        return commonHttpProtocolOptionsBuilder_.getMessageOrBuilder();
      } else {
        return commonHttpProtocolOptions_ == null ?
            io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.getDefaultInstance() : commonHttpProtocolOptions_;
      }
    }
    /**
     * <pre>
     * Additional settings for HTTP requests handled by the connection manager. These will be
     * applicable to both HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions, io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.HttpProtocolOptionsOrBuilder> 
        getCommonHttpProtocolOptionsFieldBuilder() {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        commonHttpProtocolOptionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions, io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.HttpProtocolOptionsOrBuilder>(
                getCommonHttpProtocolOptions(),
                getParentForChildren(),
                isClean());
        commonHttpProtocolOptions_ = null;
      }
      return commonHttpProtocolOptionsBuilder_;
    }

    private io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions httpProtocolOptions_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions, io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptionsOrBuilder> httpProtocolOptionsBuilder_;
    /**
     * <pre>
     * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
     * [#comment:TODO: The following fields are ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present:
     * 1. :ref:`allow_chunked_length &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.allow_chunked_length&gt;`]
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
     * @return Whether the httpProtocolOptions field is set.
     */
    public boolean hasHttpProtocolOptions() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
     * [#comment:TODO: The following fields are ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present:
     * 1. :ref:`allow_chunked_length &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.allow_chunked_length&gt;`]
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
     * @return The httpProtocolOptions.
     */
    public io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions getHttpProtocolOptions() {
      if (httpProtocolOptionsBuilder_ == null) {
        return httpProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.getDefaultInstance() : httpProtocolOptions_;
      } else {
        return httpProtocolOptionsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
     * [#comment:TODO: The following fields are ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present:
     * 1. :ref:`allow_chunked_length &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.allow_chunked_length&gt;`]
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
     */
    public Builder setHttpProtocolOptions(io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions value) {
      if (httpProtocolOptionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        httpProtocolOptions_ = value;
      } else {
        httpProtocolOptionsBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000200;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
     * [#comment:TODO: The following fields are ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present:
     * 1. :ref:`allow_chunked_length &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.allow_chunked_length&gt;`]
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
     */
    public Builder setHttpProtocolOptions(
        io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.Builder builderForValue) {
      if (httpProtocolOptionsBuilder_ == null) {
        httpProtocolOptions_ = builderForValue.build();
      } else {
        httpProtocolOptionsBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000200;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
     * [#comment:TODO: The following fields are ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present:
     * 1. :ref:`allow_chunked_length &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.allow_chunked_length&gt;`]
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
     */
    public Builder mergeHttpProtocolOptions(io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions value) {
      if (httpProtocolOptionsBuilder_ == null) {
        if (((bitField0_ & 0x00000200) != 0) &&
          httpProtocolOptions_ != null &&
          httpProtocolOptions_ != io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.getDefaultInstance()) {
          getHttpProtocolOptionsBuilder().mergeFrom(value);
        } else {
          httpProtocolOptions_ = value;
        }
      } else {
        httpProtocolOptionsBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000200;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
     * [#comment:TODO: The following fields are ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present:
     * 1. :ref:`allow_chunked_length &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.allow_chunked_length&gt;`]
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
     */
    public Builder clearHttpProtocolOptions() {
      bitField0_ = (bitField0_ & ~0x00000200);
      httpProtocolOptions_ = null;
      if (httpProtocolOptionsBuilder_ != null) {
        httpProtocolOptionsBuilder_.dispose();
        httpProtocolOptionsBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
     * [#comment:TODO: The following fields are ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present:
     * 1. :ref:`allow_chunked_length &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.allow_chunked_length&gt;`]
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.Builder getHttpProtocolOptionsBuilder() {
      bitField0_ |= 0x00000200;
      onChanged();
      return getHttpProtocolOptionsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
     * [#comment:TODO: The following fields are ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present:
     * 1. :ref:`allow_chunked_length &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.allow_chunked_length&gt;`]
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptionsOrBuilder getHttpProtocolOptionsOrBuilder() {
      if (httpProtocolOptionsBuilder_ != null) {
        return httpProtocolOptionsBuilder_.getMessageOrBuilder();
      } else {
        return httpProtocolOptions_ == null ?
            io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.getDefaultInstance() : httpProtocolOptions_;
      }
    }
    /**
     * <pre>
     * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
     * [#comment:TODO: The following fields are ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present:
     * 1. :ref:`allow_chunked_length &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.allow_chunked_length&gt;`]
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions, io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptionsOrBuilder> 
        getHttpProtocolOptionsFieldBuilder() {
      if (httpProtocolOptionsBuilder_ == null) {
        httpProtocolOptionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions, io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptionsOrBuilder>(
                getHttpProtocolOptions(),
                getParentForChildren(),
                isClean());
        httpProtocolOptions_ = null;
      }
      return httpProtocolOptionsBuilder_;
    }

    private io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions http2ProtocolOptions_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions, io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptionsOrBuilder> http2ProtocolOptionsBuilder_;
    /**
     * <pre>
     * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
     * @return Whether the http2ProtocolOptions field is set.
     */
    public boolean hasHttp2ProtocolOptions() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
     * @return The http2ProtocolOptions.
     */
    public io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions getHttp2ProtocolOptions() {
      if (http2ProtocolOptionsBuilder_ == null) {
        return http2ProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.getDefaultInstance() : http2ProtocolOptions_;
      } else {
        return http2ProtocolOptionsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setHttp2ProtocolOptions(io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions value) {
      if (http2ProtocolOptionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        http2ProtocolOptions_ = value;
      } else {
        http2ProtocolOptionsBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000400;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setHttp2ProtocolOptions(
        io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.Builder builderForValue) {
      if (http2ProtocolOptionsBuilder_ == null) {
        http2ProtocolOptions_ = builderForValue.build();
      } else {
        http2ProtocolOptionsBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000400;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder mergeHttp2ProtocolOptions(io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions value) {
      if (http2ProtocolOptionsBuilder_ == null) {
        if (((bitField0_ & 0x00000400) != 0) &&
          http2ProtocolOptions_ != null &&
          http2ProtocolOptions_ != io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.getDefaultInstance()) {
          getHttp2ProtocolOptionsBuilder().mergeFrom(value);
        } else {
          http2ProtocolOptions_ = value;
        }
      } else {
        http2ProtocolOptionsBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000400;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder clearHttp2ProtocolOptions() {
      bitField0_ = (bitField0_ & ~0x00000400);
      http2ProtocolOptions_ = null;
      if (http2ProtocolOptionsBuilder_ != null) {
        http2ProtocolOptionsBuilder_.dispose();
        http2ProtocolOptionsBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
     */
    public io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.Builder getHttp2ProtocolOptionsBuilder() {
      bitField0_ |= 0x00000400;
      onChanged();
      return getHttp2ProtocolOptionsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
     */
    public io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptionsOrBuilder getHttp2ProtocolOptionsOrBuilder() {
      if (http2ProtocolOptionsBuilder_ != null) {
        return http2ProtocolOptionsBuilder_.getMessageOrBuilder();
      } else {
        return http2ProtocolOptions_ == null ?
            io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.getDefaultInstance() : http2ProtocolOptions_;
      }
    }
    /**
     * <pre>
     * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions, io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptionsOrBuilder> 
        getHttp2ProtocolOptionsFieldBuilder() {
      if (http2ProtocolOptionsBuilder_ == null) {
        http2ProtocolOptionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions, io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptionsOrBuilder>(
                getHttp2ProtocolOptions(),
                getParentForChildren(),
                isClean());
        http2ProtocolOptions_ = null;
      }
      return http2ProtocolOptionsBuilder_;
    }

    private io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptions http3ProtocolOptions_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptions, io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptionsOrBuilder> http3ProtocolOptionsBuilder_;
    /**
     * <pre>
     * Additional HTTP/3 settings that are passed directly to the HTTP/3 codec.
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 44;</code>
     * @return Whether the http3ProtocolOptions field is set.
     */
    public boolean hasHttp3ProtocolOptions() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * Additional HTTP/3 settings that are passed directly to the HTTP/3 codec.
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 44;</code>
     * @return The http3ProtocolOptions.
     */
    public io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptions getHttp3ProtocolOptions() {
      if (http3ProtocolOptionsBuilder_ == null) {
        return http3ProtocolOptions_ == null ? io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptions.getDefaultInstance() : http3ProtocolOptions_;
      } else {
        return http3ProtocolOptionsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Additional HTTP/3 settings that are passed directly to the HTTP/3 codec.
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 44;</code>
     */
    public Builder setHttp3ProtocolOptions(io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptions value) {
      if (http3ProtocolOptionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        http3ProtocolOptions_ = value;
      } else {
        http3ProtocolOptionsBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00000800;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Additional HTTP/3 settings that are passed directly to the HTTP/3 codec.
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 44;</code>
     */
    public Builder setHttp3ProtocolOptions(
        io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptions.Builder builderForValue) {
      if (http3ProtocolOptionsBuilder_ == null) {
        http3ProtocolOptions_ = builderForValue.build();
      } else {
        http3ProtocolOptionsBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00000800;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Additional HTTP/3 settings that are passed directly to the HTTP/3 codec.
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 44;</code>
     */
    public Builder mergeHttp3ProtocolOptions(io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptions value) {
      if (http3ProtocolOptionsBuilder_ == null) {
        if (((bitField0_ & 0x00000800) != 0) &&
          http3ProtocolOptions_ != null &&
          http3ProtocolOptions_ != io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptions.getDefaultInstance()) {
          getHttp3ProtocolOptionsBuilder().mergeFrom(value);
        } else {
          http3ProtocolOptions_ = value;
        }
      } else {
        http3ProtocolOptionsBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00000800;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Additional HTTP/3 settings that are passed directly to the HTTP/3 codec.
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 44;</code>
     */
    public Builder clearHttp3ProtocolOptions() {
      bitField0_ = (bitField0_ & ~0x00000800);
      http3ProtocolOptions_ = null;
      if (http3ProtocolOptionsBuilder_ != null) {
        http3ProtocolOptionsBuilder_.dispose();
        http3ProtocolOptionsBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Additional HTTP/3 settings that are passed directly to the HTTP/3 codec.
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 44;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptions.Builder getHttp3ProtocolOptionsBuilder() {
      bitField0_ |= 0x00000800;
      onChanged();
      return getHttp3ProtocolOptionsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Additional HTTP/3 settings that are passed directly to the HTTP/3 codec.
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 44;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptionsOrBuilder getHttp3ProtocolOptionsOrBuilder() {
      if (http3ProtocolOptionsBuilder_ != null) {
        return http3ProtocolOptionsBuilder_.getMessageOrBuilder();
      } else {
        return http3ProtocolOptions_ == null ?
            io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptions.getDefaultInstance() : http3ProtocolOptions_;
      }
    }
    /**
     * <pre>
     * Additional HTTP/3 settings that are passed directly to the HTTP/3 codec.
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 44;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptions, io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptionsOrBuilder> 
        getHttp3ProtocolOptionsFieldBuilder() {
      if (http3ProtocolOptionsBuilder_ == null) {
        http3ProtocolOptionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptions, io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptions.Builder, io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptionsOrBuilder>(
                getHttp3ProtocolOptions(),
                getParentForChildren(),
                isClean());
        http3ProtocolOptions_ = null;
      }
      return http3ProtocolOptionsBuilder_;
    }

    private java.lang.Object serverName_ = "";
    /**
     * <pre>
     * An optional override that the connection manager will write to the server
     * header in responses. If not set, the default is ``envoy``.
     * </pre>
     *
     * <code>string server_name = 10 [(.validate.rules) = { ... }</code>
     * @return The serverName.
     */
    public java.lang.String getServerName() {
      java.lang.Object ref = serverName_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        serverName_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * An optional override that the connection manager will write to the server
     * header in responses. If not set, the default is ``envoy``.
     * </pre>
     *
     * <code>string server_name = 10 [(.validate.rules) = { ... }</code>
     * @return The bytes for serverName.
     */
    public com.google.protobuf.ByteString
        getServerNameBytes() {
      java.lang.Object ref = serverName_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        serverName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * An optional override that the connection manager will write to the server
     * header in responses. If not set, the default is ``envoy``.
     * </pre>
     *
     * <code>string server_name = 10 [(.validate.rules) = { ... }</code>
     * @param value The serverName to set.
     * @return This builder for chaining.
     */
    public Builder setServerName(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      serverName_ = value;
      bitField0_ |= 0x00001000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * An optional override that the connection manager will write to the server
     * header in responses. If not set, the default is ``envoy``.
     * </pre>
     *
     * <code>string server_name = 10 [(.validate.rules) = { ... }</code>
     * @return This builder for chaining.
     */
    public Builder clearServerName() {
      serverName_ = getDefaultInstance().getServerName();
      bitField0_ = (bitField0_ & ~0x00001000);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * An optional override that the connection manager will write to the server
     * header in responses. If not set, the default is ``envoy``.
     * </pre>
     *
     * <code>string server_name = 10 [(.validate.rules) = { ... }</code>
     * @param value The bytes for serverName to set.
     * @return This builder for chaining.
     */
    public Builder setServerNameBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      serverName_ = value;
      bitField0_ |= 0x00001000;
      onChanged();
      return this;
    }

    private int serverHeaderTransformation_ = 0;
    /**
     * <pre>
     * Defines the action to be applied to the Server header on the response path.
     * By default, Envoy will overwrite the header with the value specified in
     * server_name.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation server_header_transformation = 34 [(.validate.rules) = { ... }</code>
     * @return The enum numeric value on the wire for serverHeaderTransformation.
     */
    @java.lang.Override public int getServerHeaderTransformationValue() {
      return serverHeaderTransformation_;
    }
    /**
     * <pre>
     * Defines the action to be applied to the Server header on the response path.
     * By default, Envoy will overwrite the header with the value specified in
     * server_name.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation server_header_transformation = 34 [(.validate.rules) = { ... }</code>
     * @param value The enum numeric value on the wire for serverHeaderTransformation to set.
     * @return This builder for chaining.
     */
    public Builder setServerHeaderTransformationValue(int value) {
      serverHeaderTransformation_ = value;
      bitField0_ |= 0x00002000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Defines the action to be applied to the Server header on the response path.
     * By default, Envoy will overwrite the header with the value specified in
     * server_name.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation server_header_transformation = 34 [(.validate.rules) = { ... }</code>
     * @return The serverHeaderTransformation.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation getServerHeaderTransformation() {
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation result = io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation.forNumber(serverHeaderTransformation_);
      return result == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * Defines the action to be applied to the Server header on the response path.
     * By default, Envoy will overwrite the header with the value specified in
     * server_name.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation server_header_transformation = 34 [(.validate.rules) = { ... }</code>
     * @param value The serverHeaderTransformation to set.
     * @return This builder for chaining.
     */
    public Builder setServerHeaderTransformation(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00002000;
      serverHeaderTransformation_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Defines the action to be applied to the Server header on the response path.
     * By default, Envoy will overwrite the header with the value specified in
     * server_name.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation server_header_transformation = 34 [(.validate.rules) = { ... }</code>
     * @return This builder for chaining.
     */
    public Builder clearServerHeaderTransformation() {
      bitField0_ = (bitField0_ & ~0x00002000);
      serverHeaderTransformation_ = 0;
      onChanged();
      return this;
    }

    private io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformation schemeHeaderTransformation_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformation, io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformation.Builder, io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformationOrBuilder> schemeHeaderTransformationBuilder_;
    /**
     * <pre>
     * Allows for explicit transformation of the :scheme header on the request path.
     * If not set, Envoy's default :ref:`scheme  &lt;config_http_conn_man_headers_scheme&gt;`
     * handling applies.
     * </pre>
     *
     * <code>.envoy.config.core.v3.SchemeHeaderTransformation scheme_header_transformation = 48;</code>
     * @return Whether the schemeHeaderTransformation field is set.
     */
    public boolean hasSchemeHeaderTransformation() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <pre>
     * Allows for explicit transformation of the :scheme header on the request path.
     * If not set, Envoy's default :ref:`scheme  &lt;config_http_conn_man_headers_scheme&gt;`
     * handling applies.
     * </pre>
     *
     * <code>.envoy.config.core.v3.SchemeHeaderTransformation scheme_header_transformation = 48;</code>
     * @return The schemeHeaderTransformation.
     */
    public io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformation getSchemeHeaderTransformation() {
      if (schemeHeaderTransformationBuilder_ == null) {
        return schemeHeaderTransformation_ == null ? io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformation.getDefaultInstance() : schemeHeaderTransformation_;
      } else {
        return schemeHeaderTransformationBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Allows for explicit transformation of the :scheme header on the request path.
     * If not set, Envoy's default :ref:`scheme  &lt;config_http_conn_man_headers_scheme&gt;`
     * handling applies.
     * </pre>
     *
     * <code>.envoy.config.core.v3.SchemeHeaderTransformation scheme_header_transformation = 48;</code>
     */
    public Builder setSchemeHeaderTransformation(io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformation value) {
      if (schemeHeaderTransformationBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        schemeHeaderTransformation_ = value;
      } else {
        schemeHeaderTransformationBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00004000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Allows for explicit transformation of the :scheme header on the request path.
     * If not set, Envoy's default :ref:`scheme  &lt;config_http_conn_man_headers_scheme&gt;`
     * handling applies.
     * </pre>
     *
     * <code>.envoy.config.core.v3.SchemeHeaderTransformation scheme_header_transformation = 48;</code>
     */
    public Builder setSchemeHeaderTransformation(
        io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformation.Builder builderForValue) {
      if (schemeHeaderTransformationBuilder_ == null) {
        schemeHeaderTransformation_ = builderForValue.build();
      } else {
        schemeHeaderTransformationBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00004000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Allows for explicit transformation of the :scheme header on the request path.
     * If not set, Envoy's default :ref:`scheme  &lt;config_http_conn_man_headers_scheme&gt;`
     * handling applies.
     * </pre>
     *
     * <code>.envoy.config.core.v3.SchemeHeaderTransformation scheme_header_transformation = 48;</code>
     */
    public Builder mergeSchemeHeaderTransformation(io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformation value) {
      if (schemeHeaderTransformationBuilder_ == null) {
        if (((bitField0_ & 0x00004000) != 0) &&
          schemeHeaderTransformation_ != null &&
          schemeHeaderTransformation_ != io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformation.getDefaultInstance()) {
          getSchemeHeaderTransformationBuilder().mergeFrom(value);
        } else {
          schemeHeaderTransformation_ = value;
        }
      } else {
        schemeHeaderTransformationBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00004000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Allows for explicit transformation of the :scheme header on the request path.
     * If not set, Envoy's default :ref:`scheme  &lt;config_http_conn_man_headers_scheme&gt;`
     * handling applies.
     * </pre>
     *
     * <code>.envoy.config.core.v3.SchemeHeaderTransformation scheme_header_transformation = 48;</code>
     */
    public Builder clearSchemeHeaderTransformation() {
      bitField0_ = (bitField0_ & ~0x00004000);
      schemeHeaderTransformation_ = null;
      if (schemeHeaderTransformationBuilder_ != null) {
        schemeHeaderTransformationBuilder_.dispose();
        schemeHeaderTransformationBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Allows for explicit transformation of the :scheme header on the request path.
     * If not set, Envoy's default :ref:`scheme  &lt;config_http_conn_man_headers_scheme&gt;`
     * handling applies.
     * </pre>
     *
     * <code>.envoy.config.core.v3.SchemeHeaderTransformation scheme_header_transformation = 48;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformation.Builder getSchemeHeaderTransformationBuilder() {
      bitField0_ |= 0x00004000;
      onChanged();
      return getSchemeHeaderTransformationFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Allows for explicit transformation of the :scheme header on the request path.
     * If not set, Envoy's default :ref:`scheme  &lt;config_http_conn_man_headers_scheme&gt;`
     * handling applies.
     * </pre>
     *
     * <code>.envoy.config.core.v3.SchemeHeaderTransformation scheme_header_transformation = 48;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformationOrBuilder getSchemeHeaderTransformationOrBuilder() {
      if (schemeHeaderTransformationBuilder_ != null) {
        return schemeHeaderTransformationBuilder_.getMessageOrBuilder();
      } else {
        return schemeHeaderTransformation_ == null ?
            io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformation.getDefaultInstance() : schemeHeaderTransformation_;
      }
    }
    /**
     * <pre>
     * Allows for explicit transformation of the :scheme header on the request path.
     * If not set, Envoy's default :ref:`scheme  &lt;config_http_conn_man_headers_scheme&gt;`
     * handling applies.
     * </pre>
     *
     * <code>.envoy.config.core.v3.SchemeHeaderTransformation scheme_header_transformation = 48;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformation, io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformation.Builder, io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformationOrBuilder> 
        getSchemeHeaderTransformationFieldBuilder() {
      if (schemeHeaderTransformationBuilder_ == null) {
        schemeHeaderTransformationBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformation, io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformation.Builder, io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformationOrBuilder>(
                getSchemeHeaderTransformation(),
                getParentForChildren(),
                isClean());
        schemeHeaderTransformation_ = null;
      }
      return schemeHeaderTransformationBuilder_;
    }

    private com.google.protobuf.UInt32Value maxRequestHeadersKb_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> maxRequestHeadersKbBuilder_;
    /**
     * <pre>
     * The maximum request headers size for incoming connections.
     * If unconfigured, the default max request headers allowed is 60 KiB.
     * Requests that exceed this limit will receive a 431 response.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
     * @return Whether the maxRequestHeadersKb field is set.
     */
    public boolean hasMaxRequestHeadersKb() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     * <pre>
     * The maximum request headers size for incoming connections.
     * If unconfigured, the default max request headers allowed is 60 KiB.
     * Requests that exceed this limit will receive a 431 response.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
     * @return The maxRequestHeadersKb.
     */
    public com.google.protobuf.UInt32Value getMaxRequestHeadersKb() {
      if (maxRequestHeadersKbBuilder_ == null) {
        return maxRequestHeadersKb_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : maxRequestHeadersKb_;
      } else {
        return maxRequestHeadersKbBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The maximum request headers size for incoming connections.
     * If unconfigured, the default max request headers allowed is 60 KiB.
     * Requests that exceed this limit will receive a 431 response.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
     */
    public Builder setMaxRequestHeadersKb(com.google.protobuf.UInt32Value value) {
      if (maxRequestHeadersKbBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        maxRequestHeadersKb_ = value;
      } else {
        maxRequestHeadersKbBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00008000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The maximum request headers size for incoming connections.
     * If unconfigured, the default max request headers allowed is 60 KiB.
     * Requests that exceed this limit will receive a 431 response.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
     */
    public Builder setMaxRequestHeadersKb(
        com.google.protobuf.UInt32Value.Builder builderForValue) {
      if (maxRequestHeadersKbBuilder_ == null) {
        maxRequestHeadersKb_ = builderForValue.build();
      } else {
        maxRequestHeadersKbBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00008000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The maximum request headers size for incoming connections.
     * If unconfigured, the default max request headers allowed is 60 KiB.
     * Requests that exceed this limit will receive a 431 response.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
     */
    public Builder mergeMaxRequestHeadersKb(com.google.protobuf.UInt32Value value) {
      if (maxRequestHeadersKbBuilder_ == null) {
        if (((bitField0_ & 0x00008000) != 0) &&
          maxRequestHeadersKb_ != null &&
          maxRequestHeadersKb_ != com.google.protobuf.UInt32Value.getDefaultInstance()) {
          getMaxRequestHeadersKbBuilder().mergeFrom(value);
        } else {
          maxRequestHeadersKb_ = value;
        }
      } else {
        maxRequestHeadersKbBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00008000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The maximum request headers size for incoming connections.
     * If unconfigured, the default max request headers allowed is 60 KiB.
     * Requests that exceed this limit will receive a 431 response.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
     */
    public Builder clearMaxRequestHeadersKb() {
      bitField0_ = (bitField0_ & ~0x00008000);
      maxRequestHeadersKb_ = null;
      if (maxRequestHeadersKbBuilder_ != null) {
        maxRequestHeadersKbBuilder_.dispose();
        maxRequestHeadersKbBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The maximum request headers size for incoming connections.
     * If unconfigured, the default max request headers allowed is 60 KiB.
     * Requests that exceed this limit will receive a 431 response.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.UInt32Value.Builder getMaxRequestHeadersKbBuilder() {
      bitField0_ |= 0x00008000;
      onChanged();
      return getMaxRequestHeadersKbFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The maximum request headers size for incoming connections.
     * If unconfigured, the default max request headers allowed is 60 KiB.
     * Requests that exceed this limit will receive a 431 response.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.UInt32ValueOrBuilder getMaxRequestHeadersKbOrBuilder() {
      if (maxRequestHeadersKbBuilder_ != null) {
        return maxRequestHeadersKbBuilder_.getMessageOrBuilder();
      } else {
        return maxRequestHeadersKb_ == null ?
            com.google.protobuf.UInt32Value.getDefaultInstance() : maxRequestHeadersKb_;
      }
    }
    /**
     * <pre>
     * The maximum request headers size for incoming connections.
     * If unconfigured, the default max request headers allowed is 60 KiB.
     * Requests that exceed this limit will receive a 431 response.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
        getMaxRequestHeadersKbFieldBuilder() {
      if (maxRequestHeadersKbBuilder_ == null) {
        maxRequestHeadersKbBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                getMaxRequestHeadersKb(),
                getParentForChildren(),
                isClean());
        maxRequestHeadersKb_ = null;
      }
      return maxRequestHeadersKbBuilder_;
    }

    private com.google.protobuf.Duration streamIdleTimeout_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> streamIdleTimeoutBuilder_;
    /**
     * <pre>
     * The stream idle timeout for connections managed by the connection manager.
     * If not specified, this defaults to 5 minutes. The default value was selected
     * so as not to interfere with any smaller configured timeouts that may have
     * existed in configurations prior to the introduction of this feature, while
     * introducing robustness to TCP connections that terminate without a FIN.
     * This idle timeout applies to new streams and is overridable by the
     * :ref:`route-level idle_timeout
     * &lt;envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
     * which the override applies, prior to receipt of the initial request
     * headers, the :ref:`stream_idle_timeout
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
     * applies. Each time an encode/decode event for headers or data is processed
     * for the stream, the timer will be reset. If the timeout fires, the stream
     * is terminated with a 408 Request Timeout error code if no upstream response
     * header has been received, otherwise a stream reset occurs.
     * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
     * window to write any remaining stream data once the entirety of stream data (local end stream is
     * true) has been buffered pending available window. In other words, this timeout defends against
     * a peer that does not release enough window to completely write the stream, even though all
     * data has been proxied within available flow control windows. If the timeout is hit in this
     * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
     * incremented. Note that :ref:`max_stream_duration
     * &lt;envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
     * this corner case.
     * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
     * is configured, this timeout is scaled according to the value for
     * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
     * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
     * to the granularity of events presented to the connection manager. For example, while receiving
     * very large request headers, it may be the case that there is traffic regularly arriving on the
     * wire while the connection manage is only able to observe the end-of-headers event, hence the
     * stream may still idle timeout.
     * A value of 0 will completely disable the connection manager stream idle
     * timeout, although per-route idle timeout overrides will continue to apply.
     * </pre>
     *
     * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
     * @return Whether the streamIdleTimeout field is set.
     */
    public boolean hasStreamIdleTimeout() {
      return ((bitField0_ & 0x00010000) != 0);
    }
    /**
     * <pre>
     * The stream idle timeout for connections managed by the connection manager.
     * If not specified, this defaults to 5 minutes. The default value was selected
     * so as not to interfere with any smaller configured timeouts that may have
     * existed in configurations prior to the introduction of this feature, while
     * introducing robustness to TCP connections that terminate without a FIN.
     * This idle timeout applies to new streams and is overridable by the
     * :ref:`route-level idle_timeout
     * &lt;envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
     * which the override applies, prior to receipt of the initial request
     * headers, the :ref:`stream_idle_timeout
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
     * applies. Each time an encode/decode event for headers or data is processed
     * for the stream, the timer will be reset. If the timeout fires, the stream
     * is terminated with a 408 Request Timeout error code if no upstream response
     * header has been received, otherwise a stream reset occurs.
     * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
     * window to write any remaining stream data once the entirety of stream data (local end stream is
     * true) has been buffered pending available window. In other words, this timeout defends against
     * a peer that does not release enough window to completely write the stream, even though all
     * data has been proxied within available flow control windows. If the timeout is hit in this
     * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
     * incremented. Note that :ref:`max_stream_duration
     * &lt;envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
     * this corner case.
     * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
     * is configured, this timeout is scaled according to the value for
     * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
     * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
     * to the granularity of events presented to the connection manager. For example, while receiving
     * very large request headers, it may be the case that there is traffic regularly arriving on the
     * wire while the connection manage is only able to observe the end-of-headers event, hence the
     * stream may still idle timeout.
     * A value of 0 will completely disable the connection manager stream idle
     * timeout, although per-route idle timeout overrides will continue to apply.
     * </pre>
     *
     * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
     * @return The streamIdleTimeout.
     */
    public com.google.protobuf.Duration getStreamIdleTimeout() {
      if (streamIdleTimeoutBuilder_ == null) {
        return streamIdleTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : streamIdleTimeout_;
      } else {
        return streamIdleTimeoutBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The stream idle timeout for connections managed by the connection manager.
     * If not specified, this defaults to 5 minutes. The default value was selected
     * so as not to interfere with any smaller configured timeouts that may have
     * existed in configurations prior to the introduction of this feature, while
     * introducing robustness to TCP connections that terminate without a FIN.
     * This idle timeout applies to new streams and is overridable by the
     * :ref:`route-level idle_timeout
     * &lt;envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
     * which the override applies, prior to receipt of the initial request
     * headers, the :ref:`stream_idle_timeout
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
     * applies. Each time an encode/decode event for headers or data is processed
     * for the stream, the timer will be reset. If the timeout fires, the stream
     * is terminated with a 408 Request Timeout error code if no upstream response
     * header has been received, otherwise a stream reset occurs.
     * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
     * window to write any remaining stream data once the entirety of stream data (local end stream is
     * true) has been buffered pending available window. In other words, this timeout defends against
     * a peer that does not release enough window to completely write the stream, even though all
     * data has been proxied within available flow control windows. If the timeout is hit in this
     * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
     * incremented. Note that :ref:`max_stream_duration
     * &lt;envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
     * this corner case.
     * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
     * is configured, this timeout is scaled according to the value for
     * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
     * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
     * to the granularity of events presented to the connection manager. For example, while receiving
     * very large request headers, it may be the case that there is traffic regularly arriving on the
     * wire while the connection manage is only able to observe the end-of-headers event, hence the
     * stream may still idle timeout.
     * A value of 0 will completely disable the connection manager stream idle
     * timeout, although per-route idle timeout overrides will continue to apply.
     * </pre>
     *
     * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setStreamIdleTimeout(com.google.protobuf.Duration value) {
      if (streamIdleTimeoutBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        streamIdleTimeout_ = value;
      } else {
        streamIdleTimeoutBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00010000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The stream idle timeout for connections managed by the connection manager.
     * If not specified, this defaults to 5 minutes. The default value was selected
     * so as not to interfere with any smaller configured timeouts that may have
     * existed in configurations prior to the introduction of this feature, while
     * introducing robustness to TCP connections that terminate without a FIN.
     * This idle timeout applies to new streams and is overridable by the
     * :ref:`route-level idle_timeout
     * &lt;envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
     * which the override applies, prior to receipt of the initial request
     * headers, the :ref:`stream_idle_timeout
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
     * applies. Each time an encode/decode event for headers or data is processed
     * for the stream, the timer will be reset. If the timeout fires, the stream
     * is terminated with a 408 Request Timeout error code if no upstream response
     * header has been received, otherwise a stream reset occurs.
     * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
     * window to write any remaining stream data once the entirety of stream data (local end stream is
     * true) has been buffered pending available window. In other words, this timeout defends against
     * a peer that does not release enough window to completely write the stream, even though all
     * data has been proxied within available flow control windows. If the timeout is hit in this
     * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
     * incremented. Note that :ref:`max_stream_duration
     * &lt;envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
     * this corner case.
     * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
     * is configured, this timeout is scaled according to the value for
     * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
     * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
     * to the granularity of events presented to the connection manager. For example, while receiving
     * very large request headers, it may be the case that there is traffic regularly arriving on the
     * wire while the connection manage is only able to observe the end-of-headers event, hence the
     * stream may still idle timeout.
     * A value of 0 will completely disable the connection manager stream idle
     * timeout, although per-route idle timeout overrides will continue to apply.
     * </pre>
     *
     * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setStreamIdleTimeout(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (streamIdleTimeoutBuilder_ == null) {
        streamIdleTimeout_ = builderForValue.build();
      } else {
        streamIdleTimeoutBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00010000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The stream idle timeout for connections managed by the connection manager.
     * If not specified, this defaults to 5 minutes. The default value was selected
     * so as not to interfere with any smaller configured timeouts that may have
     * existed in configurations prior to the introduction of this feature, while
     * introducing robustness to TCP connections that terminate without a FIN.
     * This idle timeout applies to new streams and is overridable by the
     * :ref:`route-level idle_timeout
     * &lt;envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
     * which the override applies, prior to receipt of the initial request
     * headers, the :ref:`stream_idle_timeout
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
     * applies. Each time an encode/decode event for headers or data is processed
     * for the stream, the timer will be reset. If the timeout fires, the stream
     * is terminated with a 408 Request Timeout error code if no upstream response
     * header has been received, otherwise a stream reset occurs.
     * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
     * window to write any remaining stream data once the entirety of stream data (local end stream is
     * true) has been buffered pending available window. In other words, this timeout defends against
     * a peer that does not release enough window to completely write the stream, even though all
     * data has been proxied within available flow control windows. If the timeout is hit in this
     * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
     * incremented. Note that :ref:`max_stream_duration
     * &lt;envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
     * this corner case.
     * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
     * is configured, this timeout is scaled according to the value for
     * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
     * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
     * to the granularity of events presented to the connection manager. For example, while receiving
     * very large request headers, it may be the case that there is traffic regularly arriving on the
     * wire while the connection manage is only able to observe the end-of-headers event, hence the
     * stream may still idle timeout.
     * A value of 0 will completely disable the connection manager stream idle
     * timeout, although per-route idle timeout overrides will continue to apply.
     * </pre>
     *
     * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder mergeStreamIdleTimeout(com.google.protobuf.Duration value) {
      if (streamIdleTimeoutBuilder_ == null) {
        if (((bitField0_ & 0x00010000) != 0) &&
          streamIdleTimeout_ != null &&
          streamIdleTimeout_ != com.google.protobuf.Duration.getDefaultInstance()) {
          getStreamIdleTimeoutBuilder().mergeFrom(value);
        } else {
          streamIdleTimeout_ = value;
        }
      } else {
        streamIdleTimeoutBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00010000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The stream idle timeout for connections managed by the connection manager.
     * If not specified, this defaults to 5 minutes. The default value was selected
     * so as not to interfere with any smaller configured timeouts that may have
     * existed in configurations prior to the introduction of this feature, while
     * introducing robustness to TCP connections that terminate without a FIN.
     * This idle timeout applies to new streams and is overridable by the
     * :ref:`route-level idle_timeout
     * &lt;envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
     * which the override applies, prior to receipt of the initial request
     * headers, the :ref:`stream_idle_timeout
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
     * applies. Each time an encode/decode event for headers or data is processed
     * for the stream, the timer will be reset. If the timeout fires, the stream
     * is terminated with a 408 Request Timeout error code if no upstream response
     * header has been received, otherwise a stream reset occurs.
     * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
     * window to write any remaining stream data once the entirety of stream data (local end stream is
     * true) has been buffered pending available window. In other words, this timeout defends against
     * a peer that does not release enough window to completely write the stream, even though all
     * data has been proxied within available flow control windows. If the timeout is hit in this
     * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
     * incremented. Note that :ref:`max_stream_duration
     * &lt;envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
     * this corner case.
     * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
     * is configured, this timeout is scaled according to the value for
     * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
     * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
     * to the granularity of events presented to the connection manager. For example, while receiving
     * very large request headers, it may be the case that there is traffic regularly arriving on the
     * wire while the connection manage is only able to observe the end-of-headers event, hence the
     * stream may still idle timeout.
     * A value of 0 will completely disable the connection manager stream idle
     * timeout, although per-route idle timeout overrides will continue to apply.
     * </pre>
     *
     * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder clearStreamIdleTimeout() {
      bitField0_ = (bitField0_ & ~0x00010000);
      streamIdleTimeout_ = null;
      if (streamIdleTimeoutBuilder_ != null) {
        streamIdleTimeoutBuilder_.dispose();
        streamIdleTimeoutBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The stream idle timeout for connections managed by the connection manager.
     * If not specified, this defaults to 5 minutes. The default value was selected
     * so as not to interfere with any smaller configured timeouts that may have
     * existed in configurations prior to the introduction of this feature, while
     * introducing robustness to TCP connections that terminate without a FIN.
     * This idle timeout applies to new streams and is overridable by the
     * :ref:`route-level idle_timeout
     * &lt;envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
     * which the override applies, prior to receipt of the initial request
     * headers, the :ref:`stream_idle_timeout
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
     * applies. Each time an encode/decode event for headers or data is processed
     * for the stream, the timer will be reset. If the timeout fires, the stream
     * is terminated with a 408 Request Timeout error code if no upstream response
     * header has been received, otherwise a stream reset occurs.
     * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
     * window to write any remaining stream data once the entirety of stream data (local end stream is
     * true) has been buffered pending available window. In other words, this timeout defends against
     * a peer that does not release enough window to completely write the stream, even though all
     * data has been proxied within available flow control windows. If the timeout is hit in this
     * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
     * incremented. Note that :ref:`max_stream_duration
     * &lt;envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
     * this corner case.
     * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
     * is configured, this timeout is scaled according to the value for
     * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
     * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
     * to the granularity of events presented to the connection manager. For example, while receiving
     * very large request headers, it may be the case that there is traffic regularly arriving on the
     * wire while the connection manage is only able to observe the end-of-headers event, hence the
     * stream may still idle timeout.
     * A value of 0 will completely disable the connection manager stream idle
     * timeout, although per-route idle timeout overrides will continue to apply.
     * </pre>
     *
     * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
     */
    public com.google.protobuf.Duration.Builder getStreamIdleTimeoutBuilder() {
      bitField0_ |= 0x00010000;
      onChanged();
      return getStreamIdleTimeoutFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The stream idle timeout for connections managed by the connection manager.
     * If not specified, this defaults to 5 minutes. The default value was selected
     * so as not to interfere with any smaller configured timeouts that may have
     * existed in configurations prior to the introduction of this feature, while
     * introducing robustness to TCP connections that terminate without a FIN.
     * This idle timeout applies to new streams and is overridable by the
     * :ref:`route-level idle_timeout
     * &lt;envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
     * which the override applies, prior to receipt of the initial request
     * headers, the :ref:`stream_idle_timeout
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
     * applies. Each time an encode/decode event for headers or data is processed
     * for the stream, the timer will be reset. If the timeout fires, the stream
     * is terminated with a 408 Request Timeout error code if no upstream response
     * header has been received, otherwise a stream reset occurs.
     * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
     * window to write any remaining stream data once the entirety of stream data (local end stream is
     * true) has been buffered pending available window. In other words, this timeout defends against
     * a peer that does not release enough window to completely write the stream, even though all
     * data has been proxied within available flow control windows. If the timeout is hit in this
     * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
     * incremented. Note that :ref:`max_stream_duration
     * &lt;envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
     * this corner case.
     * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
     * is configured, this timeout is scaled according to the value for
     * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
     * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
     * to the granularity of events presented to the connection manager. For example, while receiving
     * very large request headers, it may be the case that there is traffic regularly arriving on the
     * wire while the connection manage is only able to observe the end-of-headers event, hence the
     * stream may still idle timeout.
     * A value of 0 will completely disable the connection manager stream idle
     * timeout, although per-route idle timeout overrides will continue to apply.
     * </pre>
     *
     * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
     */
    public com.google.protobuf.DurationOrBuilder getStreamIdleTimeoutOrBuilder() {
      if (streamIdleTimeoutBuilder_ != null) {
        return streamIdleTimeoutBuilder_.getMessageOrBuilder();
      } else {
        return streamIdleTimeout_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : streamIdleTimeout_;
      }
    }
    /**
     * <pre>
     * The stream idle timeout for connections managed by the connection manager.
     * If not specified, this defaults to 5 minutes. The default value was selected
     * so as not to interfere with any smaller configured timeouts that may have
     * existed in configurations prior to the introduction of this feature, while
     * introducing robustness to TCP connections that terminate without a FIN.
     * This idle timeout applies to new streams and is overridable by the
     * :ref:`route-level idle_timeout
     * &lt;envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
     * which the override applies, prior to receipt of the initial request
     * headers, the :ref:`stream_idle_timeout
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
     * applies. Each time an encode/decode event for headers or data is processed
     * for the stream, the timer will be reset. If the timeout fires, the stream
     * is terminated with a 408 Request Timeout error code if no upstream response
     * header has been received, otherwise a stream reset occurs.
     * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
     * window to write any remaining stream data once the entirety of stream data (local end stream is
     * true) has been buffered pending available window. In other words, this timeout defends against
     * a peer that does not release enough window to completely write the stream, even though all
     * data has been proxied within available flow control windows. If the timeout is hit in this
     * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
     * incremented. Note that :ref:`max_stream_duration
     * &lt;envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
     * this corner case.
     * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
     * is configured, this timeout is scaled according to the value for
     * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
     * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
     * to the granularity of events presented to the connection manager. For example, while receiving
     * very large request headers, it may be the case that there is traffic regularly arriving on the
     * wire while the connection manage is only able to observe the end-of-headers event, hence the
     * stream may still idle timeout.
     * A value of 0 will completely disable the connection manager stream idle
     * timeout, although per-route idle timeout overrides will continue to apply.
     * </pre>
     *
     * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getStreamIdleTimeoutFieldBuilder() {
      if (streamIdleTimeoutBuilder_ == null) {
        streamIdleTimeoutBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getStreamIdleTimeout(),
                getParentForChildren(),
                isClean());
        streamIdleTimeout_ = null;
      }
      return streamIdleTimeoutBuilder_;
    }

    private com.google.protobuf.Duration requestTimeout_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> requestTimeoutBuilder_;
    /**
     * <pre>
     * The amount of time that Envoy will wait for the entire request to be received.
     * The timer is activated when the request is initiated, and is disarmed when the last byte of the
     * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
     * response is initiated. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
     * @return Whether the requestTimeout field is set.
     */
    public boolean hasRequestTimeout() {
      return ((bitField0_ & 0x00020000) != 0);
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the entire request to be received.
     * The timer is activated when the request is initiated, and is disarmed when the last byte of the
     * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
     * response is initiated. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
     * @return The requestTimeout.
     */
    public com.google.protobuf.Duration getRequestTimeout() {
      if (requestTimeoutBuilder_ == null) {
        return requestTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : requestTimeout_;
      } else {
        return requestTimeoutBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the entire request to be received.
     * The timer is activated when the request is initiated, and is disarmed when the last byte of the
     * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
     * response is initiated. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setRequestTimeout(com.google.protobuf.Duration value) {
      if (requestTimeoutBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        requestTimeout_ = value;
      } else {
        requestTimeoutBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00020000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the entire request to be received.
     * The timer is activated when the request is initiated, and is disarmed when the last byte of the
     * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
     * response is initiated. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setRequestTimeout(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (requestTimeoutBuilder_ == null) {
        requestTimeout_ = builderForValue.build();
      } else {
        requestTimeoutBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00020000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the entire request to be received.
     * The timer is activated when the request is initiated, and is disarmed when the last byte of the
     * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
     * response is initiated. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder mergeRequestTimeout(com.google.protobuf.Duration value) {
      if (requestTimeoutBuilder_ == null) {
        if (((bitField0_ & 0x00020000) != 0) &&
          requestTimeout_ != null &&
          requestTimeout_ != com.google.protobuf.Duration.getDefaultInstance()) {
          getRequestTimeoutBuilder().mergeFrom(value);
        } else {
          requestTimeout_ = value;
        }
      } else {
        requestTimeoutBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00020000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the entire request to be received.
     * The timer is activated when the request is initiated, and is disarmed when the last byte of the
     * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
     * response is initiated. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder clearRequestTimeout() {
      bitField0_ = (bitField0_ & ~0x00020000);
      requestTimeout_ = null;
      if (requestTimeoutBuilder_ != null) {
        requestTimeoutBuilder_.dispose();
        requestTimeoutBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the entire request to be received.
     * The timer is activated when the request is initiated, and is disarmed when the last byte of the
     * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
     * response is initiated. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
     */
    public com.google.protobuf.Duration.Builder getRequestTimeoutBuilder() {
      bitField0_ |= 0x00020000;
      onChanged();
      return getRequestTimeoutFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the entire request to be received.
     * The timer is activated when the request is initiated, and is disarmed when the last byte of the
     * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
     * response is initiated. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
     */
    public com.google.protobuf.DurationOrBuilder getRequestTimeoutOrBuilder() {
      if (requestTimeoutBuilder_ != null) {
        return requestTimeoutBuilder_.getMessageOrBuilder();
      } else {
        return requestTimeout_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : requestTimeout_;
      }
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the entire request to be received.
     * The timer is activated when the request is initiated, and is disarmed when the last byte of the
     * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
     * response is initiated. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getRequestTimeoutFieldBuilder() {
      if (requestTimeoutBuilder_ == null) {
        requestTimeoutBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getRequestTimeout(),
                getParentForChildren(),
                isClean());
        requestTimeout_ = null;
      }
      return requestTimeoutBuilder_;
    }

    private com.google.protobuf.Duration requestHeadersTimeout_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> requestHeadersTimeoutBuilder_;
    /**
     * <pre>
     * The amount of time that Envoy will wait for the request headers to be received. The timer is
     * activated when the first byte of the headers is received, and is disarmed when the last byte of
     * the headers has been received. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
     * @return Whether the requestHeadersTimeout field is set.
     */
    public boolean hasRequestHeadersTimeout() {
      return ((bitField0_ & 0x00040000) != 0);
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the request headers to be received. The timer is
     * activated when the first byte of the headers is received, and is disarmed when the last byte of
     * the headers has been received. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
     * @return The requestHeadersTimeout.
     */
    public com.google.protobuf.Duration getRequestHeadersTimeout() {
      if (requestHeadersTimeoutBuilder_ == null) {
        return requestHeadersTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : requestHeadersTimeout_;
      } else {
        return requestHeadersTimeoutBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the request headers to be received. The timer is
     * activated when the first byte of the headers is received, and is disarmed when the last byte of
     * the headers has been received. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
     */
    public Builder setRequestHeadersTimeout(com.google.protobuf.Duration value) {
      if (requestHeadersTimeoutBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        requestHeadersTimeout_ = value;
      } else {
        requestHeadersTimeoutBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00040000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the request headers to be received. The timer is
     * activated when the first byte of the headers is received, and is disarmed when the last byte of
     * the headers has been received. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
     */
    public Builder setRequestHeadersTimeout(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (requestHeadersTimeoutBuilder_ == null) {
        requestHeadersTimeout_ = builderForValue.build();
      } else {
        requestHeadersTimeoutBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00040000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the request headers to be received. The timer is
     * activated when the first byte of the headers is received, and is disarmed when the last byte of
     * the headers has been received. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
     */
    public Builder mergeRequestHeadersTimeout(com.google.protobuf.Duration value) {
      if (requestHeadersTimeoutBuilder_ == null) {
        if (((bitField0_ & 0x00040000) != 0) &&
          requestHeadersTimeout_ != null &&
          requestHeadersTimeout_ != com.google.protobuf.Duration.getDefaultInstance()) {
          getRequestHeadersTimeoutBuilder().mergeFrom(value);
        } else {
          requestHeadersTimeout_ = value;
        }
      } else {
        requestHeadersTimeoutBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00040000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the request headers to be received. The timer is
     * activated when the first byte of the headers is received, and is disarmed when the last byte of
     * the headers has been received. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
     */
    public Builder clearRequestHeadersTimeout() {
      bitField0_ = (bitField0_ & ~0x00040000);
      requestHeadersTimeout_ = null;
      if (requestHeadersTimeoutBuilder_ != null) {
        requestHeadersTimeoutBuilder_.dispose();
        requestHeadersTimeoutBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the request headers to be received. The timer is
     * activated when the first byte of the headers is received, and is disarmed when the last byte of
     * the headers has been received. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.Duration.Builder getRequestHeadersTimeoutBuilder() {
      bitField0_ |= 0x00040000;
      onChanged();
      return getRequestHeadersTimeoutFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the request headers to be received. The timer is
     * activated when the first byte of the headers is received, and is disarmed when the last byte of
     * the headers has been received. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.DurationOrBuilder getRequestHeadersTimeoutOrBuilder() {
      if (requestHeadersTimeoutBuilder_ != null) {
        return requestHeadersTimeoutBuilder_.getMessageOrBuilder();
      } else {
        return requestHeadersTimeout_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : requestHeadersTimeout_;
      }
    }
    /**
     * <pre>
     * The amount of time that Envoy will wait for the request headers to be received. The timer is
     * activated when the first byte of the headers is received, and is disarmed when the last byte of
     * the headers has been received. If not specified or set to 0, this timeout is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getRequestHeadersTimeoutFieldBuilder() {
      if (requestHeadersTimeoutBuilder_ == null) {
        requestHeadersTimeoutBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getRequestHeadersTimeout(),
                getParentForChildren(),
                isClean());
        requestHeadersTimeout_ = null;
      }
      return requestHeadersTimeoutBuilder_;
    }

    private com.google.protobuf.Duration drainTimeout_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> drainTimeoutBuilder_;
    /**
     * <pre>
     * The time that Envoy will wait between sending an HTTP/2 “shutdown
     * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
     * This is used so that Envoy provides a grace period for new streams that
     * race with the final GOAWAY frame. During this grace period, Envoy will
     * continue to accept new streams. After the grace period, a final GOAWAY
     * frame is sent and Envoy will start refusing new streams. Draining occurs
     * both when a connection hits the idle timeout or during general server
     * draining. The default grace period is 5000 milliseconds (5 seconds) if this
     * option is not specified.
     * </pre>
     *
     * <code>.google.protobuf.Duration drain_timeout = 12;</code>
     * @return Whether the drainTimeout field is set.
     */
    public boolean hasDrainTimeout() {
      return ((bitField0_ & 0x00080000) != 0);
    }
    /**
     * <pre>
     * The time that Envoy will wait between sending an HTTP/2 “shutdown
     * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
     * This is used so that Envoy provides a grace period for new streams that
     * race with the final GOAWAY frame. During this grace period, Envoy will
     * continue to accept new streams. After the grace period, a final GOAWAY
     * frame is sent and Envoy will start refusing new streams. Draining occurs
     * both when a connection hits the idle timeout or during general server
     * draining. The default grace period is 5000 milliseconds (5 seconds) if this
     * option is not specified.
     * </pre>
     *
     * <code>.google.protobuf.Duration drain_timeout = 12;</code>
     * @return The drainTimeout.
     */
    public com.google.protobuf.Duration getDrainTimeout() {
      if (drainTimeoutBuilder_ == null) {
        return drainTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : drainTimeout_;
      } else {
        return drainTimeoutBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The time that Envoy will wait between sending an HTTP/2 “shutdown
     * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
     * This is used so that Envoy provides a grace period for new streams that
     * race with the final GOAWAY frame. During this grace period, Envoy will
     * continue to accept new streams. After the grace period, a final GOAWAY
     * frame is sent and Envoy will start refusing new streams. Draining occurs
     * both when a connection hits the idle timeout or during general server
     * draining. The default grace period is 5000 milliseconds (5 seconds) if this
     * option is not specified.
     * </pre>
     *
     * <code>.google.protobuf.Duration drain_timeout = 12;</code>
     */
    public Builder setDrainTimeout(com.google.protobuf.Duration value) {
      if (drainTimeoutBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        drainTimeout_ = value;
      } else {
        drainTimeoutBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00080000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The time that Envoy will wait between sending an HTTP/2 “shutdown
     * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
     * This is used so that Envoy provides a grace period for new streams that
     * race with the final GOAWAY frame. During this grace period, Envoy will
     * continue to accept new streams. After the grace period, a final GOAWAY
     * frame is sent and Envoy will start refusing new streams. Draining occurs
     * both when a connection hits the idle timeout or during general server
     * draining. The default grace period is 5000 milliseconds (5 seconds) if this
     * option is not specified.
     * </pre>
     *
     * <code>.google.protobuf.Duration drain_timeout = 12;</code>
     */
    public Builder setDrainTimeout(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (drainTimeoutBuilder_ == null) {
        drainTimeout_ = builderForValue.build();
      } else {
        drainTimeoutBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00080000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The time that Envoy will wait between sending an HTTP/2 “shutdown
     * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
     * This is used so that Envoy provides a grace period for new streams that
     * race with the final GOAWAY frame. During this grace period, Envoy will
     * continue to accept new streams. After the grace period, a final GOAWAY
     * frame is sent and Envoy will start refusing new streams. Draining occurs
     * both when a connection hits the idle timeout or during general server
     * draining. The default grace period is 5000 milliseconds (5 seconds) if this
     * option is not specified.
     * </pre>
     *
     * <code>.google.protobuf.Duration drain_timeout = 12;</code>
     */
    public Builder mergeDrainTimeout(com.google.protobuf.Duration value) {
      if (drainTimeoutBuilder_ == null) {
        if (((bitField0_ & 0x00080000) != 0) &&
          drainTimeout_ != null &&
          drainTimeout_ != com.google.protobuf.Duration.getDefaultInstance()) {
          getDrainTimeoutBuilder().mergeFrom(value);
        } else {
          drainTimeout_ = value;
        }
      } else {
        drainTimeoutBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00080000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The time that Envoy will wait between sending an HTTP/2 “shutdown
     * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
     * This is used so that Envoy provides a grace period for new streams that
     * race with the final GOAWAY frame. During this grace period, Envoy will
     * continue to accept new streams. After the grace period, a final GOAWAY
     * frame is sent and Envoy will start refusing new streams. Draining occurs
     * both when a connection hits the idle timeout or during general server
     * draining. The default grace period is 5000 milliseconds (5 seconds) if this
     * option is not specified.
     * </pre>
     *
     * <code>.google.protobuf.Duration drain_timeout = 12;</code>
     */
    public Builder clearDrainTimeout() {
      bitField0_ = (bitField0_ & ~0x00080000);
      drainTimeout_ = null;
      if (drainTimeoutBuilder_ != null) {
        drainTimeoutBuilder_.dispose();
        drainTimeoutBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The time that Envoy will wait between sending an HTTP/2 “shutdown
     * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
     * This is used so that Envoy provides a grace period for new streams that
     * race with the final GOAWAY frame. During this grace period, Envoy will
     * continue to accept new streams. After the grace period, a final GOAWAY
     * frame is sent and Envoy will start refusing new streams. Draining occurs
     * both when a connection hits the idle timeout or during general server
     * draining. The default grace period is 5000 milliseconds (5 seconds) if this
     * option is not specified.
     * </pre>
     *
     * <code>.google.protobuf.Duration drain_timeout = 12;</code>
     */
    public com.google.protobuf.Duration.Builder getDrainTimeoutBuilder() {
      bitField0_ |= 0x00080000;
      onChanged();
      return getDrainTimeoutFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The time that Envoy will wait between sending an HTTP/2 “shutdown
     * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
     * This is used so that Envoy provides a grace period for new streams that
     * race with the final GOAWAY frame. During this grace period, Envoy will
     * continue to accept new streams. After the grace period, a final GOAWAY
     * frame is sent and Envoy will start refusing new streams. Draining occurs
     * both when a connection hits the idle timeout or during general server
     * draining. The default grace period is 5000 milliseconds (5 seconds) if this
     * option is not specified.
     * </pre>
     *
     * <code>.google.protobuf.Duration drain_timeout = 12;</code>
     */
    public com.google.protobuf.DurationOrBuilder getDrainTimeoutOrBuilder() {
      if (drainTimeoutBuilder_ != null) {
        return drainTimeoutBuilder_.getMessageOrBuilder();
      } else {
        return drainTimeout_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : drainTimeout_;
      }
    }
    /**
     * <pre>
     * The time that Envoy will wait between sending an HTTP/2 “shutdown
     * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
     * This is used so that Envoy provides a grace period for new streams that
     * race with the final GOAWAY frame. During this grace period, Envoy will
     * continue to accept new streams. After the grace period, a final GOAWAY
     * frame is sent and Envoy will start refusing new streams. Draining occurs
     * both when a connection hits the idle timeout or during general server
     * draining. The default grace period is 5000 milliseconds (5 seconds) if this
     * option is not specified.
     * </pre>
     *
     * <code>.google.protobuf.Duration drain_timeout = 12;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getDrainTimeoutFieldBuilder() {
      if (drainTimeoutBuilder_ == null) {
        drainTimeoutBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getDrainTimeout(),
                getParentForChildren(),
                isClean());
        drainTimeout_ = null;
      }
      return drainTimeoutBuilder_;
    }

    private com.google.protobuf.Duration delayedCloseTimeout_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> delayedCloseTimeoutBuilder_;
    /**
     * <pre>
     * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
     * It is defined as a grace period after connection close processing has been locally initiated
     * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
     * from the downstream connection) prior to Envoy closing the socket associated with that
     * connection.
     * NOTE: This timeout is enforced even when the socket associated with the downstream connection
     * is pending a flush of the write buffer. However, any progress made writing data to the socket
     * will restart the timer associated with this timeout. This means that the total grace period for
     * a socket in this state will be
     * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
     * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
     * sequence mitigates a race condition that exists when downstream clients do not drain/process
     * data in a connection's receive buffer after a remote close has been detected via a socket
     * write(). This race leads to such clients failing to process the response code sent by Envoy,
     * which could result in erroneous downstream processing.
     * If the timeout triggers, Envoy will close the connection's socket.
     * The default timeout is 1000 ms if this option is not specified.
     * .. NOTE::
     *    To be useful in avoiding the race condition described above, this timeout must be set
     *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
     *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
     * .. WARNING::
     *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
     *    connection's socket will be closed immediately after the write flush is completed or will
     *    never close if the write flush does not complete.
     * </pre>
     *
     * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
     * @return Whether the delayedCloseTimeout field is set.
     */
    public boolean hasDelayedCloseTimeout() {
      return ((bitField0_ & 0x00100000) != 0);
    }
    /**
     * <pre>
     * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
     * It is defined as a grace period after connection close processing has been locally initiated
     * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
     * from the downstream connection) prior to Envoy closing the socket associated with that
     * connection.
     * NOTE: This timeout is enforced even when the socket associated with the downstream connection
     * is pending a flush of the write buffer. However, any progress made writing data to the socket
     * will restart the timer associated with this timeout. This means that the total grace period for
     * a socket in this state will be
     * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
     * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
     * sequence mitigates a race condition that exists when downstream clients do not drain/process
     * data in a connection's receive buffer after a remote close has been detected via a socket
     * write(). This race leads to such clients failing to process the response code sent by Envoy,
     * which could result in erroneous downstream processing.
     * If the timeout triggers, Envoy will close the connection's socket.
     * The default timeout is 1000 ms if this option is not specified.
     * .. NOTE::
     *    To be useful in avoiding the race condition described above, this timeout must be set
     *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
     *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
     * .. WARNING::
     *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
     *    connection's socket will be closed immediately after the write flush is completed or will
     *    never close if the write flush does not complete.
     * </pre>
     *
     * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
     * @return The delayedCloseTimeout.
     */
    public com.google.protobuf.Duration getDelayedCloseTimeout() {
      if (delayedCloseTimeoutBuilder_ == null) {
        return delayedCloseTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : delayedCloseTimeout_;
      } else {
        return delayedCloseTimeoutBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
     * It is defined as a grace period after connection close processing has been locally initiated
     * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
     * from the downstream connection) prior to Envoy closing the socket associated with that
     * connection.
     * NOTE: This timeout is enforced even when the socket associated with the downstream connection
     * is pending a flush of the write buffer. However, any progress made writing data to the socket
     * will restart the timer associated with this timeout. This means that the total grace period for
     * a socket in this state will be
     * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
     * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
     * sequence mitigates a race condition that exists when downstream clients do not drain/process
     * data in a connection's receive buffer after a remote close has been detected via a socket
     * write(). This race leads to such clients failing to process the response code sent by Envoy,
     * which could result in erroneous downstream processing.
     * If the timeout triggers, Envoy will close the connection's socket.
     * The default timeout is 1000 ms if this option is not specified.
     * .. NOTE::
     *    To be useful in avoiding the race condition described above, this timeout must be set
     *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
     *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
     * .. WARNING::
     *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
     *    connection's socket will be closed immediately after the write flush is completed or will
     *    never close if the write flush does not complete.
     * </pre>
     *
     * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
     */
    public Builder setDelayedCloseTimeout(com.google.protobuf.Duration value) {
      if (delayedCloseTimeoutBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        delayedCloseTimeout_ = value;
      } else {
        delayedCloseTimeoutBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00100000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
     * It is defined as a grace period after connection close processing has been locally initiated
     * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
     * from the downstream connection) prior to Envoy closing the socket associated with that
     * connection.
     * NOTE: This timeout is enforced even when the socket associated with the downstream connection
     * is pending a flush of the write buffer. However, any progress made writing data to the socket
     * will restart the timer associated with this timeout. This means that the total grace period for
     * a socket in this state will be
     * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
     * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
     * sequence mitigates a race condition that exists when downstream clients do not drain/process
     * data in a connection's receive buffer after a remote close has been detected via a socket
     * write(). This race leads to such clients failing to process the response code sent by Envoy,
     * which could result in erroneous downstream processing.
     * If the timeout triggers, Envoy will close the connection's socket.
     * The default timeout is 1000 ms if this option is not specified.
     * .. NOTE::
     *    To be useful in avoiding the race condition described above, this timeout must be set
     *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
     *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
     * .. WARNING::
     *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
     *    connection's socket will be closed immediately after the write flush is completed or will
     *    never close if the write flush does not complete.
     * </pre>
     *
     * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
     */
    public Builder setDelayedCloseTimeout(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (delayedCloseTimeoutBuilder_ == null) {
        delayedCloseTimeout_ = builderForValue.build();
      } else {
        delayedCloseTimeoutBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00100000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
     * It is defined as a grace period after connection close processing has been locally initiated
     * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
     * from the downstream connection) prior to Envoy closing the socket associated with that
     * connection.
     * NOTE: This timeout is enforced even when the socket associated with the downstream connection
     * is pending a flush of the write buffer. However, any progress made writing data to the socket
     * will restart the timer associated with this timeout. This means that the total grace period for
     * a socket in this state will be
     * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
     * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
     * sequence mitigates a race condition that exists when downstream clients do not drain/process
     * data in a connection's receive buffer after a remote close has been detected via a socket
     * write(). This race leads to such clients failing to process the response code sent by Envoy,
     * which could result in erroneous downstream processing.
     * If the timeout triggers, Envoy will close the connection's socket.
     * The default timeout is 1000 ms if this option is not specified.
     * .. NOTE::
     *    To be useful in avoiding the race condition described above, this timeout must be set
     *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
     *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
     * .. WARNING::
     *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
     *    connection's socket will be closed immediately after the write flush is completed or will
     *    never close if the write flush does not complete.
     * </pre>
     *
     * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
     */
    public Builder mergeDelayedCloseTimeout(com.google.protobuf.Duration value) {
      if (delayedCloseTimeoutBuilder_ == null) {
        if (((bitField0_ & 0x00100000) != 0) &&
          delayedCloseTimeout_ != null &&
          delayedCloseTimeout_ != com.google.protobuf.Duration.getDefaultInstance()) {
          getDelayedCloseTimeoutBuilder().mergeFrom(value);
        } else {
          delayedCloseTimeout_ = value;
        }
      } else {
        delayedCloseTimeoutBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00100000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
     * It is defined as a grace period after connection close processing has been locally initiated
     * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
     * from the downstream connection) prior to Envoy closing the socket associated with that
     * connection.
     * NOTE: This timeout is enforced even when the socket associated with the downstream connection
     * is pending a flush of the write buffer. However, any progress made writing data to the socket
     * will restart the timer associated with this timeout. This means that the total grace period for
     * a socket in this state will be
     * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
     * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
     * sequence mitigates a race condition that exists when downstream clients do not drain/process
     * data in a connection's receive buffer after a remote close has been detected via a socket
     * write(). This race leads to such clients failing to process the response code sent by Envoy,
     * which could result in erroneous downstream processing.
     * If the timeout triggers, Envoy will close the connection's socket.
     * The default timeout is 1000 ms if this option is not specified.
     * .. NOTE::
     *    To be useful in avoiding the race condition described above, this timeout must be set
     *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
     *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
     * .. WARNING::
     *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
     *    connection's socket will be closed immediately after the write flush is completed or will
     *    never close if the write flush does not complete.
     * </pre>
     *
     * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
     */
    public Builder clearDelayedCloseTimeout() {
      bitField0_ = (bitField0_ & ~0x00100000);
      delayedCloseTimeout_ = null;
      if (delayedCloseTimeoutBuilder_ != null) {
        delayedCloseTimeoutBuilder_.dispose();
        delayedCloseTimeoutBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
     * It is defined as a grace period after connection close processing has been locally initiated
     * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
     * from the downstream connection) prior to Envoy closing the socket associated with that
     * connection.
     * NOTE: This timeout is enforced even when the socket associated with the downstream connection
     * is pending a flush of the write buffer. However, any progress made writing data to the socket
     * will restart the timer associated with this timeout. This means that the total grace period for
     * a socket in this state will be
     * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
     * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
     * sequence mitigates a race condition that exists when downstream clients do not drain/process
     * data in a connection's receive buffer after a remote close has been detected via a socket
     * write(). This race leads to such clients failing to process the response code sent by Envoy,
     * which could result in erroneous downstream processing.
     * If the timeout triggers, Envoy will close the connection's socket.
     * The default timeout is 1000 ms if this option is not specified.
     * .. NOTE::
     *    To be useful in avoiding the race condition described above, this timeout must be set
     *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
     *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
     * .. WARNING::
     *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
     *    connection's socket will be closed immediately after the write flush is completed or will
     *    never close if the write flush does not complete.
     * </pre>
     *
     * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
     */
    public com.google.protobuf.Duration.Builder getDelayedCloseTimeoutBuilder() {
      bitField0_ |= 0x00100000;
      onChanged();
      return getDelayedCloseTimeoutFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
     * It is defined as a grace period after connection close processing has been locally initiated
     * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
     * from the downstream connection) prior to Envoy closing the socket associated with that
     * connection.
     * NOTE: This timeout is enforced even when the socket associated with the downstream connection
     * is pending a flush of the write buffer. However, any progress made writing data to the socket
     * will restart the timer associated with this timeout. This means that the total grace period for
     * a socket in this state will be
     * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
     * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
     * sequence mitigates a race condition that exists when downstream clients do not drain/process
     * data in a connection's receive buffer after a remote close has been detected via a socket
     * write(). This race leads to such clients failing to process the response code sent by Envoy,
     * which could result in erroneous downstream processing.
     * If the timeout triggers, Envoy will close the connection's socket.
     * The default timeout is 1000 ms if this option is not specified.
     * .. NOTE::
     *    To be useful in avoiding the race condition described above, this timeout must be set
     *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
     *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
     * .. WARNING::
     *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
     *    connection's socket will be closed immediately after the write flush is completed or will
     *    never close if the write flush does not complete.
     * </pre>
     *
     * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
     */
    public com.google.protobuf.DurationOrBuilder getDelayedCloseTimeoutOrBuilder() {
      if (delayedCloseTimeoutBuilder_ != null) {
        return delayedCloseTimeoutBuilder_.getMessageOrBuilder();
      } else {
        return delayedCloseTimeout_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : delayedCloseTimeout_;
      }
    }
    /**
     * <pre>
     * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
     * It is defined as a grace period after connection close processing has been locally initiated
     * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
     * from the downstream connection) prior to Envoy closing the socket associated with that
     * connection.
     * NOTE: This timeout is enforced even when the socket associated with the downstream connection
     * is pending a flush of the write buffer. However, any progress made writing data to the socket
     * will restart the timer associated with this timeout. This means that the total grace period for
     * a socket in this state will be
     * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
     * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
     * sequence mitigates a race condition that exists when downstream clients do not drain/process
     * data in a connection's receive buffer after a remote close has been detected via a socket
     * write(). This race leads to such clients failing to process the response code sent by Envoy,
     * which could result in erroneous downstream processing.
     * If the timeout triggers, Envoy will close the connection's socket.
     * The default timeout is 1000 ms if this option is not specified.
     * .. NOTE::
     *    To be useful in avoiding the race condition described above, this timeout must be set
     *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
     *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
     * .. WARNING::
     *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
     *    connection's socket will be closed immediately after the write flush is completed or will
     *    never close if the write flush does not complete.
     * </pre>
     *
     * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getDelayedCloseTimeoutFieldBuilder() {
      if (delayedCloseTimeoutBuilder_ == null) {
        delayedCloseTimeoutBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getDelayedCloseTimeout(),
                getParentForChildren(),
                isClean());
        delayedCloseTimeout_ = null;
      }
      return delayedCloseTimeoutBuilder_;
    }

    private java.util.List<io.envoyproxy.envoy.config.accesslog.v3.AccessLog> accessLog_ =
      java.util.Collections.emptyList();
    private void ensureAccessLogIsMutable() {
      if (!((bitField0_ & 0x00200000) != 0)) {
        accessLog_ = new java.util.ArrayList<io.envoyproxy.envoy.config.accesslog.v3.AccessLog>(accessLog_);
        bitField0_ |= 0x00200000;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.accesslog.v3.AccessLog, io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder, io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder> accessLogBuilder_;

    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.accesslog.v3.AccessLog> getAccessLogList() {
      if (accessLogBuilder_ == null) {
        return java.util.Collections.unmodifiableList(accessLog_);
      } else {
        return accessLogBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public int getAccessLogCount() {
      if (accessLogBuilder_ == null) {
        return accessLog_.size();
      } else {
        return accessLogBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public io.envoyproxy.envoy.config.accesslog.v3.AccessLog getAccessLog(int index) {
      if (accessLogBuilder_ == null) {
        return accessLog_.get(index);
      } else {
        return accessLogBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public Builder setAccessLog(
        int index, io.envoyproxy.envoy.config.accesslog.v3.AccessLog value) {
      if (accessLogBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAccessLogIsMutable();
        accessLog_.set(index, value);
        onChanged();
      } else {
        accessLogBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public Builder setAccessLog(
        int index, io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder builderForValue) {
      if (accessLogBuilder_ == null) {
        ensureAccessLogIsMutable();
        accessLog_.set(index, builderForValue.build());
        onChanged();
      } else {
        accessLogBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public Builder addAccessLog(io.envoyproxy.envoy.config.accesslog.v3.AccessLog value) {
      if (accessLogBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAccessLogIsMutable();
        accessLog_.add(value);
        onChanged();
      } else {
        accessLogBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public Builder addAccessLog(
        int index, io.envoyproxy.envoy.config.accesslog.v3.AccessLog value) {
      if (accessLogBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureAccessLogIsMutable();
        accessLog_.add(index, value);
        onChanged();
      } else {
        accessLogBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public Builder addAccessLog(
        io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder builderForValue) {
      if (accessLogBuilder_ == null) {
        ensureAccessLogIsMutable();
        accessLog_.add(builderForValue.build());
        onChanged();
      } else {
        accessLogBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public Builder addAccessLog(
        int index, io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder builderForValue) {
      if (accessLogBuilder_ == null) {
        ensureAccessLogIsMutable();
        accessLog_.add(index, builderForValue.build());
        onChanged();
      } else {
        accessLogBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public Builder addAllAccessLog(
        java.lang.Iterable<? extends io.envoyproxy.envoy.config.accesslog.v3.AccessLog> values) {
      if (accessLogBuilder_ == null) {
        ensureAccessLogIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, accessLog_);
        onChanged();
      } else {
        accessLogBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public Builder clearAccessLog() {
      if (accessLogBuilder_ == null) {
        accessLog_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00200000);
        onChanged();
      } else {
        accessLogBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public Builder removeAccessLog(int index) {
      if (accessLogBuilder_ == null) {
        ensureAccessLogIsMutable();
        accessLog_.remove(index);
        onChanged();
      } else {
        accessLogBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder getAccessLogBuilder(
        int index) {
      return getAccessLogFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder getAccessLogOrBuilder(
        int index) {
      if (accessLogBuilder_ == null) {
        return accessLog_.get(index);  } else {
        return accessLogBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public java.util.List<? extends io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder> 
         getAccessLogOrBuilderList() {
      if (accessLogBuilder_ != null) {
        return accessLogBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(accessLog_);
      }
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder addAccessLogBuilder() {
      return getAccessLogFieldBuilder().addBuilder(
          io.envoyproxy.envoy.config.accesslog.v3.AccessLog.getDefaultInstance());
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder addAccessLogBuilder(
        int index) {
      return getAccessLogFieldBuilder().addBuilder(
          index, io.envoyproxy.envoy.config.accesslog.v3.AccessLog.getDefaultInstance());
    }
    /**
     * <pre>
     * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
     * emitted by the connection manager.
     * </pre>
     *
     * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder> 
         getAccessLogBuilderList() {
      return getAccessLogFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.accesslog.v3.AccessLog, io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder, io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder> 
        getAccessLogFieldBuilder() {
      if (accessLogBuilder_ == null) {
        accessLogBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.envoyproxy.envoy.config.accesslog.v3.AccessLog, io.envoyproxy.envoy.config.accesslog.v3.AccessLog.Builder, io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder>(
                accessLog_,
                ((bitField0_ & 0x00200000) != 0),
                getParentForChildren(),
                isClean());
        accessLog_ = null;
      }
      return accessLogBuilder_;
    }

    private com.google.protobuf.BoolValue useRemoteAddress_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> useRemoteAddressBuilder_;
    /**
     * <pre>
     * If set to true, the connection manager will use the real remote address
     * of the client connection when determining internal versus external origin and manipulating
     * various headers. If set to false or absent, the connection manager will use the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for`,
     * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
     * @return Whether the useRemoteAddress field is set.
     */
    public boolean hasUseRemoteAddress() {
      return ((bitField0_ & 0x00400000) != 0);
    }
    /**
     * <pre>
     * If set to true, the connection manager will use the real remote address
     * of the client connection when determining internal versus external origin and manipulating
     * various headers. If set to false or absent, the connection manager will use the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for`,
     * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
     * @return The useRemoteAddress.
     */
    public com.google.protobuf.BoolValue getUseRemoteAddress() {
      if (useRemoteAddressBuilder_ == null) {
        return useRemoteAddress_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : useRemoteAddress_;
      } else {
        return useRemoteAddressBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * If set to true, the connection manager will use the real remote address
     * of the client connection when determining internal versus external origin and manipulating
     * various headers. If set to false or absent, the connection manager will use the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for`,
     * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setUseRemoteAddress(com.google.protobuf.BoolValue value) {
      if (useRemoteAddressBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        useRemoteAddress_ = value;
      } else {
        useRemoteAddressBuilder_.setMessage(value);
      }
      bitField0_ |= 0x00400000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If set to true, the connection manager will use the real remote address
     * of the client connection when determining internal versus external origin and manipulating
     * various headers. If set to false or absent, the connection manager will use the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for`,
     * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder setUseRemoteAddress(
        com.google.protobuf.BoolValue.Builder builderForValue) {
      if (useRemoteAddressBuilder_ == null) {
        useRemoteAddress_ = builderForValue.build();
      } else {
        useRemoteAddressBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x00400000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If set to true, the connection manager will use the real remote address
     * of the client connection when determining internal versus external origin and manipulating
     * various headers. If set to false or absent, the connection manager will use the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for`,
     * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder mergeUseRemoteAddress(com.google.protobuf.BoolValue value) {
      if (useRemoteAddressBuilder_ == null) {
        if (((bitField0_ & 0x00400000) != 0) &&
          useRemoteAddress_ != null &&
          useRemoteAddress_ != com.google.protobuf.BoolValue.getDefaultInstance()) {
          getUseRemoteAddressBuilder().mergeFrom(value);
        } else {
          useRemoteAddress_ = value;
        }
      } else {
        useRemoteAddressBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x00400000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If set to true, the connection manager will use the real remote address
     * of the client connection when determining internal versus external origin and manipulating
     * various headers. If set to false or absent, the connection manager will use the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for`,
     * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
     */
    public Builder clearUseRemoteAddress() {
      bitField0_ = (bitField0_ & ~0x00400000);
      useRemoteAddress_ = null;
      if (useRemoteAddressBuilder_ != null) {
        useRemoteAddressBuilder_.dispose();
        useRemoteAddressBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If set to true, the connection manager will use the real remote address
     * of the client connection when determining internal versus external origin and manipulating
     * various headers. If set to false or absent, the connection manager will use the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for`,
     * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
     */
    public com.google.protobuf.BoolValue.Builder getUseRemoteAddressBuilder() {
      bitField0_ |= 0x00400000;
      onChanged();
      return getUseRemoteAddressFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * If set to true, the connection manager will use the real remote address
     * of the client connection when determining internal versus external origin and manipulating
     * various headers. If set to false or absent, the connection manager will use the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for`,
     * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getUseRemoteAddressOrBuilder() {
      if (useRemoteAddressBuilder_ != null) {
        return useRemoteAddressBuilder_.getMessageOrBuilder();
      } else {
        return useRemoteAddress_ == null ?
            com.google.protobuf.BoolValue.getDefaultInstance() : useRemoteAddress_;
      }
    }
    /**
     * <pre>
     * If set to true, the connection manager will use the real remote address
     * of the client connection when determining internal versus external origin and manipulating
     * various headers. If set to false or absent, the connection manager will use the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for`,
     * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
        getUseRemoteAddressFieldBuilder() {
      if (useRemoteAddressBuilder_ == null) {
        useRemoteAddressBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                getUseRemoteAddress(),
                getParentForChildren(),
                isClean());
        useRemoteAddress_ = null;
      }
      return useRemoteAddressBuilder_;
    }

    private int xffNumTrustedHops_ ;
    /**
     * <pre>
     * The number of additional ingress proxy hops from the right side of the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
     * determining the origin client's IP address. The default is zero if this option
     * is not specified. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
     * </pre>
     *
     * <code>uint32 xff_num_trusted_hops = 19;</code>
     * @return The xffNumTrustedHops.
     */
    @java.lang.Override
    public int getXffNumTrustedHops() {
      return xffNumTrustedHops_;
    }
    /**
     * <pre>
     * The number of additional ingress proxy hops from the right side of the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
     * determining the origin client's IP address. The default is zero if this option
     * is not specified. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
     * </pre>
     *
     * <code>uint32 xff_num_trusted_hops = 19;</code>
     * @param value The xffNumTrustedHops to set.
     * @return This builder for chaining.
     */
    public Builder setXffNumTrustedHops(int value) {
      
      xffNumTrustedHops_ = value;
      bitField0_ |= 0x00800000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The number of additional ingress proxy hops from the right side of the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
     * determining the origin client's IP address. The default is zero if this option
     * is not specified. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
     * </pre>
     *
     * <code>uint32 xff_num_trusted_hops = 19;</code>
     * @return This builder for chaining.
     */
    public Builder clearXffNumTrustedHops() {
      bitField0_ = (bitField0_ & ~0x00800000);
      xffNumTrustedHops_ = 0;
      onChanged();
      return this;
    }

    private java.util.List<io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig> originalIpDetectionExtensions_ =
      java.util.Collections.emptyList();
    private void ensureOriginalIpDetectionExtensionsIsMutable() {
      if (!((bitField0_ & 0x01000000) != 0)) {
        originalIpDetectionExtensions_ = new java.util.ArrayList<io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig>(originalIpDetectionExtensions_);
        bitField0_ |= 0x01000000;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder> originalIpDetectionExtensionsBuilder_;

    /**
     * <pre>
     * The configuration for the original IP detection extensions.
     * When configured the extensions will be called along with the request headers
     * and information about the downstream connection, such as the directly connected address.
     * Each extension will then use these parameters to decide the request's effective remote address.
     * If an extension fails to detect the original IP address and isn't configured to reject
     * the request, the HCM will try the remaining extensions until one succeeds or rejects
     * the request. If the request isn't rejected nor any extension succeeds, the HCM will
     * fallback to using the remote address.
     * .. WARNING::
     *    Extensions cannot be used in conjunction with :ref:`use_remote_address
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     *    nor :ref:`xff_num_trusted_hops
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
     * [#extension-category: envoy.http.original_ip_detection]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig> getOriginalIpDetectionExtensionsList() {
      if (originalIpDetectionExtensionsBuilder_ == null) {
        return java.util.Collections.unmodifiableList(originalIpDetectionExtensions_);
      } else {
        return originalIpDetectionExtensionsBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * The configuration for the original IP detection extensions.
     * When configured the extensions will be called along with the request headers
     * and information about the downstream connection, such as the directly connected address.
     * Each extension will then use these parameters to decide the request's effective remote address.
     * If an extension fails to detect the original IP address and isn't configured to reject
     * the request, the HCM will try the remaining extensions until one succeeds or rejects
     * the request. If the request isn't rejected nor any extension succeeds, the HCM will
     * fallback to using the remote address.
     * .. WARNING::
     *    Extensions cannot be used in conjunction with :ref:`use_remote_address
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     *    nor :ref:`xff_num_trusted_hops
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
     * [#extension-category: envoy.http.original_ip_detection]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
     */
    public int getOriginalIpDetectionExtensionsCount() {
      if (originalIpDetectionExtensionsBuilder_ == null) {
        return originalIpDetectionExtensions_.size();
      } else {
        return originalIpDetectionExtensionsBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * The configuration for the original IP detection extensions.
     * When configured the extensions will be called along with the request headers
     * and information about the downstream connection, such as the directly connected address.
     * Each extension will then use these parameters to decide the request's effective remote address.
     * If an extension fails to detect the original IP address and isn't configured to reject
     * the request, the HCM will try the remaining extensions until one succeeds or rejects
     * the request. If the request isn't rejected nor any extension succeeds, the HCM will
     * fallback to using the remote address.
     * .. WARNING::
     *    Extensions cannot be used in conjunction with :ref:`use_remote_address
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     *    nor :ref:`xff_num_trusted_hops
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
     * [#extension-category: envoy.http.original_ip_detection]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig getOriginalIpDetectionExtensions(int index) {
      if (originalIpDetectionExtensionsBuilder_ == null) {
        return originalIpDetectionExtensions_.get(index);
      } else {
        return originalIpDetectionExtensionsBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * The configuration for the original IP detection extensions.
     * When configured the extensions will be called along with the request headers
     * and information about the downstream connection, such as the directly connected address.
     * Each extension will then use these parameters to decide the request's effective remote address.
     * If an extension fails to detect the original IP address and isn't configured to reject
     * the request, the HCM will try the remaining extensions until one succeeds or rejects
     * the request. If the request isn't rejected nor any extension succeeds, the HCM will
     * fallback to using the remote address.
     * .. WARNING::
     *    Extensions cannot be used in conjunction with :ref:`use_remote_address
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     *    nor :ref:`xff_num_trusted_hops
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
     * [#extension-category: envoy.http.original_ip_detection]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
     */
    public Builder setOriginalIpDetectionExtensions(
        int index, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig value) {
      if (originalIpDetectionExtensionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureOriginalIpDetectionExtensionsIsMutable();
        originalIpDetectionExtensions_.set(index, value);
        onChanged();
      } else {
        originalIpDetectionExtensionsBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * The configuration for the original IP detection extensions.
     * When configured the extensions will be called along with the request headers
     * and information about the downstream connection, such as the directly connected address.
     * Each extension will then use these parameters to decide the request's effective remote address.
     * If an extension fails to detect the original IP address and isn't configured to reject
     * the request, the HCM will try the remaining extensions until one succeeds or rejects
     * the request. If the request isn't rejected nor any extension succeeds, the HCM will
     * fallback to using the remote address.
     * .. WARNING::
     *    Extensions cannot be used in conjunction with :ref:`use_remote_address
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     *    nor :ref:`xff_num_trusted_hops
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
     * [#extension-category: envoy.http.original_ip_detection]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
     */
    public Builder setOriginalIpDetectionExtensions(
        int index, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder builderForValue) {
      if (originalIpDetectionExtensionsBuilder_ == null) {
        ensureOriginalIpDetectionExtensionsIsMutable();
        originalIpDetectionExtensions_.set(index, builderForValue.build());
        onChanged();
      } else {
        originalIpDetectionExtensionsBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * The configuration for the original IP detection extensions.
     * When configured the extensions will be called along with the request headers
     * and information about the downstream connection, such as the directly connected address.
     * Each extension will then use these parameters to decide the request's effective remote address.
     * If an extension fails to detect the original IP address and isn't configured to reject
     * the request, the HCM will try the remaining extensions until one succeeds or rejects
     * the request. If the request isn't rejected nor any extension succeeds, the HCM will
     * fallback to using the remote address.
     * .. WARNING::
     *    Extensions cannot be used in conjunction with :ref:`use_remote_address
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     *    nor :ref:`xff_num_trusted_hops
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
     * [#extension-category: envoy.http.original_ip_detection]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
     */
    public Builder addOriginalIpDetectionExtensions(io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig value) {
      if (originalIpDetectionExtensionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureOriginalIpDetectionExtensionsIsMutable();
        originalIpDetectionExtensions_.add(value);
        onChanged();
      } else {
        originalIpDetectionExtensionsBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * The configuration for the original IP detection extensions.
     * When configured the extensions will be called along with the request headers
     * and information about the downstream connection, such as the directly connected address.
     * Each extension will then use these parameters to decide the request's effective remote address.
     * If an extension fails to detect the original IP address and isn't configured to reject
     * the request, the HCM will try the remaining extensions until one succeeds or rejects
     * the request. If the request isn't rejected nor any extension succeeds, the HCM will
     * fallback to using the remote address.
     * .. WARNING::
     *    Extensions cannot be used in conjunction with :ref:`use_remote_address
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     *    nor :ref:`xff_num_trusted_hops
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
     * [#extension-category: envoy.http.original_ip_detection]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
     */
    public Builder addOriginalIpDetectionExtensions(
        int index, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig value) {
      if (originalIpDetectionExtensionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureOriginalIpDetectionExtensionsIsMutable();
        originalIpDetectionExtensions_.add(index, value);
        onChanged();
      } else {
        originalIpDetectionExtensionsBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * The configuration for the original IP detection extensions.
     * When configured the extensions will be called along with the request headers
     * and information about the downstream connection, such as the directly connected address.
     * Each extension will then use these parameters to decide the request's effective remote address.
     * If an extension fails to detect the original IP address and isn't configured to reject
     * the request, the HCM will try the remaining extensions until one succeeds or rejects
     * the request. If the request isn't rejected nor any extension succeeds, the HCM will
     * fallback to using the remote address.
     * .. WARNING::
     *    Extensions cannot be used in conjunction with :ref:`use_remote_address
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     *    nor :ref:`xff_num_trusted_hops
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
     * [#extension-category: envoy.http.original_ip_detection]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
     */
    public Builder addOriginalIpDetectionExtensions(
        io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder builderForValue) {
      if (originalIpDetectionExtensionsBuilder_ == null) {
        ensureOriginalIpDetectionExtensionsIsMutable();
        originalIpDetectionExtensions_.add(builderForValue.build());
        onChanged();
      } else {
        originalIpDetectionExtensionsBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * The configuration for the original IP detection extensions.
     * When configured the extensions will be called along with the request headers
     * and information about the downstream connection, such as the directly connected address.
     * Each extension will then use these parameters to decide the request's effective remote address.
     * If an extension fails to detect the original IP address and isn't configured to reject
     * the request, the HCM will try the remaining extensions until one succeeds or rejects
     * the request. If the request isn't rejected nor any extension succeeds, the HCM will
     * fallback to using the remote address.
     * .. WARNING::
     *    Extensions cannot be used in conjunction with :ref:`use_remote_address
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     *    nor :ref:`xff_num_trusted_hops
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
     * [#extension-category: envoy.http.original_ip_detection]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
     */
    public Builder addOriginalIpDetectionExtensions(
        int index, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder builderForValue) {
      if (originalIpDetectionExtensionsBuilder_ == null) {
        ensureOriginalIpDetectionExtensionsIsMutable();
        originalIpDetectionExtensions_.add(index, builderForValue.build());
        onChanged();
      } else {
        originalIpDetectionExtensionsBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * The configuration for the original IP detection extensions.
     * When configured the extensions will be called along with the request headers
     * and information about the downstream connection, such as the directly connected address.
     * Each extension will then use these parameters to decide the request's effective remote address.
     * If an extension fails to detect the original IP address and isn't configured to reject
     * the request, the HCM will try the remaining extensions until one succeeds or rejects
     * the request. If the request isn't rejected nor any extension succeeds, the HCM will
     * fallback to using the remote address.
     * .. WARNING::
     *    Extensions cannot be used in conjunction with :ref:`use_remote_address
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     *    nor :ref:`xff_num_trusted_hops
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
     * [#extension-category: envoy.http.original_ip_detection]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
     */
    public Builder addAllOriginalIpDetectionExtensions(
        java.lang.Iterable<? extends io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig> values) {
      if (originalIpDetectionExtensionsBuilder_ == null) {
        ensureOriginalIpDetectionExtensionsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, originalIpDetectionExtensions_);
        onChanged();
      } else {
        originalIpDetectionExtensionsBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * The configuration for the original IP detection extensions.
     * When configured the extensions will be called along with the request headers
     * and information about the downstream connection, such as the directly connected address.
     * Each extension will then use these parameters to decide the request's effective remote address.
     * If an extension fails to detect the original IP address and isn't configured to reject
     * the request, the HCM will try the remaining extensions until one succeeds or rejects
     * the request. If the request isn't rejected nor any extension succeeds, the HCM will
     * fallback to using the remote address.
     * .. WARNING::
     *    Extensions cannot be used in conjunction with :ref:`use_remote_address
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     *    nor :ref:`xff_num_trusted_hops
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
     * [#extension-category: envoy.http.original_ip_detection]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
     */
    public Builder clearOriginalIpDetectionExtensions() {
      if (originalIpDetectionExtensionsBuilder_ == null) {
        originalIpDetectionExtensions_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x01000000);
        onChanged();
      } else {
        originalIpDetectionExtensionsBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * The configuration for the original IP detection extensions.
     * When configured the extensions will be called along with the request headers
     * and information about the downstream connection, such as the directly connected address.
     * Each extension will then use these parameters to decide the request's effective remote address.
     * If an extension fails to detect the original IP address and isn't configured to reject
     * the request, the HCM will try the remaining extensions until one succeeds or rejects
     * the request. If the request isn't rejected nor any extension succeeds, the HCM will
     * fallback to using the remote address.
     * .. WARNING::
     *    Extensions cannot be used in conjunction with :ref:`use_remote_address
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     *    nor :ref:`xff_num_trusted_hops
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
     * [#extension-category: envoy.http.original_ip_detection]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
     */
    public Builder removeOriginalIpDetectionExtensions(int index) {
      if (originalIpDetectionExtensionsBuilder_ == null) {
        ensureOriginalIpDetectionExtensionsIsMutable();
        originalIpDetectionExtensions_.remove(index);
        onChanged();
      } else {
        originalIpDetectionExtensionsBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * The configuration for the original IP detection extensions.
     * When configured the extensions will be called along with the request headers
     * and information about the downstream connection, such as the directly connected address.
     * Each extension will then use these parameters to decide the request's effective remote address.
     * If an extension fails to detect the original IP address and isn't configured to reject
     * the request, the HCM will try the remaining extensions until one succeeds or rejects
     * the request. If the request isn't rejected nor any extension succeeds, the HCM will
     * fallback to using the remote address.
     * .. WARNING::
     *    Extensions cannot be used in conjunction with :ref:`use_remote_address
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     *    nor :ref:`xff_num_trusted_hops
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
     * [#extension-category: envoy.http.original_ip_detection]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder getOriginalIpDetectionExtensionsBuilder(
        int index) {
      return getOriginalIpDetectionExtensionsFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * The configuration for the original IP detection extensions.
     * When configured the extensions will be called along with the request headers
     * and information about the downstream connection, such as the directly connected address.
     * Each extension will then use these parameters to decide the request's effective remote address.
     * If an extension fails to detect the original IP address and isn't configured to reject
     * the request, the HCM will try the remaining extensions until one succeeds or rejects
     * the request. If the request isn't rejected nor any extension succeeds, the HCM will
     * fallback to using the remote address.
     * .. WARNING::
     *    Extensions cannot be used in conjunction with :ref:`use_remote_address
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     *    nor :ref:`xff_num_trusted_hops
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
     * [#extension-category: envoy.http.original_ip_detection]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder getOriginalIpDetectionExtensionsOrBuilder(
        int index) {
      if (originalIpDetectionExtensionsBuilder_ == null) {
        return originalIpDetectionExtensions_.get(index);  } else {
        return originalIpDetectionExtensionsBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * The configuration for the original IP detection extensions.
     * When configured the extensions will be called along with the request headers
     * and information about the downstream connection, such as the directly connected address.
     * Each extension will then use these parameters to decide the request's effective remote address.
     * If an extension fails to detect the original IP address and isn't configured to reject
     * the request, the HCM will try the remaining extensions until one succeeds or rejects
     * the request. If the request isn't rejected nor any extension succeeds, the HCM will
     * fallback to using the remote address.
     * .. WARNING::
     *    Extensions cannot be used in conjunction with :ref:`use_remote_address
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     *    nor :ref:`xff_num_trusted_hops
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
     * [#extension-category: envoy.http.original_ip_detection]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
     */
    public java.util.List<? extends io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder> 
         getOriginalIpDetectionExtensionsOrBuilderList() {
      if (originalIpDetectionExtensionsBuilder_ != null) {
        return originalIpDetectionExtensionsBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(originalIpDetectionExtensions_);
      }
    }
    /**
     * <pre>
     * The configuration for the original IP detection extensions.
     * When configured the extensions will be called along with the request headers
     * and information about the downstream connection, such as the directly connected address.
     * Each extension will then use these parameters to decide the request's effective remote address.
     * If an extension fails to detect the original IP address and isn't configured to reject
     * the request, the HCM will try the remaining extensions until one succeeds or rejects
     * the request. If the request isn't rejected nor any extension succeeds, the HCM will
     * fallback to using the remote address.
     * .. WARNING::
     *    Extensions cannot be used in conjunction with :ref:`use_remote_address
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     *    nor :ref:`xff_num_trusted_hops
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
     * [#extension-category: envoy.http.original_ip_detection]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder addOriginalIpDetectionExtensionsBuilder() {
      return getOriginalIpDetectionExtensionsFieldBuilder().addBuilder(
          io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.getDefaultInstance());
    }
    /**
     * <pre>
     * The configuration for the original IP detection extensions.
     * When configured the extensions will be called along with the request headers
     * and information about the downstream connection, such as the directly connected address.
     * Each extension will then use these parameters to decide the request's effective remote address.
     * If an extension fails to detect the original IP address and isn't configured to reject
     * the request, the HCM will try the remaining extensions until one succeeds or rejects
     * the request. If the request isn't rejected nor any extension succeeds, the HCM will
     * fallback to using the remote address.
     * .. WARNING::
     *    Extensions cannot be used in conjunction with :ref:`use_remote_address
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     *    nor :ref:`xff_num_trusted_hops
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
     * [#extension-category: envoy.http.original_ip_detection]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder addOriginalIpDetectionExtensionsBuilder(
        int index) {
      return getOriginalIpDetectionExtensionsFieldBuilder().addBuilder(
          index, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.getDefaultInstance());
    }
    /**
     * <pre>
     * The configuration for the original IP detection extensions.
     * When configured the extensions will be called along with the request headers
     * and information about the downstream connection, such as the directly connected address.
     * Each extension will then use these parameters to decide the request's effective remote address.
     * If an extension fails to detect the original IP address and isn't configured to reject
     * the request, the HCM will try the remaining extensions until one succeeds or rejects
     * the request. If the request isn't rejected nor any extension succeeds, the HCM will
     * fallback to using the remote address.
     * .. WARNING::
     *    Extensions cannot be used in conjunction with :ref:`use_remote_address
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     *    nor :ref:`xff_num_trusted_hops
     *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
     * [#extension-category: envoy.http.original_ip_detection]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder> 
         getOriginalIpDetectionExtensionsBuilderList() {
      return getOriginalIpDetectionExtensionsFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder> 
        getOriginalIpDetectionExtensionsFieldBuilder() {
      if (originalIpDetectionExtensionsBuilder_ == null) {
        originalIpDetectionExtensionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder>(
                originalIpDetectionExtensions_,
                ((bitField0_ & 0x01000000) != 0),
                getParentForChildren(),
                isClean());
        originalIpDetectionExtensions_ = null;
      }
      return originalIpDetectionExtensionsBuilder_;
    }

    private java.util.List<io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig> earlyHeaderMutationExtensions_ =
      java.util.Collections.emptyList();
    private void ensureEarlyHeaderMutationExtensionsIsMutable() {
      if (!((bitField0_ & 0x02000000) != 0)) {
        earlyHeaderMutationExtensions_ = new java.util.ArrayList<io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig>(earlyHeaderMutationExtensions_);
        bitField0_ |= 0x02000000;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder> earlyHeaderMutationExtensionsBuilder_;

    /**
     * <pre>
     * The configuration for the early header mutation extensions.
     * When configured the extensions will be called before any routing, tracing, or any filter processing.
     * Each extension will be applied in the order they are configured.
     * If the same header is mutated by multiple extensions, then the last extension will win.
     * [#extension-category: envoy.http.early_header_mutation]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig> getEarlyHeaderMutationExtensionsList() {
      if (earlyHeaderMutationExtensionsBuilder_ == null) {
        return java.util.Collections.unmodifiableList(earlyHeaderMutationExtensions_);
      } else {
        return earlyHeaderMutationExtensionsBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * The configuration for the early header mutation extensions.
     * When configured the extensions will be called before any routing, tracing, or any filter processing.
     * Each extension will be applied in the order they are configured.
     * If the same header is mutated by multiple extensions, then the last extension will win.
     * [#extension-category: envoy.http.early_header_mutation]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
     */
    public int getEarlyHeaderMutationExtensionsCount() {
      if (earlyHeaderMutationExtensionsBuilder_ == null) {
        return earlyHeaderMutationExtensions_.size();
      } else {
        return earlyHeaderMutationExtensionsBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * The configuration for the early header mutation extensions.
     * When configured the extensions will be called before any routing, tracing, or any filter processing.
     * Each extension will be applied in the order they are configured.
     * If the same header is mutated by multiple extensions, then the last extension will win.
     * [#extension-category: envoy.http.early_header_mutation]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig getEarlyHeaderMutationExtensions(int index) {
      if (earlyHeaderMutationExtensionsBuilder_ == null) {
        return earlyHeaderMutationExtensions_.get(index);
      } else {
        return earlyHeaderMutationExtensionsBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * The configuration for the early header mutation extensions.
     * When configured the extensions will be called before any routing, tracing, or any filter processing.
     * Each extension will be applied in the order they are configured.
     * If the same header is mutated by multiple extensions, then the last extension will win.
     * [#extension-category: envoy.http.early_header_mutation]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
     */
    public Builder setEarlyHeaderMutationExtensions(
        int index, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig value) {
      if (earlyHeaderMutationExtensionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureEarlyHeaderMutationExtensionsIsMutable();
        earlyHeaderMutationExtensions_.set(index, value);
        onChanged();
      } else {
        earlyHeaderMutationExtensionsBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * The configuration for the early header mutation extensions.
     * When configured the extensions will be called before any routing, tracing, or any filter processing.
     * Each extension will be applied in the order they are configured.
     * If the same header is mutated by multiple extensions, then the last extension will win.
     * [#extension-category: envoy.http.early_header_mutation]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
     */
    public Builder setEarlyHeaderMutationExtensions(
        int index, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder builderForValue) {
      if (earlyHeaderMutationExtensionsBuilder_ == null) {
        ensureEarlyHeaderMutationExtensionsIsMutable();
        earlyHeaderMutationExtensions_.set(index, builderForValue.build());
        onChanged();
      } else {
        earlyHeaderMutationExtensionsBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * The configuration for the early header mutation extensions.
     * When configured the extensions will be called before any routing, tracing, or any filter processing.
     * Each extension will be applied in the order they are configured.
     * If the same header is mutated by multiple extensions, then the last extension will win.
     * [#extension-category: envoy.http.early_header_mutation]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
     */
    public Builder addEarlyHeaderMutationExtensions(io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig value) {
      if (earlyHeaderMutationExtensionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureEarlyHeaderMutationExtensionsIsMutable();
        earlyHeaderMutationExtensions_.add(value);
        onChanged();
      } else {
        earlyHeaderMutationExtensionsBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * The configuration for the early header mutation extensions.
     * When configured the extensions will be called before any routing, tracing, or any filter processing.
     * Each extension will be applied in the order they are configured.
     * If the same header is mutated by multiple extensions, then the last extension will win.
     * [#extension-category: envoy.http.early_header_mutation]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
     */
    public Builder addEarlyHeaderMutationExtensions(
        int index, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig value) {
      if (earlyHeaderMutationExtensionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureEarlyHeaderMutationExtensionsIsMutable();
        earlyHeaderMutationExtensions_.add(index, value);
        onChanged();
      } else {
        earlyHeaderMutationExtensionsBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * The configuration for the early header mutation extensions.
     * When configured the extensions will be called before any routing, tracing, or any filter processing.
     * Each extension will be applied in the order they are configured.
     * If the same header is mutated by multiple extensions, then the last extension will win.
     * [#extension-category: envoy.http.early_header_mutation]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
     */
    public Builder addEarlyHeaderMutationExtensions(
        io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder builderForValue) {
      if (earlyHeaderMutationExtensionsBuilder_ == null) {
        ensureEarlyHeaderMutationExtensionsIsMutable();
        earlyHeaderMutationExtensions_.add(builderForValue.build());
        onChanged();
      } else {
        earlyHeaderMutationExtensionsBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * The configuration for the early header mutation extensions.
     * When configured the extensions will be called before any routing, tracing, or any filter processing.
     * Each extension will be applied in the order they are configured.
     * If the same header is mutated by multiple extensions, then the last extension will win.
     * [#extension-category: envoy.http.early_header_mutation]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
     */
    public Builder addEarlyHeaderMutationExtensions(
        int index, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder builderForValue) {
      if (earlyHeaderMutationExtensionsBuilder_ == null) {
        ensureEarlyHeaderMutationExtensionsIsMutable();
        earlyHeaderMutationExtensions_.add(index, builderForValue.build());
        onChanged();
      } else {
        earlyHeaderMutationExtensionsBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * The configuration for the early header mutation extensions.
     * When configured the extensions will be called before any routing, tracing, or any filter processing.
     * Each extension will be applied in the order they are configured.
     * If the same header is mutated by multiple extensions, then the last extension will win.
     * [#extension-category: envoy.http.early_header_mutation]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
     */
    public Builder addAllEarlyHeaderMutationExtensions(
        java.lang.Iterable<? extends io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig> values) {
      if (earlyHeaderMutationExtensionsBuilder_ == null) {
        ensureEarlyHeaderMutationExtensionsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, earlyHeaderMutationExtensions_);
        onChanged();
      } else {
        earlyHeaderMutationExtensionsBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * The configuration for the early header mutation extensions.
     * When configured the extensions will be called before any routing, tracing, or any filter processing.
     * Each extension will be applied in the order they are configured.
     * If the same header is mutated by multiple extensions, then the last extension will win.
     * [#extension-category: envoy.http.early_header_mutation]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
     */
    public Builder clearEarlyHeaderMutationExtensions() {
      if (earlyHeaderMutationExtensionsBuilder_ == null) {
        earlyHeaderMutationExtensions_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x02000000);
        onChanged();
      } else {
        earlyHeaderMutationExtensionsBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * The configuration for the early header mutation extensions.
     * When configured the extensions will be called before any routing, tracing, or any filter processing.
     * Each extension will be applied in the order they are configured.
     * If the same header is mutated by multiple extensions, then the last extension will win.
     * [#extension-category: envoy.http.early_header_mutation]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
     */
    public Builder removeEarlyHeaderMutationExtensions(int index) {
      if (earlyHeaderMutationExtensionsBuilder_ == null) {
        ensureEarlyHeaderMutationExtensionsIsMutable();
        earlyHeaderMutationExtensions_.remove(index);
        onChanged();
      } else {
        earlyHeaderMutationExtensionsBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * The configuration for the early header mutation extensions.
     * When configured the extensions will be called before any routing, tracing, or any filter processing.
     * Each extension will be applied in the order they are configured.
     * If the same header is mutated by multiple extensions, then the last extension will win.
     * [#extension-category: envoy.http.early_header_mutation]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder getEarlyHeaderMutationExtensionsBuilder(
        int index) {
      return getEarlyHeaderMutationExtensionsFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * The configuration for the early header mutation extensions.
     * When configured the extensions will be called before any routing, tracing, or any filter processing.
     * Each extension will be applied in the order they are configured.
     * If the same header is mutated by multiple extensions, then the last extension will win.
     * [#extension-category: envoy.http.early_header_mutation]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder getEarlyHeaderMutationExtensionsOrBuilder(
        int index) {
      if (earlyHeaderMutationExtensionsBuilder_ == null) {
        return earlyHeaderMutationExtensions_.get(index);  } else {
        return earlyHeaderMutationExtensionsBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * The configuration for the early header mutation extensions.
     * When configured the extensions will be called before any routing, tracing, or any filter processing.
     * Each extension will be applied in the order they are configured.
     * If the same header is mutated by multiple extensions, then the last extension will win.
     * [#extension-category: envoy.http.early_header_mutation]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
     */
    public java.util.List<? extends io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder> 
         getEarlyHeaderMutationExtensionsOrBuilderList() {
      if (earlyHeaderMutationExtensionsBuilder_ != null) {
        return earlyHeaderMutationExtensionsBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(earlyHeaderMutationExtensions_);
      }
    }
    /**
     * <pre>
     * The configuration for the early header mutation extensions.
     * When configured the extensions will be called before any routing, tracing, or any filter processing.
     * Each extension will be applied in the order they are configured.
     * If the same header is mutated by multiple extensions, then the last extension will win.
     * [#extension-category: envoy.http.early_header_mutation]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder addEarlyHeaderMutationExtensionsBuilder() {
      return getEarlyHeaderMutationExtensionsFieldBuilder().addBuilder(
          io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.getDefaultInstance());
    }
    /**
     * <pre>
     * The configuration for the early header mutation extensions.
     * When configured the extensions will be called before any routing, tracing, or any filter processing.
     * Each extension will be applied in the order they are configured.
     * If the same header is mutated by multiple extensions, then the last extension will win.
     * [#extension-category: envoy.http.early_header_mutation]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder addEarlyHeaderMutationExtensionsBuilder(
        int index) {
      return getEarlyHeaderMutationExtensionsFieldBuilder().addBuilder(
          index, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.getDefaultInstance());
    }
    /**
     * <pre>
     * The configuration for the early header mutation extensions.
     * When configured the extensions will be called before any routing, tracing, or any filter processing.
     * Each extension will be applied in the order they are configured.
     * If the same header is mutated by multiple extensions, then the last extension will win.
     * [#extension-category: envoy.http.early_header_mutation]
     * </pre>
     *
     * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
     */
    public java.util.List<io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder> 
         getEarlyHeaderMutationExtensionsBuilderList() {
      return getEarlyHeaderMutationExtensionsFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder> 
        getEarlyHeaderMutationExtensionsFieldBuilder() {
      if (earlyHeaderMutationExtensionsBuilder_ == null) {
        earlyHeaderMutationExtensionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder>(
                earlyHeaderMutationExtensions_,
                ((bitField0_ & 0x02000000) != 0),
                getParentForChildren(),
                isClean());
        earlyHeaderMutationExtensions_ = null;
      }
      return earlyHeaderMutationExtensionsBuilder_;
    }

    private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internalAddressConfig_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfigOrBuilder> internalAddressConfigBuilder_;
    /**
     * <pre>
     * Configures what network addresses are considered internal for stats and header sanitation
     * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
     * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
     * information about internal/external addresses.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
     * @return Whether the internalAddressConfig field is set.
     */
    public boolean hasInternalAddressConfig() {
      return ((bitField0_ & 0x04000000) != 0);
    }
    /**
     * <pre>
     * Configures what network addresses are considered internal for stats and header sanitation
     * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
     * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
     * information about internal/external addresses.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
     * @return The internalAddressConfig.
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig getInternalAddressConfig() {
      if (internalAddressConfigBuilder_ == null) {
        return internalAddressConfig_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.getDefaultInstance() : internalAddressConfig_;
      } else {
        return internalAddressConfigBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Configures what network addresses are considered internal for stats and header sanitation
     * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
     * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
     * information about internal/external addresses.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
     */
    public Builder setInternalAddressConfig(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig value) {
      if (internalAddressConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        internalAddressConfig_ = value;
      } else {
        internalAddressConfigBuilder_.setMessage(value);
      }
      bitField0_ |= 0x04000000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Configures what network addresses are considered internal for stats and header sanitation
     * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
     * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
     * information about internal/external addresses.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
     */
    public Builder setInternalAddressConfig(
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.Builder builderForValue) {
      if (internalAddressConfigBuilder_ == null) {
        internalAddressConfig_ = builderForValue.build();
      } else {
        internalAddressConfigBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x04000000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Configures what network addresses are considered internal for stats and header sanitation
     * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
     * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
     * information about internal/external addresses.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
     */
    public Builder mergeInternalAddressConfig(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig value) {
      if (internalAddressConfigBuilder_ == null) {
        if (((bitField0_ & 0x04000000) != 0) &&
          internalAddressConfig_ != null &&
          internalAddressConfig_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.getDefaultInstance()) {
          getInternalAddressConfigBuilder().mergeFrom(value);
        } else {
          internalAddressConfig_ = value;
        }
      } else {
        internalAddressConfigBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x04000000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Configures what network addresses are considered internal for stats and header sanitation
     * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
     * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
     * information about internal/external addresses.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
     */
    public Builder clearInternalAddressConfig() {
      bitField0_ = (bitField0_ & ~0x04000000);
      internalAddressConfig_ = null;
      if (internalAddressConfigBuilder_ != null) {
        internalAddressConfigBuilder_.dispose();
        internalAddressConfigBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Configures what network addresses are considered internal for stats and header sanitation
     * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
     * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
     * information about internal/external addresses.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.Builder getInternalAddressConfigBuilder() {
      bitField0_ |= 0x04000000;
      onChanged();
      return getInternalAddressConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Configures what network addresses are considered internal for stats and header sanitation
     * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
     * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
     * information about internal/external addresses.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfigOrBuilder getInternalAddressConfigOrBuilder() {
      if (internalAddressConfigBuilder_ != null) {
        return internalAddressConfigBuilder_.getMessageOrBuilder();
      } else {
        return internalAddressConfig_ == null ?
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.getDefaultInstance() : internalAddressConfig_;
      }
    }
    /**
     * <pre>
     * Configures what network addresses are considered internal for stats and header sanitation
     * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
     * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
     * information about internal/external addresses.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfigOrBuilder> 
        getInternalAddressConfigFieldBuilder() {
      if (internalAddressConfigBuilder_ == null) {
        internalAddressConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfigOrBuilder>(
                getInternalAddressConfig(),
                getParentForChildren(),
                isClean());
        internalAddressConfig_ = null;
      }
      return internalAddressConfigBuilder_;
    }

    private boolean skipXffAppend_ ;
    /**
     * <pre>
     * If set, Envoy will not append the remote address to the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. This may be used in
     * conjunction with HTTP filters that explicitly manipulate XFF after the HTTP connection manager
     * has mutated the request headers. While :ref:`use_remote_address
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     * will also suppress XFF addition, it has consequences for logging and other
     * Envoy uses of the remote address, so ``skip_xff_append`` should be used
     * when only an elision of XFF addition is intended.
     * </pre>
     *
     * <code>bool skip_xff_append = 21;</code>
     * @return The skipXffAppend.
     */
    @java.lang.Override
    public boolean getSkipXffAppend() {
      return skipXffAppend_;
    }
    /**
     * <pre>
     * If set, Envoy will not append the remote address to the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. This may be used in
     * conjunction with HTTP filters that explicitly manipulate XFF after the HTTP connection manager
     * has mutated the request headers. While :ref:`use_remote_address
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     * will also suppress XFF addition, it has consequences for logging and other
     * Envoy uses of the remote address, so ``skip_xff_append`` should be used
     * when only an elision of XFF addition is intended.
     * </pre>
     *
     * <code>bool skip_xff_append = 21;</code>
     * @param value The skipXffAppend to set.
     * @return This builder for chaining.
     */
    public Builder setSkipXffAppend(boolean value) {
      
      skipXffAppend_ = value;
      bitField0_ |= 0x08000000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If set, Envoy will not append the remote address to the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. This may be used in
     * conjunction with HTTP filters that explicitly manipulate XFF after the HTTP connection manager
     * has mutated the request headers. While :ref:`use_remote_address
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     * will also suppress XFF addition, it has consequences for logging and other
     * Envoy uses of the remote address, so ``skip_xff_append`` should be used
     * when only an elision of XFF addition is intended.
     * </pre>
     *
     * <code>bool skip_xff_append = 21;</code>
     * @return This builder for chaining.
     */
    public Builder clearSkipXffAppend() {
      bitField0_ = (bitField0_ & ~0x08000000);
      skipXffAppend_ = false;
      onChanged();
      return this;
    }

    private java.lang.Object via_ = "";
    /**
     * <pre>
     * Via header value to append to request and response headers. If this is
     * empty, no via header will be appended.
     * </pre>
     *
     * <code>string via = 22 [(.validate.rules) = { ... }</code>
     * @return The via.
     */
    public java.lang.String getVia() {
      java.lang.Object ref = via_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        via_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Via header value to append to request and response headers. If this is
     * empty, no via header will be appended.
     * </pre>
     *
     * <code>string via = 22 [(.validate.rules) = { ... }</code>
     * @return The bytes for via.
     */
    public com.google.protobuf.ByteString
        getViaBytes() {
      java.lang.Object ref = via_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        via_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Via header value to append to request and response headers. If this is
     * empty, no via header will be appended.
     * </pre>
     *
     * <code>string via = 22 [(.validate.rules) = { ... }</code>
     * @param value The via to set.
     * @return This builder for chaining.
     */
    public Builder setVia(
        java.lang.String value) {
      if (value == null) { throw new NullPointerException(); }
      via_ = value;
      bitField0_ |= 0x10000000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Via header value to append to request and response headers. If this is
     * empty, no via header will be appended.
     * </pre>
     *
     * <code>string via = 22 [(.validate.rules) = { ... }</code>
     * @return This builder for chaining.
     */
    public Builder clearVia() {
      via_ = getDefaultInstance().getVia();
      bitField0_ = (bitField0_ & ~0x10000000);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Via header value to append to request and response headers. If this is
     * empty, no via header will be appended.
     * </pre>
     *
     * <code>string via = 22 [(.validate.rules) = { ... }</code>
     * @param value The bytes for via to set.
     * @return This builder for chaining.
     */
    public Builder setViaBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) { throw new NullPointerException(); }
      checkByteStringIsUtf8(value);
      via_ = value;
      bitField0_ |= 0x10000000;
      onChanged();
      return this;
    }

    private com.google.protobuf.BoolValue generateRequestId_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> generateRequestIdBuilder_;
    /**
     * <pre>
     * Whether the connection manager will generate the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
     * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
     * is not desired it can be disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
     * @return Whether the generateRequestId field is set.
     */
    public boolean hasGenerateRequestId() {
      return ((bitField0_ & 0x20000000) != 0);
    }
    /**
     * <pre>
     * Whether the connection manager will generate the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
     * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
     * is not desired it can be disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
     * @return The generateRequestId.
     */
    public com.google.protobuf.BoolValue getGenerateRequestId() {
      if (generateRequestIdBuilder_ == null) {
        return generateRequestId_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : generateRequestId_;
      } else {
        return generateRequestIdBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Whether the connection manager will generate the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
     * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
     * is not desired it can be disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
     */
    public Builder setGenerateRequestId(com.google.protobuf.BoolValue value) {
      if (generateRequestIdBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        generateRequestId_ = value;
      } else {
        generateRequestIdBuilder_.setMessage(value);
      }
      bitField0_ |= 0x20000000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the connection manager will generate the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
     * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
     * is not desired it can be disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
     */
    public Builder setGenerateRequestId(
        com.google.protobuf.BoolValue.Builder builderForValue) {
      if (generateRequestIdBuilder_ == null) {
        generateRequestId_ = builderForValue.build();
      } else {
        generateRequestIdBuilder_.setMessage(builderForValue.build());
      }
      bitField0_ |= 0x20000000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the connection manager will generate the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
     * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
     * is not desired it can be disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
     */
    public Builder mergeGenerateRequestId(com.google.protobuf.BoolValue value) {
      if (generateRequestIdBuilder_ == null) {
        if (((bitField0_ & 0x20000000) != 0) &&
          generateRequestId_ != null &&
          generateRequestId_ != com.google.protobuf.BoolValue.getDefaultInstance()) {
          getGenerateRequestIdBuilder().mergeFrom(value);
        } else {
          generateRequestId_ = value;
        }
      } else {
        generateRequestIdBuilder_.mergeFrom(value);
      }
      bitField0_ |= 0x20000000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the connection manager will generate the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
     * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
     * is not desired it can be disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
     */
    public Builder clearGenerateRequestId() {
      bitField0_ = (bitField0_ & ~0x20000000);
      generateRequestId_ = null;
      if (generateRequestIdBuilder_ != null) {
        generateRequestIdBuilder_.dispose();
        generateRequestIdBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the connection manager will generate the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
     * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
     * is not desired it can be disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
     */
    public com.google.protobuf.BoolValue.Builder getGenerateRequestIdBuilder() {
      bitField0_ |= 0x20000000;
      onChanged();
      return getGenerateRequestIdFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Whether the connection manager will generate the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
     * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
     * is not desired it can be disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getGenerateRequestIdOrBuilder() {
      if (generateRequestIdBuilder_ != null) {
        return generateRequestIdBuilder_.getMessageOrBuilder();
      } else {
        return generateRequestId_ == null ?
            com.google.protobuf.BoolValue.getDefaultInstance() : generateRequestId_;
      }
    }
    /**
     * <pre>
     * Whether the connection manager will generate the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
     * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
     * is not desired it can be disabled.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
        getGenerateRequestIdFieldBuilder() {
      if (generateRequestIdBuilder_ == null) {
        generateRequestIdBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                getGenerateRequestId(),
                getParentForChildren(),
                isClean());
        generateRequestId_ = null;
      }
      return generateRequestIdBuilder_;
    }

    private boolean preserveExternalRequestId_ ;
    /**
     * <pre>
     * Whether the connection manager will keep the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if passed for a request that is edge
     * (Edge request is the request from external clients to front Envoy) and not reset it, which
     * is the current Envoy behaviour. This defaults to false.
     * </pre>
     *
     * <code>bool preserve_external_request_id = 32;</code>
     * @return The preserveExternalRequestId.
     */
    @java.lang.Override
    public boolean getPreserveExternalRequestId() {
      return preserveExternalRequestId_;
    }
    /**
     * <pre>
     * Whether the connection manager will keep the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if passed for a request that is edge
     * (Edge request is the request from external clients to front Envoy) and not reset it, which
     * is the current Envoy behaviour. This defaults to false.
     * </pre>
     *
     * <code>bool preserve_external_request_id = 32;</code>
     * @param value The preserveExternalRequestId to set.
     * @return This builder for chaining.
     */
    public Builder setPreserveExternalRequestId(boolean value) {
      
      preserveExternalRequestId_ = value;
      bitField0_ |= 0x40000000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the connection manager will keep the :ref:`x-request-id
     * &lt;config_http_conn_man_headers_x-request-id&gt;` header if passed for a request that is edge
     * (Edge request is the request from external clients to front Envoy) and not reset it, which
     * is the current Envoy behaviour. This defaults to false.
     * </pre>
     *
     * <code>bool preserve_external_request_id = 32;</code>
     * @return This builder for chaining.
     */
    public Builder clearPreserveExternalRequestId() {
      bitField0_ = (bitField0_ & ~0x40000000);
      preserveExternalRequestId_ = false;
      onChanged();
      return this;
    }

    private boolean alwaysSetRequestIdInResponse_ ;
    /**
     * <pre>
     * If set, Envoy will always set :ref:`x-request-id &lt;config_http_conn_man_headers_x-request-id&gt;` header in response.
     * If this is false or not set, the request ID is returned in responses only if tracing is forced using
     * :ref:`x-envoy-force-trace &lt;config_http_conn_man_headers_x-envoy-force-trace&gt;` header.
     * </pre>
     *
     * <code>bool always_set_request_id_in_response = 37;</code>
     * @return The alwaysSetRequestIdInResponse.
     */
    @java.lang.Override
    public boolean getAlwaysSetRequestIdInResponse() {
      return alwaysSetRequestIdInResponse_;
    }
    /**
     * <pre>
     * If set, Envoy will always set :ref:`x-request-id &lt;config_http_conn_man_headers_x-request-id&gt;` header in response.
     * If this is false or not set, the request ID is returned in responses only if tracing is forced using
     * :ref:`x-envoy-force-trace &lt;config_http_conn_man_headers_x-envoy-force-trace&gt;` header.
     * </pre>
     *
     * <code>bool always_set_request_id_in_response = 37;</code>
     * @param value The alwaysSetRequestIdInResponse to set.
     * @return This builder for chaining.
     */
    public Builder setAlwaysSetRequestIdInResponse(boolean value) {
      
      alwaysSetRequestIdInResponse_ = value;
      bitField0_ |= 0x80000000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If set, Envoy will always set :ref:`x-request-id &lt;config_http_conn_man_headers_x-request-id&gt;` header in response.
     * If this is false or not set, the request ID is returned in responses only if tracing is forced using
     * :ref:`x-envoy-force-trace &lt;config_http_conn_man_headers_x-envoy-force-trace&gt;` header.
     * </pre>
     *
     * <code>bool always_set_request_id_in_response = 37;</code>
     * @return This builder for chaining.
     */
    public Builder clearAlwaysSetRequestIdInResponse() {
      bitField0_ = (bitField0_ & ~0x80000000);
      alwaysSetRequestIdInResponse_ = false;
      onChanged();
      return this;
    }

    private int forwardClientCertDetails_ = 0;
    /**
     * <pre>
     * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
     * header.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails forward_client_cert_details = 16 [(.validate.rules) = { ... }</code>
     * @return The enum numeric value on the wire for forwardClientCertDetails.
     */
    @java.lang.Override public int getForwardClientCertDetailsValue() {
      return forwardClientCertDetails_;
    }
    /**
     * <pre>
     * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
     * header.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails forward_client_cert_details = 16 [(.validate.rules) = { ... }</code>
     * @param value The enum numeric value on the wire for forwardClientCertDetails to set.
     * @return This builder for chaining.
     */
    public Builder setForwardClientCertDetailsValue(int value) {
      forwardClientCertDetails_ = value;
      bitField1_ |= 0x00000001;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
     * header.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails forward_client_cert_details = 16 [(.validate.rules) = { ... }</code>
     * @return The forwardClientCertDetails.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails getForwardClientCertDetails() {
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails result = io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails.forNumber(forwardClientCertDetails_);
      return result == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
     * header.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails forward_client_cert_details = 16 [(.validate.rules) = { ... }</code>
     * @param value The forwardClientCertDetails to set.
     * @return This builder for chaining.
     */
    public Builder setForwardClientCertDetails(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField1_ |= 0x00000001;
      forwardClientCertDetails_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
     * header.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails forward_client_cert_details = 16 [(.validate.rules) = { ... }</code>
     * @return This builder for chaining.
     */
    public Builder clearForwardClientCertDetails() {
      bitField1_ = (bitField1_ & ~0x00000001);
      forwardClientCertDetails_ = 0;
      onChanged();
      return this;
    }

    private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails setCurrentClientCertDetails_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetailsOrBuilder> setCurrentClientCertDetailsBuilder_;
    /**
     * <pre>
     * This field is valid only when :ref:`forward_client_cert_details
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
     * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
     * the client certificate to be forwarded. Note that in the
     * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, ``Hash`` is always set, and
     * ``By`` is always set when the client certificate presents the URI type Subject Alternative Name
     * value.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
     * @return Whether the setCurrentClientCertDetails field is set.
     */
    public boolean hasSetCurrentClientCertDetails() {
      return ((bitField1_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * This field is valid only when :ref:`forward_client_cert_details
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
     * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
     * the client certificate to be forwarded. Note that in the
     * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, ``Hash`` is always set, and
     * ``By`` is always set when the client certificate presents the URI type Subject Alternative Name
     * value.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
     * @return The setCurrentClientCertDetails.
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails getSetCurrentClientCertDetails() {
      if (setCurrentClientCertDetailsBuilder_ == null) {
        return setCurrentClientCertDetails_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.getDefaultInstance() : setCurrentClientCertDetails_;
      } else {
        return setCurrentClientCertDetailsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * This field is valid only when :ref:`forward_client_cert_details
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
     * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
     * the client certificate to be forwarded. Note that in the
     * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, ``Hash`` is always set, and
     * ``By`` is always set when the client certificate presents the URI type Subject Alternative Name
     * value.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
     */
    public Builder setSetCurrentClientCertDetails(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails value) {
      if (setCurrentClientCertDetailsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        setCurrentClientCertDetails_ = value;
      } else {
        setCurrentClientCertDetailsBuilder_.setMessage(value);
      }
      bitField1_ |= 0x00000002;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * This field is valid only when :ref:`forward_client_cert_details
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
     * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
     * the client certificate to be forwarded. Note that in the
     * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, ``Hash`` is always set, and
     * ``By`` is always set when the client certificate presents the URI type Subject Alternative Name
     * value.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
     */
    public Builder setSetCurrentClientCertDetails(
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.Builder builderForValue) {
      if (setCurrentClientCertDetailsBuilder_ == null) {
        setCurrentClientCertDetails_ = builderForValue.build();
      } else {
        setCurrentClientCertDetailsBuilder_.setMessage(builderForValue.build());
      }
      bitField1_ |= 0x00000002;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * This field is valid only when :ref:`forward_client_cert_details
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
     * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
     * the client certificate to be forwarded. Note that in the
     * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, ``Hash`` is always set, and
     * ``By`` is always set when the client certificate presents the URI type Subject Alternative Name
     * value.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
     */
    public Builder mergeSetCurrentClientCertDetails(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails value) {
      if (setCurrentClientCertDetailsBuilder_ == null) {
        if (((bitField1_ & 0x00000002) != 0) &&
          setCurrentClientCertDetails_ != null &&
          setCurrentClientCertDetails_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.getDefaultInstance()) {
          getSetCurrentClientCertDetailsBuilder().mergeFrom(value);
        } else {
          setCurrentClientCertDetails_ = value;
        }
      } else {
        setCurrentClientCertDetailsBuilder_.mergeFrom(value);
      }
      bitField1_ |= 0x00000002;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * This field is valid only when :ref:`forward_client_cert_details
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
     * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
     * the client certificate to be forwarded. Note that in the
     * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, ``Hash`` is always set, and
     * ``By`` is always set when the client certificate presents the URI type Subject Alternative Name
     * value.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
     */
    public Builder clearSetCurrentClientCertDetails() {
      bitField1_ = (bitField1_ & ~0x00000002);
      setCurrentClientCertDetails_ = null;
      if (setCurrentClientCertDetailsBuilder_ != null) {
        setCurrentClientCertDetailsBuilder_.dispose();
        setCurrentClientCertDetailsBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * This field is valid only when :ref:`forward_client_cert_details
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
     * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
     * the client certificate to be forwarded. Note that in the
     * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, ``Hash`` is always set, and
     * ``By`` is always set when the client certificate presents the URI type Subject Alternative Name
     * value.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.Builder getSetCurrentClientCertDetailsBuilder() {
      bitField1_ |= 0x00000002;
      onChanged();
      return getSetCurrentClientCertDetailsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * This field is valid only when :ref:`forward_client_cert_details
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
     * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
     * the client certificate to be forwarded. Note that in the
     * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, ``Hash`` is always set, and
     * ``By`` is always set when the client certificate presents the URI type Subject Alternative Name
     * value.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetailsOrBuilder getSetCurrentClientCertDetailsOrBuilder() {
      if (setCurrentClientCertDetailsBuilder_ != null) {
        return setCurrentClientCertDetailsBuilder_.getMessageOrBuilder();
      } else {
        return setCurrentClientCertDetails_ == null ?
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.getDefaultInstance() : setCurrentClientCertDetails_;
      }
    }
    /**
     * <pre>
     * This field is valid only when :ref:`forward_client_cert_details
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
     * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
     * the client certificate to be forwarded. Note that in the
     * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, ``Hash`` is always set, and
     * ``By`` is always set when the client certificate presents the URI type Subject Alternative Name
     * value.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetailsOrBuilder> 
        getSetCurrentClientCertDetailsFieldBuilder() {
      if (setCurrentClientCertDetailsBuilder_ == null) {
        setCurrentClientCertDetailsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetailsOrBuilder>(
                getSetCurrentClientCertDetails(),
                getParentForChildren(),
                isClean());
        setCurrentClientCertDetails_ = null;
      }
      return setCurrentClientCertDetailsBuilder_;
    }

    private boolean proxy100Continue_ ;
    /**
     * <pre>
     * If proxy_100_continue is true, Envoy will proxy incoming "Expect:
     * 100-continue" headers upstream, and forward "100 Continue" responses
     * downstream. If this is false or not set, Envoy will instead strip the
     * "Expect: 100-continue" header, and send a "100 Continue" response itself.
     * </pre>
     *
     * <code>bool proxy_100_continue = 18;</code>
     * @return The proxy100Continue.
     */
    @java.lang.Override
    public boolean getProxy100Continue() {
      return proxy100Continue_;
    }
    /**
     * <pre>
     * If proxy_100_continue is true, Envoy will proxy incoming "Expect:
     * 100-continue" headers upstream, and forward "100 Continue" responses
     * downstream. If this is false or not set, Envoy will instead strip the
     * "Expect: 100-continue" header, and send a "100 Continue" response itself.
     * </pre>
     *
     * <code>bool proxy_100_continue = 18;</code>
     * @param value The proxy100Continue to set.
     * @return This builder for chaining.
     */
    public Builder setProxy100Continue(boolean value) {
      
      proxy100Continue_ = value;
      bitField1_ |= 0x00000004;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If proxy_100_continue is true, Envoy will proxy incoming "Expect:
     * 100-continue" headers upstream, and forward "100 Continue" responses
     * downstream. If this is false or not set, Envoy will instead strip the
     * "Expect: 100-continue" header, and send a "100 Continue" response itself.
     * </pre>
     *
     * <code>bool proxy_100_continue = 18;</code>
     * @return This builder for chaining.
     */
    public Builder clearProxy100Continue() {
      bitField1_ = (bitField1_ & ~0x00000004);
      proxy100Continue_ = false;
      onChanged();
      return this;
    }

    private boolean representIpv4RemoteAddressAsIpv4MappedIpv6_ ;
    /**
     * <pre>
     * If
     * :ref:`use_remote_address
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     * is true and represent_ipv4_remote_address_as_ipv4_mapped_ipv6 is true and the remote address is
     * an IPv4 address, the address will be mapped to IPv6 before it is appended to ``x-forwarded-for``.
     * This is useful for testing compatibility of upstream services that parse the header value. For
     * example, 50.0.0.1 is represented as ::FFFF:50.0.0.1. See `IPv4-Mapped IPv6 Addresses
     * &lt;https://tools.ietf.org/html/rfc4291#section-2.5.5.2&gt;`_ for details. This will also affect the
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` header. See
     * :ref:`http_connection_manager.represent_ipv4_remote_address_as_ipv4_mapped_ipv6
     * &lt;config_http_conn_man_runtime_represent_ipv4_remote_address_as_ipv4_mapped_ipv6&gt;` for runtime
     * control.
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>bool represent_ipv4_remote_address_as_ipv4_mapped_ipv6 = 20;</code>
     * @return The representIpv4RemoteAddressAsIpv4MappedIpv6.
     */
    @java.lang.Override
    public boolean getRepresentIpv4RemoteAddressAsIpv4MappedIpv6() {
      return representIpv4RemoteAddressAsIpv4MappedIpv6_;
    }
    /**
     * <pre>
     * If
     * :ref:`use_remote_address
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     * is true and represent_ipv4_remote_address_as_ipv4_mapped_ipv6 is true and the remote address is
     * an IPv4 address, the address will be mapped to IPv6 before it is appended to ``x-forwarded-for``.
     * This is useful for testing compatibility of upstream services that parse the header value. For
     * example, 50.0.0.1 is represented as ::FFFF:50.0.0.1. See `IPv4-Mapped IPv6 Addresses
     * &lt;https://tools.ietf.org/html/rfc4291#section-2.5.5.2&gt;`_ for details. This will also affect the
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` header. See
     * :ref:`http_connection_manager.represent_ipv4_remote_address_as_ipv4_mapped_ipv6
     * &lt;config_http_conn_man_runtime_represent_ipv4_remote_address_as_ipv4_mapped_ipv6&gt;` for runtime
     * control.
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>bool represent_ipv4_remote_address_as_ipv4_mapped_ipv6 = 20;</code>
     * @param value The representIpv4RemoteAddressAsIpv4MappedIpv6 to set.
     * @return This builder for chaining.
     */
    public Builder setRepresentIpv4RemoteAddressAsIpv4MappedIpv6(boolean value) {
      
      representIpv4RemoteAddressAsIpv4MappedIpv6_ = value;
      bitField1_ |= 0x00000008;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If
     * :ref:`use_remote_address
     * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
     * is true and represent_ipv4_remote_address_as_ipv4_mapped_ipv6 is true and the remote address is
     * an IPv4 address, the address will be mapped to IPv6 before it is appended to ``x-forwarded-for``.
     * This is useful for testing compatibility of upstream services that parse the header value. For
     * example, 50.0.0.1 is represented as ::FFFF:50.0.0.1. See `IPv4-Mapped IPv6 Addresses
     * &lt;https://tools.ietf.org/html/rfc4291#section-2.5.5.2&gt;`_ for details. This will also affect the
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` header. See
     * :ref:`http_connection_manager.represent_ipv4_remote_address_as_ipv4_mapped_ipv6
     * &lt;config_http_conn_man_runtime_represent_ipv4_remote_address_as_ipv4_mapped_ipv6&gt;` for runtime
     * control.
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>bool represent_ipv4_remote_address_as_ipv4_mapped_ipv6 = 20;</code>
     * @return This builder for chaining.
     */
    public Builder clearRepresentIpv4RemoteAddressAsIpv4MappedIpv6() {
      bitField1_ = (bitField1_ & ~0x00000008);
      representIpv4RemoteAddressAsIpv4MappedIpv6_ = false;
      onChanged();
      return this;
    }

    private java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig> upgradeConfigs_ =
      java.util.Collections.emptyList();
    private void ensureUpgradeConfigsIsMutable() {
      if (!((bitField1_ & 0x00000010) != 0)) {
        upgradeConfigs_ = new java.util.ArrayList<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig>(upgradeConfigs_);
        bitField1_ |= 0x00000010;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfigOrBuilder> upgradeConfigsBuilder_;

    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig> getUpgradeConfigsList() {
      if (upgradeConfigsBuilder_ == null) {
        return java.util.Collections.unmodifiableList(upgradeConfigs_);
      } else {
        return upgradeConfigsBuilder_.getMessageList();
      }
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public int getUpgradeConfigsCount() {
      if (upgradeConfigsBuilder_ == null) {
        return upgradeConfigs_.size();
      } else {
        return upgradeConfigsBuilder_.getCount();
      }
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig getUpgradeConfigs(int index) {
      if (upgradeConfigsBuilder_ == null) {
        return upgradeConfigs_.get(index);
      } else {
        return upgradeConfigsBuilder_.getMessage(index);
      }
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public Builder setUpgradeConfigs(
        int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig value) {
      if (upgradeConfigsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureUpgradeConfigsIsMutable();
        upgradeConfigs_.set(index, value);
        onChanged();
      } else {
        upgradeConfigsBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public Builder setUpgradeConfigs(
        int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder builderForValue) {
      if (upgradeConfigsBuilder_ == null) {
        ensureUpgradeConfigsIsMutable();
        upgradeConfigs_.set(index, builderForValue.build());
        onChanged();
      } else {
        upgradeConfigsBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public Builder addUpgradeConfigs(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig value) {
      if (upgradeConfigsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureUpgradeConfigsIsMutable();
        upgradeConfigs_.add(value);
        onChanged();
      } else {
        upgradeConfigsBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public Builder addUpgradeConfigs(
        int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig value) {
      if (upgradeConfigsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureUpgradeConfigsIsMutable();
        upgradeConfigs_.add(index, value);
        onChanged();
      } else {
        upgradeConfigsBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public Builder addUpgradeConfigs(
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder builderForValue) {
      if (upgradeConfigsBuilder_ == null) {
        ensureUpgradeConfigsIsMutable();
        upgradeConfigs_.add(builderForValue.build());
        onChanged();
      } else {
        upgradeConfigsBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public Builder addUpgradeConfigs(
        int index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder builderForValue) {
      if (upgradeConfigsBuilder_ == null) {
        ensureUpgradeConfigsIsMutable();
        upgradeConfigs_.add(index, builderForValue.build());
        onChanged();
      } else {
        upgradeConfigsBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public Builder addAllUpgradeConfigs(
        java.lang.Iterable<? extends io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig> values) {
      if (upgradeConfigsBuilder_ == null) {
        ensureUpgradeConfigsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, upgradeConfigs_);
        onChanged();
      } else {
        upgradeConfigsBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public Builder clearUpgradeConfigs() {
      if (upgradeConfigsBuilder_ == null) {
        upgradeConfigs_ = java.util.Collections.emptyList();
        bitField1_ = (bitField1_ & ~0x00000010);
        onChanged();
      } else {
        upgradeConfigsBuilder_.clear();
      }
      return this;
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public Builder removeUpgradeConfigs(int index) {
      if (upgradeConfigsBuilder_ == null) {
        ensureUpgradeConfigsIsMutable();
        upgradeConfigs_.remove(index);
        onChanged();
      } else {
        upgradeConfigsBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder getUpgradeConfigsBuilder(
        int index) {
      return getUpgradeConfigsFieldBuilder().getBuilder(index);
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfigOrBuilder getUpgradeConfigsOrBuilder(
        int index) {
      if (upgradeConfigsBuilder_ == null) {
        return upgradeConfigs_.get(index);  } else {
        return upgradeConfigsBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public java.util.List<? extends io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfigOrBuilder> 
         getUpgradeConfigsOrBuilderList() {
      if (upgradeConfigsBuilder_ != null) {
        return upgradeConfigsBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(upgradeConfigs_);
      }
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder addUpgradeConfigsBuilder() {
      return getUpgradeConfigsFieldBuilder().addBuilder(
          io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.getDefaultInstance());
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder addUpgradeConfigsBuilder(
        int index) {
      return getUpgradeConfigsFieldBuilder().addBuilder(
          index, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.getDefaultInstance());
    }
    /**
     * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
     */
    public java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder> 
         getUpgradeConfigsBuilderList() {
      return getUpgradeConfigsFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfigOrBuilder> 
        getUpgradeConfigsFieldBuilder() {
      if (upgradeConfigsBuilder_ == null) {
        upgradeConfigsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfigOrBuilder>(
                upgradeConfigs_,
                ((bitField1_ & 0x00000010) != 0),
                getParentForChildren(),
                isClean());
        upgradeConfigs_ = null;
      }
      return upgradeConfigsBuilder_;
    }

    private com.google.protobuf.BoolValue normalizePath_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> normalizePathBuilder_;
    /**
     * <pre>
     * Should paths be normalized according to RFC 3986 before any processing of
     * requests by HTTP filters or routing? This affects the upstream ``:path`` header
     * as well. For paths that fail this check, Envoy will respond with 400 to
     * paths that are malformed. This defaults to false currently but will default
     * true in the future. When not specified, this value may be overridden by the
     * runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
     * for details of normalization.
     * Note that Envoy does not perform
     * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
     * [#comment:TODO: This field is ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present.]
     * </pre>
     *
     * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
     * @return Whether the normalizePath field is set.
     */
    public boolean hasNormalizePath() {
      return ((bitField1_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Should paths be normalized according to RFC 3986 before any processing of
     * requests by HTTP filters or routing? This affects the upstream ``:path`` header
     * as well. For paths that fail this check, Envoy will respond with 400 to
     * paths that are malformed. This defaults to false currently but will default
     * true in the future. When not specified, this value may be overridden by the
     * runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
     * for details of normalization.
     * Note that Envoy does not perform
     * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
     * [#comment:TODO: This field is ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present.]
     * </pre>
     *
     * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
     * @return The normalizePath.
     */
    public com.google.protobuf.BoolValue getNormalizePath() {
      if (normalizePathBuilder_ == null) {
        return normalizePath_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : normalizePath_;
      } else {
        return normalizePathBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Should paths be normalized according to RFC 3986 before any processing of
     * requests by HTTP filters or routing? This affects the upstream ``:path`` header
     * as well. For paths that fail this check, Envoy will respond with 400 to
     * paths that are malformed. This defaults to false currently but will default
     * true in the future. When not specified, this value may be overridden by the
     * runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
     * for details of normalization.
     * Note that Envoy does not perform
     * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
     * [#comment:TODO: This field is ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present.]
     * </pre>
     *
     * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
     */
    public Builder setNormalizePath(com.google.protobuf.BoolValue value) {
      if (normalizePathBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        normalizePath_ = value;
      } else {
        normalizePathBuilder_.setMessage(value);
      }
      bitField1_ |= 0x00000020;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Should paths be normalized according to RFC 3986 before any processing of
     * requests by HTTP filters or routing? This affects the upstream ``:path`` header
     * as well. For paths that fail this check, Envoy will respond with 400 to
     * paths that are malformed. This defaults to false currently but will default
     * true in the future. When not specified, this value may be overridden by the
     * runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
     * for details of normalization.
     * Note that Envoy does not perform
     * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
     * [#comment:TODO: This field is ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present.]
     * </pre>
     *
     * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
     */
    public Builder setNormalizePath(
        com.google.protobuf.BoolValue.Builder builderForValue) {
      if (normalizePathBuilder_ == null) {
        normalizePath_ = builderForValue.build();
      } else {
        normalizePathBuilder_.setMessage(builderForValue.build());
      }
      bitField1_ |= 0x00000020;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Should paths be normalized according to RFC 3986 before any processing of
     * requests by HTTP filters or routing? This affects the upstream ``:path`` header
     * as well. For paths that fail this check, Envoy will respond with 400 to
     * paths that are malformed. This defaults to false currently but will default
     * true in the future. When not specified, this value may be overridden by the
     * runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
     * for details of normalization.
     * Note that Envoy does not perform
     * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
     * [#comment:TODO: This field is ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present.]
     * </pre>
     *
     * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
     */
    public Builder mergeNormalizePath(com.google.protobuf.BoolValue value) {
      if (normalizePathBuilder_ == null) {
        if (((bitField1_ & 0x00000020) != 0) &&
          normalizePath_ != null &&
          normalizePath_ != com.google.protobuf.BoolValue.getDefaultInstance()) {
          getNormalizePathBuilder().mergeFrom(value);
        } else {
          normalizePath_ = value;
        }
      } else {
        normalizePathBuilder_.mergeFrom(value);
      }
      bitField1_ |= 0x00000020;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Should paths be normalized according to RFC 3986 before any processing of
     * requests by HTTP filters or routing? This affects the upstream ``:path`` header
     * as well. For paths that fail this check, Envoy will respond with 400 to
     * paths that are malformed. This defaults to false currently but will default
     * true in the future. When not specified, this value may be overridden by the
     * runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
     * for details of normalization.
     * Note that Envoy does not perform
     * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
     * [#comment:TODO: This field is ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present.]
     * </pre>
     *
     * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
     */
    public Builder clearNormalizePath() {
      bitField1_ = (bitField1_ & ~0x00000020);
      normalizePath_ = null;
      if (normalizePathBuilder_ != null) {
        normalizePathBuilder_.dispose();
        normalizePathBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Should paths be normalized according to RFC 3986 before any processing of
     * requests by HTTP filters or routing? This affects the upstream ``:path`` header
     * as well. For paths that fail this check, Envoy will respond with 400 to
     * paths that are malformed. This defaults to false currently but will default
     * true in the future. When not specified, this value may be overridden by the
     * runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
     * for details of normalization.
     * Note that Envoy does not perform
     * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
     * [#comment:TODO: This field is ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present.]
     * </pre>
     *
     * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
     */
    public com.google.protobuf.BoolValue.Builder getNormalizePathBuilder() {
      bitField1_ |= 0x00000020;
      onChanged();
      return getNormalizePathFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Should paths be normalized according to RFC 3986 before any processing of
     * requests by HTTP filters or routing? This affects the upstream ``:path`` header
     * as well. For paths that fail this check, Envoy will respond with 400 to
     * paths that are malformed. This defaults to false currently but will default
     * true in the future. When not specified, this value may be overridden by the
     * runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
     * for details of normalization.
     * Note that Envoy does not perform
     * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
     * [#comment:TODO: This field is ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present.]
     * </pre>
     *
     * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getNormalizePathOrBuilder() {
      if (normalizePathBuilder_ != null) {
        return normalizePathBuilder_.getMessageOrBuilder();
      } else {
        return normalizePath_ == null ?
            com.google.protobuf.BoolValue.getDefaultInstance() : normalizePath_;
      }
    }
    /**
     * <pre>
     * Should paths be normalized according to RFC 3986 before any processing of
     * requests by HTTP filters or routing? This affects the upstream ``:path`` header
     * as well. For paths that fail this check, Envoy will respond with 400 to
     * paths that are malformed. This defaults to false currently but will default
     * true in the future. When not specified, this value may be overridden by the
     * runtime variable
     * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
     * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
     * for details of normalization.
     * Note that Envoy does not perform
     * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
     * [#comment:TODO: This field is ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present.]
     * </pre>
     *
     * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
        getNormalizePathFieldBuilder() {
      if (normalizePathBuilder_ == null) {
        normalizePathBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                getNormalizePath(),
                getParentForChildren(),
                isClean());
        normalizePath_ = null;
      }
      return normalizePathBuilder_;
    }

    private boolean mergeSlashes_ ;
    /**
     * <pre>
     * Determines if adjacent slashes in the path are merged into one before any processing of
     * requests by HTTP filters or routing. This affects the upstream ``:path`` header as well. Without
     * setting this option, incoming requests with path ``//dir///file`` will not match against route
     * with ``prefix`` match set to ``/dir``. Defaults to ``false``. Note that slash merging is not part of
     * `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
     * [#comment:TODO: This field is ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present.]
     * </pre>
     *
     * <code>bool merge_slashes = 33;</code>
     * @return The mergeSlashes.
     */
    @java.lang.Override
    public boolean getMergeSlashes() {
      return mergeSlashes_;
    }
    /**
     * <pre>
     * Determines if adjacent slashes in the path are merged into one before any processing of
     * requests by HTTP filters or routing. This affects the upstream ``:path`` header as well. Without
     * setting this option, incoming requests with path ``//dir///file`` will not match against route
     * with ``prefix`` match set to ``/dir``. Defaults to ``false``. Note that slash merging is not part of
     * `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
     * [#comment:TODO: This field is ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present.]
     * </pre>
     *
     * <code>bool merge_slashes = 33;</code>
     * @param value The mergeSlashes to set.
     * @return This builder for chaining.
     */
    public Builder setMergeSlashes(boolean value) {
      
      mergeSlashes_ = value;
      bitField1_ |= 0x00000040;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Determines if adjacent slashes in the path are merged into one before any processing of
     * requests by HTTP filters or routing. This affects the upstream ``:path`` header as well. Without
     * setting this option, incoming requests with path ``//dir///file`` will not match against route
     * with ``prefix`` match set to ``/dir``. Defaults to ``false``. Note that slash merging is not part of
     * `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
     * [#comment:TODO: This field is ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present.]
     * </pre>
     *
     * <code>bool merge_slashes = 33;</code>
     * @return This builder for chaining.
     */
    public Builder clearMergeSlashes() {
      bitField1_ = (bitField1_ & ~0x00000040);
      mergeSlashes_ = false;
      onChanged();
      return this;
    }

    private int pathWithEscapedSlashesAction_ = 0;
    /**
     * <pre>
     * Action to take when request URL path contains escaped slash sequences (%2F, %2f, %5C and %5c).
     * The default value can be overridden by the :ref:`http_connection_manager.path_with_escaped_slashes_action&lt;config_http_conn_man_runtime_path_with_escaped_slashes_action&gt;`
     * runtime variable.
     * The :ref:`http_connection_manager.path_with_escaped_slashes_action_sampling&lt;config_http_conn_man_runtime_path_with_escaped_slashes_action_enabled&gt;` runtime
     * variable can be used to apply the action to a portion of all requests.
     * [#comment:TODO: This field is ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present.]
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction path_with_escaped_slashes_action = 45;</code>
     * @return The enum numeric value on the wire for pathWithEscapedSlashesAction.
     */
    @java.lang.Override public int getPathWithEscapedSlashesActionValue() {
      return pathWithEscapedSlashesAction_;
    }
    /**
     * <pre>
     * Action to take when request URL path contains escaped slash sequences (%2F, %2f, %5C and %5c).
     * The default value can be overridden by the :ref:`http_connection_manager.path_with_escaped_slashes_action&lt;config_http_conn_man_runtime_path_with_escaped_slashes_action&gt;`
     * runtime variable.
     * The :ref:`http_connection_manager.path_with_escaped_slashes_action_sampling&lt;config_http_conn_man_runtime_path_with_escaped_slashes_action_enabled&gt;` runtime
     * variable can be used to apply the action to a portion of all requests.
     * [#comment:TODO: This field is ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present.]
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction path_with_escaped_slashes_action = 45;</code>
     * @param value The enum numeric value on the wire for pathWithEscapedSlashesAction to set.
     * @return This builder for chaining.
     */
    public Builder setPathWithEscapedSlashesActionValue(int value) {
      pathWithEscapedSlashesAction_ = value;
      bitField1_ |= 0x00000080;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Action to take when request URL path contains escaped slash sequences (%2F, %2f, %5C and %5c).
     * The default value can be overridden by the :ref:`http_connection_manager.path_with_escaped_slashes_action&lt;config_http_conn_man_runtime_path_with_escaped_slashes_action&gt;`
     * runtime variable.
     * The :ref:`http_connection_manager.path_with_escaped_slashes_action_sampling&lt;config_http_conn_man_runtime_path_with_escaped_slashes_action_enabled&gt;` runtime
     * variable can be used to apply the action to a portion of all requests.
     * [#comment:TODO: This field is ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present.]
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction path_with_escaped_slashes_action = 45;</code>
     * @return The pathWithEscapedSlashesAction.
     */
    @java.lang.Override
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction getPathWithEscapedSlashesAction() {
      io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction result = io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction.forNumber(pathWithEscapedSlashesAction_);
      return result == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * Action to take when request URL path contains escaped slash sequences (%2F, %2f, %5C and %5c).
     * The default value can be overridden by the :ref:`http_connection_manager.path_with_escaped_slashes_action&lt;config_http_conn_man_runtime_path_with_escaped_slashes_action&gt;`
     * runtime variable.
     * The :ref:`http_connection_manager.path_with_escaped_slashes_action_sampling&lt;config_http_conn_man_runtime_path_with_escaped_slashes_action_enabled&gt;` runtime
     * variable can be used to apply the action to a portion of all requests.
     * [#comment:TODO: This field is ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present.]
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction path_with_escaped_slashes_action = 45;</code>
     * @param value The pathWithEscapedSlashesAction to set.
     * @return This builder for chaining.
     */
    public Builder setPathWithEscapedSlashesAction(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField1_ |= 0x00000080;
      pathWithEscapedSlashesAction_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Action to take when request URL path contains escaped slash sequences (%2F, %2f, %5C and %5c).
     * The default value can be overridden by the :ref:`http_connection_manager.path_with_escaped_slashes_action&lt;config_http_conn_man_runtime_path_with_escaped_slashes_action&gt;`
     * runtime variable.
     * The :ref:`http_connection_manager.path_with_escaped_slashes_action_sampling&lt;config_http_conn_man_runtime_path_with_escaped_slashes_action_enabled&gt;` runtime
     * variable can be used to apply the action to a portion of all requests.
     * [#comment:TODO: This field is ignored when the
     * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
     * is present.]
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction path_with_escaped_slashes_action = 45;</code>
     * @return This builder for chaining.
     */
    public Builder clearPathWithEscapedSlashesAction() {
      bitField1_ = (bitField1_ & ~0x00000080);
      pathWithEscapedSlashesAction_ = 0;
      onChanged();
      return this;
    }

    private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension requestIdExtension_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtensionOrBuilder> requestIdExtensionBuilder_;
    /**
     * <pre>
     * The configuration of the request ID extension. This includes operations such as
     * generation, validation, and associated tracing operations. If empty, the
     * :ref:`UuidRequestIdConfig &lt;envoy_v3_api_msg_extensions.request_id.uuid.v3.UuidRequestIdConfig&gt;`
     * default extension is used with default parameters. See the documentation for that extension
     * for details on what it does. Customizing the configuration for the default extension can be
     * achieved by configuring it explicitly here. For example, to disable trace reason packing,
     * the following configuration can be used:
     * .. validated-code-block:: yaml
     *   :type-name: envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension
     *   typed_config:
     *     "&#64;type": type.googleapis.com/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig
     *     pack_trace_reason: false
     * [#extension-category: envoy.request_id]
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
     * @return Whether the requestIdExtension field is set.
     */
    public boolean hasRequestIdExtension() {
      return ((bitField1_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * The configuration of the request ID extension. This includes operations such as
     * generation, validation, and associated tracing operations. If empty, the
     * :ref:`UuidRequestIdConfig &lt;envoy_v3_api_msg_extensions.request_id.uuid.v3.UuidRequestIdConfig&gt;`
     * default extension is used with default parameters. See the documentation for that extension
     * for details on what it does. Customizing the configuration for the default extension can be
     * achieved by configuring it explicitly here. For example, to disable trace reason packing,
     * the following configuration can be used:
     * .. validated-code-block:: yaml
     *   :type-name: envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension
     *   typed_config:
     *     "&#64;type": type.googleapis.com/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig
     *     pack_trace_reason: false
     * [#extension-category: envoy.request_id]
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
     * @return The requestIdExtension.
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension getRequestIdExtension() {
      if (requestIdExtensionBuilder_ == null) {
        return requestIdExtension_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension.getDefaultInstance() : requestIdExtension_;
      } else {
        return requestIdExtensionBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The configuration of the request ID extension. This includes operations such as
     * generation, validation, and associated tracing operations. If empty, the
     * :ref:`UuidRequestIdConfig &lt;envoy_v3_api_msg_extensions.request_id.uuid.v3.UuidRequestIdConfig&gt;`
     * default extension is used with default parameters. See the documentation for that extension
     * for details on what it does. Customizing the configuration for the default extension can be
     * achieved by configuring it explicitly here. For example, to disable trace reason packing,
     * the following configuration can be used:
     * .. validated-code-block:: yaml
     *   :type-name: envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension
     *   typed_config:
     *     "&#64;type": type.googleapis.com/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig
     *     pack_trace_reason: false
     * [#extension-category: envoy.request_id]
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
     */
    public Builder setRequestIdExtension(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension value) {
      if (requestIdExtensionBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        requestIdExtension_ = value;
      } else {
        requestIdExtensionBuilder_.setMessage(value);
      }
      bitField1_ |= 0x00000100;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The configuration of the request ID extension. This includes operations such as
     * generation, validation, and associated tracing operations. If empty, the
     * :ref:`UuidRequestIdConfig &lt;envoy_v3_api_msg_extensions.request_id.uuid.v3.UuidRequestIdConfig&gt;`
     * default extension is used with default parameters. See the documentation for that extension
     * for details on what it does. Customizing the configuration for the default extension can be
     * achieved by configuring it explicitly here. For example, to disable trace reason packing,
     * the following configuration can be used:
     * .. validated-code-block:: yaml
     *   :type-name: envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension
     *   typed_config:
     *     "&#64;type": type.googleapis.com/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig
     *     pack_trace_reason: false
     * [#extension-category: envoy.request_id]
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
     */
    public Builder setRequestIdExtension(
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension.Builder builderForValue) {
      if (requestIdExtensionBuilder_ == null) {
        requestIdExtension_ = builderForValue.build();
      } else {
        requestIdExtensionBuilder_.setMessage(builderForValue.build());
      }
      bitField1_ |= 0x00000100;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The configuration of the request ID extension. This includes operations such as
     * generation, validation, and associated tracing operations. If empty, the
     * :ref:`UuidRequestIdConfig &lt;envoy_v3_api_msg_extensions.request_id.uuid.v3.UuidRequestIdConfig&gt;`
     * default extension is used with default parameters. See the documentation for that extension
     * for details on what it does. Customizing the configuration for the default extension can be
     * achieved by configuring it explicitly here. For example, to disable trace reason packing,
     * the following configuration can be used:
     * .. validated-code-block:: yaml
     *   :type-name: envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension
     *   typed_config:
     *     "&#64;type": type.googleapis.com/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig
     *     pack_trace_reason: false
     * [#extension-category: envoy.request_id]
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
     */
    public Builder mergeRequestIdExtension(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension value) {
      if (requestIdExtensionBuilder_ == null) {
        if (((bitField1_ & 0x00000100) != 0) &&
          requestIdExtension_ != null &&
          requestIdExtension_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension.getDefaultInstance()) {
          getRequestIdExtensionBuilder().mergeFrom(value);
        } else {
          requestIdExtension_ = value;
        }
      } else {
        requestIdExtensionBuilder_.mergeFrom(value);
      }
      bitField1_ |= 0x00000100;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The configuration of the request ID extension. This includes operations such as
     * generation, validation, and associated tracing operations. If empty, the
     * :ref:`UuidRequestIdConfig &lt;envoy_v3_api_msg_extensions.request_id.uuid.v3.UuidRequestIdConfig&gt;`
     * default extension is used with default parameters. See the documentation for that extension
     * for details on what it does. Customizing the configuration for the default extension can be
     * achieved by configuring it explicitly here. For example, to disable trace reason packing,
     * the following configuration can be used:
     * .. validated-code-block:: yaml
     *   :type-name: envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension
     *   typed_config:
     *     "&#64;type": type.googleapis.com/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig
     *     pack_trace_reason: false
     * [#extension-category: envoy.request_id]
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
     */
    public Builder clearRequestIdExtension() {
      bitField1_ = (bitField1_ & ~0x00000100);
      requestIdExtension_ = null;
      if (requestIdExtensionBuilder_ != null) {
        requestIdExtensionBuilder_.dispose();
        requestIdExtensionBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The configuration of the request ID extension. This includes operations such as
     * generation, validation, and associated tracing operations. If empty, the
     * :ref:`UuidRequestIdConfig &lt;envoy_v3_api_msg_extensions.request_id.uuid.v3.UuidRequestIdConfig&gt;`
     * default extension is used with default parameters. See the documentation for that extension
     * for details on what it does. Customizing the configuration for the default extension can be
     * achieved by configuring it explicitly here. For example, to disable trace reason packing,
     * the following configuration can be used:
     * .. validated-code-block:: yaml
     *   :type-name: envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension
     *   typed_config:
     *     "&#64;type": type.googleapis.com/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig
     *     pack_trace_reason: false
     * [#extension-category: envoy.request_id]
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension.Builder getRequestIdExtensionBuilder() {
      bitField1_ |= 0x00000100;
      onChanged();
      return getRequestIdExtensionFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The configuration of the request ID extension. This includes operations such as
     * generation, validation, and associated tracing operations. If empty, the
     * :ref:`UuidRequestIdConfig &lt;envoy_v3_api_msg_extensions.request_id.uuid.v3.UuidRequestIdConfig&gt;`
     * default extension is used with default parameters. See the documentation for that extension
     * for details on what it does. Customizing the configuration for the default extension can be
     * achieved by configuring it explicitly here. For example, to disable trace reason packing,
     * the following configuration can be used:
     * .. validated-code-block:: yaml
     *   :type-name: envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension
     *   typed_config:
     *     "&#64;type": type.googleapis.com/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig
     *     pack_trace_reason: false
     * [#extension-category: envoy.request_id]
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtensionOrBuilder getRequestIdExtensionOrBuilder() {
      if (requestIdExtensionBuilder_ != null) {
        return requestIdExtensionBuilder_.getMessageOrBuilder();
      } else {
        return requestIdExtension_ == null ?
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension.getDefaultInstance() : requestIdExtension_;
      }
    }
    /**
     * <pre>
     * The configuration of the request ID extension. This includes operations such as
     * generation, validation, and associated tracing operations. If empty, the
     * :ref:`UuidRequestIdConfig &lt;envoy_v3_api_msg_extensions.request_id.uuid.v3.UuidRequestIdConfig&gt;`
     * default extension is used with default parameters. See the documentation for that extension
     * for details on what it does. Customizing the configuration for the default extension can be
     * achieved by configuring it explicitly here. For example, to disable trace reason packing,
     * the following configuration can be used:
     * .. validated-code-block:: yaml
     *   :type-name: envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension
     *   typed_config:
     *     "&#64;type": type.googleapis.com/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig
     *     pack_trace_reason: false
     * [#extension-category: envoy.request_id]
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtensionOrBuilder> 
        getRequestIdExtensionFieldBuilder() {
      if (requestIdExtensionBuilder_ == null) {
        requestIdExtensionBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtensionOrBuilder>(
                getRequestIdExtension(),
                getParentForChildren(),
                isClean());
        requestIdExtension_ = null;
      }
      return requestIdExtensionBuilder_;
    }

    private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig localReplyConfig_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfigOrBuilder> localReplyConfigBuilder_;
    /**
     * <pre>
     * The configuration to customize local reply returned by Envoy. It can customize status code,
     * body text and response content type. If not specified, status code and text body are hard
     * coded in Envoy, the response content type is plain text.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
     * @return Whether the localReplyConfig field is set.
     */
    public boolean hasLocalReplyConfig() {
      return ((bitField1_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * The configuration to customize local reply returned by Envoy. It can customize status code,
     * body text and response content type. If not specified, status code and text body are hard
     * coded in Envoy, the response content type is plain text.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
     * @return The localReplyConfig.
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig getLocalReplyConfig() {
      if (localReplyConfigBuilder_ == null) {
        return localReplyConfig_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.getDefaultInstance() : localReplyConfig_;
      } else {
        return localReplyConfigBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The configuration to customize local reply returned by Envoy. It can customize status code,
     * body text and response content type. If not specified, status code and text body are hard
     * coded in Envoy, the response content type is plain text.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
     */
    public Builder setLocalReplyConfig(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig value) {
      if (localReplyConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        localReplyConfig_ = value;
      } else {
        localReplyConfigBuilder_.setMessage(value);
      }
      bitField1_ |= 0x00000200;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The configuration to customize local reply returned by Envoy. It can customize status code,
     * body text and response content type. If not specified, status code and text body are hard
     * coded in Envoy, the response content type is plain text.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
     */
    public Builder setLocalReplyConfig(
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.Builder builderForValue) {
      if (localReplyConfigBuilder_ == null) {
        localReplyConfig_ = builderForValue.build();
      } else {
        localReplyConfigBuilder_.setMessage(builderForValue.build());
      }
      bitField1_ |= 0x00000200;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The configuration to customize local reply returned by Envoy. It can customize status code,
     * body text and response content type. If not specified, status code and text body are hard
     * coded in Envoy, the response content type is plain text.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
     */
    public Builder mergeLocalReplyConfig(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig value) {
      if (localReplyConfigBuilder_ == null) {
        if (((bitField1_ & 0x00000200) != 0) &&
          localReplyConfig_ != null &&
          localReplyConfig_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.getDefaultInstance()) {
          getLocalReplyConfigBuilder().mergeFrom(value);
        } else {
          localReplyConfig_ = value;
        }
      } else {
        localReplyConfigBuilder_.mergeFrom(value);
      }
      bitField1_ |= 0x00000200;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The configuration to customize local reply returned by Envoy. It can customize status code,
     * body text and response content type. If not specified, status code and text body are hard
     * coded in Envoy, the response content type is plain text.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
     */
    public Builder clearLocalReplyConfig() {
      bitField1_ = (bitField1_ & ~0x00000200);
      localReplyConfig_ = null;
      if (localReplyConfigBuilder_ != null) {
        localReplyConfigBuilder_.dispose();
        localReplyConfigBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The configuration to customize local reply returned by Envoy. It can customize status code,
     * body text and response content type. If not specified, status code and text body are hard
     * coded in Envoy, the response content type is plain text.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.Builder getLocalReplyConfigBuilder() {
      bitField1_ |= 0x00000200;
      onChanged();
      return getLocalReplyConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The configuration to customize local reply returned by Envoy. It can customize status code,
     * body text and response content type. If not specified, status code and text body are hard
     * coded in Envoy, the response content type is plain text.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfigOrBuilder getLocalReplyConfigOrBuilder() {
      if (localReplyConfigBuilder_ != null) {
        return localReplyConfigBuilder_.getMessageOrBuilder();
      } else {
        return localReplyConfig_ == null ?
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.getDefaultInstance() : localReplyConfig_;
      }
    }
    /**
     * <pre>
     * The configuration to customize local reply returned by Envoy. It can customize status code,
     * body text and response content type. If not specified, status code and text body are hard
     * coded in Envoy, the response content type is plain text.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfigOrBuilder> 
        getLocalReplyConfigFieldBuilder() {
      if (localReplyConfigBuilder_ == null) {
        localReplyConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfigOrBuilder>(
                getLocalReplyConfig(),
                getParentForChildren(),
                isClean());
        localReplyConfig_ = null;
      }
      return localReplyConfigBuilder_;
    }

    private boolean stripMatchingHostPort_ ;
    /**
     * <pre>
     * Determines if the port part should be removed from host/authority header before any processing
     * of request by HTTP filters or routing. The port would be removed only if it is equal to the :ref:`listener's&lt;envoy_v3_api_field_config.listener.v3.Listener.address&gt;`
     * local port. This affects the upstream host header unless the method is
     * CONNECT in which case if no filter adds a port the original port will be restored before headers are
     * sent upstream.
     * Without setting this option, incoming requests with host ``example:443`` will not match against
     * route with :ref:`domains&lt;envoy_v3_api_field_config.route.v3.VirtualHost.domains&gt;` match set to ``example``. Defaults to ``false``. Note that port removal is not part
     * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
     * Only one of ``strip_matching_host_port`` or ``strip_any_host_port`` can be set.
     * </pre>
     *
     * <code>bool strip_matching_host_port = 39 [(.udpa.annotations.field_migrate) = { ... }</code>
     * @return The stripMatchingHostPort.
     */
    @java.lang.Override
    public boolean getStripMatchingHostPort() {
      return stripMatchingHostPort_;
    }
    /**
     * <pre>
     * Determines if the port part should be removed from host/authority header before any processing
     * of request by HTTP filters or routing. The port would be removed only if it is equal to the :ref:`listener's&lt;envoy_v3_api_field_config.listener.v3.Listener.address&gt;`
     * local port. This affects the upstream host header unless the method is
     * CONNECT in which case if no filter adds a port the original port will be restored before headers are
     * sent upstream.
     * Without setting this option, incoming requests with host ``example:443`` will not match against
     * route with :ref:`domains&lt;envoy_v3_api_field_config.route.v3.VirtualHost.domains&gt;` match set to ``example``. Defaults to ``false``. Note that port removal is not part
     * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
     * Only one of ``strip_matching_host_port`` or ``strip_any_host_port`` can be set.
     * </pre>
     *
     * <code>bool strip_matching_host_port = 39 [(.udpa.annotations.field_migrate) = { ... }</code>
     * @param value The stripMatchingHostPort to set.
     * @return This builder for chaining.
     */
    public Builder setStripMatchingHostPort(boolean value) {
      
      stripMatchingHostPort_ = value;
      bitField1_ |= 0x00000400;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Determines if the port part should be removed from host/authority header before any processing
     * of request by HTTP filters or routing. The port would be removed only if it is equal to the :ref:`listener's&lt;envoy_v3_api_field_config.listener.v3.Listener.address&gt;`
     * local port. This affects the upstream host header unless the method is
     * CONNECT in which case if no filter adds a port the original port will be restored before headers are
     * sent upstream.
     * Without setting this option, incoming requests with host ``example:443`` will not match against
     * route with :ref:`domains&lt;envoy_v3_api_field_config.route.v3.VirtualHost.domains&gt;` match set to ``example``. Defaults to ``false``. Note that port removal is not part
     * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
     * Only one of ``strip_matching_host_port`` or ``strip_any_host_port`` can be set.
     * </pre>
     *
     * <code>bool strip_matching_host_port = 39 [(.udpa.annotations.field_migrate) = { ... }</code>
     * @return This builder for chaining.
     */
    public Builder clearStripMatchingHostPort() {
      bitField1_ = (bitField1_ & ~0x00000400);
      stripMatchingHostPort_ = false;
      onChanged();
      return this;
    }

    /**
     * <pre>
     * Determines if the port part should be removed from host/authority header before any processing
     * of request by HTTP filters or routing.
     * This affects the upstream host header unless the method is CONNECT in
     * which case if no filter adds a port the original port will be restored before headers are sent upstream.
     * Without setting this option, incoming requests with host ``example:443`` will not match against
     * route with :ref:`domains&lt;envoy_v3_api_field_config.route.v3.VirtualHost.domains&gt;` match set to ``example``. Defaults to ``false``. Note that port removal is not part
     * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
     * Only one of ``strip_matching_host_port`` or ``strip_any_host_port`` can be set.
     * </pre>
     *
     * <code>bool strip_any_host_port = 42;</code>
     * @return Whether the stripAnyHostPort field is set.
     */
    public boolean hasStripAnyHostPort() {
      return stripPortModeCase_ == 42;
    }
    /**
     * <pre>
     * Determines if the port part should be removed from host/authority header before any processing
     * of request by HTTP filters or routing.
     * This affects the upstream host header unless the method is CONNECT in
     * which case if no filter adds a port the original port will be restored before headers are sent upstream.
     * Without setting this option, incoming requests with host ``example:443`` will not match against
     * route with :ref:`domains&lt;envoy_v3_api_field_config.route.v3.VirtualHost.domains&gt;` match set to ``example``. Defaults to ``false``. Note that port removal is not part
     * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
     * Only one of ``strip_matching_host_port`` or ``strip_any_host_port`` can be set.
     * </pre>
     *
     * <code>bool strip_any_host_port = 42;</code>
     * @return The stripAnyHostPort.
     */
    public boolean getStripAnyHostPort() {
      if (stripPortModeCase_ == 42) {
        return (java.lang.Boolean) stripPortMode_;
      }
      return false;
    }
    /**
     * <pre>
     * Determines if the port part should be removed from host/authority header before any processing
     * of request by HTTP filters or routing.
     * This affects the upstream host header unless the method is CONNECT in
     * which case if no filter adds a port the original port will be restored before headers are sent upstream.
     * Without setting this option, incoming requests with host ``example:443`` will not match against
     * route with :ref:`domains&lt;envoy_v3_api_field_config.route.v3.VirtualHost.domains&gt;` match set to ``example``. Defaults to ``false``. Note that port removal is not part
     * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
     * Only one of ``strip_matching_host_port`` or ``strip_any_host_port`` can be set.
     * </pre>
     *
     * <code>bool strip_any_host_port = 42;</code>
     * @param value The stripAnyHostPort to set.
     * @return This builder for chaining.
     */
    public Builder setStripAnyHostPort(boolean value) {
      
      stripPortModeCase_ = 42;
      stripPortMode_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Determines if the port part should be removed from host/authority header before any processing
     * of request by HTTP filters or routing.
     * This affects the upstream host header unless the method is CONNECT in
     * which case if no filter adds a port the original port will be restored before headers are sent upstream.
     * Without setting this option, incoming requests with host ``example:443`` will not match against
     * route with :ref:`domains&lt;envoy_v3_api_field_config.route.v3.VirtualHost.domains&gt;` match set to ``example``. Defaults to ``false``. Note that port removal is not part
     * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
     * Only one of ``strip_matching_host_port`` or ``strip_any_host_port`` can be set.
     * </pre>
     *
     * <code>bool strip_any_host_port = 42;</code>
     * @return This builder for chaining.
     */
    public Builder clearStripAnyHostPort() {
      if (stripPortModeCase_ == 42) {
        stripPortModeCase_ = 0;
        stripPortMode_ = null;
        onChanged();
      }
      return this;
    }

    private com.google.protobuf.BoolValue streamErrorOnInvalidHttpMessage_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> streamErrorOnInvalidHttpMessageBuilder_;
    /**
     * <pre>
     * Governs Envoy's behavior when receiving invalid HTTP from downstream.
     * If this option is false (default), Envoy will err on the conservative side handling HTTP
     * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
     * If this option is set to true, Envoy will be more permissive, only resetting the invalid
     * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
     * request is read for HTTP/1.1)
     * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
     * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
     * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
     * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
     * :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
     * ``not`` the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
     * @return Whether the streamErrorOnInvalidHttpMessage field is set.
     */
    public boolean hasStreamErrorOnInvalidHttpMessage() {
      return ((bitField1_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * Governs Envoy's behavior when receiving invalid HTTP from downstream.
     * If this option is false (default), Envoy will err on the conservative side handling HTTP
     * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
     * If this option is set to true, Envoy will be more permissive, only resetting the invalid
     * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
     * request is read for HTTP/1.1)
     * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
     * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
     * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
     * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
     * :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
     * ``not`` the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
     * @return The streamErrorOnInvalidHttpMessage.
     */
    public com.google.protobuf.BoolValue getStreamErrorOnInvalidHttpMessage() {
      if (streamErrorOnInvalidHttpMessageBuilder_ == null) {
        return streamErrorOnInvalidHttpMessage_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : streamErrorOnInvalidHttpMessage_;
      } else {
        return streamErrorOnInvalidHttpMessageBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Governs Envoy's behavior when receiving invalid HTTP from downstream.
     * If this option is false (default), Envoy will err on the conservative side handling HTTP
     * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
     * If this option is set to true, Envoy will be more permissive, only resetting the invalid
     * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
     * request is read for HTTP/1.1)
     * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
     * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
     * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
     * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
     * :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
     * ``not`` the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
     */
    public Builder setStreamErrorOnInvalidHttpMessage(com.google.protobuf.BoolValue value) {
      if (streamErrorOnInvalidHttpMessageBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        streamErrorOnInvalidHttpMessage_ = value;
      } else {
        streamErrorOnInvalidHttpMessageBuilder_.setMessage(value);
      }
      bitField1_ |= 0x00001000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Governs Envoy's behavior when receiving invalid HTTP from downstream.
     * If this option is false (default), Envoy will err on the conservative side handling HTTP
     * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
     * If this option is set to true, Envoy will be more permissive, only resetting the invalid
     * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
     * request is read for HTTP/1.1)
     * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
     * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
     * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
     * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
     * :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
     * ``not`` the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
     */
    public Builder setStreamErrorOnInvalidHttpMessage(
        com.google.protobuf.BoolValue.Builder builderForValue) {
      if (streamErrorOnInvalidHttpMessageBuilder_ == null) {
        streamErrorOnInvalidHttpMessage_ = builderForValue.build();
      } else {
        streamErrorOnInvalidHttpMessageBuilder_.setMessage(builderForValue.build());
      }
      bitField1_ |= 0x00001000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Governs Envoy's behavior when receiving invalid HTTP from downstream.
     * If this option is false (default), Envoy will err on the conservative side handling HTTP
     * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
     * If this option is set to true, Envoy will be more permissive, only resetting the invalid
     * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
     * request is read for HTTP/1.1)
     * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
     * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
     * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
     * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
     * :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
     * ``not`` the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
     */
    public Builder mergeStreamErrorOnInvalidHttpMessage(com.google.protobuf.BoolValue value) {
      if (streamErrorOnInvalidHttpMessageBuilder_ == null) {
        if (((bitField1_ & 0x00001000) != 0) &&
          streamErrorOnInvalidHttpMessage_ != null &&
          streamErrorOnInvalidHttpMessage_ != com.google.protobuf.BoolValue.getDefaultInstance()) {
          getStreamErrorOnInvalidHttpMessageBuilder().mergeFrom(value);
        } else {
          streamErrorOnInvalidHttpMessage_ = value;
        }
      } else {
        streamErrorOnInvalidHttpMessageBuilder_.mergeFrom(value);
      }
      bitField1_ |= 0x00001000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Governs Envoy's behavior when receiving invalid HTTP from downstream.
     * If this option is false (default), Envoy will err on the conservative side handling HTTP
     * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
     * If this option is set to true, Envoy will be more permissive, only resetting the invalid
     * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
     * request is read for HTTP/1.1)
     * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
     * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
     * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
     * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
     * :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
     * ``not`` the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
     */
    public Builder clearStreamErrorOnInvalidHttpMessage() {
      bitField1_ = (bitField1_ & ~0x00001000);
      streamErrorOnInvalidHttpMessage_ = null;
      if (streamErrorOnInvalidHttpMessageBuilder_ != null) {
        streamErrorOnInvalidHttpMessageBuilder_.dispose();
        streamErrorOnInvalidHttpMessageBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Governs Envoy's behavior when receiving invalid HTTP from downstream.
     * If this option is false (default), Envoy will err on the conservative side handling HTTP
     * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
     * If this option is set to true, Envoy will be more permissive, only resetting the invalid
     * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
     * request is read for HTTP/1.1)
     * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
     * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
     * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
     * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
     * :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
     * ``not`` the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
     */
    public com.google.protobuf.BoolValue.Builder getStreamErrorOnInvalidHttpMessageBuilder() {
      bitField1_ |= 0x00001000;
      onChanged();
      return getStreamErrorOnInvalidHttpMessageFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Governs Envoy's behavior when receiving invalid HTTP from downstream.
     * If this option is false (default), Envoy will err on the conservative side handling HTTP
     * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
     * If this option is set to true, Envoy will be more permissive, only resetting the invalid
     * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
     * request is read for HTTP/1.1)
     * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
     * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
     * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
     * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
     * :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
     * ``not`` the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getStreamErrorOnInvalidHttpMessageOrBuilder() {
      if (streamErrorOnInvalidHttpMessageBuilder_ != null) {
        return streamErrorOnInvalidHttpMessageBuilder_.getMessageOrBuilder();
      } else {
        return streamErrorOnInvalidHttpMessage_ == null ?
            com.google.protobuf.BoolValue.getDefaultInstance() : streamErrorOnInvalidHttpMessage_;
      }
    }
    /**
     * <pre>
     * Governs Envoy's behavior when receiving invalid HTTP from downstream.
     * If this option is false (default), Envoy will err on the conservative side handling HTTP
     * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
     * If this option is set to true, Envoy will be more permissive, only resetting the invalid
     * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
     * request is read for HTTP/1.1)
     * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
     * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
     * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
     * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
     * :ref:`override_stream_error_on_invalid_http_message
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
     * ``not`` the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
     * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
     * </pre>
     *
     * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
        getStreamErrorOnInvalidHttpMessageFieldBuilder() {
      if (streamErrorOnInvalidHttpMessageBuilder_ == null) {
        streamErrorOnInvalidHttpMessageBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                getStreamErrorOnInvalidHttpMessage(),
                getParentForChildren(),
                isClean());
        streamErrorOnInvalidHttpMessage_ = null;
      }
      return streamErrorOnInvalidHttpMessageBuilder_;
    }

    private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions pathNormalizationOptions_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptionsOrBuilder> pathNormalizationOptionsBuilder_;
    /**
     * <pre>
     * [#not-implemented-hide:] Path normalization configuration. This includes
     * configurations for transformations (e.g. RFC 3986 normalization or merge
     * adjacent slashes) and the policy to apply them. The policy determines
     * whether transformations affect the forwarded ``:path`` header. RFC 3986 path
     * normalization is enabled by default and the default policy is that the
     * normalized header will be forwarded. See :ref:`PathNormalizationOptions
     * &lt;envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.PathNormalizationOptions&gt;`
     * for details.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions path_normalization_options = 43;</code>
     * @return Whether the pathNormalizationOptions field is set.
     */
    public boolean hasPathNormalizationOptions() {
      return ((bitField1_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Path normalization configuration. This includes
     * configurations for transformations (e.g. RFC 3986 normalization or merge
     * adjacent slashes) and the policy to apply them. The policy determines
     * whether transformations affect the forwarded ``:path`` header. RFC 3986 path
     * normalization is enabled by default and the default policy is that the
     * normalized header will be forwarded. See :ref:`PathNormalizationOptions
     * &lt;envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.PathNormalizationOptions&gt;`
     * for details.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions path_normalization_options = 43;</code>
     * @return The pathNormalizationOptions.
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions getPathNormalizationOptions() {
      if (pathNormalizationOptionsBuilder_ == null) {
        return pathNormalizationOptions_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions.getDefaultInstance() : pathNormalizationOptions_;
      } else {
        return pathNormalizationOptionsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Path normalization configuration. This includes
     * configurations for transformations (e.g. RFC 3986 normalization or merge
     * adjacent slashes) and the policy to apply them. The policy determines
     * whether transformations affect the forwarded ``:path`` header. RFC 3986 path
     * normalization is enabled by default and the default policy is that the
     * normalized header will be forwarded. See :ref:`PathNormalizationOptions
     * &lt;envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.PathNormalizationOptions&gt;`
     * for details.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions path_normalization_options = 43;</code>
     */
    public Builder setPathNormalizationOptions(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions value) {
      if (pathNormalizationOptionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        pathNormalizationOptions_ = value;
      } else {
        pathNormalizationOptionsBuilder_.setMessage(value);
      }
      bitField1_ |= 0x00002000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Path normalization configuration. This includes
     * configurations for transformations (e.g. RFC 3986 normalization or merge
     * adjacent slashes) and the policy to apply them. The policy determines
     * whether transformations affect the forwarded ``:path`` header. RFC 3986 path
     * normalization is enabled by default and the default policy is that the
     * normalized header will be forwarded. See :ref:`PathNormalizationOptions
     * &lt;envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.PathNormalizationOptions&gt;`
     * for details.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions path_normalization_options = 43;</code>
     */
    public Builder setPathNormalizationOptions(
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions.Builder builderForValue) {
      if (pathNormalizationOptionsBuilder_ == null) {
        pathNormalizationOptions_ = builderForValue.build();
      } else {
        pathNormalizationOptionsBuilder_.setMessage(builderForValue.build());
      }
      bitField1_ |= 0x00002000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Path normalization configuration. This includes
     * configurations for transformations (e.g. RFC 3986 normalization or merge
     * adjacent slashes) and the policy to apply them. The policy determines
     * whether transformations affect the forwarded ``:path`` header. RFC 3986 path
     * normalization is enabled by default and the default policy is that the
     * normalized header will be forwarded. See :ref:`PathNormalizationOptions
     * &lt;envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.PathNormalizationOptions&gt;`
     * for details.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions path_normalization_options = 43;</code>
     */
    public Builder mergePathNormalizationOptions(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions value) {
      if (pathNormalizationOptionsBuilder_ == null) {
        if (((bitField1_ & 0x00002000) != 0) &&
          pathNormalizationOptions_ != null &&
          pathNormalizationOptions_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions.getDefaultInstance()) {
          getPathNormalizationOptionsBuilder().mergeFrom(value);
        } else {
          pathNormalizationOptions_ = value;
        }
      } else {
        pathNormalizationOptionsBuilder_.mergeFrom(value);
      }
      bitField1_ |= 0x00002000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Path normalization configuration. This includes
     * configurations for transformations (e.g. RFC 3986 normalization or merge
     * adjacent slashes) and the policy to apply them. The policy determines
     * whether transformations affect the forwarded ``:path`` header. RFC 3986 path
     * normalization is enabled by default and the default policy is that the
     * normalized header will be forwarded. See :ref:`PathNormalizationOptions
     * &lt;envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.PathNormalizationOptions&gt;`
     * for details.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions path_normalization_options = 43;</code>
     */
    public Builder clearPathNormalizationOptions() {
      bitField1_ = (bitField1_ & ~0x00002000);
      pathNormalizationOptions_ = null;
      if (pathNormalizationOptionsBuilder_ != null) {
        pathNormalizationOptionsBuilder_.dispose();
        pathNormalizationOptionsBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Path normalization configuration. This includes
     * configurations for transformations (e.g. RFC 3986 normalization or merge
     * adjacent slashes) and the policy to apply them. The policy determines
     * whether transformations affect the forwarded ``:path`` header. RFC 3986 path
     * normalization is enabled by default and the default policy is that the
     * normalized header will be forwarded. See :ref:`PathNormalizationOptions
     * &lt;envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.PathNormalizationOptions&gt;`
     * for details.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions path_normalization_options = 43;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions.Builder getPathNormalizationOptionsBuilder() {
      bitField1_ |= 0x00002000;
      onChanged();
      return getPathNormalizationOptionsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Path normalization configuration. This includes
     * configurations for transformations (e.g. RFC 3986 normalization or merge
     * adjacent slashes) and the policy to apply them. The policy determines
     * whether transformations affect the forwarded ``:path`` header. RFC 3986 path
     * normalization is enabled by default and the default policy is that the
     * normalized header will be forwarded. See :ref:`PathNormalizationOptions
     * &lt;envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.PathNormalizationOptions&gt;`
     * for details.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions path_normalization_options = 43;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptionsOrBuilder getPathNormalizationOptionsOrBuilder() {
      if (pathNormalizationOptionsBuilder_ != null) {
        return pathNormalizationOptionsBuilder_.getMessageOrBuilder();
      } else {
        return pathNormalizationOptions_ == null ?
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions.getDefaultInstance() : pathNormalizationOptions_;
      }
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Path normalization configuration. This includes
     * configurations for transformations (e.g. RFC 3986 normalization or merge
     * adjacent slashes) and the policy to apply them. The policy determines
     * whether transformations affect the forwarded ``:path`` header. RFC 3986 path
     * normalization is enabled by default and the default policy is that the
     * normalized header will be forwarded. See :ref:`PathNormalizationOptions
     * &lt;envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.PathNormalizationOptions&gt;`
     * for details.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions path_normalization_options = 43;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptionsOrBuilder> 
        getPathNormalizationOptionsFieldBuilder() {
      if (pathNormalizationOptionsBuilder_ == null) {
        pathNormalizationOptionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptionsOrBuilder>(
                getPathNormalizationOptions(),
                getParentForChildren(),
                isClean());
        pathNormalizationOptions_ = null;
      }
      return pathNormalizationOptionsBuilder_;
    }

    private boolean stripTrailingHostDot_ ;
    /**
     * <pre>
     * Determines if trailing dot of the host should be removed from host/authority header before any
     * processing of request by HTTP filters or routing.
     * This affects the upstream host header.
     * Without setting this option, incoming requests with host ``example.com.`` will not match against
     * route with :ref:`domains&lt;envoy_v3_api_field_config.route.v3.VirtualHost.domains&gt;` match set to ``example.com``. Defaults to ``false``.
     * When the incoming request contains a host/authority header that includes a port number,
     * setting this option will strip a trailing dot, if present, from the host section,
     * leaving the port as is (e.g. host value ``example.com.:443`` will be updated to ``example.com:443``).
     * </pre>
     *
     * <code>bool strip_trailing_host_dot = 47;</code>
     * @return The stripTrailingHostDot.
     */
    @java.lang.Override
    public boolean getStripTrailingHostDot() {
      return stripTrailingHostDot_;
    }
    /**
     * <pre>
     * Determines if trailing dot of the host should be removed from host/authority header before any
     * processing of request by HTTP filters or routing.
     * This affects the upstream host header.
     * Without setting this option, incoming requests with host ``example.com.`` will not match against
     * route with :ref:`domains&lt;envoy_v3_api_field_config.route.v3.VirtualHost.domains&gt;` match set to ``example.com``. Defaults to ``false``.
     * When the incoming request contains a host/authority header that includes a port number,
     * setting this option will strip a trailing dot, if present, from the host section,
     * leaving the port as is (e.g. host value ``example.com.:443`` will be updated to ``example.com:443``).
     * </pre>
     *
     * <code>bool strip_trailing_host_dot = 47;</code>
     * @param value The stripTrailingHostDot to set.
     * @return This builder for chaining.
     */
    public Builder setStripTrailingHostDot(boolean value) {
      
      stripTrailingHostDot_ = value;
      bitField1_ |= 0x00004000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Determines if trailing dot of the host should be removed from host/authority header before any
     * processing of request by HTTP filters or routing.
     * This affects the upstream host header.
     * Without setting this option, incoming requests with host ``example.com.`` will not match against
     * route with :ref:`domains&lt;envoy_v3_api_field_config.route.v3.VirtualHost.domains&gt;` match set to ``example.com``. Defaults to ``false``.
     * When the incoming request contains a host/authority header that includes a port number,
     * setting this option will strip a trailing dot, if present, from the host section,
     * leaving the port as is (e.g. host value ``example.com.:443`` will be updated to ``example.com:443``).
     * </pre>
     *
     * <code>bool strip_trailing_host_dot = 47;</code>
     * @return This builder for chaining.
     */
    public Builder clearStripTrailingHostDot() {
      bitField1_ = (bitField1_ & ~0x00004000);
      stripTrailingHostDot_ = false;
      onChanged();
      return this;
    }

    private io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig proxyStatusConfig_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfigOrBuilder> proxyStatusConfigBuilder_;
    /**
     * <pre>
     * Proxy-Status HTTP response header configuration.
     * If this config is set, the Proxy-Status HTTP response header field is
     * populated. By default, it is not.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig proxy_status_config = 49;</code>
     * @return Whether the proxyStatusConfig field is set.
     */
    public boolean hasProxyStatusConfig() {
      return ((bitField1_ & 0x00008000) != 0);
    }
    /**
     * <pre>
     * Proxy-Status HTTP response header configuration.
     * If this config is set, the Proxy-Status HTTP response header field is
     * populated. By default, it is not.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig proxy_status_config = 49;</code>
     * @return The proxyStatusConfig.
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig getProxyStatusConfig() {
      if (proxyStatusConfigBuilder_ == null) {
        return proxyStatusConfig_ == null ? io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig.getDefaultInstance() : proxyStatusConfig_;
      } else {
        return proxyStatusConfigBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Proxy-Status HTTP response header configuration.
     * If this config is set, the Proxy-Status HTTP response header field is
     * populated. By default, it is not.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig proxy_status_config = 49;</code>
     */
    public Builder setProxyStatusConfig(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig value) {
      if (proxyStatusConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        proxyStatusConfig_ = value;
      } else {
        proxyStatusConfigBuilder_.setMessage(value);
      }
      bitField1_ |= 0x00008000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Proxy-Status HTTP response header configuration.
     * If this config is set, the Proxy-Status HTTP response header field is
     * populated. By default, it is not.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig proxy_status_config = 49;</code>
     */
    public Builder setProxyStatusConfig(
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig.Builder builderForValue) {
      if (proxyStatusConfigBuilder_ == null) {
        proxyStatusConfig_ = builderForValue.build();
      } else {
        proxyStatusConfigBuilder_.setMessage(builderForValue.build());
      }
      bitField1_ |= 0x00008000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Proxy-Status HTTP response header configuration.
     * If this config is set, the Proxy-Status HTTP response header field is
     * populated. By default, it is not.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig proxy_status_config = 49;</code>
     */
    public Builder mergeProxyStatusConfig(io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig value) {
      if (proxyStatusConfigBuilder_ == null) {
        if (((bitField1_ & 0x00008000) != 0) &&
          proxyStatusConfig_ != null &&
          proxyStatusConfig_ != io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig.getDefaultInstance()) {
          getProxyStatusConfigBuilder().mergeFrom(value);
        } else {
          proxyStatusConfig_ = value;
        }
      } else {
        proxyStatusConfigBuilder_.mergeFrom(value);
      }
      bitField1_ |= 0x00008000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Proxy-Status HTTP response header configuration.
     * If this config is set, the Proxy-Status HTTP response header field is
     * populated. By default, it is not.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig proxy_status_config = 49;</code>
     */
    public Builder clearProxyStatusConfig() {
      bitField1_ = (bitField1_ & ~0x00008000);
      proxyStatusConfig_ = null;
      if (proxyStatusConfigBuilder_ != null) {
        proxyStatusConfigBuilder_.dispose();
        proxyStatusConfigBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Proxy-Status HTTP response header configuration.
     * If this config is set, the Proxy-Status HTTP response header field is
     * populated. By default, it is not.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig proxy_status_config = 49;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig.Builder getProxyStatusConfigBuilder() {
      bitField1_ |= 0x00008000;
      onChanged();
      return getProxyStatusConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Proxy-Status HTTP response header configuration.
     * If this config is set, the Proxy-Status HTTP response header field is
     * populated. By default, it is not.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig proxy_status_config = 49;</code>
     */
    public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfigOrBuilder getProxyStatusConfigOrBuilder() {
      if (proxyStatusConfigBuilder_ != null) {
        return proxyStatusConfigBuilder_.getMessageOrBuilder();
      } else {
        return proxyStatusConfig_ == null ?
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig.getDefaultInstance() : proxyStatusConfig_;
      }
    }
    /**
     * <pre>
     * Proxy-Status HTTP response header configuration.
     * If this config is set, the Proxy-Status HTTP response header field is
     * populated. By default, it is not.
     * </pre>
     *
     * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig proxy_status_config = 49;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfigOrBuilder> 
        getProxyStatusConfigFieldBuilder() {
      if (proxyStatusConfigBuilder_ == null) {
        proxyStatusConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig.Builder, io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfigOrBuilder>(
                getProxyStatusConfig(),
                getParentForChildren(),
                isClean());
        proxyStatusConfig_ = null;
      }
      return proxyStatusConfigBuilder_;
    }

    private io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig typedHeaderValidationConfig_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder> typedHeaderValidationConfigBuilder_;
    /**
     * <pre>
     * Configuration options for Header Validation (UHV).
     * UHV is an extensible mechanism for checking validity of HTTP requests as well as providing
     * normalization for request attributes, such as URI path.
     * If the typed_header_validation_config is present it overrides the following options:
     * ``normalize_path``, ``merge_slashes``, ``path_with_escaped_slashes_action``
     * ``http_protocol_options.allow_chunked_length``, ``common_http_protocol_options.headers_with_underscores_action``.
     * The default UHV checks the following:
     * #. HTTP/1 header map validity according to `RFC 7230 section 3.2&lt;https://datatracker.ietf.org/doc/html/rfc7230#section-3.2&gt;`_
     * #. Syntax of HTTP/1 request target URI and response status
     * #. HTTP/2 header map validity according to `RFC 7540 section 8.1.2&lt;https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2`_
     * #. Syntax of HTTP/2 pseudo headers
     * #. HTTP/3 header map validity according to `RFC 9114 section 4.3 &lt;https://www.rfc-editor.org/rfc/rfc9114.html&gt;`_
     * #. Syntax of HTTP/3 pseudo headers
     * #. Syntax of ``Content-Length`` and ``Transfer-Encoding``
     * #. Validation of HTTP/1 requests with both ``Content-Length`` and ``Transfer-Encoding`` headers
     * #. Normalization of the URI path according to `Normalization and Comparison &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6&gt;`_
     *    without `case normalization &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1&gt;`_
     * [#not-implemented-hide:]
     * [#extension-category: envoy.http.header_validators]
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig typed_header_validation_config = 50;</code>
     * @return Whether the typedHeaderValidationConfig field is set.
     */
    public boolean hasTypedHeaderValidationConfig() {
      return ((bitField1_ & 0x00010000) != 0);
    }
    /**
     * <pre>
     * Configuration options for Header Validation (UHV).
     * UHV is an extensible mechanism for checking validity of HTTP requests as well as providing
     * normalization for request attributes, such as URI path.
     * If the typed_header_validation_config is present it overrides the following options:
     * ``normalize_path``, ``merge_slashes``, ``path_with_escaped_slashes_action``
     * ``http_protocol_options.allow_chunked_length``, ``common_http_protocol_options.headers_with_underscores_action``.
     * The default UHV checks the following:
     * #. HTTP/1 header map validity according to `RFC 7230 section 3.2&lt;https://datatracker.ietf.org/doc/html/rfc7230#section-3.2&gt;`_
     * #. Syntax of HTTP/1 request target URI and response status
     * #. HTTP/2 header map validity according to `RFC 7540 section 8.1.2&lt;https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2`_
     * #. Syntax of HTTP/2 pseudo headers
     * #. HTTP/3 header map validity according to `RFC 9114 section 4.3 &lt;https://www.rfc-editor.org/rfc/rfc9114.html&gt;`_
     * #. Syntax of HTTP/3 pseudo headers
     * #. Syntax of ``Content-Length`` and ``Transfer-Encoding``
     * #. Validation of HTTP/1 requests with both ``Content-Length`` and ``Transfer-Encoding`` headers
     * #. Normalization of the URI path according to `Normalization and Comparison &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6&gt;`_
     *    without `case normalization &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1&gt;`_
     * [#not-implemented-hide:]
     * [#extension-category: envoy.http.header_validators]
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig typed_header_validation_config = 50;</code>
     * @return The typedHeaderValidationConfig.
     */
    public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig getTypedHeaderValidationConfig() {
      if (typedHeaderValidationConfigBuilder_ == null) {
        return typedHeaderValidationConfig_ == null ? io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.getDefaultInstance() : typedHeaderValidationConfig_;
      } else {
        return typedHeaderValidationConfigBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Configuration options for Header Validation (UHV).
     * UHV is an extensible mechanism for checking validity of HTTP requests as well as providing
     * normalization for request attributes, such as URI path.
     * If the typed_header_validation_config is present it overrides the following options:
     * ``normalize_path``, ``merge_slashes``, ``path_with_escaped_slashes_action``
     * ``http_protocol_options.allow_chunked_length``, ``common_http_protocol_options.headers_with_underscores_action``.
     * The default UHV checks the following:
     * #. HTTP/1 header map validity according to `RFC 7230 section 3.2&lt;https://datatracker.ietf.org/doc/html/rfc7230#section-3.2&gt;`_
     * #. Syntax of HTTP/1 request target URI and response status
     * #. HTTP/2 header map validity according to `RFC 7540 section 8.1.2&lt;https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2`_
     * #. Syntax of HTTP/2 pseudo headers
     * #. HTTP/3 header map validity according to `RFC 9114 section 4.3 &lt;https://www.rfc-editor.org/rfc/rfc9114.html&gt;`_
     * #. Syntax of HTTP/3 pseudo headers
     * #. Syntax of ``Content-Length`` and ``Transfer-Encoding``
     * #. Validation of HTTP/1 requests with both ``Content-Length`` and ``Transfer-Encoding`` headers
     * #. Normalization of the URI path according to `Normalization and Comparison &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6&gt;`_
     *    without `case normalization &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1&gt;`_
     * [#not-implemented-hide:]
     * [#extension-category: envoy.http.header_validators]
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig typed_header_validation_config = 50;</code>
     */
    public Builder setTypedHeaderValidationConfig(io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig value) {
      if (typedHeaderValidationConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        typedHeaderValidationConfig_ = value;
      } else {
        typedHeaderValidationConfigBuilder_.setMessage(value);
      }
      bitField1_ |= 0x00010000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Configuration options for Header Validation (UHV).
     * UHV is an extensible mechanism for checking validity of HTTP requests as well as providing
     * normalization for request attributes, such as URI path.
     * If the typed_header_validation_config is present it overrides the following options:
     * ``normalize_path``, ``merge_slashes``, ``path_with_escaped_slashes_action``
     * ``http_protocol_options.allow_chunked_length``, ``common_http_protocol_options.headers_with_underscores_action``.
     * The default UHV checks the following:
     * #. HTTP/1 header map validity according to `RFC 7230 section 3.2&lt;https://datatracker.ietf.org/doc/html/rfc7230#section-3.2&gt;`_
     * #. Syntax of HTTP/1 request target URI and response status
     * #. HTTP/2 header map validity according to `RFC 7540 section 8.1.2&lt;https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2`_
     * #. Syntax of HTTP/2 pseudo headers
     * #. HTTP/3 header map validity according to `RFC 9114 section 4.3 &lt;https://www.rfc-editor.org/rfc/rfc9114.html&gt;`_
     * #. Syntax of HTTP/3 pseudo headers
     * #. Syntax of ``Content-Length`` and ``Transfer-Encoding``
     * #. Validation of HTTP/1 requests with both ``Content-Length`` and ``Transfer-Encoding`` headers
     * #. Normalization of the URI path according to `Normalization and Comparison &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6&gt;`_
     *    without `case normalization &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1&gt;`_
     * [#not-implemented-hide:]
     * [#extension-category: envoy.http.header_validators]
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig typed_header_validation_config = 50;</code>
     */
    public Builder setTypedHeaderValidationConfig(
        io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder builderForValue) {
      if (typedHeaderValidationConfigBuilder_ == null) {
        typedHeaderValidationConfig_ = builderForValue.build();
      } else {
        typedHeaderValidationConfigBuilder_.setMessage(builderForValue.build());
      }
      bitField1_ |= 0x00010000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Configuration options for Header Validation (UHV).
     * UHV is an extensible mechanism for checking validity of HTTP requests as well as providing
     * normalization for request attributes, such as URI path.
     * If the typed_header_validation_config is present it overrides the following options:
     * ``normalize_path``, ``merge_slashes``, ``path_with_escaped_slashes_action``
     * ``http_protocol_options.allow_chunked_length``, ``common_http_protocol_options.headers_with_underscores_action``.
     * The default UHV checks the following:
     * #. HTTP/1 header map validity according to `RFC 7230 section 3.2&lt;https://datatracker.ietf.org/doc/html/rfc7230#section-3.2&gt;`_
     * #. Syntax of HTTP/1 request target URI and response status
     * #. HTTP/2 header map validity according to `RFC 7540 section 8.1.2&lt;https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2`_
     * #. Syntax of HTTP/2 pseudo headers
     * #. HTTP/3 header map validity according to `RFC 9114 section 4.3 &lt;https://www.rfc-editor.org/rfc/rfc9114.html&gt;`_
     * #. Syntax of HTTP/3 pseudo headers
     * #. Syntax of ``Content-Length`` and ``Transfer-Encoding``
     * #. Validation of HTTP/1 requests with both ``Content-Length`` and ``Transfer-Encoding`` headers
     * #. Normalization of the URI path according to `Normalization and Comparison &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6&gt;`_
     *    without `case normalization &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1&gt;`_
     * [#not-implemented-hide:]
     * [#extension-category: envoy.http.header_validators]
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig typed_header_validation_config = 50;</code>
     */
    public Builder mergeTypedHeaderValidationConfig(io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig value) {
      if (typedHeaderValidationConfigBuilder_ == null) {
        if (((bitField1_ & 0x00010000) != 0) &&
          typedHeaderValidationConfig_ != null &&
          typedHeaderValidationConfig_ != io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.getDefaultInstance()) {
          getTypedHeaderValidationConfigBuilder().mergeFrom(value);
        } else {
          typedHeaderValidationConfig_ = value;
        }
      } else {
        typedHeaderValidationConfigBuilder_.mergeFrom(value);
      }
      bitField1_ |= 0x00010000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Configuration options for Header Validation (UHV).
     * UHV is an extensible mechanism for checking validity of HTTP requests as well as providing
     * normalization for request attributes, such as URI path.
     * If the typed_header_validation_config is present it overrides the following options:
     * ``normalize_path``, ``merge_slashes``, ``path_with_escaped_slashes_action``
     * ``http_protocol_options.allow_chunked_length``, ``common_http_protocol_options.headers_with_underscores_action``.
     * The default UHV checks the following:
     * #. HTTP/1 header map validity according to `RFC 7230 section 3.2&lt;https://datatracker.ietf.org/doc/html/rfc7230#section-3.2&gt;`_
     * #. Syntax of HTTP/1 request target URI and response status
     * #. HTTP/2 header map validity according to `RFC 7540 section 8.1.2&lt;https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2`_
     * #. Syntax of HTTP/2 pseudo headers
     * #. HTTP/3 header map validity according to `RFC 9114 section 4.3 &lt;https://www.rfc-editor.org/rfc/rfc9114.html&gt;`_
     * #. Syntax of HTTP/3 pseudo headers
     * #. Syntax of ``Content-Length`` and ``Transfer-Encoding``
     * #. Validation of HTTP/1 requests with both ``Content-Length`` and ``Transfer-Encoding`` headers
     * #. Normalization of the URI path according to `Normalization and Comparison &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6&gt;`_
     *    without `case normalization &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1&gt;`_
     * [#not-implemented-hide:]
     * [#extension-category: envoy.http.header_validators]
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig typed_header_validation_config = 50;</code>
     */
    public Builder clearTypedHeaderValidationConfig() {
      bitField1_ = (bitField1_ & ~0x00010000);
      typedHeaderValidationConfig_ = null;
      if (typedHeaderValidationConfigBuilder_ != null) {
        typedHeaderValidationConfigBuilder_.dispose();
        typedHeaderValidationConfigBuilder_ = null;
      }
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Configuration options for Header Validation (UHV).
     * UHV is an extensible mechanism for checking validity of HTTP requests as well as providing
     * normalization for request attributes, such as URI path.
     * If the typed_header_validation_config is present it overrides the following options:
     * ``normalize_path``, ``merge_slashes``, ``path_with_escaped_slashes_action``
     * ``http_protocol_options.allow_chunked_length``, ``common_http_protocol_options.headers_with_underscores_action``.
     * The default UHV checks the following:
     * #. HTTP/1 header map validity according to `RFC 7230 section 3.2&lt;https://datatracker.ietf.org/doc/html/rfc7230#section-3.2&gt;`_
     * #. Syntax of HTTP/1 request target URI and response status
     * #. HTTP/2 header map validity according to `RFC 7540 section 8.1.2&lt;https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2`_
     * #. Syntax of HTTP/2 pseudo headers
     * #. HTTP/3 header map validity according to `RFC 9114 section 4.3 &lt;https://www.rfc-editor.org/rfc/rfc9114.html&gt;`_
     * #. Syntax of HTTP/3 pseudo headers
     * #. Syntax of ``Content-Length`` and ``Transfer-Encoding``
     * #. Validation of HTTP/1 requests with both ``Content-Length`` and ``Transfer-Encoding`` headers
     * #. Normalization of the URI path according to `Normalization and Comparison &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6&gt;`_
     *    without `case normalization &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1&gt;`_
     * [#not-implemented-hide:]
     * [#extension-category: envoy.http.header_validators]
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig typed_header_validation_config = 50;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder getTypedHeaderValidationConfigBuilder() {
      bitField1_ |= 0x00010000;
      onChanged();
      return getTypedHeaderValidationConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Configuration options for Header Validation (UHV).
     * UHV is an extensible mechanism for checking validity of HTTP requests as well as providing
     * normalization for request attributes, such as URI path.
     * If the typed_header_validation_config is present it overrides the following options:
     * ``normalize_path``, ``merge_slashes``, ``path_with_escaped_slashes_action``
     * ``http_protocol_options.allow_chunked_length``, ``common_http_protocol_options.headers_with_underscores_action``.
     * The default UHV checks the following:
     * #. HTTP/1 header map validity according to `RFC 7230 section 3.2&lt;https://datatracker.ietf.org/doc/html/rfc7230#section-3.2&gt;`_
     * #. Syntax of HTTP/1 request target URI and response status
     * #. HTTP/2 header map validity according to `RFC 7540 section 8.1.2&lt;https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2`_
     * #. Syntax of HTTP/2 pseudo headers
     * #. HTTP/3 header map validity according to `RFC 9114 section 4.3 &lt;https://www.rfc-editor.org/rfc/rfc9114.html&gt;`_
     * #. Syntax of HTTP/3 pseudo headers
     * #. Syntax of ``Content-Length`` and ``Transfer-Encoding``
     * #. Validation of HTTP/1 requests with both ``Content-Length`` and ``Transfer-Encoding`` headers
     * #. Normalization of the URI path according to `Normalization and Comparison &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6&gt;`_
     *    without `case normalization &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1&gt;`_
     * [#not-implemented-hide:]
     * [#extension-category: envoy.http.header_validators]
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig typed_header_validation_config = 50;</code>
     */
    public io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder getTypedHeaderValidationConfigOrBuilder() {
      if (typedHeaderValidationConfigBuilder_ != null) {
        return typedHeaderValidationConfigBuilder_.getMessageOrBuilder();
      } else {
        return typedHeaderValidationConfig_ == null ?
            io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.getDefaultInstance() : typedHeaderValidationConfig_;
      }
    }
    /**
     * <pre>
     * Configuration options for Header Validation (UHV).
     * UHV is an extensible mechanism for checking validity of HTTP requests as well as providing
     * normalization for request attributes, such as URI path.
     * If the typed_header_validation_config is present it overrides the following options:
     * ``normalize_path``, ``merge_slashes``, ``path_with_escaped_slashes_action``
     * ``http_protocol_options.allow_chunked_length``, ``common_http_protocol_options.headers_with_underscores_action``.
     * The default UHV checks the following:
     * #. HTTP/1 header map validity according to `RFC 7230 section 3.2&lt;https://datatracker.ietf.org/doc/html/rfc7230#section-3.2&gt;`_
     * #. Syntax of HTTP/1 request target URI and response status
     * #. HTTP/2 header map validity according to `RFC 7540 section 8.1.2&lt;https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2`_
     * #. Syntax of HTTP/2 pseudo headers
     * #. HTTP/3 header map validity according to `RFC 9114 section 4.3 &lt;https://www.rfc-editor.org/rfc/rfc9114.html&gt;`_
     * #. Syntax of HTTP/3 pseudo headers
     * #. Syntax of ``Content-Length`` and ``Transfer-Encoding``
     * #. Validation of HTTP/1 requests with both ``Content-Length`` and ``Transfer-Encoding`` headers
     * #. Normalization of the URI path according to `Normalization and Comparison &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6&gt;`_
     *    without `case normalization &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1&gt;`_
     * [#not-implemented-hide:]
     * [#extension-category: envoy.http.header_validators]
     * </pre>
     *
     * <code>.envoy.config.core.v3.TypedExtensionConfig typed_header_validation_config = 50;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder> 
        getTypedHeaderValidationConfigFieldBuilder() {
      if (typedHeaderValidationConfigBuilder_ == null) {
        typedHeaderValidationConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig.Builder, io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder>(
                getTypedHeaderValidationConfig(),
                getParentForChildren(),
                isClean());
        typedHeaderValidationConfig_ = null;
      }
      return typedHeaderValidationConfigBuilder_;
    }

    private boolean appendXForwardedPort_ ;
    /**
     * <pre>
     * Append the `x-forwarded-port` header with the port value client used to connect to Envoy. It
     * will be ignored if the `x-forwarded-port` header has been set by any trusted proxy in front of Envoy.
     * </pre>
     *
     * <code>bool append_x_forwarded_port = 51;</code>
     * @return The appendXForwardedPort.
     */
    @java.lang.Override
    public boolean getAppendXForwardedPort() {
      return appendXForwardedPort_;
    }
    /**
     * <pre>
     * Append the `x-forwarded-port` header with the port value client used to connect to Envoy. It
     * will be ignored if the `x-forwarded-port` header has been set by any trusted proxy in front of Envoy.
     * </pre>
     *
     * <code>bool append_x_forwarded_port = 51;</code>
     * @param value The appendXForwardedPort to set.
     * @return This builder for chaining.
     */
    public Builder setAppendXForwardedPort(boolean value) {
      
      appendXForwardedPort_ = value;
      bitField1_ |= 0x00020000;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Append the `x-forwarded-port` header with the port value client used to connect to Envoy. It
     * will be ignored if the `x-forwarded-port` header has been set by any trusted proxy in front of Envoy.
     * </pre>
     *
     * <code>bool append_x_forwarded_port = 51;</code>
     * @return This builder for chaining.
     */
    public Builder clearAppendXForwardedPort() {
      bitField1_ = (bitField1_ & ~0x00020000);
      appendXForwardedPort_ = false;
      onChanged();
      return this;
    }
    @java.lang.Override
    public final Builder setUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }


    // @@protoc_insertion_point(builder_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager)
  }

  // @@protoc_insertion_point(class_scope:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager)
  private static final io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager();
  }

  public static io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<HttpConnectionManager>
      PARSER = new com.google.protobuf.AbstractParser<HttpConnectionManager>() {
    @java.lang.Override
    public HttpConnectionManager parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      Builder builder = newBuilder();
      try {
        builder.mergeFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(builder.buildPartial());
      } catch (com.google.protobuf.UninitializedMessageException e) {
        throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(e)
            .setUnfinishedMessage(builder.buildPartial());
      }
      return builder.buildPartial();
    }
  };

  public static com.google.protobuf.Parser<HttpConnectionManager> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<HttpConnectionManager> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}

