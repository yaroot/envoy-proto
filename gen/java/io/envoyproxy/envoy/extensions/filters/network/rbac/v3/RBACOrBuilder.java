// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/extensions/filters/network/rbac/v3/rbac.proto

package io.envoyproxy.envoy.extensions.filters.network.rbac.v3;

public interface RBACOrBuilder extends
    // @@protoc_insertion_point(interface_extends:envoy.extensions.filters.network.rbac.v3.RBAC)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * Specify the RBAC rules to be applied globally.
   * If absent, no enforcing RBAC policy will be applied.
   * If present and empty, DENY.
   * If both rules and matcher are configured, rules will be ignored.
   * </pre>
   *
   * <code>.envoy.config.rbac.v3.RBAC rules = 1 [(.udpa.annotations.field_migrate) = { ... }</code>
   * @return Whether the rules field is set.
   */
  boolean hasRules();
  /**
   * <pre>
   * Specify the RBAC rules to be applied globally.
   * If absent, no enforcing RBAC policy will be applied.
   * If present and empty, DENY.
   * If both rules and matcher are configured, rules will be ignored.
   * </pre>
   *
   * <code>.envoy.config.rbac.v3.RBAC rules = 1 [(.udpa.annotations.field_migrate) = { ... }</code>
   * @return The rules.
   */
  io.envoyproxy.envoy.config.rbac.v3.RBAC getRules();
  /**
   * <pre>
   * Specify the RBAC rules to be applied globally.
   * If absent, no enforcing RBAC policy will be applied.
   * If present and empty, DENY.
   * If both rules and matcher are configured, rules will be ignored.
   * </pre>
   *
   * <code>.envoy.config.rbac.v3.RBAC rules = 1 [(.udpa.annotations.field_migrate) = { ... }</code>
   */
  io.envoyproxy.envoy.config.rbac.v3.RBACOrBuilder getRulesOrBuilder();

  /**
   * <pre>
   * The match tree to use when resolving RBAC action for incoming connections. Connections do
   * not match any matcher will be denied.
   * If absent, no enforcing RBAC matcher will be applied.
   * If present and empty, deny all connections.
   * </pre>
   *
   * <code>.xds.type.matcher.v3.Matcher matcher = 6 [(.udpa.annotations.field_migrate) = { ... }</code>
   * @return Whether the matcher field is set.
   */
  boolean hasMatcher();
  /**
   * <pre>
   * The match tree to use when resolving RBAC action for incoming connections. Connections do
   * not match any matcher will be denied.
   * If absent, no enforcing RBAC matcher will be applied.
   * If present and empty, deny all connections.
   * </pre>
   *
   * <code>.xds.type.matcher.v3.Matcher matcher = 6 [(.udpa.annotations.field_migrate) = { ... }</code>
   * @return The matcher.
   */
  com.github.xds.type.matcher.v3.Matcher getMatcher();
  /**
   * <pre>
   * The match tree to use when resolving RBAC action for incoming connections. Connections do
   * not match any matcher will be denied.
   * If absent, no enforcing RBAC matcher will be applied.
   * If present and empty, deny all connections.
   * </pre>
   *
   * <code>.xds.type.matcher.v3.Matcher matcher = 6 [(.udpa.annotations.field_migrate) = { ... }</code>
   */
  com.github.xds.type.matcher.v3.MatcherOrBuilder getMatcherOrBuilder();

  /**
   * <pre>
   * Shadow rules are not enforced by the filter but will emit stats and logs
   * and can be used for rule testing.
   * If absent, no shadow RBAC policy will be applied.
   * If both shadow rules and shadow matcher are configured, shadow rules will be ignored.
   * </pre>
   *
   * <code>.envoy.config.rbac.v3.RBAC shadow_rules = 2 [(.udpa.annotations.field_migrate) = { ... }</code>
   * @return Whether the shadowRules field is set.
   */
  boolean hasShadowRules();
  /**
   * <pre>
   * Shadow rules are not enforced by the filter but will emit stats and logs
   * and can be used for rule testing.
   * If absent, no shadow RBAC policy will be applied.
   * If both shadow rules and shadow matcher are configured, shadow rules will be ignored.
   * </pre>
   *
   * <code>.envoy.config.rbac.v3.RBAC shadow_rules = 2 [(.udpa.annotations.field_migrate) = { ... }</code>
   * @return The shadowRules.
   */
  io.envoyproxy.envoy.config.rbac.v3.RBAC getShadowRules();
  /**
   * <pre>
   * Shadow rules are not enforced by the filter but will emit stats and logs
   * and can be used for rule testing.
   * If absent, no shadow RBAC policy will be applied.
   * If both shadow rules and shadow matcher are configured, shadow rules will be ignored.
   * </pre>
   *
   * <code>.envoy.config.rbac.v3.RBAC shadow_rules = 2 [(.udpa.annotations.field_migrate) = { ... }</code>
   */
  io.envoyproxy.envoy.config.rbac.v3.RBACOrBuilder getShadowRulesOrBuilder();

  /**
   * <pre>
   * The match tree to use for emitting stats and logs which can be used for rule testing for
   * incoming connections.
   * If absent, no shadow matcher will be applied.
   * </pre>
   *
   * <code>.xds.type.matcher.v3.Matcher shadow_matcher = 7 [(.udpa.annotations.field_migrate) = { ... }</code>
   * @return Whether the shadowMatcher field is set.
   */
  boolean hasShadowMatcher();
  /**
   * <pre>
   * The match tree to use for emitting stats and logs which can be used for rule testing for
   * incoming connections.
   * If absent, no shadow matcher will be applied.
   * </pre>
   *
   * <code>.xds.type.matcher.v3.Matcher shadow_matcher = 7 [(.udpa.annotations.field_migrate) = { ... }</code>
   * @return The shadowMatcher.
   */
  com.github.xds.type.matcher.v3.Matcher getShadowMatcher();
  /**
   * <pre>
   * The match tree to use for emitting stats and logs which can be used for rule testing for
   * incoming connections.
   * If absent, no shadow matcher will be applied.
   * </pre>
   *
   * <code>.xds.type.matcher.v3.Matcher shadow_matcher = 7 [(.udpa.annotations.field_migrate) = { ... }</code>
   */
  com.github.xds.type.matcher.v3.MatcherOrBuilder getShadowMatcherOrBuilder();

  /**
   * <pre>
   * If specified, shadow rules will emit stats with the given prefix.
   * This is useful to distinguish the stat when there are more than 1 RBAC filter configured with
   * shadow rules.
   * </pre>
   *
   * <code>string shadow_rules_stat_prefix = 5;</code>
   * @return The shadowRulesStatPrefix.
   */
  java.lang.String getShadowRulesStatPrefix();
  /**
   * <pre>
   * If specified, shadow rules will emit stats with the given prefix.
   * This is useful to distinguish the stat when there are more than 1 RBAC filter configured with
   * shadow rules.
   * </pre>
   *
   * <code>string shadow_rules_stat_prefix = 5;</code>
   * @return The bytes for shadowRulesStatPrefix.
   */
  com.google.protobuf.ByteString
      getShadowRulesStatPrefixBytes();

  /**
   * <pre>
   * The prefix to use when emitting statistics.
   * </pre>
   *
   * <code>string stat_prefix = 3 [(.validate.rules) = { ... }</code>
   * @return The statPrefix.
   */
  java.lang.String getStatPrefix();
  /**
   * <pre>
   * The prefix to use when emitting statistics.
   * </pre>
   *
   * <code>string stat_prefix = 3 [(.validate.rules) = { ... }</code>
   * @return The bytes for statPrefix.
   */
  com.google.protobuf.ByteString
      getStatPrefixBytes();

  /**
   * <pre>
   * RBAC enforcement strategy. By default RBAC will be enforced only once
   * when the first byte of data arrives from the downstream. When used in
   * conjunction with filters that emit dynamic metadata after decoding
   * every payload (e.g., Mongo, MySQL, Kafka) set the enforcement type to
   * CONTINUOUS to enforce RBAC policies on every message boundary.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.rbac.v3.RBAC.EnforcementType enforcement_type = 4;</code>
   * @return The enum numeric value on the wire for enforcementType.
   */
  int getEnforcementTypeValue();
  /**
   * <pre>
   * RBAC enforcement strategy. By default RBAC will be enforced only once
   * when the first byte of data arrives from the downstream. When used in
   * conjunction with filters that emit dynamic metadata after decoding
   * every payload (e.g., Mongo, MySQL, Kafka) set the enforcement type to
   * CONTINUOUS to enforce RBAC policies on every message boundary.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.rbac.v3.RBAC.EnforcementType enforcement_type = 4;</code>
   * @return The enforcementType.
   */
  io.envoyproxy.envoy.extensions.filters.network.rbac.v3.RBAC.EnforcementType getEnforcementType();
}
