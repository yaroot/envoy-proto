// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto

package io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3;

public interface HttpConnectionManagerOrBuilder extends
    // @@protoc_insertion_point(interface_extends:envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * Supplies the type of codec that the connection manager should use.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType codec_type = 1 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for codecType.
   */
  int getCodecTypeValue();
  /**
   * <pre>
   * Supplies the type of codec that the connection manager should use.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType codec_type = 1 [(.validate.rules) = { ... }</code>
   * @return The codecType.
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType getCodecType();

  /**
   * <pre>
   * The human readable prefix to use when emitting statistics for the
   * connection manager. See the :ref:`statistics documentation &lt;config_http_conn_man_stats&gt;` for
   * more information.
   * </pre>
   *
   * <code>string stat_prefix = 2 [(.validate.rules) = { ... }</code>
   * @return The statPrefix.
   */
  java.lang.String getStatPrefix();
  /**
   * <pre>
   * The human readable prefix to use when emitting statistics for the
   * connection manager. See the :ref:`statistics documentation &lt;config_http_conn_man_stats&gt;` for
   * more information.
   * </pre>
   *
   * <code>string stat_prefix = 2 [(.validate.rules) = { ... }</code>
   * @return The bytes for statPrefix.
   */
  com.google.protobuf.ByteString
      getStatPrefixBytes();

  /**
   * <pre>
   * The connection manager’s route table will be dynamically loaded via the RDS API.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
   * @return Whether the rds field is set.
   */
  boolean hasRds();
  /**
   * <pre>
   * The connection manager’s route table will be dynamically loaded via the RDS API.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
   * @return The rds.
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds getRds();
  /**
   * <pre>
   * The connection manager’s route table will be dynamically loaded via the RDS API.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;</code>
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RdsOrBuilder getRdsOrBuilder();

  /**
   * <pre>
   * The route table for the connection manager is static and is specified in this property.
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
   * @return Whether the routeConfig field is set.
   */
  boolean hasRouteConfig();
  /**
   * <pre>
   * The route table for the connection manager is static and is specified in this property.
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
   * @return The routeConfig.
   */
  io.envoyproxy.envoy.config.route.v3.RouteConfiguration getRouteConfig();
  /**
   * <pre>
   * The route table for the connection manager is static and is specified in this property.
   * </pre>
   *
   * <code>.envoy.config.route.v3.RouteConfiguration route_config = 4;</code>
   */
  io.envoyproxy.envoy.config.route.v3.RouteConfigurationOrBuilder getRouteConfigOrBuilder();

  /**
   * <pre>
   * A route table will be dynamically assigned to each request based on request attributes
   * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
   * specified in this message.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
   * @return Whether the scopedRoutes field is set.
   */
  boolean hasScopedRoutes();
  /**
   * <pre>
   * A route table will be dynamically assigned to each request based on request attributes
   * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
   * specified in this message.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
   * @return The scopedRoutes.
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes getScopedRoutes();
  /**
   * <pre>
   * A route table will be dynamically assigned to each request based on request attributes
   * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
   * specified in this message.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;</code>
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutesOrBuilder getScopedRoutesOrBuilder();

  /**
   * <pre>
   * A list of individual HTTP filters that make up the filter chain for
   * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
   * as the filters are processed sequentially as request events happen.
   * </pre>
   *
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
   */
  java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter> 
      getHttpFiltersList();
  /**
   * <pre>
   * A list of individual HTTP filters that make up the filter chain for
   * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
   * as the filters are processed sequentially as request events happen.
   * </pre>
   *
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter getHttpFilters(int index);
  /**
   * <pre>
   * A list of individual HTTP filters that make up the filter chain for
   * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
   * as the filters are processed sequentially as request events happen.
   * </pre>
   *
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
   */
  int getHttpFiltersCount();
  /**
   * <pre>
   * A list of individual HTTP filters that make up the filter chain for
   * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
   * as the filters are processed sequentially as request events happen.
   * </pre>
   *
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder> 
      getHttpFiltersOrBuilderList();
  /**
   * <pre>
   * A list of individual HTTP filters that make up the filter chain for
   * requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering&gt;`
   * as the filters are processed sequentially as request events happen.
   * </pre>
   *
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;</code>
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpFilterOrBuilder getHttpFiltersOrBuilder(
      int index);

  /**
   * <pre>
   * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
   * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
   * documentation for more information. Defaults to false.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
   * @return Whether the addUserAgent field is set.
   */
  boolean hasAddUserAgent();
  /**
   * <pre>
   * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
   * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
   * documentation for more information. Defaults to false.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
   * @return The addUserAgent.
   */
  com.google.protobuf.BoolValue getAddUserAgent();
  /**
   * <pre>
   * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
   * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
   * documentation for more information. Defaults to false.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue add_user_agent = 6;</code>
   */
  com.google.protobuf.BoolValueOrBuilder getAddUserAgentOrBuilder();

  /**
   * <pre>
   * Presence of the object defines whether the connection manager
   * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
   * &lt;envoy_v3_api_msg_config.trace.v3.Tracing&gt;`.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
   * @return Whether the tracing field is set.
   */
  boolean hasTracing();
  /**
   * <pre>
   * Presence of the object defines whether the connection manager
   * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
   * &lt;envoy_v3_api_msg_config.trace.v3.Tracing&gt;`.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
   * @return The tracing.
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing getTracing();
  /**
   * <pre>
   * Presence of the object defines whether the connection manager
   * emits :ref:`tracing &lt;arch_overview_tracing&gt;` data to the :ref:`configured tracing provider
   * &lt;envoy_v3_api_msg_config.trace.v3.Tracing&gt;`.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;</code>
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.TracingOrBuilder getTracingOrBuilder();

  /**
   * <pre>
   * Additional settings for HTTP requests handled by the connection manager. These will be
   * applicable to both HTTP1 and HTTP2 requests.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
   * @return Whether the commonHttpProtocolOptions field is set.
   */
  boolean hasCommonHttpProtocolOptions();
  /**
   * <pre>
   * Additional settings for HTTP requests handled by the connection manager. These will be
   * applicable to both HTTP1 and HTTP2 requests.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
   * @return The commonHttpProtocolOptions.
   */
  io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions getCommonHttpProtocolOptions();
  /**
   * <pre>
   * Additional settings for HTTP requests handled by the connection manager. These will be
   * applicable to both HTTP1 and HTTP2 requests.
   * </pre>
   *
   * <code>.envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35 [(.udpa.annotations.security) = { ... }</code>
   */
  io.envoyproxy.envoy.config.core.v3.HttpProtocolOptionsOrBuilder getCommonHttpProtocolOptionsOrBuilder();

  /**
   * <pre>
   * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
   * [#comment:TODO: The following fields are ignored when the
   * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
   * is present:
   * 1. :ref:`allow_chunked_length &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.allow_chunked_length&gt;`]
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
   * @return Whether the httpProtocolOptions field is set.
   */
  boolean hasHttpProtocolOptions();
  /**
   * <pre>
   * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
   * [#comment:TODO: The following fields are ignored when the
   * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
   * is present:
   * 1. :ref:`allow_chunked_length &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.allow_chunked_length&gt;`]
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
   * @return The httpProtocolOptions.
   */
  io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptions getHttpProtocolOptions();
  /**
   * <pre>
   * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
   * [#comment:TODO: The following fields are ignored when the
   * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
   * is present:
   * 1. :ref:`allow_chunked_length &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.allow_chunked_length&gt;`]
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;</code>
   */
  io.envoyproxy.envoy.config.core.v3.Http1ProtocolOptionsOrBuilder getHttpProtocolOptionsOrBuilder();

  /**
   * <pre>
   * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
   * @return Whether the http2ProtocolOptions field is set.
   */
  boolean hasHttp2ProtocolOptions();
  /**
   * <pre>
   * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
   * @return The http2ProtocolOptions.
   */
  io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptions getHttp2ProtocolOptions();
  /**
   * <pre>
   * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9 [(.udpa.annotations.security) = { ... }</code>
   */
  io.envoyproxy.envoy.config.core.v3.Http2ProtocolOptionsOrBuilder getHttp2ProtocolOptionsOrBuilder();

  /**
   * <pre>
   * Additional HTTP/3 settings that are passed directly to the HTTP/3 codec.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 44;</code>
   * @return Whether the http3ProtocolOptions field is set.
   */
  boolean hasHttp3ProtocolOptions();
  /**
   * <pre>
   * Additional HTTP/3 settings that are passed directly to the HTTP/3 codec.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 44;</code>
   * @return The http3ProtocolOptions.
   */
  io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptions getHttp3ProtocolOptions();
  /**
   * <pre>
   * Additional HTTP/3 settings that are passed directly to the HTTP/3 codec.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>.envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 44;</code>
   */
  io.envoyproxy.envoy.config.core.v3.Http3ProtocolOptionsOrBuilder getHttp3ProtocolOptionsOrBuilder();

  /**
   * <pre>
   * An optional override that the connection manager will write to the server
   * header in responses. If not set, the default is ``envoy``.
   * </pre>
   *
   * <code>string server_name = 10 [(.validate.rules) = { ... }</code>
   * @return The serverName.
   */
  java.lang.String getServerName();
  /**
   * <pre>
   * An optional override that the connection manager will write to the server
   * header in responses. If not set, the default is ``envoy``.
   * </pre>
   *
   * <code>string server_name = 10 [(.validate.rules) = { ... }</code>
   * @return The bytes for serverName.
   */
  com.google.protobuf.ByteString
      getServerNameBytes();

  /**
   * <pre>
   * Defines the action to be applied to the Server header on the response path.
   * By default, Envoy will overwrite the header with the value specified in
   * server_name.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation server_header_transformation = 34 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for serverHeaderTransformation.
   */
  int getServerHeaderTransformationValue();
  /**
   * <pre>
   * Defines the action to be applied to the Server header on the response path.
   * By default, Envoy will overwrite the header with the value specified in
   * server_name.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation server_header_transformation = 34 [(.validate.rules) = { ... }</code>
   * @return The serverHeaderTransformation.
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation getServerHeaderTransformation();

  /**
   * <pre>
   * Allows for explicit transformation of the :scheme header on the request path.
   * If not set, Envoy's default :ref:`scheme  &lt;config_http_conn_man_headers_scheme&gt;`
   * handling applies.
   * </pre>
   *
   * <code>.envoy.config.core.v3.SchemeHeaderTransformation scheme_header_transformation = 48;</code>
   * @return Whether the schemeHeaderTransformation field is set.
   */
  boolean hasSchemeHeaderTransformation();
  /**
   * <pre>
   * Allows for explicit transformation of the :scheme header on the request path.
   * If not set, Envoy's default :ref:`scheme  &lt;config_http_conn_man_headers_scheme&gt;`
   * handling applies.
   * </pre>
   *
   * <code>.envoy.config.core.v3.SchemeHeaderTransformation scheme_header_transformation = 48;</code>
   * @return The schemeHeaderTransformation.
   */
  io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformation getSchemeHeaderTransformation();
  /**
   * <pre>
   * Allows for explicit transformation of the :scheme header on the request path.
   * If not set, Envoy's default :ref:`scheme  &lt;config_http_conn_man_headers_scheme&gt;`
   * handling applies.
   * </pre>
   *
   * <code>.envoy.config.core.v3.SchemeHeaderTransformation scheme_header_transformation = 48;</code>
   */
  io.envoyproxy.envoy.config.core.v3.SchemeHeaderTransformationOrBuilder getSchemeHeaderTransformationOrBuilder();

  /**
   * <pre>
   * The maximum request headers size for incoming connections.
   * If unconfigured, the default max request headers allowed is 60 KiB.
   * Requests that exceed this limit will receive a 431 response.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
   * @return Whether the maxRequestHeadersKb field is set.
   */
  boolean hasMaxRequestHeadersKb();
  /**
   * <pre>
   * The maximum request headers size for incoming connections.
   * If unconfigured, the default max request headers allowed is 60 KiB.
   * Requests that exceed this limit will receive a 431 response.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
   * @return The maxRequestHeadersKb.
   */
  com.google.protobuf.UInt32Value getMaxRequestHeadersKb();
  /**
   * <pre>
   * The maximum request headers size for incoming connections.
   * If unconfigured, the default max request headers allowed is 60 KiB.
   * Requests that exceed this limit will receive a 431 response.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_request_headers_kb = 29 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.UInt32ValueOrBuilder getMaxRequestHeadersKbOrBuilder();

  /**
   * <pre>
   * The stream idle timeout for connections managed by the connection manager.
   * If not specified, this defaults to 5 minutes. The default value was selected
   * so as not to interfere with any smaller configured timeouts that may have
   * existed in configurations prior to the introduction of this feature, while
   * introducing robustness to TCP connections that terminate without a FIN.
   * This idle timeout applies to new streams and is overridable by the
   * :ref:`route-level idle_timeout
   * &lt;envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
   * which the override applies, prior to receipt of the initial request
   * headers, the :ref:`stream_idle_timeout
   * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
   * applies. Each time an encode/decode event for headers or data is processed
   * for the stream, the timer will be reset. If the timeout fires, the stream
   * is terminated with a 408 Request Timeout error code if no upstream response
   * header has been received, otherwise a stream reset occurs.
   * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
   * window to write any remaining stream data once the entirety of stream data (local end stream is
   * true) has been buffered pending available window. In other words, this timeout defends against
   * a peer that does not release enough window to completely write the stream, even though all
   * data has been proxied within available flow control windows. If the timeout is hit in this
   * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
   * incremented. Note that :ref:`max_stream_duration
   * &lt;envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
   * this corner case.
   * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
   * is configured, this timeout is scaled according to the value for
   * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
   * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
   * to the granularity of events presented to the connection manager. For example, while receiving
   * very large request headers, it may be the case that there is traffic regularly arriving on the
   * wire while the connection manage is only able to observe the end-of-headers event, hence the
   * stream may still idle timeout.
   * A value of 0 will completely disable the connection manager stream idle
   * timeout, although per-route idle timeout overrides will continue to apply.
   * </pre>
   *
   * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
   * @return Whether the streamIdleTimeout field is set.
   */
  boolean hasStreamIdleTimeout();
  /**
   * <pre>
   * The stream idle timeout for connections managed by the connection manager.
   * If not specified, this defaults to 5 minutes. The default value was selected
   * so as not to interfere with any smaller configured timeouts that may have
   * existed in configurations prior to the introduction of this feature, while
   * introducing robustness to TCP connections that terminate without a FIN.
   * This idle timeout applies to new streams and is overridable by the
   * :ref:`route-level idle_timeout
   * &lt;envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
   * which the override applies, prior to receipt of the initial request
   * headers, the :ref:`stream_idle_timeout
   * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
   * applies. Each time an encode/decode event for headers or data is processed
   * for the stream, the timer will be reset. If the timeout fires, the stream
   * is terminated with a 408 Request Timeout error code if no upstream response
   * header has been received, otherwise a stream reset occurs.
   * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
   * window to write any remaining stream data once the entirety of stream data (local end stream is
   * true) has been buffered pending available window. In other words, this timeout defends against
   * a peer that does not release enough window to completely write the stream, even though all
   * data has been proxied within available flow control windows. If the timeout is hit in this
   * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
   * incremented. Note that :ref:`max_stream_duration
   * &lt;envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
   * this corner case.
   * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
   * is configured, this timeout is scaled according to the value for
   * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
   * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
   * to the granularity of events presented to the connection manager. For example, while receiving
   * very large request headers, it may be the case that there is traffic regularly arriving on the
   * wire while the connection manage is only able to observe the end-of-headers event, hence the
   * stream may still idle timeout.
   * A value of 0 will completely disable the connection manager stream idle
   * timeout, although per-route idle timeout overrides will continue to apply.
   * </pre>
   *
   * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
   * @return The streamIdleTimeout.
   */
  com.google.protobuf.Duration getStreamIdleTimeout();
  /**
   * <pre>
   * The stream idle timeout for connections managed by the connection manager.
   * If not specified, this defaults to 5 minutes. The default value was selected
   * so as not to interfere with any smaller configured timeouts that may have
   * existed in configurations prior to the introduction of this feature, while
   * introducing robustness to TCP connections that terminate without a FIN.
   * This idle timeout applies to new streams and is overridable by the
   * :ref:`route-level idle_timeout
   * &lt;envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout&gt;`. Even on a stream in
   * which the override applies, prior to receipt of the initial request
   * headers, the :ref:`stream_idle_timeout
   * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout&gt;`
   * applies. Each time an encode/decode event for headers or data is processed
   * for the stream, the timer will be reset. If the timeout fires, the stream
   * is terminated with a 408 Request Timeout error code if no upstream response
   * header has been received, otherwise a stream reset occurs.
   * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
   * window to write any remaining stream data once the entirety of stream data (local end stream is
   * true) has been buffered pending available window. In other words, this timeout defends against
   * a peer that does not release enough window to completely write the stream, even though all
   * data has been proxied within available flow control windows. If the timeout is hit in this
   * case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec&gt;` counter will be
   * incremented. Note that :ref:`max_stream_duration
   * &lt;envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration&gt;` does not apply to
   * this corner case.
   * If the :ref:`overload action &lt;config_overload_manager_overload_actions&gt;` "envoy.overload_actions.reduce_timeouts"
   * is configured, this timeout is scaled according to the value for
   * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE&gt;`.
   * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
   * to the granularity of events presented to the connection manager. For example, while receiving
   * very large request headers, it may be the case that there is traffic regularly arriving on the
   * wire while the connection manage is only able to observe the end-of-headers event, hence the
   * stream may still idle timeout.
   * A value of 0 will completely disable the connection manager stream idle
   * timeout, although per-route idle timeout overrides will continue to apply.
   * </pre>
   *
   * <code>.google.protobuf.Duration stream_idle_timeout = 24 [(.udpa.annotations.security) = { ... }</code>
   */
  com.google.protobuf.DurationOrBuilder getStreamIdleTimeoutOrBuilder();

  /**
   * <pre>
   * The amount of time that Envoy will wait for the entire request to be received.
   * The timer is activated when the request is initiated, and is disarmed when the last byte of the
   * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
   * response is initiated. If not specified or set to 0, this timeout is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
   * @return Whether the requestTimeout field is set.
   */
  boolean hasRequestTimeout();
  /**
   * <pre>
   * The amount of time that Envoy will wait for the entire request to be received.
   * The timer is activated when the request is initiated, and is disarmed when the last byte of the
   * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
   * response is initiated. If not specified or set to 0, this timeout is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
   * @return The requestTimeout.
   */
  com.google.protobuf.Duration getRequestTimeout();
  /**
   * <pre>
   * The amount of time that Envoy will wait for the entire request to be received.
   * The timer is activated when the request is initiated, and is disarmed when the last byte of the
   * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
   * response is initiated. If not specified or set to 0, this timeout is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration request_timeout = 28 [(.udpa.annotations.security) = { ... }</code>
   */
  com.google.protobuf.DurationOrBuilder getRequestTimeoutOrBuilder();

  /**
   * <pre>
   * The amount of time that Envoy will wait for the request headers to be received. The timer is
   * activated when the first byte of the headers is received, and is disarmed when the last byte of
   * the headers has been received. If not specified or set to 0, this timeout is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
   * @return Whether the requestHeadersTimeout field is set.
   */
  boolean hasRequestHeadersTimeout();
  /**
   * <pre>
   * The amount of time that Envoy will wait for the request headers to be received. The timer is
   * activated when the first byte of the headers is received, and is disarmed when the last byte of
   * the headers has been received. If not specified or set to 0, this timeout is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
   * @return The requestHeadersTimeout.
   */
  com.google.protobuf.Duration getRequestHeadersTimeout();
  /**
   * <pre>
   * The amount of time that Envoy will wait for the request headers to be received. The timer is
   * activated when the first byte of the headers is received, and is disarmed when the last byte of
   * the headers has been received. If not specified or set to 0, this timeout is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration request_headers_timeout = 41 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.DurationOrBuilder getRequestHeadersTimeoutOrBuilder();

  /**
   * <pre>
   * The time that Envoy will wait between sending an HTTP/2 “shutdown
   * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
   * This is used so that Envoy provides a grace period for new streams that
   * race with the final GOAWAY frame. During this grace period, Envoy will
   * continue to accept new streams. After the grace period, a final GOAWAY
   * frame is sent and Envoy will start refusing new streams. Draining occurs
   * both when a connection hits the idle timeout or during general server
   * draining. The default grace period is 5000 milliseconds (5 seconds) if this
   * option is not specified.
   * </pre>
   *
   * <code>.google.protobuf.Duration drain_timeout = 12;</code>
   * @return Whether the drainTimeout field is set.
   */
  boolean hasDrainTimeout();
  /**
   * <pre>
   * The time that Envoy will wait between sending an HTTP/2 “shutdown
   * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
   * This is used so that Envoy provides a grace period for new streams that
   * race with the final GOAWAY frame. During this grace period, Envoy will
   * continue to accept new streams. After the grace period, a final GOAWAY
   * frame is sent and Envoy will start refusing new streams. Draining occurs
   * both when a connection hits the idle timeout or during general server
   * draining. The default grace period is 5000 milliseconds (5 seconds) if this
   * option is not specified.
   * </pre>
   *
   * <code>.google.protobuf.Duration drain_timeout = 12;</code>
   * @return The drainTimeout.
   */
  com.google.protobuf.Duration getDrainTimeout();
  /**
   * <pre>
   * The time that Envoy will wait between sending an HTTP/2 “shutdown
   * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
   * This is used so that Envoy provides a grace period for new streams that
   * race with the final GOAWAY frame. During this grace period, Envoy will
   * continue to accept new streams. After the grace period, a final GOAWAY
   * frame is sent and Envoy will start refusing new streams. Draining occurs
   * both when a connection hits the idle timeout or during general server
   * draining. The default grace period is 5000 milliseconds (5 seconds) if this
   * option is not specified.
   * </pre>
   *
   * <code>.google.protobuf.Duration drain_timeout = 12;</code>
   */
  com.google.protobuf.DurationOrBuilder getDrainTimeoutOrBuilder();

  /**
   * <pre>
   * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
   * It is defined as a grace period after connection close processing has been locally initiated
   * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
   * from the downstream connection) prior to Envoy closing the socket associated with that
   * connection.
   * NOTE: This timeout is enforced even when the socket associated with the downstream connection
   * is pending a flush of the write buffer. However, any progress made writing data to the socket
   * will restart the timer associated with this timeout. This means that the total grace period for
   * a socket in this state will be
   * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
   * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
   * sequence mitigates a race condition that exists when downstream clients do not drain/process
   * data in a connection's receive buffer after a remote close has been detected via a socket
   * write(). This race leads to such clients failing to process the response code sent by Envoy,
   * which could result in erroneous downstream processing.
   * If the timeout triggers, Envoy will close the connection's socket.
   * The default timeout is 1000 ms if this option is not specified.
   * .. NOTE::
   *    To be useful in avoiding the race condition described above, this timeout must be set
   *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
   *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
   * .. WARNING::
   *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
   *    connection's socket will be closed immediately after the write flush is completed or will
   *    never close if the write flush does not complete.
   * </pre>
   *
   * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
   * @return Whether the delayedCloseTimeout field is set.
   */
  boolean hasDelayedCloseTimeout();
  /**
   * <pre>
   * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
   * It is defined as a grace period after connection close processing has been locally initiated
   * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
   * from the downstream connection) prior to Envoy closing the socket associated with that
   * connection.
   * NOTE: This timeout is enforced even when the socket associated with the downstream connection
   * is pending a flush of the write buffer. However, any progress made writing data to the socket
   * will restart the timer associated with this timeout. This means that the total grace period for
   * a socket in this state will be
   * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
   * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
   * sequence mitigates a race condition that exists when downstream clients do not drain/process
   * data in a connection's receive buffer after a remote close has been detected via a socket
   * write(). This race leads to such clients failing to process the response code sent by Envoy,
   * which could result in erroneous downstream processing.
   * If the timeout triggers, Envoy will close the connection's socket.
   * The default timeout is 1000 ms if this option is not specified.
   * .. NOTE::
   *    To be useful in avoiding the race condition described above, this timeout must be set
   *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
   *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
   * .. WARNING::
   *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
   *    connection's socket will be closed immediately after the write flush is completed or will
   *    never close if the write flush does not complete.
   * </pre>
   *
   * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
   * @return The delayedCloseTimeout.
   */
  com.google.protobuf.Duration getDelayedCloseTimeout();
  /**
   * <pre>
   * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
   * It is defined as a grace period after connection close processing has been locally initiated
   * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
   * from the downstream connection) prior to Envoy closing the socket associated with that
   * connection.
   * NOTE: This timeout is enforced even when the socket associated with the downstream connection
   * is pending a flush of the write buffer. However, any progress made writing data to the socket
   * will restart the timer associated with this timeout. This means that the total grace period for
   * a socket in this state will be
   * &lt;total_time_waiting_for_write_buffer_flushes&gt;+&lt;delayed_close_timeout&gt;.
   * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
   * sequence mitigates a race condition that exists when downstream clients do not drain/process
   * data in a connection's receive buffer after a remote close has been detected via a socket
   * write(). This race leads to such clients failing to process the response code sent by Envoy,
   * which could result in erroneous downstream processing.
   * If the timeout triggers, Envoy will close the connection's socket.
   * The default timeout is 1000 ms if this option is not specified.
   * .. NOTE::
   *    To be useful in avoiding the race condition described above, this timeout must be set
   *    to *at least* &lt;max round trip time expected between clients and Envoy&gt;+&lt;100ms to account for
   *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop&gt;.
   * .. WARNING::
   *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
   *    connection's socket will be closed immediately after the write flush is completed or will
   *    never close if the write flush does not complete.
   * </pre>
   *
   * <code>.google.protobuf.Duration delayed_close_timeout = 26;</code>
   */
  com.google.protobuf.DurationOrBuilder getDelayedCloseTimeoutOrBuilder();

  /**
   * <pre>
   * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
   * emitted by the connection manager.
   * </pre>
   *
   * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
   */
  java.util.List<io.envoyproxy.envoy.config.accesslog.v3.AccessLog> 
      getAccessLogList();
  /**
   * <pre>
   * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
   * emitted by the connection manager.
   * </pre>
   *
   * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
   */
  io.envoyproxy.envoy.config.accesslog.v3.AccessLog getAccessLog(int index);
  /**
   * <pre>
   * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
   * emitted by the connection manager.
   * </pre>
   *
   * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
   */
  int getAccessLogCount();
  /**
   * <pre>
   * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
   * emitted by the connection manager.
   * </pre>
   *
   * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder> 
      getAccessLogOrBuilderList();
  /**
   * <pre>
   * Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs&gt;`
   * emitted by the connection manager.
   * </pre>
   *
   * <code>repeated .envoy.config.accesslog.v3.AccessLog access_log = 13;</code>
   */
  io.envoyproxy.envoy.config.accesslog.v3.AccessLogOrBuilder getAccessLogOrBuilder(
      int index);

  /**
   * <pre>
   * If set to true, the connection manager will use the real remote address
   * of the client connection when determining internal versus external origin and manipulating
   * various headers. If set to false or absent, the connection manager will use the
   * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
   * :ref:`config_http_conn_man_headers_x-forwarded-for`,
   * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
   * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
   * @return Whether the useRemoteAddress field is set.
   */
  boolean hasUseRemoteAddress();
  /**
   * <pre>
   * If set to true, the connection manager will use the real remote address
   * of the client connection when determining internal versus external origin and manipulating
   * various headers. If set to false or absent, the connection manager will use the
   * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
   * :ref:`config_http_conn_man_headers_x-forwarded-for`,
   * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
   * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
   * @return The useRemoteAddress.
   */
  com.google.protobuf.BoolValue getUseRemoteAddress();
  /**
   * <pre>
   * If set to true, the connection manager will use the real remote address
   * of the client connection when determining internal versus external origin and manipulating
   * various headers. If set to false or absent, the connection manager will use the
   * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
   * :ref:`config_http_conn_man_headers_x-forwarded-for`,
   * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
   * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue use_remote_address = 14 [(.udpa.annotations.security) = { ... }</code>
   */
  com.google.protobuf.BoolValueOrBuilder getUseRemoteAddressOrBuilder();

  /**
   * <pre>
   * The number of additional ingress proxy hops from the right side of the
   * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
   * determining the origin client's IP address. The default is zero if this option
   * is not specified. See the documentation for
   * :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
   * </pre>
   *
   * <code>uint32 xff_num_trusted_hops = 19;</code>
   * @return The xffNumTrustedHops.
   */
  int getXffNumTrustedHops();

  /**
   * <pre>
   * The configuration for the original IP detection extensions.
   * When configured the extensions will be called along with the request headers
   * and information about the downstream connection, such as the directly connected address.
   * Each extension will then use these parameters to decide the request's effective remote address.
   * If an extension fails to detect the original IP address and isn't configured to reject
   * the request, the HCM will try the remaining extensions until one succeeds or rejects
   * the request. If the request isn't rejected nor any extension succeeds, the HCM will
   * fallback to using the remote address.
   * .. WARNING::
   *    Extensions cannot be used in conjunction with :ref:`use_remote_address
   *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
   *    nor :ref:`xff_num_trusted_hops
   *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
   * [#extension-category: envoy.http.original_ip_detection]
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
   */
  java.util.List<io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig> 
      getOriginalIpDetectionExtensionsList();
  /**
   * <pre>
   * The configuration for the original IP detection extensions.
   * When configured the extensions will be called along with the request headers
   * and information about the downstream connection, such as the directly connected address.
   * Each extension will then use these parameters to decide the request's effective remote address.
   * If an extension fails to detect the original IP address and isn't configured to reject
   * the request, the HCM will try the remaining extensions until one succeeds or rejects
   * the request. If the request isn't rejected nor any extension succeeds, the HCM will
   * fallback to using the remote address.
   * .. WARNING::
   *    Extensions cannot be used in conjunction with :ref:`use_remote_address
   *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
   *    nor :ref:`xff_num_trusted_hops
   *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
   * [#extension-category: envoy.http.original_ip_detection]
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
   */
  io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig getOriginalIpDetectionExtensions(int index);
  /**
   * <pre>
   * The configuration for the original IP detection extensions.
   * When configured the extensions will be called along with the request headers
   * and information about the downstream connection, such as the directly connected address.
   * Each extension will then use these parameters to decide the request's effective remote address.
   * If an extension fails to detect the original IP address and isn't configured to reject
   * the request, the HCM will try the remaining extensions until one succeeds or rejects
   * the request. If the request isn't rejected nor any extension succeeds, the HCM will
   * fallback to using the remote address.
   * .. WARNING::
   *    Extensions cannot be used in conjunction with :ref:`use_remote_address
   *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
   *    nor :ref:`xff_num_trusted_hops
   *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
   * [#extension-category: envoy.http.original_ip_detection]
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
   */
  int getOriginalIpDetectionExtensionsCount();
  /**
   * <pre>
   * The configuration for the original IP detection extensions.
   * When configured the extensions will be called along with the request headers
   * and information about the downstream connection, such as the directly connected address.
   * Each extension will then use these parameters to decide the request's effective remote address.
   * If an extension fails to detect the original IP address and isn't configured to reject
   * the request, the HCM will try the remaining extensions until one succeeds or rejects
   * the request. If the request isn't rejected nor any extension succeeds, the HCM will
   * fallback to using the remote address.
   * .. WARNING::
   *    Extensions cannot be used in conjunction with :ref:`use_remote_address
   *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
   *    nor :ref:`xff_num_trusted_hops
   *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
   * [#extension-category: envoy.http.original_ip_detection]
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder> 
      getOriginalIpDetectionExtensionsOrBuilderList();
  /**
   * <pre>
   * The configuration for the original IP detection extensions.
   * When configured the extensions will be called along with the request headers
   * and information about the downstream connection, such as the directly connected address.
   * Each extension will then use these parameters to decide the request's effective remote address.
   * If an extension fails to detect the original IP address and isn't configured to reject
   * the request, the HCM will try the remaining extensions until one succeeds or rejects
   * the request. If the request isn't rejected nor any extension succeeds, the HCM will
   * fallback to using the remote address.
   * .. WARNING::
   *    Extensions cannot be used in conjunction with :ref:`use_remote_address
   *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
   *    nor :ref:`xff_num_trusted_hops
   *    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops&gt;`.
   * [#extension-category: envoy.http.original_ip_detection]
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;</code>
   */
  io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder getOriginalIpDetectionExtensionsOrBuilder(
      int index);

  /**
   * <pre>
   * The configuration for the early header mutation extensions.
   * When configured the extensions will be called before any routing, tracing, or any filter processing.
   * Each extension will be applied in the order they are configured.
   * If the same header is mutated by multiple extensions, then the last extension will win.
   * [#extension-category: envoy.http.early_header_mutation]
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
   */
  java.util.List<io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig> 
      getEarlyHeaderMutationExtensionsList();
  /**
   * <pre>
   * The configuration for the early header mutation extensions.
   * When configured the extensions will be called before any routing, tracing, or any filter processing.
   * Each extension will be applied in the order they are configured.
   * If the same header is mutated by multiple extensions, then the last extension will win.
   * [#extension-category: envoy.http.early_header_mutation]
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
   */
  io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig getEarlyHeaderMutationExtensions(int index);
  /**
   * <pre>
   * The configuration for the early header mutation extensions.
   * When configured the extensions will be called before any routing, tracing, or any filter processing.
   * Each extension will be applied in the order they are configured.
   * If the same header is mutated by multiple extensions, then the last extension will win.
   * [#extension-category: envoy.http.early_header_mutation]
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
   */
  int getEarlyHeaderMutationExtensionsCount();
  /**
   * <pre>
   * The configuration for the early header mutation extensions.
   * When configured the extensions will be called before any routing, tracing, or any filter processing.
   * Each extension will be applied in the order they are configured.
   * If the same header is mutated by multiple extensions, then the last extension will win.
   * [#extension-category: envoy.http.early_header_mutation]
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder> 
      getEarlyHeaderMutationExtensionsOrBuilderList();
  /**
   * <pre>
   * The configuration for the early header mutation extensions.
   * When configured the extensions will be called before any routing, tracing, or any filter processing.
   * Each extension will be applied in the order they are configured.
   * If the same header is mutated by multiple extensions, then the last extension will win.
   * [#extension-category: envoy.http.early_header_mutation]
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;</code>
   */
  io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder getEarlyHeaderMutationExtensionsOrBuilder(
      int index);

  /**
   * <pre>
   * Configures what network addresses are considered internal for stats and header sanitation
   * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
   * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
   * information about internal/external addresses.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
   * @return Whether the internalAddressConfig field is set.
   */
  boolean hasInternalAddressConfig();
  /**
   * <pre>
   * Configures what network addresses are considered internal for stats and header sanitation
   * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
   * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
   * information about internal/external addresses.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
   * @return The internalAddressConfig.
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig getInternalAddressConfig();
  /**
   * <pre>
   * Configures what network addresses are considered internal for stats and header sanitation
   * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
   * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
   * information about internal/external addresses.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;</code>
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfigOrBuilder getInternalAddressConfigOrBuilder();

  /**
   * <pre>
   * If set, Envoy will not append the remote address to the
   * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. This may be used in
   * conjunction with HTTP filters that explicitly manipulate XFF after the HTTP connection manager
   * has mutated the request headers. While :ref:`use_remote_address
   * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
   * will also suppress XFF addition, it has consequences for logging and other
   * Envoy uses of the remote address, so ``skip_xff_append`` should be used
   * when only an elision of XFF addition is intended.
   * </pre>
   *
   * <code>bool skip_xff_append = 21;</code>
   * @return The skipXffAppend.
   */
  boolean getSkipXffAppend();

  /**
   * <pre>
   * Via header value to append to request and response headers. If this is
   * empty, no via header will be appended.
   * </pre>
   *
   * <code>string via = 22 [(.validate.rules) = { ... }</code>
   * @return The via.
   */
  java.lang.String getVia();
  /**
   * <pre>
   * Via header value to append to request and response headers. If this is
   * empty, no via header will be appended.
   * </pre>
   *
   * <code>string via = 22 [(.validate.rules) = { ... }</code>
   * @return The bytes for via.
   */
  com.google.protobuf.ByteString
      getViaBytes();

  /**
   * <pre>
   * Whether the connection manager will generate the :ref:`x-request-id
   * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
   * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
   * is not desired it can be disabled.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
   * @return Whether the generateRequestId field is set.
   */
  boolean hasGenerateRequestId();
  /**
   * <pre>
   * Whether the connection manager will generate the :ref:`x-request-id
   * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
   * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
   * is not desired it can be disabled.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
   * @return The generateRequestId.
   */
  com.google.protobuf.BoolValue getGenerateRequestId();
  /**
   * <pre>
   * Whether the connection manager will generate the :ref:`x-request-id
   * &lt;config_http_conn_man_headers_x-request-id&gt;` header if it does not exist. This defaults to
   * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
   * is not desired it can be disabled.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue generate_request_id = 15;</code>
   */
  com.google.protobuf.BoolValueOrBuilder getGenerateRequestIdOrBuilder();

  /**
   * <pre>
   * Whether the connection manager will keep the :ref:`x-request-id
   * &lt;config_http_conn_man_headers_x-request-id&gt;` header if passed for a request that is edge
   * (Edge request is the request from external clients to front Envoy) and not reset it, which
   * is the current Envoy behaviour. This defaults to false.
   * </pre>
   *
   * <code>bool preserve_external_request_id = 32;</code>
   * @return The preserveExternalRequestId.
   */
  boolean getPreserveExternalRequestId();

  /**
   * <pre>
   * If set, Envoy will always set :ref:`x-request-id &lt;config_http_conn_man_headers_x-request-id&gt;` header in response.
   * If this is false or not set, the request ID is returned in responses only if tracing is forced using
   * :ref:`x-envoy-force-trace &lt;config_http_conn_man_headers_x-envoy-force-trace&gt;` header.
   * </pre>
   *
   * <code>bool always_set_request_id_in_response = 37;</code>
   * @return The alwaysSetRequestIdInResponse.
   */
  boolean getAlwaysSetRequestIdInResponse();

  /**
   * <pre>
   * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
   * header.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails forward_client_cert_details = 16 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for forwardClientCertDetails.
   */
  int getForwardClientCertDetailsValue();
  /**
   * <pre>
   * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
   * header.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails forward_client_cert_details = 16 [(.validate.rules) = { ... }</code>
   * @return The forwardClientCertDetails.
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails getForwardClientCertDetails();

  /**
   * <pre>
   * This field is valid only when :ref:`forward_client_cert_details
   * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
   * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
   * the client certificate to be forwarded. Note that in the
   * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, ``Hash`` is always set, and
   * ``By`` is always set when the client certificate presents the URI type Subject Alternative Name
   * value.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
   * @return Whether the setCurrentClientCertDetails field is set.
   */
  boolean hasSetCurrentClientCertDetails();
  /**
   * <pre>
   * This field is valid only when :ref:`forward_client_cert_details
   * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
   * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
   * the client certificate to be forwarded. Note that in the
   * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, ``Hash`` is always set, and
   * ``By`` is always set when the client certificate presents the URI type Subject Alternative Name
   * value.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
   * @return The setCurrentClientCertDetails.
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails getSetCurrentClientCertDetails();
  /**
   * <pre>
   * This field is valid only when :ref:`forward_client_cert_details
   * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details&gt;`
   * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
   * the client certificate to be forwarded. Note that in the
   * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, ``Hash`` is always set, and
   * ``By`` is always set when the client certificate presents the URI type Subject Alternative Name
   * value.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;</code>
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetailsOrBuilder getSetCurrentClientCertDetailsOrBuilder();

  /**
   * <pre>
   * If proxy_100_continue is true, Envoy will proxy incoming "Expect:
   * 100-continue" headers upstream, and forward "100 Continue" responses
   * downstream. If this is false or not set, Envoy will instead strip the
   * "Expect: 100-continue" header, and send a "100 Continue" response itself.
   * </pre>
   *
   * <code>bool proxy_100_continue = 18;</code>
   * @return The proxy100Continue.
   */
  boolean getProxy100Continue();

  /**
   * <pre>
   * If
   * :ref:`use_remote_address
   * &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address&gt;`
   * is true and represent_ipv4_remote_address_as_ipv4_mapped_ipv6 is true and the remote address is
   * an IPv4 address, the address will be mapped to IPv6 before it is appended to ``x-forwarded-for``.
   * This is useful for testing compatibility of upstream services that parse the header value. For
   * example, 50.0.0.1 is represented as ::FFFF:50.0.0.1. See `IPv4-Mapped IPv6 Addresses
   * &lt;https://tools.ietf.org/html/rfc4291#section-2.5.5.2&gt;`_ for details. This will also affect the
   * :ref:`config_http_conn_man_headers_x-envoy-external-address` header. See
   * :ref:`http_connection_manager.represent_ipv4_remote_address_as_ipv4_mapped_ipv6
   * &lt;config_http_conn_man_runtime_represent_ipv4_remote_address_as_ipv4_mapped_ipv6&gt;` for runtime
   * control.
   * [#not-implemented-hide:]
   * </pre>
   *
   * <code>bool represent_ipv4_remote_address_as_ipv4_mapped_ipv6 = 20;</code>
   * @return The representIpv4RemoteAddressAsIpv4MappedIpv6.
   */
  boolean getRepresentIpv4RemoteAddressAsIpv4MappedIpv6();

  /**
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
   */
  java.util.List<io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig> 
      getUpgradeConfigsList();
  /**
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig getUpgradeConfigs(int index);
  /**
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
   */
  int getUpgradeConfigsCount();
  /**
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfigOrBuilder> 
      getUpgradeConfigsOrBuilderList();
  /**
   * <code>repeated .envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;</code>
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfigOrBuilder getUpgradeConfigsOrBuilder(
      int index);

  /**
   * <pre>
   * Should paths be normalized according to RFC 3986 before any processing of
   * requests by HTTP filters or routing? This affects the upstream ``:path`` header
   * as well. For paths that fail this check, Envoy will respond with 400 to
   * paths that are malformed. This defaults to false currently but will default
   * true in the future. When not specified, this value may be overridden by the
   * runtime variable
   * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
   * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
   * for details of normalization.
   * Note that Envoy does not perform
   * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
   * [#comment:TODO: This field is ignored when the
   * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
   * is present.]
   * </pre>
   *
   * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
   * @return Whether the normalizePath field is set.
   */
  boolean hasNormalizePath();
  /**
   * <pre>
   * Should paths be normalized according to RFC 3986 before any processing of
   * requests by HTTP filters or routing? This affects the upstream ``:path`` header
   * as well. For paths that fail this check, Envoy will respond with 400 to
   * paths that are malformed. This defaults to false currently but will default
   * true in the future. When not specified, this value may be overridden by the
   * runtime variable
   * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
   * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
   * for details of normalization.
   * Note that Envoy does not perform
   * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
   * [#comment:TODO: This field is ignored when the
   * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
   * is present.]
   * </pre>
   *
   * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
   * @return The normalizePath.
   */
  com.google.protobuf.BoolValue getNormalizePath();
  /**
   * <pre>
   * Should paths be normalized according to RFC 3986 before any processing of
   * requests by HTTP filters or routing? This affects the upstream ``:path`` header
   * as well. For paths that fail this check, Envoy will respond with 400 to
   * paths that are malformed. This defaults to false currently but will default
   * true in the future. When not specified, this value may be overridden by the
   * runtime variable
   * :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path&gt;`.
   * See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6&gt;`_
   * for details of normalization.
   * Note that Envoy does not perform
   * `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1&gt;`_
   * [#comment:TODO: This field is ignored when the
   * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
   * is present.]
   * </pre>
   *
   * <code>.google.protobuf.BoolValue normalize_path = 30;</code>
   */
  com.google.protobuf.BoolValueOrBuilder getNormalizePathOrBuilder();

  /**
   * <pre>
   * Determines if adjacent slashes in the path are merged into one before any processing of
   * requests by HTTP filters or routing. This affects the upstream ``:path`` header as well. Without
   * setting this option, incoming requests with path ``//dir///file`` will not match against route
   * with ``prefix`` match set to ``/dir``. Defaults to ``false``. Note that slash merging is not part of
   * `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
   * [#comment:TODO: This field is ignored when the
   * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
   * is present.]
   * </pre>
   *
   * <code>bool merge_slashes = 33;</code>
   * @return The mergeSlashes.
   */
  boolean getMergeSlashes();

  /**
   * <pre>
   * Action to take when request URL path contains escaped slash sequences (%2F, %2f, %5C and %5c).
   * The default value can be overridden by the :ref:`http_connection_manager.path_with_escaped_slashes_action&lt;config_http_conn_man_runtime_path_with_escaped_slashes_action&gt;`
   * runtime variable.
   * The :ref:`http_connection_manager.path_with_escaped_slashes_action_sampling&lt;config_http_conn_man_runtime_path_with_escaped_slashes_action_enabled&gt;` runtime
   * variable can be used to apply the action to a portion of all requests.
   * [#comment:TODO: This field is ignored when the
   * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
   * is present.]
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction path_with_escaped_slashes_action = 45;</code>
   * @return The enum numeric value on the wire for pathWithEscapedSlashesAction.
   */
  int getPathWithEscapedSlashesActionValue();
  /**
   * <pre>
   * Action to take when request URL path contains escaped slash sequences (%2F, %2f, %5C and %5c).
   * The default value can be overridden by the :ref:`http_connection_manager.path_with_escaped_slashes_action&lt;config_http_conn_man_runtime_path_with_escaped_slashes_action&gt;`
   * runtime variable.
   * The :ref:`http_connection_manager.path_with_escaped_slashes_action_sampling&lt;config_http_conn_man_runtime_path_with_escaped_slashes_action_enabled&gt;` runtime
   * variable can be used to apply the action to a portion of all requests.
   * [#comment:TODO: This field is ignored when the
   * :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config&gt;`
   * is present.]
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction path_with_escaped_slashes_action = 45;</code>
   * @return The pathWithEscapedSlashesAction.
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction getPathWithEscapedSlashesAction();

  /**
   * <pre>
   * The configuration of the request ID extension. This includes operations such as
   * generation, validation, and associated tracing operations. If empty, the
   * :ref:`UuidRequestIdConfig &lt;envoy_v3_api_msg_extensions.request_id.uuid.v3.UuidRequestIdConfig&gt;`
   * default extension is used with default parameters. See the documentation for that extension
   * for details on what it does. Customizing the configuration for the default extension can be
   * achieved by configuring it explicitly here. For example, to disable trace reason packing,
   * the following configuration can be used:
   * .. validated-code-block:: yaml
   *   :type-name: envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension
   *   typed_config:
   *     "&#64;type": type.googleapis.com/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig
   *     pack_trace_reason: false
   * [#extension-category: envoy.request_id]
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
   * @return Whether the requestIdExtension field is set.
   */
  boolean hasRequestIdExtension();
  /**
   * <pre>
   * The configuration of the request ID extension. This includes operations such as
   * generation, validation, and associated tracing operations. If empty, the
   * :ref:`UuidRequestIdConfig &lt;envoy_v3_api_msg_extensions.request_id.uuid.v3.UuidRequestIdConfig&gt;`
   * default extension is used with default parameters. See the documentation for that extension
   * for details on what it does. Customizing the configuration for the default extension can be
   * achieved by configuring it explicitly here. For example, to disable trace reason packing,
   * the following configuration can be used:
   * .. validated-code-block:: yaml
   *   :type-name: envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension
   *   typed_config:
   *     "&#64;type": type.googleapis.com/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig
   *     pack_trace_reason: false
   * [#extension-category: envoy.request_id]
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
   * @return The requestIdExtension.
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension getRequestIdExtension();
  /**
   * <pre>
   * The configuration of the request ID extension. This includes operations such as
   * generation, validation, and associated tracing operations. If empty, the
   * :ref:`UuidRequestIdConfig &lt;envoy_v3_api_msg_extensions.request_id.uuid.v3.UuidRequestIdConfig&gt;`
   * default extension is used with default parameters. See the documentation for that extension
   * for details on what it does. Customizing the configuration for the default extension can be
   * achieved by configuring it explicitly here. For example, to disable trace reason packing,
   * the following configuration can be used:
   * .. validated-code-block:: yaml
   *   :type-name: envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension
   *   typed_config:
   *     "&#64;type": type.googleapis.com/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig
   *     pack_trace_reason: false
   * [#extension-category: envoy.request_id]
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;</code>
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtensionOrBuilder getRequestIdExtensionOrBuilder();

  /**
   * <pre>
   * The configuration to customize local reply returned by Envoy. It can customize status code,
   * body text and response content type. If not specified, status code and text body are hard
   * coded in Envoy, the response content type is plain text.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
   * @return Whether the localReplyConfig field is set.
   */
  boolean hasLocalReplyConfig();
  /**
   * <pre>
   * The configuration to customize local reply returned by Envoy. It can customize status code,
   * body text and response content type. If not specified, status code and text body are hard
   * coded in Envoy, the response content type is plain text.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
   * @return The localReplyConfig.
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig getLocalReplyConfig();
  /**
   * <pre>
   * The configuration to customize local reply returned by Envoy. It can customize status code,
   * body text and response content type. If not specified, status code and text body are hard
   * coded in Envoy, the response content type is plain text.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;</code>
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfigOrBuilder getLocalReplyConfigOrBuilder();

  /**
   * <pre>
   * Determines if the port part should be removed from host/authority header before any processing
   * of request by HTTP filters or routing. The port would be removed only if it is equal to the :ref:`listener's&lt;envoy_v3_api_field_config.listener.v3.Listener.address&gt;`
   * local port. This affects the upstream host header unless the method is
   * CONNECT in which case if no filter adds a port the original port will be restored before headers are
   * sent upstream.
   * Without setting this option, incoming requests with host ``example:443`` will not match against
   * route with :ref:`domains&lt;envoy_v3_api_field_config.route.v3.VirtualHost.domains&gt;` match set to ``example``. Defaults to ``false``. Note that port removal is not part
   * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
   * Only one of ``strip_matching_host_port`` or ``strip_any_host_port`` can be set.
   * </pre>
   *
   * <code>bool strip_matching_host_port = 39 [(.udpa.annotations.field_migrate) = { ... }</code>
   * @return The stripMatchingHostPort.
   */
  boolean getStripMatchingHostPort();

  /**
   * <pre>
   * Determines if the port part should be removed from host/authority header before any processing
   * of request by HTTP filters or routing.
   * This affects the upstream host header unless the method is CONNECT in
   * which case if no filter adds a port the original port will be restored before headers are sent upstream.
   * Without setting this option, incoming requests with host ``example:443`` will not match against
   * route with :ref:`domains&lt;envoy_v3_api_field_config.route.v3.VirtualHost.domains&gt;` match set to ``example``. Defaults to ``false``. Note that port removal is not part
   * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
   * Only one of ``strip_matching_host_port`` or ``strip_any_host_port`` can be set.
   * </pre>
   *
   * <code>bool strip_any_host_port = 42;</code>
   * @return Whether the stripAnyHostPort field is set.
   */
  boolean hasStripAnyHostPort();
  /**
   * <pre>
   * Determines if the port part should be removed from host/authority header before any processing
   * of request by HTTP filters or routing.
   * This affects the upstream host header unless the method is CONNECT in
   * which case if no filter adds a port the original port will be restored before headers are sent upstream.
   * Without setting this option, incoming requests with host ``example:443`` will not match against
   * route with :ref:`domains&lt;envoy_v3_api_field_config.route.v3.VirtualHost.domains&gt;` match set to ``example``. Defaults to ``false``. Note that port removal is not part
   * of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986&gt;`_ and is provided for convenience.
   * Only one of ``strip_matching_host_port`` or ``strip_any_host_port`` can be set.
   * </pre>
   *
   * <code>bool strip_any_host_port = 42;</code>
   * @return The stripAnyHostPort.
   */
  boolean getStripAnyHostPort();

  /**
   * <pre>
   * Governs Envoy's behavior when receiving invalid HTTP from downstream.
   * If this option is false (default), Envoy will err on the conservative side handling HTTP
   * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
   * If this option is set to true, Envoy will be more permissive, only resetting the invalid
   * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
   * request is read for HTTP/1.1)
   * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
   * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
   * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
   * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
   * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
   * :ref:`override_stream_error_on_invalid_http_message
   * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
   * ``not`` the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
   * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
   * </pre>
   *
   * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
   * @return Whether the streamErrorOnInvalidHttpMessage field is set.
   */
  boolean hasStreamErrorOnInvalidHttpMessage();
  /**
   * <pre>
   * Governs Envoy's behavior when receiving invalid HTTP from downstream.
   * If this option is false (default), Envoy will err on the conservative side handling HTTP
   * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
   * If this option is set to true, Envoy will be more permissive, only resetting the invalid
   * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
   * request is read for HTTP/1.1)
   * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
   * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
   * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
   * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
   * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
   * :ref:`override_stream_error_on_invalid_http_message
   * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
   * ``not`` the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
   * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
   * </pre>
   *
   * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
   * @return The streamErrorOnInvalidHttpMessage.
   */
  com.google.protobuf.BoolValue getStreamErrorOnInvalidHttpMessage();
  /**
   * <pre>
   * Governs Envoy's behavior when receiving invalid HTTP from downstream.
   * If this option is false (default), Envoy will err on the conservative side handling HTTP
   * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
   * If this option is set to true, Envoy will be more permissive, only resetting the invalid
   * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
   * request is read for HTTP/1.1)
   * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
   * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
   * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
   * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
   * &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message&gt;` or the new HTTP/2 option
   * :ref:`override_stream_error_on_invalid_http_message
   * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message&gt;`
   * ``not`` the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
   * &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging&gt;`
   * </pre>
   *
   * <code>.google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;</code>
   */
  com.google.protobuf.BoolValueOrBuilder getStreamErrorOnInvalidHttpMessageOrBuilder();

  /**
   * <pre>
   * [#not-implemented-hide:] Path normalization configuration. This includes
   * configurations for transformations (e.g. RFC 3986 normalization or merge
   * adjacent slashes) and the policy to apply them. The policy determines
   * whether transformations affect the forwarded ``:path`` header. RFC 3986 path
   * normalization is enabled by default and the default policy is that the
   * normalized header will be forwarded. See :ref:`PathNormalizationOptions
   * &lt;envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.PathNormalizationOptions&gt;`
   * for details.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions path_normalization_options = 43;</code>
   * @return Whether the pathNormalizationOptions field is set.
   */
  boolean hasPathNormalizationOptions();
  /**
   * <pre>
   * [#not-implemented-hide:] Path normalization configuration. This includes
   * configurations for transformations (e.g. RFC 3986 normalization or merge
   * adjacent slashes) and the policy to apply them. The policy determines
   * whether transformations affect the forwarded ``:path`` header. RFC 3986 path
   * normalization is enabled by default and the default policy is that the
   * normalized header will be forwarded. See :ref:`PathNormalizationOptions
   * &lt;envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.PathNormalizationOptions&gt;`
   * for details.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions path_normalization_options = 43;</code>
   * @return The pathNormalizationOptions.
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions getPathNormalizationOptions();
  /**
   * <pre>
   * [#not-implemented-hide:] Path normalization configuration. This includes
   * configurations for transformations (e.g. RFC 3986 normalization or merge
   * adjacent slashes) and the policy to apply them. The policy determines
   * whether transformations affect the forwarded ``:path`` header. RFC 3986 path
   * normalization is enabled by default and the default policy is that the
   * normalized header will be forwarded. See :ref:`PathNormalizationOptions
   * &lt;envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.PathNormalizationOptions&gt;`
   * for details.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions path_normalization_options = 43;</code>
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptionsOrBuilder getPathNormalizationOptionsOrBuilder();

  /**
   * <pre>
   * Determines if trailing dot of the host should be removed from host/authority header before any
   * processing of request by HTTP filters or routing.
   * This affects the upstream host header.
   * Without setting this option, incoming requests with host ``example.com.`` will not match against
   * route with :ref:`domains&lt;envoy_v3_api_field_config.route.v3.VirtualHost.domains&gt;` match set to ``example.com``. Defaults to ``false``.
   * When the incoming request contains a host/authority header that includes a port number,
   * setting this option will strip a trailing dot, if present, from the host section,
   * leaving the port as is (e.g. host value ``example.com.:443`` will be updated to ``example.com:443``).
   * </pre>
   *
   * <code>bool strip_trailing_host_dot = 47;</code>
   * @return The stripTrailingHostDot.
   */
  boolean getStripTrailingHostDot();

  /**
   * <pre>
   * Proxy-Status HTTP response header configuration.
   * If this config is set, the Proxy-Status HTTP response header field is
   * populated. By default, it is not.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig proxy_status_config = 49;</code>
   * @return Whether the proxyStatusConfig field is set.
   */
  boolean hasProxyStatusConfig();
  /**
   * <pre>
   * Proxy-Status HTTP response header configuration.
   * If this config is set, the Proxy-Status HTTP response header field is
   * populated. By default, it is not.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig proxy_status_config = 49;</code>
   * @return The proxyStatusConfig.
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig getProxyStatusConfig();
  /**
   * <pre>
   * Proxy-Status HTTP response header configuration.
   * If this config is set, the Proxy-Status HTTP response header field is
   * populated. By default, it is not.
   * </pre>
   *
   * <code>.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig proxy_status_config = 49;</code>
   */
  io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfigOrBuilder getProxyStatusConfigOrBuilder();

  /**
   * <pre>
   * Configuration options for Header Validation (UHV).
   * UHV is an extensible mechanism for checking validity of HTTP requests as well as providing
   * normalization for request attributes, such as URI path.
   * If the typed_header_validation_config is present it overrides the following options:
   * ``normalize_path``, ``merge_slashes``, ``path_with_escaped_slashes_action``
   * ``http_protocol_options.allow_chunked_length``, ``common_http_protocol_options.headers_with_underscores_action``.
   * The default UHV checks the following:
   * #. HTTP/1 header map validity according to `RFC 7230 section 3.2&lt;https://datatracker.ietf.org/doc/html/rfc7230#section-3.2&gt;`_
   * #. Syntax of HTTP/1 request target URI and response status
   * #. HTTP/2 header map validity according to `RFC 7540 section 8.1.2&lt;https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2`_
   * #. Syntax of HTTP/2 pseudo headers
   * #. HTTP/3 header map validity according to `RFC 9114 section 4.3 &lt;https://www.rfc-editor.org/rfc/rfc9114.html&gt;`_
   * #. Syntax of HTTP/3 pseudo headers
   * #. Syntax of ``Content-Length`` and ``Transfer-Encoding``
   * #. Validation of HTTP/1 requests with both ``Content-Length`` and ``Transfer-Encoding`` headers
   * #. Normalization of the URI path according to `Normalization and Comparison &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6&gt;`_
   *    without `case normalization &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1&gt;`_
   * [#not-implemented-hide:]
   * [#extension-category: envoy.http.header_validators]
   * </pre>
   *
   * <code>.envoy.config.core.v3.TypedExtensionConfig typed_header_validation_config = 50;</code>
   * @return Whether the typedHeaderValidationConfig field is set.
   */
  boolean hasTypedHeaderValidationConfig();
  /**
   * <pre>
   * Configuration options for Header Validation (UHV).
   * UHV is an extensible mechanism for checking validity of HTTP requests as well as providing
   * normalization for request attributes, such as URI path.
   * If the typed_header_validation_config is present it overrides the following options:
   * ``normalize_path``, ``merge_slashes``, ``path_with_escaped_slashes_action``
   * ``http_protocol_options.allow_chunked_length``, ``common_http_protocol_options.headers_with_underscores_action``.
   * The default UHV checks the following:
   * #. HTTP/1 header map validity according to `RFC 7230 section 3.2&lt;https://datatracker.ietf.org/doc/html/rfc7230#section-3.2&gt;`_
   * #. Syntax of HTTP/1 request target URI and response status
   * #. HTTP/2 header map validity according to `RFC 7540 section 8.1.2&lt;https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2`_
   * #. Syntax of HTTP/2 pseudo headers
   * #. HTTP/3 header map validity according to `RFC 9114 section 4.3 &lt;https://www.rfc-editor.org/rfc/rfc9114.html&gt;`_
   * #. Syntax of HTTP/3 pseudo headers
   * #. Syntax of ``Content-Length`` and ``Transfer-Encoding``
   * #. Validation of HTTP/1 requests with both ``Content-Length`` and ``Transfer-Encoding`` headers
   * #. Normalization of the URI path according to `Normalization and Comparison &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6&gt;`_
   *    without `case normalization &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1&gt;`_
   * [#not-implemented-hide:]
   * [#extension-category: envoy.http.header_validators]
   * </pre>
   *
   * <code>.envoy.config.core.v3.TypedExtensionConfig typed_header_validation_config = 50;</code>
   * @return The typedHeaderValidationConfig.
   */
  io.envoyproxy.envoy.config.core.v3.TypedExtensionConfig getTypedHeaderValidationConfig();
  /**
   * <pre>
   * Configuration options for Header Validation (UHV).
   * UHV is an extensible mechanism for checking validity of HTTP requests as well as providing
   * normalization for request attributes, such as URI path.
   * If the typed_header_validation_config is present it overrides the following options:
   * ``normalize_path``, ``merge_slashes``, ``path_with_escaped_slashes_action``
   * ``http_protocol_options.allow_chunked_length``, ``common_http_protocol_options.headers_with_underscores_action``.
   * The default UHV checks the following:
   * #. HTTP/1 header map validity according to `RFC 7230 section 3.2&lt;https://datatracker.ietf.org/doc/html/rfc7230#section-3.2&gt;`_
   * #. Syntax of HTTP/1 request target URI and response status
   * #. HTTP/2 header map validity according to `RFC 7540 section 8.1.2&lt;https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2`_
   * #. Syntax of HTTP/2 pseudo headers
   * #. HTTP/3 header map validity according to `RFC 9114 section 4.3 &lt;https://www.rfc-editor.org/rfc/rfc9114.html&gt;`_
   * #. Syntax of HTTP/3 pseudo headers
   * #. Syntax of ``Content-Length`` and ``Transfer-Encoding``
   * #. Validation of HTTP/1 requests with both ``Content-Length`` and ``Transfer-Encoding`` headers
   * #. Normalization of the URI path according to `Normalization and Comparison &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6&gt;`_
   *    without `case normalization &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1&gt;`_
   * [#not-implemented-hide:]
   * [#extension-category: envoy.http.header_validators]
   * </pre>
   *
   * <code>.envoy.config.core.v3.TypedExtensionConfig typed_header_validation_config = 50;</code>
   */
  io.envoyproxy.envoy.config.core.v3.TypedExtensionConfigOrBuilder getTypedHeaderValidationConfigOrBuilder();

  /**
   * <pre>
   * Append the `x-forwarded-port` header with the port value client used to connect to Envoy. It
   * will be ignored if the `x-forwarded-port` header has been set by any trusted proxy in front of Envoy.
   * </pre>
   *
   * <code>bool append_x_forwarded_port = 51;</code>
   * @return The appendXForwardedPort.
   */
  boolean getAppendXForwardedPort();

  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.RouteSpecifierCase getRouteSpecifierCase();

  public io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.StripPortModeCase getStripPortModeCase();
}
