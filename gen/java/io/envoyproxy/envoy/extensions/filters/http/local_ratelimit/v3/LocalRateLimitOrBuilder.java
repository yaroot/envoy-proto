// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/extensions/filters/http/local_ratelimit/v3/local_rate_limit.proto

package io.envoyproxy.envoy.extensions.filters.http.local_ratelimit.v3;

public interface LocalRateLimitOrBuilder extends
    // @@protoc_insertion_point(interface_extends:envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * The human readable prefix to use when emitting stats.
   * </pre>
   *
   * <code>string stat_prefix = 1 [(.validate.rules) = { ... }</code>
   * @return The statPrefix.
   */
  java.lang.String getStatPrefix();
  /**
   * <pre>
   * The human readable prefix to use when emitting stats.
   * </pre>
   *
   * <code>string stat_prefix = 1 [(.validate.rules) = { ... }</code>
   * @return The bytes for statPrefix.
   */
  com.google.protobuf.ByteString
      getStatPrefixBytes();

  /**
   * <pre>
   * This field allows for a custom HTTP response status code to the downstream client when
   * the request has been rate limited.
   * Defaults to 429 (TooManyRequests).
   * .. note::
   *   If this is set to &lt; 400, 429 will be used instead.
   * </pre>
   *
   * <code>.envoy.type.v3.HttpStatus status = 2;</code>
   * @return Whether the status field is set.
   */
  boolean hasStatus();
  /**
   * <pre>
   * This field allows for a custom HTTP response status code to the downstream client when
   * the request has been rate limited.
   * Defaults to 429 (TooManyRequests).
   * .. note::
   *   If this is set to &lt; 400, 429 will be used instead.
   * </pre>
   *
   * <code>.envoy.type.v3.HttpStatus status = 2;</code>
   * @return The status.
   */
  io.envoyproxy.envoy.type.v3.HttpStatus getStatus();
  /**
   * <pre>
   * This field allows for a custom HTTP response status code to the downstream client when
   * the request has been rate limited.
   * Defaults to 429 (TooManyRequests).
   * .. note::
   *   If this is set to &lt; 400, 429 will be used instead.
   * </pre>
   *
   * <code>.envoy.type.v3.HttpStatus status = 2;</code>
   */
  io.envoyproxy.envoy.type.v3.HttpStatusOrBuilder getStatusOrBuilder();

  /**
   * <pre>
   * The token bucket configuration to use for rate limiting requests that are processed by this
   * filter. Each request processed by the filter consumes a single token. If the token is available,
   * the request will be allowed. If no tokens are available, the request will receive the configured
   * rate limit status.
   * .. note::
   *   It's fine for the token bucket to be unset for the global configuration since the rate limit
   *   can be applied at a the virtual host or route level. Thus, the token bucket must be set
   *   for the per route configuration otherwise the config will be rejected.
   * .. note::
   *   When using per route configuration, the bucket becomes unique to that route.
   * .. note::
   *   In the current implementation the token bucket's :ref:`fill_interval
   *   &lt;envoy_v3_api_field_type.v3.TokenBucket.fill_interval&gt;` must be &gt;= 50ms to avoid too aggressive
   *   refills.
   * </pre>
   *
   * <code>.envoy.type.v3.TokenBucket token_bucket = 3;</code>
   * @return Whether the tokenBucket field is set.
   */
  boolean hasTokenBucket();
  /**
   * <pre>
   * The token bucket configuration to use for rate limiting requests that are processed by this
   * filter. Each request processed by the filter consumes a single token. If the token is available,
   * the request will be allowed. If no tokens are available, the request will receive the configured
   * rate limit status.
   * .. note::
   *   It's fine for the token bucket to be unset for the global configuration since the rate limit
   *   can be applied at a the virtual host or route level. Thus, the token bucket must be set
   *   for the per route configuration otherwise the config will be rejected.
   * .. note::
   *   When using per route configuration, the bucket becomes unique to that route.
   * .. note::
   *   In the current implementation the token bucket's :ref:`fill_interval
   *   &lt;envoy_v3_api_field_type.v3.TokenBucket.fill_interval&gt;` must be &gt;= 50ms to avoid too aggressive
   *   refills.
   * </pre>
   *
   * <code>.envoy.type.v3.TokenBucket token_bucket = 3;</code>
   * @return The tokenBucket.
   */
  io.envoyproxy.envoy.type.v3.TokenBucket getTokenBucket();
  /**
   * <pre>
   * The token bucket configuration to use for rate limiting requests that are processed by this
   * filter. Each request processed by the filter consumes a single token. If the token is available,
   * the request will be allowed. If no tokens are available, the request will receive the configured
   * rate limit status.
   * .. note::
   *   It's fine for the token bucket to be unset for the global configuration since the rate limit
   *   can be applied at a the virtual host or route level. Thus, the token bucket must be set
   *   for the per route configuration otherwise the config will be rejected.
   * .. note::
   *   When using per route configuration, the bucket becomes unique to that route.
   * .. note::
   *   In the current implementation the token bucket's :ref:`fill_interval
   *   &lt;envoy_v3_api_field_type.v3.TokenBucket.fill_interval&gt;` must be &gt;= 50ms to avoid too aggressive
   *   refills.
   * </pre>
   *
   * <code>.envoy.type.v3.TokenBucket token_bucket = 3;</code>
   */
  io.envoyproxy.envoy.type.v3.TokenBucketOrBuilder getTokenBucketOrBuilder();

  /**
   * <pre>
   * If set, this will enable -- but not necessarily enforce -- the rate limit for the given
   * fraction of requests.
   * Defaults to 0% of requests for safety.
   * </pre>
   *
   * <code>.envoy.config.core.v3.RuntimeFractionalPercent filter_enabled = 4;</code>
   * @return Whether the filterEnabled field is set.
   */
  boolean hasFilterEnabled();
  /**
   * <pre>
   * If set, this will enable -- but not necessarily enforce -- the rate limit for the given
   * fraction of requests.
   * Defaults to 0% of requests for safety.
   * </pre>
   *
   * <code>.envoy.config.core.v3.RuntimeFractionalPercent filter_enabled = 4;</code>
   * @return The filterEnabled.
   */
  io.envoyproxy.envoy.config.core.v3.RuntimeFractionalPercent getFilterEnabled();
  /**
   * <pre>
   * If set, this will enable -- but not necessarily enforce -- the rate limit for the given
   * fraction of requests.
   * Defaults to 0% of requests for safety.
   * </pre>
   *
   * <code>.envoy.config.core.v3.RuntimeFractionalPercent filter_enabled = 4;</code>
   */
  io.envoyproxy.envoy.config.core.v3.RuntimeFractionalPercentOrBuilder getFilterEnabledOrBuilder();

  /**
   * <pre>
   * If set, this will enforce the rate limit decisions for the given fraction of requests.
   * Note: this only applies to the fraction of enabled requests.
   * Defaults to 0% of requests for safety.
   * </pre>
   *
   * <code>.envoy.config.core.v3.RuntimeFractionalPercent filter_enforced = 5;</code>
   * @return Whether the filterEnforced field is set.
   */
  boolean hasFilterEnforced();
  /**
   * <pre>
   * If set, this will enforce the rate limit decisions for the given fraction of requests.
   * Note: this only applies to the fraction of enabled requests.
   * Defaults to 0% of requests for safety.
   * </pre>
   *
   * <code>.envoy.config.core.v3.RuntimeFractionalPercent filter_enforced = 5;</code>
   * @return The filterEnforced.
   */
  io.envoyproxy.envoy.config.core.v3.RuntimeFractionalPercent getFilterEnforced();
  /**
   * <pre>
   * If set, this will enforce the rate limit decisions for the given fraction of requests.
   * Note: this only applies to the fraction of enabled requests.
   * Defaults to 0% of requests for safety.
   * </pre>
   *
   * <code>.envoy.config.core.v3.RuntimeFractionalPercent filter_enforced = 5;</code>
   */
  io.envoyproxy.envoy.config.core.v3.RuntimeFractionalPercentOrBuilder getFilterEnforcedOrBuilder();

  /**
   * <pre>
   * Specifies a list of HTTP headers that should be added to each request that
   * has been rate limited and is also forwarded upstream. This can only occur when the
   * filter is enabled but not enforced.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add_when_not_enforced = 10 [(.validate.rules) = { ... }</code>
   */
  java.util.List<io.envoyproxy.envoy.config.core.v3.HeaderValueOption> 
      getRequestHeadersToAddWhenNotEnforcedList();
  /**
   * <pre>
   * Specifies a list of HTTP headers that should be added to each request that
   * has been rate limited and is also forwarded upstream. This can only occur when the
   * filter is enabled but not enforced.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add_when_not_enforced = 10 [(.validate.rules) = { ... }</code>
   */
  io.envoyproxy.envoy.config.core.v3.HeaderValueOption getRequestHeadersToAddWhenNotEnforced(int index);
  /**
   * <pre>
   * Specifies a list of HTTP headers that should be added to each request that
   * has been rate limited and is also forwarded upstream. This can only occur when the
   * filter is enabled but not enforced.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add_when_not_enforced = 10 [(.validate.rules) = { ... }</code>
   */
  int getRequestHeadersToAddWhenNotEnforcedCount();
  /**
   * <pre>
   * Specifies a list of HTTP headers that should be added to each request that
   * has been rate limited and is also forwarded upstream. This can only occur when the
   * filter is enabled but not enforced.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add_when_not_enforced = 10 [(.validate.rules) = { ... }</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.config.core.v3.HeaderValueOptionOrBuilder> 
      getRequestHeadersToAddWhenNotEnforcedOrBuilderList();
  /**
   * <pre>
   * Specifies a list of HTTP headers that should be added to each request that
   * has been rate limited and is also forwarded upstream. This can only occur when the
   * filter is enabled but not enforced.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add_when_not_enforced = 10 [(.validate.rules) = { ... }</code>
   */
  io.envoyproxy.envoy.config.core.v3.HeaderValueOptionOrBuilder getRequestHeadersToAddWhenNotEnforcedOrBuilder(
      int index);

  /**
   * <pre>
   * Specifies a list of HTTP headers that should be added to each response for requests that
   * have been rate limited. This occurs when the filter is either enabled or fully enforced.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.HeaderValueOption response_headers_to_add = 6 [(.validate.rules) = { ... }</code>
   */
  java.util.List<io.envoyproxy.envoy.config.core.v3.HeaderValueOption> 
      getResponseHeadersToAddList();
  /**
   * <pre>
   * Specifies a list of HTTP headers that should be added to each response for requests that
   * have been rate limited. This occurs when the filter is either enabled or fully enforced.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.HeaderValueOption response_headers_to_add = 6 [(.validate.rules) = { ... }</code>
   */
  io.envoyproxy.envoy.config.core.v3.HeaderValueOption getResponseHeadersToAdd(int index);
  /**
   * <pre>
   * Specifies a list of HTTP headers that should be added to each response for requests that
   * have been rate limited. This occurs when the filter is either enabled or fully enforced.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.HeaderValueOption response_headers_to_add = 6 [(.validate.rules) = { ... }</code>
   */
  int getResponseHeadersToAddCount();
  /**
   * <pre>
   * Specifies a list of HTTP headers that should be added to each response for requests that
   * have been rate limited. This occurs when the filter is either enabled or fully enforced.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.HeaderValueOption response_headers_to_add = 6 [(.validate.rules) = { ... }</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.config.core.v3.HeaderValueOptionOrBuilder> 
      getResponseHeadersToAddOrBuilderList();
  /**
   * <pre>
   * Specifies a list of HTTP headers that should be added to each response for requests that
   * have been rate limited. This occurs when the filter is either enabled or fully enforced.
   * </pre>
   *
   * <code>repeated .envoy.config.core.v3.HeaderValueOption response_headers_to_add = 6 [(.validate.rules) = { ... }</code>
   */
  io.envoyproxy.envoy.config.core.v3.HeaderValueOptionOrBuilder getResponseHeadersToAddOrBuilder(
      int index);

  /**
   * <pre>
   * The rate limit descriptor list to use in the local rate limit to override
   * on. The rate limit descriptor is selected by the first full match from the
   * request descriptors.
   * Example on how to use ::ref:`this &lt;config_http_filters_local_rate_limit_descriptors&gt;`
   * .. note::
   *   In the current implementation the descriptor's token bucket :ref:`fill_interval
   *   &lt;envoy_v3_api_field_type.v3.TokenBucket.fill_interval&gt;` must be a multiple
   *   global :ref:`token bucket's&lt;envoy_v3_api_field_extensions.filters.http.local_ratelimit.v3.LocalRateLimit.token_bucket&gt;` fill interval.
   *   The descriptors must match verbatim for rate limiting to apply. There is no partial
   *   match by a subset of descriptor entries in the current implementation.
   * </pre>
   *
   * <code>repeated .envoy.extensions.common.ratelimit.v3.LocalRateLimitDescriptor descriptors = 8;</code>
   */
  java.util.List<io.envoyproxy.envoy.extensions.common.ratelimit.v3.LocalRateLimitDescriptor> 
      getDescriptorsList();
  /**
   * <pre>
   * The rate limit descriptor list to use in the local rate limit to override
   * on. The rate limit descriptor is selected by the first full match from the
   * request descriptors.
   * Example on how to use ::ref:`this &lt;config_http_filters_local_rate_limit_descriptors&gt;`
   * .. note::
   *   In the current implementation the descriptor's token bucket :ref:`fill_interval
   *   &lt;envoy_v3_api_field_type.v3.TokenBucket.fill_interval&gt;` must be a multiple
   *   global :ref:`token bucket's&lt;envoy_v3_api_field_extensions.filters.http.local_ratelimit.v3.LocalRateLimit.token_bucket&gt;` fill interval.
   *   The descriptors must match verbatim for rate limiting to apply. There is no partial
   *   match by a subset of descriptor entries in the current implementation.
   * </pre>
   *
   * <code>repeated .envoy.extensions.common.ratelimit.v3.LocalRateLimitDescriptor descriptors = 8;</code>
   */
  io.envoyproxy.envoy.extensions.common.ratelimit.v3.LocalRateLimitDescriptor getDescriptors(int index);
  /**
   * <pre>
   * The rate limit descriptor list to use in the local rate limit to override
   * on. The rate limit descriptor is selected by the first full match from the
   * request descriptors.
   * Example on how to use ::ref:`this &lt;config_http_filters_local_rate_limit_descriptors&gt;`
   * .. note::
   *   In the current implementation the descriptor's token bucket :ref:`fill_interval
   *   &lt;envoy_v3_api_field_type.v3.TokenBucket.fill_interval&gt;` must be a multiple
   *   global :ref:`token bucket's&lt;envoy_v3_api_field_extensions.filters.http.local_ratelimit.v3.LocalRateLimit.token_bucket&gt;` fill interval.
   *   The descriptors must match verbatim for rate limiting to apply. There is no partial
   *   match by a subset of descriptor entries in the current implementation.
   * </pre>
   *
   * <code>repeated .envoy.extensions.common.ratelimit.v3.LocalRateLimitDescriptor descriptors = 8;</code>
   */
  int getDescriptorsCount();
  /**
   * <pre>
   * The rate limit descriptor list to use in the local rate limit to override
   * on. The rate limit descriptor is selected by the first full match from the
   * request descriptors.
   * Example on how to use ::ref:`this &lt;config_http_filters_local_rate_limit_descriptors&gt;`
   * .. note::
   *   In the current implementation the descriptor's token bucket :ref:`fill_interval
   *   &lt;envoy_v3_api_field_type.v3.TokenBucket.fill_interval&gt;` must be a multiple
   *   global :ref:`token bucket's&lt;envoy_v3_api_field_extensions.filters.http.local_ratelimit.v3.LocalRateLimit.token_bucket&gt;` fill interval.
   *   The descriptors must match verbatim for rate limiting to apply. There is no partial
   *   match by a subset of descriptor entries in the current implementation.
   * </pre>
   *
   * <code>repeated .envoy.extensions.common.ratelimit.v3.LocalRateLimitDescriptor descriptors = 8;</code>
   */
  java.util.List<? extends io.envoyproxy.envoy.extensions.common.ratelimit.v3.LocalRateLimitDescriptorOrBuilder> 
      getDescriptorsOrBuilderList();
  /**
   * <pre>
   * The rate limit descriptor list to use in the local rate limit to override
   * on. The rate limit descriptor is selected by the first full match from the
   * request descriptors.
   * Example on how to use ::ref:`this &lt;config_http_filters_local_rate_limit_descriptors&gt;`
   * .. note::
   *   In the current implementation the descriptor's token bucket :ref:`fill_interval
   *   &lt;envoy_v3_api_field_type.v3.TokenBucket.fill_interval&gt;` must be a multiple
   *   global :ref:`token bucket's&lt;envoy_v3_api_field_extensions.filters.http.local_ratelimit.v3.LocalRateLimit.token_bucket&gt;` fill interval.
   *   The descriptors must match verbatim for rate limiting to apply. There is no partial
   *   match by a subset of descriptor entries in the current implementation.
   * </pre>
   *
   * <code>repeated .envoy.extensions.common.ratelimit.v3.LocalRateLimitDescriptor descriptors = 8;</code>
   */
  io.envoyproxy.envoy.extensions.common.ratelimit.v3.LocalRateLimitDescriptorOrBuilder getDescriptorsOrBuilder(
      int index);

  /**
   * <pre>
   * Specifies the rate limit configurations to be applied with the same
   * stage number. If not set, the default stage number is 0.
   * .. note::
   *  The filter supports a range of 0 - 10 inclusively for stage numbers.
   * </pre>
   *
   * <code>uint32 stage = 9 [(.validate.rules) = { ... }</code>
   * @return The stage.
   */
  int getStage();

  /**
   * <pre>
   * Specifies the scope of the rate limiter's token bucket.
   * If set to false, the token bucket is shared across all worker threads,
   * thus the rate limits are applied per Envoy process.
   * If set to true, a token bucket is allocated for each connection.
   * Thus the rate limits are applied per connection thereby allowing
   * one to rate limit requests on a per connection basis.
   * If unspecified, the default value is false.
   * </pre>
   *
   * <code>bool local_rate_limit_per_downstream_connection = 11;</code>
   * @return The localRateLimitPerDownstreamConnection.
   */
  boolean getLocalRateLimitPerDownstreamConnection();

  /**
   * <pre>
   * Defines the standard version to use for X-RateLimit headers emitted by the filter.
   * Disabled by default.
   * </pre>
   *
   * <code>.envoy.extensions.common.ratelimit.v3.XRateLimitHeadersRFCVersion enable_x_ratelimit_headers = 12 [(.validate.rules) = { ... }</code>
   * @return The enum numeric value on the wire for enableXRatelimitHeaders.
   */
  int getEnableXRatelimitHeadersValue();
  /**
   * <pre>
   * Defines the standard version to use for X-RateLimit headers emitted by the filter.
   * Disabled by default.
   * </pre>
   *
   * <code>.envoy.extensions.common.ratelimit.v3.XRateLimitHeadersRFCVersion enable_x_ratelimit_headers = 12 [(.validate.rules) = { ... }</code>
   * @return The enableXRatelimitHeaders.
   */
  io.envoyproxy.envoy.extensions.common.ratelimit.v3.XRateLimitHeadersRFCVersion getEnableXRatelimitHeaders();
}
