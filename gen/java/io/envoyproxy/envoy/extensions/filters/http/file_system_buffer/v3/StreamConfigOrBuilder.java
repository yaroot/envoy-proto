// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/extensions/filters/http/file_system_buffer/v3/file_system_buffer.proto

package io.envoyproxy.envoy.extensions.filters.http.file_system_buffer.v3;

public interface StreamConfigOrBuilder extends
    // @@protoc_insertion_point(interface_extends:envoy.extensions.filters.http.file_system_buffer.v3.StreamConfig)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * Whether to bypass / stream / fully buffer / etc.
   * If unset in route, vhost and listener config, the default is ``stream_when_possible``.
   * </pre>
   *
   * <code>.envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior behavior = 1;</code>
   * @return Whether the behavior field is set.
   */
  boolean hasBehavior();
  /**
   * <pre>
   * Whether to bypass / stream / fully buffer / etc.
   * If unset in route, vhost and listener config, the default is ``stream_when_possible``.
   * </pre>
   *
   * <code>.envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior behavior = 1;</code>
   * @return The behavior.
   */
  io.envoyproxy.envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior getBehavior();
  /**
   * <pre>
   * Whether to bypass / stream / fully buffer / etc.
   * If unset in route, vhost and listener config, the default is ``stream_when_possible``.
   * </pre>
   *
   * <code>.envoy.extensions.filters.http.file_system_buffer.v3.BufferBehavior behavior = 1;</code>
   */
  io.envoyproxy.envoy.extensions.filters.http.file_system_buffer.v3.BufferBehaviorOrBuilder getBehaviorOrBuilder();

  /**
   * <pre>
   * The amount stored in the memory buffer before buffering to disk.
   * If unset in route, vhost and listener config, defaults to a hardcoded value of 1MiB
   * </pre>
   *
   * <code>.google.protobuf.UInt64Value memory_buffer_bytes_limit = 2 [(.validate.rules) = { ... }</code>
   * @return Whether the memoryBufferBytesLimit field is set.
   */
  boolean hasMemoryBufferBytesLimit();
  /**
   * <pre>
   * The amount stored in the memory buffer before buffering to disk.
   * If unset in route, vhost and listener config, defaults to a hardcoded value of 1MiB
   * </pre>
   *
   * <code>.google.protobuf.UInt64Value memory_buffer_bytes_limit = 2 [(.validate.rules) = { ... }</code>
   * @return The memoryBufferBytesLimit.
   */
  com.google.protobuf.UInt64Value getMemoryBufferBytesLimit();
  /**
   * <pre>
   * The amount stored in the memory buffer before buffering to disk.
   * If unset in route, vhost and listener config, defaults to a hardcoded value of 1MiB
   * </pre>
   *
   * <code>.google.protobuf.UInt64Value memory_buffer_bytes_limit = 2 [(.validate.rules) = { ... }</code>
   */
  com.google.protobuf.UInt64ValueOrBuilder getMemoryBufferBytesLimitOrBuilder();

  /**
   * <pre>
   * The maximum storage (excluding memory) to be buffered in this filter.
   * If unset in route, vhost and listener config, defaults to a hardcoded value of 32MiB
   * </pre>
   *
   * <code>.google.protobuf.UInt64Value storage_buffer_bytes_limit = 3;</code>
   * @return Whether the storageBufferBytesLimit field is set.
   */
  boolean hasStorageBufferBytesLimit();
  /**
   * <pre>
   * The maximum storage (excluding memory) to be buffered in this filter.
   * If unset in route, vhost and listener config, defaults to a hardcoded value of 32MiB
   * </pre>
   *
   * <code>.google.protobuf.UInt64Value storage_buffer_bytes_limit = 3;</code>
   * @return The storageBufferBytesLimit.
   */
  com.google.protobuf.UInt64Value getStorageBufferBytesLimit();
  /**
   * <pre>
   * The maximum storage (excluding memory) to be buffered in this filter.
   * If unset in route, vhost and listener config, defaults to a hardcoded value of 32MiB
   * </pre>
   *
   * <code>.google.protobuf.UInt64Value storage_buffer_bytes_limit = 3;</code>
   */
  com.google.protobuf.UInt64ValueOrBuilder getStorageBufferBytesLimitOrBuilder();

  /**
   * <pre>
   * The maximum amount that can be queued for writing to storage, above which the
   * source is requested to pause. If unset, defaults to the same value as
   * ``memory_buffer_bytes_limit``.
   * For example, assuming the recipient is not consuming data at all, if
   * ``memory_buffer_bytes_limit`` was 32MiB, and ``storage_buffer_queue_high_watermark_bytes``
   * was 64MiB, and the filesystem is backed up so writes are not occurring promptly,
   * then:
   * * Any request less than 32MiB will eventually pass through without ever attempting
   *   to write to disk.
   * * Any request with over 32MiB buffered will start trying to write to disk.
   *   If it reaches (32+64)MiB buffered in memory (write to disk isn't keeping up), a high
   *   watermark signal is sent to the source.
   * * Any stream whose total size exceeds
   *   ``memory_buffer_bytes_limit + storage_buffer_bytes_limit`` will provoke an error.
   *   (Note, if the recipient *is* consuming data then it is possible for such an
   *   oversized request to pass through the buffer filter, provided the recipient
   *   isn't consuming data too slowly.)
   * The low watermark signal is sent when the memory buffer is at size
   * ``memory_buffer_bytes_limit + (storage_buffer_queue_high_watermark_bytes / 2)``.
   * </pre>
   *
   * <code>.google.protobuf.UInt64Value storage_buffer_queue_high_watermark_bytes = 4;</code>
   * @return Whether the storageBufferQueueHighWatermarkBytes field is set.
   */
  boolean hasStorageBufferQueueHighWatermarkBytes();
  /**
   * <pre>
   * The maximum amount that can be queued for writing to storage, above which the
   * source is requested to pause. If unset, defaults to the same value as
   * ``memory_buffer_bytes_limit``.
   * For example, assuming the recipient is not consuming data at all, if
   * ``memory_buffer_bytes_limit`` was 32MiB, and ``storage_buffer_queue_high_watermark_bytes``
   * was 64MiB, and the filesystem is backed up so writes are not occurring promptly,
   * then:
   * * Any request less than 32MiB will eventually pass through without ever attempting
   *   to write to disk.
   * * Any request with over 32MiB buffered will start trying to write to disk.
   *   If it reaches (32+64)MiB buffered in memory (write to disk isn't keeping up), a high
   *   watermark signal is sent to the source.
   * * Any stream whose total size exceeds
   *   ``memory_buffer_bytes_limit + storage_buffer_bytes_limit`` will provoke an error.
   *   (Note, if the recipient *is* consuming data then it is possible for such an
   *   oversized request to pass through the buffer filter, provided the recipient
   *   isn't consuming data too slowly.)
   * The low watermark signal is sent when the memory buffer is at size
   * ``memory_buffer_bytes_limit + (storage_buffer_queue_high_watermark_bytes / 2)``.
   * </pre>
   *
   * <code>.google.protobuf.UInt64Value storage_buffer_queue_high_watermark_bytes = 4;</code>
   * @return The storageBufferQueueHighWatermarkBytes.
   */
  com.google.protobuf.UInt64Value getStorageBufferQueueHighWatermarkBytes();
  /**
   * <pre>
   * The maximum amount that can be queued for writing to storage, above which the
   * source is requested to pause. If unset, defaults to the same value as
   * ``memory_buffer_bytes_limit``.
   * For example, assuming the recipient is not consuming data at all, if
   * ``memory_buffer_bytes_limit`` was 32MiB, and ``storage_buffer_queue_high_watermark_bytes``
   * was 64MiB, and the filesystem is backed up so writes are not occurring promptly,
   * then:
   * * Any request less than 32MiB will eventually pass through without ever attempting
   *   to write to disk.
   * * Any request with over 32MiB buffered will start trying to write to disk.
   *   If it reaches (32+64)MiB buffered in memory (write to disk isn't keeping up), a high
   *   watermark signal is sent to the source.
   * * Any stream whose total size exceeds
   *   ``memory_buffer_bytes_limit + storage_buffer_bytes_limit`` will provoke an error.
   *   (Note, if the recipient *is* consuming data then it is possible for such an
   *   oversized request to pass through the buffer filter, provided the recipient
   *   isn't consuming data too slowly.)
   * The low watermark signal is sent when the memory buffer is at size
   * ``memory_buffer_bytes_limit + (storage_buffer_queue_high_watermark_bytes / 2)``.
   * </pre>
   *
   * <code>.google.protobuf.UInt64Value storage_buffer_queue_high_watermark_bytes = 4;</code>
   */
  com.google.protobuf.UInt64ValueOrBuilder getStorageBufferQueueHighWatermarkBytesOrBuilder();
}
