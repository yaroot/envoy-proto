// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/timeseriesinsights/v1/timeseries_insights.proto

package com.google.cloud.timeseriesinsights.v1;

public interface TimeseriesParamsOrBuilder extends
    // @@protoc_insertion_point(interface_extends:google.cloud.timeseriesinsights.v1.TimeseriesParams)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * Required. How long should we go in the past when fetching the timeline used for
   * forecasting each slice.
   * This is used in combination with the
   * [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time] parameter.
   * The time series we construct will have the following time range:
   * `[detectionTime - forecastHistory, detectionTime + granularity]`.
   * The forecast history might be rounded up, so that a multiple of
   * `granularity` is used to process the query.
   * Note: If there are not enough events in the
   * `[detectionTime - forecastHistory, detectionTime + granularity]` time
   * interval, the slice evaluation can fail. For more information, see
   * [EvaluatedSlice.status][google.cloud.timeseriesinsights.v1.EvaluatedSlice.status].
   * </pre>
   *
   * <code>.google.protobuf.Duration forecast_history = 1 [(.google.api.field_behavior) = REQUIRED];</code>
   * @return Whether the forecastHistory field is set.
   */
  boolean hasForecastHistory();
  /**
   * <pre>
   * Required. How long should we go in the past when fetching the timeline used for
   * forecasting each slice.
   * This is used in combination with the
   * [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time] parameter.
   * The time series we construct will have the following time range:
   * `[detectionTime - forecastHistory, detectionTime + granularity]`.
   * The forecast history might be rounded up, so that a multiple of
   * `granularity` is used to process the query.
   * Note: If there are not enough events in the
   * `[detectionTime - forecastHistory, detectionTime + granularity]` time
   * interval, the slice evaluation can fail. For more information, see
   * [EvaluatedSlice.status][google.cloud.timeseriesinsights.v1.EvaluatedSlice.status].
   * </pre>
   *
   * <code>.google.protobuf.Duration forecast_history = 1 [(.google.api.field_behavior) = REQUIRED];</code>
   * @return The forecastHistory.
   */
  com.google.protobuf.Duration getForecastHistory();
  /**
   * <pre>
   * Required. How long should we go in the past when fetching the timeline used for
   * forecasting each slice.
   * This is used in combination with the
   * [detectionTime][google.cloud.timeseriesinsights.v1.QueryDataSetRequest.detection_time] parameter.
   * The time series we construct will have the following time range:
   * `[detectionTime - forecastHistory, detectionTime + granularity]`.
   * The forecast history might be rounded up, so that a multiple of
   * `granularity` is used to process the query.
   * Note: If there are not enough events in the
   * `[detectionTime - forecastHistory, detectionTime + granularity]` time
   * interval, the slice evaluation can fail. For more information, see
   * [EvaluatedSlice.status][google.cloud.timeseriesinsights.v1.EvaluatedSlice.status].
   * </pre>
   *
   * <code>.google.protobuf.Duration forecast_history = 1 [(.google.api.field_behavior) = REQUIRED];</code>
   */
  com.google.protobuf.DurationOrBuilder getForecastHistoryOrBuilder();

  /**
   * <pre>
   * Required. The time granularity of the time series (on the x-axis). Each time series
   * point starting at time T will aggregate all events for a particular slice
   * in *[T, T + granularity)* time windows.
   * Note: The aggregation is decided based on the
   * [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] parameter.
   * This granularity defines the query-time aggregation windows and is not
   * necessarily related to any event time granularity in the raw data (though
   * we do recommend that the query-time granularity is not finer than the
   * ingestion-time one).
   * Currently, the minimal supported granularity is 10 seconds.
   * </pre>
   *
   * <code>.google.protobuf.Duration granularity = 2 [(.google.api.field_behavior) = REQUIRED];</code>
   * @return Whether the granularity field is set.
   */
  boolean hasGranularity();
  /**
   * <pre>
   * Required. The time granularity of the time series (on the x-axis). Each time series
   * point starting at time T will aggregate all events for a particular slice
   * in *[T, T + granularity)* time windows.
   * Note: The aggregation is decided based on the
   * [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] parameter.
   * This granularity defines the query-time aggregation windows and is not
   * necessarily related to any event time granularity in the raw data (though
   * we do recommend that the query-time granularity is not finer than the
   * ingestion-time one).
   * Currently, the minimal supported granularity is 10 seconds.
   * </pre>
   *
   * <code>.google.protobuf.Duration granularity = 2 [(.google.api.field_behavior) = REQUIRED];</code>
   * @return The granularity.
   */
  com.google.protobuf.Duration getGranularity();
  /**
   * <pre>
   * Required. The time granularity of the time series (on the x-axis). Each time series
   * point starting at time T will aggregate all events for a particular slice
   * in *[T, T + granularity)* time windows.
   * Note: The aggregation is decided based on the
   * [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] parameter.
   * This granularity defines the query-time aggregation windows and is not
   * necessarily related to any event time granularity in the raw data (though
   * we do recommend that the query-time granularity is not finer than the
   * ingestion-time one).
   * Currently, the minimal supported granularity is 10 seconds.
   * </pre>
   *
   * <code>.google.protobuf.Duration granularity = 2 [(.google.api.field_behavior) = REQUIRED];</code>
   */
  com.google.protobuf.DurationOrBuilder getGranularityOrBuilder();

  /**
   * <pre>
   * Optional. Denotes the [name][google.cloud.timeseriesinsights.v1.EventDimension.name] of a numerical
   * dimension that will have its values aggregated to compute the y-axis of the
   * time series.
   * The aggregation method must also be specified by setting the
   * [metricAggregationMethod][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]
   * field.
   * Note: Currently, if the aggregation method is unspecified, we will
   * default to SUM for backward compatibility reasons, but new implementations
   * should set the
   * [metricAggregationMethod][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]
   * explicitly.
   * If the metric is unspecified, we will use the number of events that each
   * time series point contains as the point value.
   * Example: Let's assume we have the following three events in our dataset:
   * ```json
   * {
   *   eventTime: "2020-12-27T00:00:00Z",
   *   dimensions: [
   *     { name: "d1" stringVal: "v1" },
   *     { name: "d2" stringVal: "v2" }
   *     { name: "m1" longVal: 100 }
   *     { name: "m2" longVal: 11 }
   *   ]
   * },
   * {
   *   eventTime: "2020-12-27T00:10:00Z",
   *   dimensions: [
   *     { name: "d1" stringVal: "v1" },
   *     { name: "d2" stringVal: "v2" }
   *     { name: "m1" longVal: 200 }
   *     { name: "m2" longVal: 22 }
   *   ]
   * },
   * {
   *   eventTime: "2020-12-27T00:20:00Z",
   *   dimensions: [
   *     { name: "d1" stringVal: "v1" },
   *     { name: "d2" stringVal: "v2" }
   *     { name: "m1" longVal: 300 }
   *     { name: "m2" longVal: 33 }
   *   ]
   * }
   * ```
   * These events are all within the same hour, spaced 10 minutes between each
   * of them. Assuming our [QueryDataSetRequest][google.cloud.timeseriesinsights.v1.QueryDataSetRequest] had set
   * [slicingParams.dimensionNames][google.cloud.timeseriesinsights.v1.SlicingParams.dimension_names] to ["d1",
   * "d2"] and [timeseries_params.granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity] to
   * "3600s", then all the previous events will be aggregated into the same
   * [timeseries point][google.cloud.timeseriesinsights.v1.TimeseriesPoint].
   * The time series point that they're all part of will have the
   * [time][google.cloud.timeseriesinsights.v1.TimeseriesPoint.time] set to "2020-12-27T00:00:00Z" and the
   * [value][google.cloud.timeseriesinsights.v1.TimeseriesPoint.value] populated based on this metric field:
   * - If the metric is set to "m1" and metric_aggregation_method to SUM, then
   * the value of the point will be 600.
   * - If the metric is set to "m2" and metric_aggregation_method to SUM, then
   * the value of the point will be 66.
   * - If the metric is set to "m1" and metric_aggregation_method to AVERAGE,
   * then the value of the point will be 200.
   * - If the metric is set to "m2" and metric_aggregation_method to AVERAGE,
   * then the value of the point will be 22.
   * - If the metric field is "" or unspecified, then the value of the point
   * will be 3, as we will simply count the events.
   * </pre>
   *
   * <code>optional string metric = 4 [(.google.api.field_behavior) = OPTIONAL];</code>
   * @return Whether the metric field is set.
   */
  boolean hasMetric();
  /**
   * <pre>
   * Optional. Denotes the [name][google.cloud.timeseriesinsights.v1.EventDimension.name] of a numerical
   * dimension that will have its values aggregated to compute the y-axis of the
   * time series.
   * The aggregation method must also be specified by setting the
   * [metricAggregationMethod][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]
   * field.
   * Note: Currently, if the aggregation method is unspecified, we will
   * default to SUM for backward compatibility reasons, but new implementations
   * should set the
   * [metricAggregationMethod][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]
   * explicitly.
   * If the metric is unspecified, we will use the number of events that each
   * time series point contains as the point value.
   * Example: Let's assume we have the following three events in our dataset:
   * ```json
   * {
   *   eventTime: "2020-12-27T00:00:00Z",
   *   dimensions: [
   *     { name: "d1" stringVal: "v1" },
   *     { name: "d2" stringVal: "v2" }
   *     { name: "m1" longVal: 100 }
   *     { name: "m2" longVal: 11 }
   *   ]
   * },
   * {
   *   eventTime: "2020-12-27T00:10:00Z",
   *   dimensions: [
   *     { name: "d1" stringVal: "v1" },
   *     { name: "d2" stringVal: "v2" }
   *     { name: "m1" longVal: 200 }
   *     { name: "m2" longVal: 22 }
   *   ]
   * },
   * {
   *   eventTime: "2020-12-27T00:20:00Z",
   *   dimensions: [
   *     { name: "d1" stringVal: "v1" },
   *     { name: "d2" stringVal: "v2" }
   *     { name: "m1" longVal: 300 }
   *     { name: "m2" longVal: 33 }
   *   ]
   * }
   * ```
   * These events are all within the same hour, spaced 10 minutes between each
   * of them. Assuming our [QueryDataSetRequest][google.cloud.timeseriesinsights.v1.QueryDataSetRequest] had set
   * [slicingParams.dimensionNames][google.cloud.timeseriesinsights.v1.SlicingParams.dimension_names] to ["d1",
   * "d2"] and [timeseries_params.granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity] to
   * "3600s", then all the previous events will be aggregated into the same
   * [timeseries point][google.cloud.timeseriesinsights.v1.TimeseriesPoint].
   * The time series point that they're all part of will have the
   * [time][google.cloud.timeseriesinsights.v1.TimeseriesPoint.time] set to "2020-12-27T00:00:00Z" and the
   * [value][google.cloud.timeseriesinsights.v1.TimeseriesPoint.value] populated based on this metric field:
   * - If the metric is set to "m1" and metric_aggregation_method to SUM, then
   * the value of the point will be 600.
   * - If the metric is set to "m2" and metric_aggregation_method to SUM, then
   * the value of the point will be 66.
   * - If the metric is set to "m1" and metric_aggregation_method to AVERAGE,
   * then the value of the point will be 200.
   * - If the metric is set to "m2" and metric_aggregation_method to AVERAGE,
   * then the value of the point will be 22.
   * - If the metric field is "" or unspecified, then the value of the point
   * will be 3, as we will simply count the events.
   * </pre>
   *
   * <code>optional string metric = 4 [(.google.api.field_behavior) = OPTIONAL];</code>
   * @return The metric.
   */
  java.lang.String getMetric();
  /**
   * <pre>
   * Optional. Denotes the [name][google.cloud.timeseriesinsights.v1.EventDimension.name] of a numerical
   * dimension that will have its values aggregated to compute the y-axis of the
   * time series.
   * The aggregation method must also be specified by setting the
   * [metricAggregationMethod][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]
   * field.
   * Note: Currently, if the aggregation method is unspecified, we will
   * default to SUM for backward compatibility reasons, but new implementations
   * should set the
   * [metricAggregationMethod][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric_aggregation_method]
   * explicitly.
   * If the metric is unspecified, we will use the number of events that each
   * time series point contains as the point value.
   * Example: Let's assume we have the following three events in our dataset:
   * ```json
   * {
   *   eventTime: "2020-12-27T00:00:00Z",
   *   dimensions: [
   *     { name: "d1" stringVal: "v1" },
   *     { name: "d2" stringVal: "v2" }
   *     { name: "m1" longVal: 100 }
   *     { name: "m2" longVal: 11 }
   *   ]
   * },
   * {
   *   eventTime: "2020-12-27T00:10:00Z",
   *   dimensions: [
   *     { name: "d1" stringVal: "v1" },
   *     { name: "d2" stringVal: "v2" }
   *     { name: "m1" longVal: 200 }
   *     { name: "m2" longVal: 22 }
   *   ]
   * },
   * {
   *   eventTime: "2020-12-27T00:20:00Z",
   *   dimensions: [
   *     { name: "d1" stringVal: "v1" },
   *     { name: "d2" stringVal: "v2" }
   *     { name: "m1" longVal: 300 }
   *     { name: "m2" longVal: 33 }
   *   ]
   * }
   * ```
   * These events are all within the same hour, spaced 10 minutes between each
   * of them. Assuming our [QueryDataSetRequest][google.cloud.timeseriesinsights.v1.QueryDataSetRequest] had set
   * [slicingParams.dimensionNames][google.cloud.timeseriesinsights.v1.SlicingParams.dimension_names] to ["d1",
   * "d2"] and [timeseries_params.granularity][google.cloud.timeseriesinsights.v1.TimeseriesParams.granularity] to
   * "3600s", then all the previous events will be aggregated into the same
   * [timeseries point][google.cloud.timeseriesinsights.v1.TimeseriesPoint].
   * The time series point that they're all part of will have the
   * [time][google.cloud.timeseriesinsights.v1.TimeseriesPoint.time] set to "2020-12-27T00:00:00Z" and the
   * [value][google.cloud.timeseriesinsights.v1.TimeseriesPoint.value] populated based on this metric field:
   * - If the metric is set to "m1" and metric_aggregation_method to SUM, then
   * the value of the point will be 600.
   * - If the metric is set to "m2" and metric_aggregation_method to SUM, then
   * the value of the point will be 66.
   * - If the metric is set to "m1" and metric_aggregation_method to AVERAGE,
   * then the value of the point will be 200.
   * - If the metric is set to "m2" and metric_aggregation_method to AVERAGE,
   * then the value of the point will be 22.
   * - If the metric field is "" or unspecified, then the value of the point
   * will be 3, as we will simply count the events.
   * </pre>
   *
   * <code>optional string metric = 4 [(.google.api.field_behavior) = OPTIONAL];</code>
   * @return The bytes for metric.
   */
  com.google.protobuf.ByteString
      getMetricBytes();

  /**
   * <pre>
   * Optional. Together with the [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] field, specifies how
   * we will aggregate multiple events to obtain the value of a time series
   * point. See the [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] documentation for more
   * details.
   * If the metric is not specified or "", then this field will be ignored.
   * </pre>
   *
   * <code>.google.cloud.timeseriesinsights.v1.TimeseriesParams.AggregationMethod metric_aggregation_method = 5 [(.google.api.field_behavior) = OPTIONAL];</code>
   * @return The enum numeric value on the wire for metricAggregationMethod.
   */
  int getMetricAggregationMethodValue();
  /**
   * <pre>
   * Optional. Together with the [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] field, specifies how
   * we will aggregate multiple events to obtain the value of a time series
   * point. See the [metric][google.cloud.timeseriesinsights.v1.TimeseriesParams.metric] documentation for more
   * details.
   * If the metric is not specified or "", then this field will be ignored.
   * </pre>
   *
   * <code>.google.cloud.timeseriesinsights.v1.TimeseriesParams.AggregationMethod metric_aggregation_method = 5 [(.google.api.field_behavior) = OPTIONAL];</code>
   * @return The metricAggregationMethod.
   */
  com.google.cloud.timeseriesinsights.v1.TimeseriesParams.AggregationMethod getMetricAggregationMethod();
}
