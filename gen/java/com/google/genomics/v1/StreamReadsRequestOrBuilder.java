// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/genomics/v1/reads.proto

package com.google.genomics.v1;

public interface StreamReadsRequestOrBuilder extends
    // @@protoc_insertion_point(interface_extends:google.genomics.v1.StreamReadsRequest)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * The Google Cloud project ID which will be billed
   * for this access. The caller must have WRITE access to this project.
   * Required.
   * </pre>
   *
   * <code>string project_id = 1;</code>
   * @return The projectId.
   */
  java.lang.String getProjectId();
  /**
   * <pre>
   * The Google Cloud project ID which will be billed
   * for this access. The caller must have WRITE access to this project.
   * Required.
   * </pre>
   *
   * <code>string project_id = 1;</code>
   * @return The bytes for projectId.
   */
  com.google.protobuf.ByteString
      getProjectIdBytes();

  /**
   * <pre>
   * The ID of the read group set from which to stream reads.
   * </pre>
   *
   * <code>string read_group_set_id = 2;</code>
   * @return The readGroupSetId.
   */
  java.lang.String getReadGroupSetId();
  /**
   * <pre>
   * The ID of the read group set from which to stream reads.
   * </pre>
   *
   * <code>string read_group_set_id = 2;</code>
   * @return The bytes for readGroupSetId.
   */
  com.google.protobuf.ByteString
      getReadGroupSetIdBytes();

  /**
   * <pre>
   * The reference sequence name, for example `chr1`,
   * `1`, or `chrX`. If set to *, only unmapped reads are
   * returned.
   * </pre>
   *
   * <code>string reference_name = 3;</code>
   * @return The referenceName.
   */
  java.lang.String getReferenceName();
  /**
   * <pre>
   * The reference sequence name, for example `chr1`,
   * `1`, or `chrX`. If set to *, only unmapped reads are
   * returned.
   * </pre>
   *
   * <code>string reference_name = 3;</code>
   * @return The bytes for referenceName.
   */
  com.google.protobuf.ByteString
      getReferenceNameBytes();

  /**
   * <pre>
   * The start position of the range on the reference, 0-based inclusive. If
   * specified, `referenceName` must also be specified.
   * </pre>
   *
   * <code>int64 start = 4;</code>
   * @return The start.
   */
  long getStart();

  /**
   * <pre>
   * The end position of the range on the reference, 0-based exclusive. If
   * specified, `referenceName` must also be specified.
   * </pre>
   *
   * <code>int64 end = 5;</code>
   * @return The end.
   */
  long getEnd();

  /**
   * <pre>
   * Restricts results to a shard containing approximately `1/totalShards`
   * of the normal response payload for this query. Results from a sharded
   * request are disjoint from those returned by all queries which differ only
   * in their shard parameter. A shard may yield 0 results; this is especially
   * likely for large values of `totalShards`.
   * Valid values are `[0, totalShards)`.
   * </pre>
   *
   * <code>int32 shard = 6;</code>
   * @return The shard.
   */
  int getShard();

  /**
   * <pre>
   * Specifying `totalShards` causes a disjoint subset of the normal response
   * payload to be returned for each query with a unique `shard` parameter
   * specified. A best effort is made to yield equally sized shards. Sharding
   * can be used to distribute processing amongst workers, where each worker is
   * assigned a unique `shard` number and all workers specify the same
   * `totalShards` number. The union of reads returned for all sharded queries
   * `[0, totalShards)` is equal to those returned by a single unsharded query.
   * Queries for different values of `totalShards` with common divisors will
   * share shard boundaries. For example, streaming `shard` 2 of 5
   * `totalShards` yields the same results as streaming `shard`s 4 and 5 of 10
   * `totalShards`. This property can be leveraged for adaptive retries.
   * </pre>
   *
   * <code>int32 total_shards = 7;</code>
   * @return The totalShards.
   */
  int getTotalShards();
}
