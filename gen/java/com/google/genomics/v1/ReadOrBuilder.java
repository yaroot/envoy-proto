// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/genomics/v1/readalignment.proto

package com.google.genomics.v1;

public interface ReadOrBuilder extends
    // @@protoc_insertion_point(interface_extends:google.genomics.v1.Read)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * The server-generated read ID, unique across all reads. This is different
   * from the `fragmentName`.
   * </pre>
   *
   * <code>string id = 1;</code>
   * @return The id.
   */
  java.lang.String getId();
  /**
   * <pre>
   * The server-generated read ID, unique across all reads. This is different
   * from the `fragmentName`.
   * </pre>
   *
   * <code>string id = 1;</code>
   * @return The bytes for id.
   */
  com.google.protobuf.ByteString
      getIdBytes();

  /**
   * <pre>
   * The ID of the read group this read belongs to. A read belongs to exactly
   * one read group. This is a server-generated ID which is distinct from SAM's
   * RG tag (for that value, see
   * [ReadGroup.name][google.genomics.v1.ReadGroup.name]).
   * </pre>
   *
   * <code>string read_group_id = 2;</code>
   * @return The readGroupId.
   */
  java.lang.String getReadGroupId();
  /**
   * <pre>
   * The ID of the read group this read belongs to. A read belongs to exactly
   * one read group. This is a server-generated ID which is distinct from SAM's
   * RG tag (for that value, see
   * [ReadGroup.name][google.genomics.v1.ReadGroup.name]).
   * </pre>
   *
   * <code>string read_group_id = 2;</code>
   * @return The bytes for readGroupId.
   */
  com.google.protobuf.ByteString
      getReadGroupIdBytes();

  /**
   * <pre>
   * The ID of the read group set this read belongs to. A read belongs to
   * exactly one read group set.
   * </pre>
   *
   * <code>string read_group_set_id = 3;</code>
   * @return The readGroupSetId.
   */
  java.lang.String getReadGroupSetId();
  /**
   * <pre>
   * The ID of the read group set this read belongs to. A read belongs to
   * exactly one read group set.
   * </pre>
   *
   * <code>string read_group_set_id = 3;</code>
   * @return The bytes for readGroupSetId.
   */
  com.google.protobuf.ByteString
      getReadGroupSetIdBytes();

  /**
   * <pre>
   * The fragment name. Equivalent to QNAME (query template name) in SAM.
   * </pre>
   *
   * <code>string fragment_name = 4;</code>
   * @return The fragmentName.
   */
  java.lang.String getFragmentName();
  /**
   * <pre>
   * The fragment name. Equivalent to QNAME (query template name) in SAM.
   * </pre>
   *
   * <code>string fragment_name = 4;</code>
   * @return The bytes for fragmentName.
   */
  com.google.protobuf.ByteString
      getFragmentNameBytes();

  /**
   * <pre>
   * The orientation and the distance between reads from the fragment are
   * consistent with the sequencing protocol (SAM flag 0x2).
   * </pre>
   *
   * <code>bool proper_placement = 5;</code>
   * @return The properPlacement.
   */
  boolean getProperPlacement();

  /**
   * <pre>
   * The fragment is a PCR or optical duplicate (SAM flag 0x400).
   * </pre>
   *
   * <code>bool duplicate_fragment = 6;</code>
   * @return The duplicateFragment.
   */
  boolean getDuplicateFragment();

  /**
   * <pre>
   * The observed length of the fragment, equivalent to TLEN in SAM.
   * </pre>
   *
   * <code>int32 fragment_length = 7;</code>
   * @return The fragmentLength.
   */
  int getFragmentLength();

  /**
   * <pre>
   * The read number in sequencing. 0-based and less than numberReads. This
   * field replaces SAM flag 0x40 and 0x80.
   * </pre>
   *
   * <code>int32 read_number = 8;</code>
   * @return The readNumber.
   */
  int getReadNumber();

  /**
   * <pre>
   * The number of reads in the fragment (extension to SAM flag 0x1).
   * </pre>
   *
   * <code>int32 number_reads = 9;</code>
   * @return The numberReads.
   */
  int getNumberReads();

  /**
   * <pre>
   * Whether this read did not pass filters, such as platform or vendor quality
   * controls (SAM flag 0x200).
   * </pre>
   *
   * <code>bool failed_vendor_quality_checks = 10;</code>
   * @return The failedVendorQualityChecks.
   */
  boolean getFailedVendorQualityChecks();

  /**
   * <pre>
   * The linear alignment for this alignment record. This field is null for
   * unmapped reads.
   * </pre>
   *
   * <code>.google.genomics.v1.LinearAlignment alignment = 11;</code>
   * @return Whether the alignment field is set.
   */
  boolean hasAlignment();
  /**
   * <pre>
   * The linear alignment for this alignment record. This field is null for
   * unmapped reads.
   * </pre>
   *
   * <code>.google.genomics.v1.LinearAlignment alignment = 11;</code>
   * @return The alignment.
   */
  com.google.genomics.v1.LinearAlignment getAlignment();
  /**
   * <pre>
   * The linear alignment for this alignment record. This field is null for
   * unmapped reads.
   * </pre>
   *
   * <code>.google.genomics.v1.LinearAlignment alignment = 11;</code>
   */
  com.google.genomics.v1.LinearAlignmentOrBuilder getAlignmentOrBuilder();

  /**
   * <pre>
   * Whether this alignment is secondary. Equivalent to SAM flag 0x100.
   * A secondary alignment represents an alternative to the primary alignment
   * for this read. Aligners may return secondary alignments if a read can map
   * ambiguously to multiple coordinates in the genome. By convention, each read
   * has one and only one alignment where both `secondaryAlignment`
   * and `supplementaryAlignment` are false.
   * </pre>
   *
   * <code>bool secondary_alignment = 12;</code>
   * @return The secondaryAlignment.
   */
  boolean getSecondaryAlignment();

  /**
   * <pre>
   * Whether this alignment is supplementary. Equivalent to SAM flag 0x800.
   * Supplementary alignments are used in the representation of a chimeric
   * alignment. In a chimeric alignment, a read is split into multiple
   * linear alignments that map to different reference contigs. The first
   * linear alignment in the read will be designated as the representative
   * alignment; the remaining linear alignments will be designated as
   * supplementary alignments. These alignments may have different mapping
   * quality scores. In each linear alignment in a chimeric alignment, the read
   * will be hard clipped. The `alignedSequence` and
   * `alignedQuality` fields in the alignment record will only
   * represent the bases for its respective linear alignment.
   * </pre>
   *
   * <code>bool supplementary_alignment = 13;</code>
   * @return The supplementaryAlignment.
   */
  boolean getSupplementaryAlignment();

  /**
   * <pre>
   * The bases of the read sequence contained in this alignment record,
   * **without CIGAR operations applied** (equivalent to SEQ in SAM).
   * `alignedSequence` and `alignedQuality` may be
   * shorter than the full read sequence and quality. This will occur if the
   * alignment is part of a chimeric alignment, or if the read was trimmed. When
   * this occurs, the CIGAR for this read will begin/end with a hard clip
   * operator that will indicate the length of the excised sequence.
   * </pre>
   *
   * <code>string aligned_sequence = 14;</code>
   * @return The alignedSequence.
   */
  java.lang.String getAlignedSequence();
  /**
   * <pre>
   * The bases of the read sequence contained in this alignment record,
   * **without CIGAR operations applied** (equivalent to SEQ in SAM).
   * `alignedSequence` and `alignedQuality` may be
   * shorter than the full read sequence and quality. This will occur if the
   * alignment is part of a chimeric alignment, or if the read was trimmed. When
   * this occurs, the CIGAR for this read will begin/end with a hard clip
   * operator that will indicate the length of the excised sequence.
   * </pre>
   *
   * <code>string aligned_sequence = 14;</code>
   * @return The bytes for alignedSequence.
   */
  com.google.protobuf.ByteString
      getAlignedSequenceBytes();

  /**
   * <pre>
   * The quality of the read sequence contained in this alignment record
   * (equivalent to QUAL in SAM).
   * `alignedSequence` and `alignedQuality` may be shorter than the full read
   * sequence and quality. This will occur if the alignment is part of a
   * chimeric alignment, or if the read was trimmed. When this occurs, the CIGAR
   * for this read will begin/end with a hard clip operator that will indicate
   * the length of the excised sequence.
   * </pre>
   *
   * <code>repeated int32 aligned_quality = 15;</code>
   * @return A list containing the alignedQuality.
   */
  java.util.List<java.lang.Integer> getAlignedQualityList();
  /**
   * <pre>
   * The quality of the read sequence contained in this alignment record
   * (equivalent to QUAL in SAM).
   * `alignedSequence` and `alignedQuality` may be shorter than the full read
   * sequence and quality. This will occur if the alignment is part of a
   * chimeric alignment, or if the read was trimmed. When this occurs, the CIGAR
   * for this read will begin/end with a hard clip operator that will indicate
   * the length of the excised sequence.
   * </pre>
   *
   * <code>repeated int32 aligned_quality = 15;</code>
   * @return The count of alignedQuality.
   */
  int getAlignedQualityCount();
  /**
   * <pre>
   * The quality of the read sequence contained in this alignment record
   * (equivalent to QUAL in SAM).
   * `alignedSequence` and `alignedQuality` may be shorter than the full read
   * sequence and quality. This will occur if the alignment is part of a
   * chimeric alignment, or if the read was trimmed. When this occurs, the CIGAR
   * for this read will begin/end with a hard clip operator that will indicate
   * the length of the excised sequence.
   * </pre>
   *
   * <code>repeated int32 aligned_quality = 15;</code>
   * @param index The index of the element to return.
   * @return The alignedQuality at the given index.
   */
  int getAlignedQuality(int index);

  /**
   * <pre>
   * The mapping of the primary alignment of the
   * `(readNumber+1)%numberReads` read in the fragment. It replaces
   * mate position and mate strand in SAM.
   * </pre>
   *
   * <code>.google.genomics.v1.Position next_mate_position = 16;</code>
   * @return Whether the nextMatePosition field is set.
   */
  boolean hasNextMatePosition();
  /**
   * <pre>
   * The mapping of the primary alignment of the
   * `(readNumber+1)%numberReads` read in the fragment. It replaces
   * mate position and mate strand in SAM.
   * </pre>
   *
   * <code>.google.genomics.v1.Position next_mate_position = 16;</code>
   * @return The nextMatePosition.
   */
  com.google.genomics.v1.Position getNextMatePosition();
  /**
   * <pre>
   * The mapping of the primary alignment of the
   * `(readNumber+1)%numberReads` read in the fragment. It replaces
   * mate position and mate strand in SAM.
   * </pre>
   *
   * <code>.google.genomics.v1.Position next_mate_position = 16;</code>
   */
  com.google.genomics.v1.PositionOrBuilder getNextMatePositionOrBuilder();

  /**
   * <pre>
   * A map of additional read alignment information. This must be of the form
   * map&lt;string, string[]&gt; (string key mapping to a list of string values).
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.ListValue&gt; info = 17;</code>
   */
  int getInfoCount();
  /**
   * <pre>
   * A map of additional read alignment information. This must be of the form
   * map&lt;string, string[]&gt; (string key mapping to a list of string values).
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.ListValue&gt; info = 17;</code>
   */
  boolean containsInfo(
      java.lang.String key);
  /**
   * Use {@link #getInfoMap()} instead.
   */
  @java.lang.Deprecated
  java.util.Map<java.lang.String, com.google.protobuf.ListValue>
  getInfo();
  /**
   * <pre>
   * A map of additional read alignment information. This must be of the form
   * map&lt;string, string[]&gt; (string key mapping to a list of string values).
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.ListValue&gt; info = 17;</code>
   */
  java.util.Map<java.lang.String, com.google.protobuf.ListValue>
  getInfoMap();
  /**
   * <pre>
   * A map of additional read alignment information. This must be of the form
   * map&lt;string, string[]&gt; (string key mapping to a list of string values).
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.ListValue&gt; info = 17;</code>
   */
  /* nullable */
com.google.protobuf.ListValue getInfoOrDefault(
      java.lang.String key,
      /* nullable */
com.google.protobuf.ListValue defaultValue);
  /**
   * <pre>
   * A map of additional read alignment information. This must be of the form
   * map&lt;string, string[]&gt; (string key mapping to a list of string values).
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.ListValue&gt; info = 17;</code>
   */
  com.google.protobuf.ListValue getInfoOrThrow(
      java.lang.String key);
}
